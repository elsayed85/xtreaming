var qr = Object.defineProperty;
var Zr = (_, _e, et) => _e in _ ? qr(_, _e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: et
}) : _[_e] = et;
var kr = (_, _e, et) => (Zr(_, typeof _e != "symbol" ? _e + "" : _e, et), et);

function _mergeNamespaces(_, _e) {
    for (var et = 0; et < _e.length; et++) {
        const tt = _e[et];
        if (typeof tt != "string" && !Array.isArray(tt)) {
            for (const rt in tt)
                if (rt !== "default" && !(rt in _)) {
                    const nt = Object.getOwnPropertyDescriptor(tt, rt);
                    nt && Object.defineProperty(_, rt, nt.get ? nt : {
                        enumerable: !0,
                        get: () => tt[rt]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(_, Symbol.toStringTag, {
        value: "Module"
    }))
}(function() {
    const _e = document.createElement("link").relList;
    if (_e && _e.supports && _e.supports("modulepreload")) return;
    for (const rt of document.querySelectorAll('link[rel="modulepreload"]')) tt(rt);
    new MutationObserver(rt => {
        for (const nt of rt)
            if (nt.type === "childList")
                for (const at of nt.addedNodes) at.tagName === "LINK" && at.rel === "modulepreload" && tt(at)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function et(rt) {
        const nt = {};
        return rt.integrity && (nt.integrity = rt.integrity), rt.referrerpolicy && (nt.referrerPolicy = rt.referrerpolicy), rt.crossorigin === "use-credentials" ? nt.credentials = "include" : rt.crossorigin === "anonymous" ? nt.credentials = "omit" : nt.credentials = "same-origin", nt
    }

    function tt(rt) {
        if (rt.ep) return;
        rt.ep = !0;
        const nt = et(rt);
        fetch(rt.href, nt)
    }
})();
var commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function getDefaultExportFromCjs(_) {
    return _ && _.__esModule && Object.prototype.hasOwnProperty.call(_, "default") ? _.default : _
}

function getAugmentedNamespace(_) {
    var _e = _.default;
    if (typeof _e == "function") {
        var et = function tt() {
            if (this instanceof tt) {
                var rt = [null];
                rt.push.apply(rt, arguments);
                var nt = Function.bind.apply(_e, rt);
                return new nt
            }
            return _e.apply(this, arguments)
        };
        et.prototype = _e.prototype
    } else et = {};
    return Object.defineProperty(et, "__esModule", {
        value: !0
    }), Object.keys(_).forEach(function(tt) {
        var rt = Object.getOwnPropertyDescriptor(_, tt);
        Object.defineProperty(et, tt, rt.get ? rt : {
            enumerable: !0,
            get: function() {
                return _[tt]
            }
        })
    }), et
}
var jsxRuntime = {
        exports: {}
    },
    reactJsxRuntime_production_min = {};
var getOwnPropertySymbols = Object.getOwnPropertySymbols,
    hasOwnProperty = Object.prototype.hasOwnProperty,
    propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(_) {
    if (_ == null) throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(_)
}

function shouldUseNative() {
    try {
        if (!Object.assign) return !1;
        var _ = new String("abc");
        if (_[5] = "de", Object.getOwnPropertyNames(_)[0] === "5") return !1;
        for (var _e = {}, et = 0; et < 10; et++) _e["_" + String.fromCharCode(et)] = et;
        var tt = Object.getOwnPropertyNames(_e).map(function(nt) {
            return _e[nt]
        });
        if (tt.join("") !== "0123456789") return !1;
        var rt = {};
        return "abcdefghijklmnopqrst".split("").forEach(function(nt) {
            rt[nt] = nt
        }), Object.keys(Object.assign({}, rt)).join("") === "abcdefghijklmnopqrst"
    } catch {
        return !1
    }
}
var objectAssign = shouldUseNative() ? Object.assign : function(_, _e) {
        for (var et, tt = toObject(_), rt, nt = 1; nt < arguments.length; nt++) {
            et = Object(arguments[nt]);
            for (var at in et) hasOwnProperty.call(et, at) && (tt[at] = et[at]);
            if (getOwnPropertySymbols) {
                rt = getOwnPropertySymbols(et);
                for (var st = 0; st < rt.length; st++) propIsEnumerable.call(et, rt[st]) && (tt[rt[st]] = et[rt[st]])
            }
        }
        return tt
    },
    react = {
        exports: {}
    },
    react_production_min = {};
var l$3 = objectAssign,
    n$2 = 60103,
    p$5 = 60106;
react_production_min.Fragment = 60107;
react_production_min.StrictMode = 60108;
react_production_min.Profiler = 60114;
var q$3 = 60109,
    r$5 = 60110,
    t$3 = 60112;
react_production_min.Suspense = 60113;
var u$4 = 60115,
    v$2 = 60116;
if (typeof Symbol == "function" && Symbol.for) {
    var w$2 = Symbol.for;
    n$2 = w$2("react.element"), p$5 = w$2("react.portal"), react_production_min.Fragment = w$2("react.fragment"), react_production_min.StrictMode = w$2("react.strict_mode"), react_production_min.Profiler = w$2("react.profiler"), q$3 = w$2("react.provider"), r$5 = w$2("react.context"), t$3 = w$2("react.forward_ref"), react_production_min.Suspense = w$2("react.suspense"), u$4 = w$2("react.memo"), v$2 = w$2("react.lazy")
}
var x$2 = typeof Symbol == "function" && Symbol.iterator;

function y$3(_) {
    return _ === null || typeof _ != "object" ? null : (_ = x$2 && _[x$2] || _["@@iterator"], typeof _ == "function" ? _ : null)
}

function z$1(_) {
    for (var _e = "https://reactjs.org/docs/error-decoder.html?invariant=" + _, et = 1; et < arguments.length; et++) _e += "&args[]=" + encodeURIComponent(arguments[et]);
    return "Minified React error #" + _ + "; visit " + _e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var A$2 = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    },
    B$2 = {};

function C$2(_, _e, et) {
    this.props = _, this.context = _e, this.refs = B$2, this.updater = et || A$2
}
C$2.prototype.isReactComponent = {};
C$2.prototype.setState = function(_, _e) {
    if (typeof _ != "object" && typeof _ != "function" && _ != null) throw Error(z$1(85));
    this.updater.enqueueSetState(this, _, _e, "setState")
};
C$2.prototype.forceUpdate = function(_) {
    this.updater.enqueueForceUpdate(this, _, "forceUpdate")
};

function D$2() {}
D$2.prototype = C$2.prototype;

function E$1(_, _e, et) {
    this.props = _, this.context = _e, this.refs = B$2, this.updater = et || A$2
}
var F$4 = E$1.prototype = new D$2;
F$4.constructor = E$1;
l$3(F$4, C$2.prototype);
F$4.isPureReactComponent = !0;
var G$1 = {
        current: null
    },
    H$2 = Object.prototype.hasOwnProperty,
    I$3 = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function J$2(_, _e, et) {
    var tt, rt = {},
        nt = null,
        at = null;
    if (_e != null)
        for (tt in _e.ref !== void 0 && (at = _e.ref), _e.key !== void 0 && (nt = "" + _e.key), _e) H$2.call(_e, tt) && !I$3.hasOwnProperty(tt) && (rt[tt] = _e[tt]);
    var st = arguments.length - 2;
    if (st === 1) rt.children = et;
    else if (1 < st) {
        for (var it = Array(st), ut = 0; ut < st; ut++) it[ut] = arguments[ut + 2];
        rt.children = it
    }
    if (_ && _.defaultProps)
        for (tt in st = _.defaultProps, st) rt[tt] === void 0 && (rt[tt] = st[tt]);
    return {
        $$typeof: n$2,
        type: _,
        key: nt,
        ref: at,
        props: rt,
        _owner: G$1.current
    }
}

function K(_, _e) {
    return {
        $$typeof: n$2,
        type: _.type,
        key: _e,
        ref: _.ref,
        props: _.props,
        _owner: _._owner
    }
}

function L$1(_) {
    return typeof _ == "object" && _ !== null && _.$$typeof === n$2
}

function escape$3(_) {
    var _e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + _.replace(/[=:]/g, function(et) {
        return _e[et]
    })
}
var M$4 = /\/+/g;

function N$2(_, _e) {
    return typeof _ == "object" && _ !== null && _.key != null ? escape$3("" + _.key) : _e.toString(36)
}

function O$1(_, _e, et, tt, rt) {
    var nt = typeof _;
    (nt === "undefined" || nt === "boolean") && (_ = null);
    var at = !1;
    if (_ === null) at = !0;
    else switch (nt) {
        case "string":
        case "number":
            at = !0;
            break;
        case "object":
            switch (_.$$typeof) {
                case n$2:
                case p$5:
                    at = !0
            }
    }
    if (at) return at = _, rt = rt(at), _ = tt === "" ? "." + N$2(at, 0) : tt, Array.isArray(rt) ? (et = "", _ != null && (et = _.replace(M$4, "$&/") + "/"), O$1(rt, _e, et, "", function(ut) {
        return ut
    })) : rt != null && (L$1(rt) && (rt = K(rt, et + (!rt.key || at && at.key === rt.key ? "" : ("" + rt.key).replace(M$4, "$&/") + "/") + _)), _e.push(rt)), 1;
    if (at = 0, tt = tt === "" ? "." : tt + ":", Array.isArray(_))
        for (var st = 0; st < _.length; st++) {
            nt = _[st];
            var it = tt + N$2(nt, st);
            at += O$1(nt, _e, et, it, rt)
        } else if (it = y$3(_), typeof it == "function")
            for (_ = it.call(_), st = 0; !(nt = _.next()).done;) nt = nt.value, it = tt + N$2(nt, st++), at += O$1(nt, _e, et, it, rt);
        else if (nt === "object") throw _e = "" + _, Error(z$1(31, _e === "[object Object]" ? "object with keys {" + Object.keys(_).join(", ") + "}" : _e));
    return at
}

function P$2(_, _e, et) {
    if (_ == null) return _;
    var tt = [],
        rt = 0;
    return O$1(_, tt, "", "", function(nt) {
        return _e.call(et, nt, rt++)
    }), tt
}

function Q(_) {
    if (_._status === -1) {
        var _e = _._result;
        _e = _e(), _._status = 0, _._result = _e, _e.then(function(et) {
            _._status === 0 && (et = et.default, _._status = 1, _._result = et)
        }, function(et) {
            _._status === 0 && (_._status = 2, _._result = et)
        })
    }
    if (_._status === 1) return _._result;
    throw _._result
}
var R$1 = {
    current: null
};

function S$3() {
    var _ = R$1.current;
    if (_ === null) throw Error(z$1(321));
    return _
}
var T$4 = {
    ReactCurrentDispatcher: R$1,
    ReactCurrentBatchConfig: {
        transition: 0
    },
    ReactCurrentOwner: G$1,
    IsSomeRendererActing: {
        current: !1
    },
    assign: l$3
};
react_production_min.Children = {
    map: P$2,
    forEach: function(_, _e, et) {
        P$2(_, function() {
            _e.apply(this, arguments)
        }, et)
    },
    count: function(_) {
        var _e = 0;
        return P$2(_, function() {
            _e++
        }), _e
    },
    toArray: function(_) {
        return P$2(_, function(_e) {
            return _e
        }) || []
    },
    only: function(_) {
        if (!L$1(_)) throw Error(z$1(143));
        return _
    }
};
react_production_min.Component = C$2;
react_production_min.PureComponent = E$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T$4;
react_production_min.cloneElement = function(_, _e, et) {
    if (_ == null) throw Error(z$1(267, _));
    var tt = l$3({}, _.props),
        rt = _.key,
        nt = _.ref,
        at = _._owner;
    if (_e != null) {
        if (_e.ref !== void 0 && (nt = _e.ref, at = G$1.current), _e.key !== void 0 && (rt = "" + _e.key), _.type && _.type.defaultProps) var st = _.type.defaultProps;
        for (it in _e) H$2.call(_e, it) && !I$3.hasOwnProperty(it) && (tt[it] = _e[it] === void 0 && st !== void 0 ? st[it] : _e[it])
    }
    var it = arguments.length - 2;
    if (it === 1) tt.children = et;
    else if (1 < it) {
        st = Array(it);
        for (var ut = 0; ut < it; ut++) st[ut] = arguments[ut + 2];
        tt.children = st
    }
    return {
        $$typeof: n$2,
        type: _.type,
        key: rt,
        ref: nt,
        props: tt,
        _owner: at
    }
};
react_production_min.createContext = function(_, _e) {
    return _e === void 0 && (_e = null), _ = {
        $$typeof: r$5,
        _calculateChangedBits: _e,
        _currentValue: _,
        _currentValue2: _,
        _threadCount: 0,
        Provider: null,
        Consumer: null
    }, _.Provider = {
        $$typeof: q$3,
        _context: _
    }, _.Consumer = _
};
react_production_min.createElement = J$2;
react_production_min.createFactory = function(_) {
    var _e = J$2.bind(null, _);
    return _e.type = _, _e
};
react_production_min.createRef = function() {
    return {
        current: null
    }
};
react_production_min.forwardRef = function(_) {
    return {
        $$typeof: t$3,
        render: _
    }
};
react_production_min.isValidElement = L$1;
react_production_min.lazy = function(_) {
    return {
        $$typeof: v$2,
        _payload: {
            _status: -1,
            _result: _
        },
        _init: Q
    }
};
react_production_min.memo = function(_, _e) {
    return {
        $$typeof: u$4,
        type: _,
        compare: _e === void 0 ? null : _e
    }
};
react_production_min.useCallback = function(_, _e) {
    return S$3().useCallback(_, _e)
};
react_production_min.useContext = function(_, _e) {
    return S$3().useContext(_, _e)
};
react_production_min.useDebugValue = function() {};
react_production_min.useEffect = function(_, _e) {
    return S$3().useEffect(_, _e)
};
react_production_min.useImperativeHandle = function(_, _e, et) {
    return S$3().useImperativeHandle(_, _e, et)
};
react_production_min.useLayoutEffect = function(_, _e) {
    return S$3().useLayoutEffect(_, _e)
};
react_production_min.useMemo = function(_, _e) {
    return S$3().useMemo(_, _e)
};
react_production_min.useReducer = function(_, _e, et) {
    return S$3().useReducer(_, _e, et)
};
react_production_min.useRef = function(_) {
    return S$3().useRef(_)
};
react_production_min.useState = function(_) {
    return S$3().useState(_)
};
react_production_min.version = "17.0.2";
(function(_) {
    _.exports = react_production_min
})(react);
const React = getDefaultExportFromCjs(react.exports);
var f$5 = react.exports,
    g$1 = 60103;
reactJsxRuntime_production_min.Fragment = 60107;
if (typeof Symbol == "function" && Symbol.for) {
    var h$2 = Symbol.for;
    g$1 = h$2("react.element"), reactJsxRuntime_production_min.Fragment = h$2("react.fragment")
}
var m$5 = f$5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    n$1 = Object.prototype.hasOwnProperty,
    p$4 = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function q$2(_, _e, et) {
    var tt, rt = {},
        nt = null,
        at = null;
    et !== void 0 && (nt = "" + et), _e.key !== void 0 && (nt = "" + _e.key), _e.ref !== void 0 && (at = _e.ref);
    for (tt in _e) n$1.call(_e, tt) && !p$4.hasOwnProperty(tt) && (rt[tt] = _e[tt]);
    if (_ && _.defaultProps)
        for (tt in _e = _.defaultProps, _e) rt[tt] === void 0 && (rt[tt] = _e[tt]);
    return {
        $$typeof: g$1,
        type: _,
        key: nt,
        ref: at,
        props: rt,
        _owner: m$5.current
    }
}
reactJsxRuntime_production_min.jsx = q$2;
reactJsxRuntime_production_min.jsxs = q$2;
(function(_) {
    _.exports = reactJsxRuntime_production_min
})(jsxRuntime);
var reactDom = {
        exports: {}
    },
    reactDom_production_min = {},
    scheduler = {
        exports: {}
    },
    scheduler_production_min = {};
(function(_) {
    var _e, et, tt, rt;
    if (typeof performance == "object" && typeof performance.now == "function") {
        var nt = performance;
        _.unstable_now = function() {
            return nt.now()
        }
    } else {
        var at = Date,
            st = at.now();
        _.unstable_now = function() {
            return at.now() - st
        }
    }
    if (typeof window > "u" || typeof MessageChannel != "function") {
        var it = null,
            ut = null,
            lt = function() {
                if (it !== null) try {
                    var Lt = _.unstable_now();
                    it(!0, Lt), it = null
                } catch (Bt) {
                    throw setTimeout(lt, 0), Bt
                }
            };
        _e = function(Lt) {
            it !== null ? setTimeout(_e, 0, Lt) : (it = Lt, setTimeout(lt, 0))
        }, et = function(Lt, Bt) {
            ut = setTimeout(Lt, Bt)
        }, tt = function() {
            clearTimeout(ut)
        }, _.unstable_shouldYield = function() {
            return !1
        }, rt = _.unstable_forceFrameRate = function() {}
    } else {
        var bt = window.setTimeout,
            pt = window.clearTimeout;
        if (typeof console < "u") {
            var It = window.cancelAnimationFrame;
            typeof window.requestAnimationFrame != "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), typeof It != "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")
        }
        var At = !1,
            Ct = null,
            ht = -1,
            ot = 5,
            ct = 0;
        _.unstable_shouldYield = function() {
            return _.unstable_now() >= ct
        }, rt = function() {}, _.unstable_forceFrameRate = function(Lt) {
            0 > Lt || 125 < Lt ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : ot = 0 < Lt ? Math.floor(1e3 / Lt) : 5
        };
        var Et = new MessageChannel,
            Dt = Et.port2;
        Et.port1.onmessage = function() {
            if (Ct !== null) {
                var Lt = _.unstable_now();
                ct = Lt + ot;
                try {
                    Ct(!0, Lt) ? Dt.postMessage(null) : (At = !1, Ct = null)
                } catch (Bt) {
                    throw Dt.postMessage(null), Bt
                }
            } else At = !1
        }, _e = function(Lt) {
            Ct = Lt, At || (At = !0, Dt.postMessage(null))
        }, et = function(Lt, Bt) {
            ht = bt(function() {
                Lt(_.unstable_now())
            }, Bt)
        }, tt = function() {
            pt(ht), ht = -1
        }
    }

    function Pt(Lt, Bt) {
        var Nt = Lt.length;
        Lt.push(Bt);
        e: for (;;) {
            var $t = Nt - 1 >>> 1,
                jt = Lt[$t];
            if (jt !== void 0 && 0 < dt(jt, Bt)) Lt[$t] = Bt, Lt[Nt] = jt, Nt = $t;
            else break e
        }
    }

    function gt(Lt) {
        return Lt = Lt[0], Lt === void 0 ? null : Lt
    }

    function ft(Lt) {
        var Bt = Lt[0];
        if (Bt !== void 0) {
            var Nt = Lt.pop();
            if (Nt !== Bt) {
                Lt[0] = Nt;
                e: for (var $t = 0, jt = Lt.length; $t < jt;) {
                    var Ut = 2 * ($t + 1) - 1,
                        Ht = Lt[Ut],
                        Wt = Ut + 1,
                        Kt = Lt[Wt];
                    if (Ht !== void 0 && 0 > dt(Ht, Nt)) Kt !== void 0 && 0 > dt(Kt, Ht) ? (Lt[$t] = Kt, Lt[Wt] = Nt, $t = Wt) : (Lt[$t] = Ht, Lt[Ut] = Nt, $t = Ut);
                    else if (Kt !== void 0 && 0 > dt(Kt, Nt)) Lt[$t] = Kt, Lt[Wt] = Nt, $t = Wt;
                    else break e
                }
            }
            return Bt
        }
        return null
    }

    function dt(Lt, Bt) {
        var Nt = Lt.sortIndex - Bt.sortIndex;
        return Nt !== 0 ? Nt : Lt.id - Bt.id
    }
    var St = [],
        _t = [],
        vt = 1,
        mt = null,
        xt = 3,
        yt = !1,
        Tt = !1,
        Ft = !1;

    function wt(Lt) {
        for (var Bt = gt(_t); Bt !== null;) {
            if (Bt.callback === null) ft(_t);
            else if (Bt.startTime <= Lt) ft(_t), Bt.sortIndex = Bt.expirationTime, Pt(St, Bt);
            else break;
            Bt = gt(_t)
        }
    }

    function kt(Lt) {
        if (Ft = !1, wt(Lt), !Tt)
            if (gt(St) !== null) Tt = !0, _e(Ot);
            else {
                var Bt = gt(_t);
                Bt !== null && et(kt, Bt.startTime - Lt)
            }
    }

    function Ot(Lt, Bt) {
        Tt = !1, Ft && (Ft = !1, tt()), yt = !0;
        var Nt = xt;
        try {
            for (wt(Bt), mt = gt(St); mt !== null && (!(mt.expirationTime > Bt) || Lt && !_.unstable_shouldYield());) {
                var $t = mt.callback;
                if (typeof $t == "function") {
                    mt.callback = null, xt = mt.priorityLevel;
                    var jt = $t(mt.expirationTime <= Bt);
                    Bt = _.unstable_now(), typeof jt == "function" ? mt.callback = jt : mt === gt(St) && ft(St), wt(Bt)
                } else ft(St);
                mt = gt(St)
            }
            if (mt !== null) var Ut = !0;
            else {
                var Ht = gt(_t);
                Ht !== null && et(kt, Ht.startTime - Bt), Ut = !1
            }
            return Ut
        } finally {
            mt = null, xt = Nt, yt = !1
        }
    }
    var Rt = rt;
    _.unstable_IdlePriority = 5, _.unstable_ImmediatePriority = 1, _.unstable_LowPriority = 4, _.unstable_NormalPriority = 3, _.unstable_Profiling = null, _.unstable_UserBlockingPriority = 2, _.unstable_cancelCallback = function(Lt) {
        Lt.callback = null
    }, _.unstable_continueExecution = function() {
        Tt || yt || (Tt = !0, _e(Ot))
    }, _.unstable_getCurrentPriorityLevel = function() {
        return xt
    }, _.unstable_getFirstCallbackNode = function() {
        return gt(St)
    }, _.unstable_next = function(Lt) {
        switch (xt) {
            case 1:
            case 2:
            case 3:
                var Bt = 3;
                break;
            default:
                Bt = xt
        }
        var Nt = xt;
        xt = Bt;
        try {
            return Lt()
        } finally {
            xt = Nt
        }
    }, _.unstable_pauseExecution = function() {}, _.unstable_requestPaint = Rt, _.unstable_runWithPriority = function(Lt, Bt) {
        switch (Lt) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                Lt = 3
        }
        var Nt = xt;
        xt = Lt;
        try {
            return Bt()
        } finally {
            xt = Nt
        }
    }, _.unstable_scheduleCallback = function(Lt, Bt, Nt) {
        var $t = _.unstable_now();
        switch (typeof Nt == "object" && Nt !== null ? (Nt = Nt.delay, Nt = typeof Nt == "number" && 0 < Nt ? $t + Nt : $t) : Nt = $t, Lt) {
            case 1:
                var jt = -1;
                break;
            case 2:
                jt = 250;
                break;
            case 5:
                jt = 1073741823;
                break;
            case 4:
                jt = 1e4;
                break;
            default:
                jt = 5e3
        }
        return jt = Nt + jt, Lt = {
            id: vt++,
            callback: Bt,
            priorityLevel: Lt,
            startTime: Nt,
            expirationTime: jt,
            sortIndex: -1
        }, Nt > $t ? (Lt.sortIndex = Nt, Pt(_t, Lt), gt(St) === null && Lt === gt(_t) && (Ft ? tt() : Ft = !0, et(kt, Nt - $t))) : (Lt.sortIndex = jt, Pt(St, Lt), Tt || yt || (Tt = !0, _e(Ot))), Lt
    }, _.unstable_wrapCallback = function(Lt) {
        var Bt = xt;
        return function() {
            var Nt = xt;
            xt = Bt;
            try {
                return Lt.apply(this, arguments)
            } finally {
                xt = Nt
            }
        }
    }
})(scheduler_production_min);
(function(_) {
    _.exports = scheduler_production_min
})(scheduler);
var aa = react.exports,
    m$4 = objectAssign,
    r$4 = scheduler.exports;

function y$2(_) {
    for (var _e = "https://reactjs.org/docs/error-decoder.html?invariant=" + _, et = 1; et < arguments.length; et++) _e += "&args[]=" + encodeURIComponent(arguments[et]);
    return "Minified React error #" + _ + "; visit " + _e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
if (!aa) throw Error(y$2(227));
var ba = new Set,
    ca = {};

function da(_, _e) {
    ea(_, _e), ea(_ + "Capture", _e)
}

function ea(_, _e) {
    for (ca[_] = _e, _ = 0; _ < _e.length; _++) ba.add(_e[_])
}
var fa = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
    ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    ia = Object.prototype.hasOwnProperty,
    ja = {},
    ka = {};

function la(_) {
    return ia.call(ka, _) ? !0 : ia.call(ja, _) ? !1 : ha.test(_) ? ka[_] = !0 : (ja[_] = !0, !1)
}

function ma(_, _e, et, tt) {
    if (et !== null && et.type === 0) return !1;
    switch (typeof _e) {
        case "function":
        case "symbol":
            return !0;
        case "boolean":
            return tt ? !1 : et !== null ? !et.acceptsBooleans : (_ = _.toLowerCase().slice(0, 5), _ !== "data-" && _ !== "aria-");
        default:
            return !1
    }
}

function na(_, _e, et, tt) {
    if (_e === null || typeof _e > "u" || ma(_, _e, et, tt)) return !0;
    if (tt) return !1;
    if (et !== null) switch (et.type) {
        case 3:
            return !_e;
        case 4:
            return _e === !1;
        case 5:
            return isNaN(_e);
        case 6:
            return isNaN(_e) || 1 > _e
    }
    return !1
}

function B$1(_, _e, et, tt, rt, nt, at) {
    this.acceptsBooleans = _e === 2 || _e === 3 || _e === 4, this.attributeName = tt, this.attributeNamespace = rt, this.mustUseProperty = et, this.propertyName = _, this.type = _e, this.sanitizeURL = nt, this.removeEmptyString = at
}
var D$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(_) {
    D$1[_] = new B$1(_, 0, !1, _, null, !1, !1)
});
[
    ["acceptCharset", "accept-charset"],
    ["className", "class"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"]
].forEach(function(_) {
    var _e = _[0];
    D$1[_e] = new B$1(_e, 1, !1, _[1], null, !1, !1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(_) {
    D$1[_] = new B$1(_, 2, !1, _.toLowerCase(), null, !1, !1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(_) {
    D$1[_] = new B$1(_, 2, !1, _, null, !1, !1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(_) {
    D$1[_] = new B$1(_, 3, !1, _.toLowerCase(), null, !1, !1)
});
["checked", "multiple", "muted", "selected"].forEach(function(_) {
    D$1[_] = new B$1(_, 3, !0, _, null, !1, !1)
});
["capture", "download"].forEach(function(_) {
    D$1[_] = new B$1(_, 4, !1, _, null, !1, !1)
});
["cols", "rows", "size", "span"].forEach(function(_) {
    D$1[_] = new B$1(_, 6, !1, _, null, !1, !1)
});
["rowSpan", "start"].forEach(function(_) {
    D$1[_] = new B$1(_, 5, !1, _.toLowerCase(), null, !1, !1)
});
var oa = /[\-:]([a-z])/g;

function pa(_) {
    return _[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(_) {
    var _e = _.replace(oa, pa);
    D$1[_e] = new B$1(_e, 1, !1, _, null, !1, !1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(_) {
    var _e = _.replace(oa, pa);
    D$1[_e] = new B$1(_e, 1, !1, _, "http://www.w3.org/1999/xlink", !1, !1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(_) {
    var _e = _.replace(oa, pa);
    D$1[_e] = new B$1(_e, 1, !1, _, "http://www.w3.org/XML/1998/namespace", !1, !1)
});
["tabIndex", "crossOrigin"].forEach(function(_) {
    D$1[_] = new B$1(_, 1, !1, _.toLowerCase(), null, !1, !1)
});
D$1.xlinkHref = new B$1("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(_) {
    D$1[_] = new B$1(_, 1, !1, _.toLowerCase(), null, !0, !0)
});

function qa(_, _e, et, tt) {
    var rt = D$1.hasOwnProperty(_e) ? D$1[_e] : null,
        nt = rt !== null ? rt.type === 0 : tt ? !1 : !(!(2 < _e.length) || _e[0] !== "o" && _e[0] !== "O" || _e[1] !== "n" && _e[1] !== "N");
    nt || (na(_e, et, rt, tt) && (et = null), tt || rt === null ? la(_e) && (et === null ? _.removeAttribute(_e) : _.setAttribute(_e, "" + et)) : rt.mustUseProperty ? _[rt.propertyName] = et === null ? rt.type === 3 ? !1 : "" : et : (_e = rt.attributeName, tt = rt.attributeNamespace, et === null ? _.removeAttribute(_e) : (rt = rt.type, et = rt === 3 || rt === 4 && et === !0 ? "" : "" + et, tt ? _.setAttributeNS(tt, _e, et) : _.setAttribute(_e, et))))
}
var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    sa = 60103,
    ta = 60106,
    ua = 60107,
    wa = 60108,
    xa = 60114,
    ya = 60109,
    za = 60110,
    Aa = 60112,
    Ba = 60113,
    Ca = 60120,
    Da = 60115,
    Ea = 60116,
    Fa = 60121,
    Ga = 60128,
    Ha = 60129,
    Ia = 60130,
    Ja = 60131;
if (typeof Symbol == "function" && Symbol.for) {
    var E = Symbol.for;
    sa = E("react.element"), ta = E("react.portal"), ua = E("react.fragment"), wa = E("react.strict_mode"), xa = E("react.profiler"), ya = E("react.provider"), za = E("react.context"), Aa = E("react.forward_ref"), Ba = E("react.suspense"), Ca = E("react.suspense_list"), Da = E("react.memo"), Ea = E("react.lazy"), Fa = E("react.block"), E("react.scope"), Ga = E("react.opaque.id"), Ha = E("react.debug_trace_mode"), Ia = E("react.offscreen"), Ja = E("react.legacy_hidden")
}
var Ka = typeof Symbol == "function" && Symbol.iterator;

function La(_) {
    return _ === null || typeof _ != "object" ? null : (_ = Ka && _[Ka] || _["@@iterator"], typeof _ == "function" ? _ : null)
}
var Ma;

function Na(_) {
    if (Ma === void 0) try {
        throw Error()
    } catch (et) {
        var _e = et.stack.trim().match(/\n( *(at )?)/);
        Ma = _e && _e[1] || ""
    }
    return `
` + Ma + _
}
var Oa = !1;

function Pa(_, _e) {
    if (!_ || Oa) return "";
    Oa = !0;
    var et = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (_e)
            if (_e = function() {
                    throw Error()
                }, Object.defineProperty(_e.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }), typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(_e, [])
                } catch (it) {
                    var tt = it
                }
                Reflect.construct(_, [], _e)
            } else {
                try {
                    _e.call()
                } catch (it) {
                    tt = it
                }
                _.call(_e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (it) {
                tt = it
            }
            _()
        }
    } catch (it) {
        if (it && tt && typeof it.stack == "string") {
            for (var rt = it.stack.split(`
`), nt = tt.stack.split(`
`), at = rt.length - 1, st = nt.length - 1; 1 <= at && 0 <= st && rt[at] !== nt[st];) st--;
            for (; 1 <= at && 0 <= st; at--, st--)
                if (rt[at] !== nt[st]) {
                    if (at !== 1 || st !== 1)
                        do
                            if (at--, st--, 0 > st || rt[at] !== nt[st]) return `
` + rt[at].replace(" at new ", " at "); while (1 <= at && 0 <= st);
                    break
                }
        }
    } finally {
        Oa = !1, Error.prepareStackTrace = et
    }
    return (_ = _ ? _.displayName || _.name : "") ? Na(_) : ""
}

function Qa(_) {
    switch (_.tag) {
        case 5:
            return Na(_.type);
        case 16:
            return Na("Lazy");
        case 13:
            return Na("Suspense");
        case 19:
            return Na("SuspenseList");
        case 0:
        case 2:
        case 15:
            return _ = Pa(_.type, !1), _;
        case 11:
            return _ = Pa(_.type.render, !1), _;
        case 22:
            return _ = Pa(_.type._render, !1), _;
        case 1:
            return _ = Pa(_.type, !0), _;
        default:
            return ""
    }
}

function Ra(_) {
    if (_ == null) return null;
    if (typeof _ == "function") return _.displayName || _.name || null;
    if (typeof _ == "string") return _;
    switch (_) {
        case ua:
            return "Fragment";
        case ta:
            return "Portal";
        case xa:
            return "Profiler";
        case wa:
            return "StrictMode";
        case Ba:
            return "Suspense";
        case Ca:
            return "SuspenseList"
    }
    if (typeof _ == "object") switch (_.$$typeof) {
        case za:
            return (_.displayName || "Context") + ".Consumer";
        case ya:
            return (_._context.displayName || "Context") + ".Provider";
        case Aa:
            var _e = _.render;
            return _e = _e.displayName || _e.name || "", _.displayName || (_e !== "" ? "ForwardRef(" + _e + ")" : "ForwardRef");
        case Da:
            return Ra(_.type);
        case Fa:
            return Ra(_._render);
        case Ea:
            _e = _._payload, _ = _._init;
            try {
                return Ra(_(_e))
            } catch {}
    }
    return null
}

function Sa(_) {
    switch (typeof _) {
        case "boolean":
        case "number":
        case "object":
        case "string":
        case "undefined":
            return _;
        default:
            return ""
    }
}

function Ta(_) {
    var _e = _.type;
    return (_ = _.nodeName) && _.toLowerCase() === "input" && (_e === "checkbox" || _e === "radio")
}

function Ua(_) {
    var _e = Ta(_) ? "checked" : "value",
        et = Object.getOwnPropertyDescriptor(_.constructor.prototype, _e),
        tt = "" + _[_e];
    if (!_.hasOwnProperty(_e) && typeof et < "u" && typeof et.get == "function" && typeof et.set == "function") {
        var rt = et.get,
            nt = et.set;
        return Object.defineProperty(_, _e, {
            configurable: !0,
            get: function() {
                return rt.call(this)
            },
            set: function(at) {
                tt = "" + at, nt.call(this, at)
            }
        }), Object.defineProperty(_, _e, {
            enumerable: et.enumerable
        }), {
            getValue: function() {
                return tt
            },
            setValue: function(at) {
                tt = "" + at
            },
            stopTracking: function() {
                _._valueTracker = null, delete _[_e]
            }
        }
    }
}

function Va(_) {
    _._valueTracker || (_._valueTracker = Ua(_))
}

function Wa(_) {
    if (!_) return !1;
    var _e = _._valueTracker;
    if (!_e) return !0;
    var et = _e.getValue(),
        tt = "";
    return _ && (tt = Ta(_) ? _.checked ? "true" : "false" : _.value), _ = tt, _ !== et ? (_e.setValue(_), !0) : !1
}

function Xa(_) {
    if (_ = _ || (typeof document < "u" ? document : void 0), typeof _ > "u") return null;
    try {
        return _.activeElement || _.body
    } catch {
        return _.body
    }
}

function Ya(_, _e) {
    var et = _e.checked;
    return m$4({}, _e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: et ?? _._wrapperState.initialChecked
    })
}

function Za(_, _e) {
    var et = _e.defaultValue == null ? "" : _e.defaultValue,
        tt = _e.checked != null ? _e.checked : _e.defaultChecked;
    et = Sa(_e.value != null ? _e.value : et), _._wrapperState = {
        initialChecked: tt,
        initialValue: et,
        controlled: _e.type === "checkbox" || _e.type === "radio" ? _e.checked != null : _e.value != null
    }
}

function $a(_, _e) {
    _e = _e.checked, _e != null && qa(_, "checked", _e, !1)
}

function ab(_, _e) {
    $a(_, _e);
    var et = Sa(_e.value),
        tt = _e.type;
    if (et != null) tt === "number" ? (et === 0 && _.value === "" || _.value != et) && (_.value = "" + et) : _.value !== "" + et && (_.value = "" + et);
    else if (tt === "submit" || tt === "reset") {
        _.removeAttribute("value");
        return
    }
    _e.hasOwnProperty("value") ? bb(_, _e.type, et) : _e.hasOwnProperty("defaultValue") && bb(_, _e.type, Sa(_e.defaultValue)), _e.checked == null && _e.defaultChecked != null && (_.defaultChecked = !!_e.defaultChecked)
}

function cb(_, _e, et) {
    if (_e.hasOwnProperty("value") || _e.hasOwnProperty("defaultValue")) {
        var tt = _e.type;
        if (!(tt !== "submit" && tt !== "reset" || _e.value !== void 0 && _e.value !== null)) return;
        _e = "" + _._wrapperState.initialValue, et || _e === _.value || (_.value = _e), _.defaultValue = _e
    }
    et = _.name, et !== "" && (_.name = ""), _.defaultChecked = !!_._wrapperState.initialChecked, et !== "" && (_.name = et)
}

function bb(_, _e, et) {
    (_e !== "number" || Xa(_.ownerDocument) !== _) && (et == null ? _.defaultValue = "" + _._wrapperState.initialValue : _.defaultValue !== "" + et && (_.defaultValue = "" + et))
}

function db(_) {
    var _e = "";
    return aa.Children.forEach(_, function(et) {
        et != null && (_e += et)
    }), _e
}

function eb(_, _e) {
    return _ = m$4({
        children: void 0
    }, _e), (_e = db(_e.children)) && (_.children = _e), _
}

function fb(_, _e, et, tt) {
    if (_ = _.options, _e) {
        _e = {};
        for (var rt = 0; rt < et.length; rt++) _e["$" + et[rt]] = !0;
        for (et = 0; et < _.length; et++) rt = _e.hasOwnProperty("$" + _[et].value), _[et].selected !== rt && (_[et].selected = rt), rt && tt && (_[et].defaultSelected = !0)
    } else {
        for (et = "" + Sa(et), _e = null, rt = 0; rt < _.length; rt++) {
            if (_[rt].value === et) {
                _[rt].selected = !0, tt && (_[rt].defaultSelected = !0);
                return
            }
            _e !== null || _[rt].disabled || (_e = _[rt])
        }
        _e !== null && (_e.selected = !0)
    }
}

function gb(_, _e) {
    if (_e.dangerouslySetInnerHTML != null) throw Error(y$2(91));
    return m$4({}, _e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + _._wrapperState.initialValue
    })
}

function hb(_, _e) {
    var et = _e.value;
    if (et == null) {
        if (et = _e.children, _e = _e.defaultValue, et != null) {
            if (_e != null) throw Error(y$2(92));
            if (Array.isArray(et)) {
                if (!(1 >= et.length)) throw Error(y$2(93));
                et = et[0]
            }
            _e = et
        }
        _e == null && (_e = ""), et = _e
    }
    _._wrapperState = {
        initialValue: Sa(et)
    }
}

function ib(_, _e) {
    var et = Sa(_e.value),
        tt = Sa(_e.defaultValue);
    et != null && (et = "" + et, et !== _.value && (_.value = et), _e.defaultValue == null && _.defaultValue !== et && (_.defaultValue = et)), tt != null && (_.defaultValue = "" + tt)
}

function jb(_) {
    var _e = _.textContent;
    _e === _._wrapperState.initialValue && _e !== "" && _e !== null && (_.value = _e)
}
var kb = {
    html: "http://www.w3.org/1999/xhtml",
    mathml: "http://www.w3.org/1998/Math/MathML",
    svg: "http://www.w3.org/2000/svg"
};

function lb(_) {
    switch (_) {
        case "svg":
            return "http://www.w3.org/2000/svg";
        case "math":
            return "http://www.w3.org/1998/Math/MathML";
        default:
            return "http://www.w3.org/1999/xhtml"
    }
}

function mb(_, _e) {
    return _ == null || _ === "http://www.w3.org/1999/xhtml" ? lb(_e) : _ === "http://www.w3.org/2000/svg" && _e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : _
}
var nb, ob = function(_) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(_e, et, tt, rt) {
        MSApp.execUnsafeLocalFunction(function() {
            return _(_e, et, tt, rt)
        })
    } : _
}(function(_, _e) {
    if (_.namespaceURI !== kb.svg || "innerHTML" in _) _.innerHTML = _e;
    else {
        for (nb = nb || document.createElement("div"), nb.innerHTML = "<svg>" + _e.valueOf().toString() + "</svg>", _e = nb.firstChild; _.firstChild;) _.removeChild(_.firstChild);
        for (; _e.firstChild;) _.appendChild(_e.firstChild)
    }
});

function pb(_, _e) {
    if (_e) {
        var et = _.firstChild;
        if (et && et === _.lastChild && et.nodeType === 3) {
            et.nodeValue = _e;
            return
        }
    }
    _.textContent = _e
}
var qb = {
        animationIterationCount: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    },
    rb = ["Webkit", "ms", "Moz", "O"];
Object.keys(qb).forEach(function(_) {
    rb.forEach(function(_e) {
        _e = _e + _.charAt(0).toUpperCase() + _.substring(1), qb[_e] = qb[_]
    })
});

function sb(_, _e, et) {
    return _e == null || typeof _e == "boolean" || _e === "" ? "" : et || typeof _e != "number" || _e === 0 || qb.hasOwnProperty(_) && qb[_] ? ("" + _e).trim() : _e + "px"
}

function tb(_, _e) {
    _ = _.style;
    for (var et in _e)
        if (_e.hasOwnProperty(et)) {
            var tt = et.indexOf("--") === 0,
                rt = sb(et, _e[et], tt);
            et === "float" && (et = "cssFloat"), tt ? _.setProperty(et, rt) : _[et] = rt
        }
}
var ub = m$4({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});

function vb(_, _e) {
    if (_e) {
        if (ub[_] && (_e.children != null || _e.dangerouslySetInnerHTML != null)) throw Error(y$2(137, _));
        if (_e.dangerouslySetInnerHTML != null) {
            if (_e.children != null) throw Error(y$2(60));
            if (!(typeof _e.dangerouslySetInnerHTML == "object" && "__html" in _e.dangerouslySetInnerHTML)) throw Error(y$2(61))
        }
        if (_e.style != null && typeof _e.style != "object") throw Error(y$2(62))
    }
}

function wb(_, _e) {
    if (_.indexOf("-") === -1) return typeof _e.is == "string";
    switch (_) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
    }
}

function xb(_) {
    return _ = _.target || _.srcElement || window, _.correspondingUseElement && (_ = _.correspondingUseElement), _.nodeType === 3 ? _.parentNode : _
}
var yb = null,
    zb = null,
    Ab = null;

function Bb(_) {
    if (_ = Cb(_)) {
        if (typeof yb != "function") throw Error(y$2(280));
        var _e = _.stateNode;
        _e && (_e = Db(_e), yb(_.stateNode, _.type, _e))
    }
}

function Eb(_) {
    zb ? Ab ? Ab.push(_) : Ab = [_] : zb = _
}

function Fb() {
    if (zb) {
        var _ = zb,
            _e = Ab;
        if (Ab = zb = null, Bb(_), _e)
            for (_ = 0; _ < _e.length; _++) Bb(_e[_])
    }
}

function Gb(_, _e) {
    return _(_e)
}

function Hb(_, _e, et, tt, rt) {
    return _(_e, et, tt, rt)
}

function Ib() {}
var Jb = Gb,
    Kb = !1,
    Lb = !1;

function Mb() {
    (zb !== null || Ab !== null) && (Ib(), Fb())
}

function Nb(_, _e, et) {
    if (Lb) return _(_e, et);
    Lb = !0;
    try {
        return Jb(_, _e, et)
    } finally {
        Lb = !1, Mb()
    }
}

function Ob(_, _e) {
    var et = _.stateNode;
    if (et === null) return null;
    var tt = Db(et);
    if (tt === null) return null;
    et = tt[_e];
    e: switch (_e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (tt = !tt.disabled) || (_ = _.type, tt = !(_ === "button" || _ === "input" || _ === "select" || _ === "textarea")), _ = !tt;
            break e;
        default:
            _ = !1
    }
    if (_) return null;
    if (et && typeof et != "function") throw Error(y$2(231, _e, typeof et));
    return et
}
var Pb = !1;
if (fa) try {
    var Qb = {};
    Object.defineProperty(Qb, "passive", {
        get: function() {
            Pb = !0
        }
    }), window.addEventListener("test", Qb, Qb), window.removeEventListener("test", Qb, Qb)
} catch {
    Pb = !1
}

function Rb(_, _e, et, tt, rt, nt, at, st, it) {
    var ut = Array.prototype.slice.call(arguments, 3);
    try {
        _e.apply(et, ut)
    } catch (lt) {
        this.onError(lt)
    }
}
var Sb = !1,
    Tb = null,
    Ub = !1,
    Vb = null,
    Wb = {
        onError: function(_) {
            Sb = !0, Tb = _
        }
    };

function Xb(_, _e, et, tt, rt, nt, at, st, it) {
    Sb = !1, Tb = null, Rb.apply(Wb, arguments)
}

function Yb(_, _e, et, tt, rt, nt, at, st, it) {
    if (Xb.apply(this, arguments), Sb) {
        if (Sb) {
            var ut = Tb;
            Sb = !1, Tb = null
        } else throw Error(y$2(198));
        Ub || (Ub = !0, Vb = ut)
    }
}

function Zb(_) {
    var _e = _,
        et = _;
    if (_.alternate)
        for (; _e.return;) _e = _e.return;
    else {
        _ = _e;
        do _e = _, _e.flags & 1026 && (et = _e.return), _ = _e.return; while (_)
    }
    return _e.tag === 3 ? et : null
}

function $b(_) {
    if (_.tag === 13) {
        var _e = _.memoizedState;
        if (_e === null && (_ = _.alternate, _ !== null && (_e = _.memoizedState)), _e !== null) return _e.dehydrated
    }
    return null
}

function ac(_) {
    if (Zb(_) !== _) throw Error(y$2(188))
}

function bc(_) {
    var _e = _.alternate;
    if (!_e) {
        if (_e = Zb(_), _e === null) throw Error(y$2(188));
        return _e !== _ ? null : _
    }
    for (var et = _, tt = _e;;) {
        var rt = et.return;
        if (rt === null) break;
        var nt = rt.alternate;
        if (nt === null) {
            if (tt = rt.return, tt !== null) {
                et = tt;
                continue
            }
            break
        }
        if (rt.child === nt.child) {
            for (nt = rt.child; nt;) {
                if (nt === et) return ac(rt), _;
                if (nt === tt) return ac(rt), _e;
                nt = nt.sibling
            }
            throw Error(y$2(188))
        }
        if (et.return !== tt.return) et = rt, tt = nt;
        else {
            for (var at = !1, st = rt.child; st;) {
                if (st === et) {
                    at = !0, et = rt, tt = nt;
                    break
                }
                if (st === tt) {
                    at = !0, tt = rt, et = nt;
                    break
                }
                st = st.sibling
            }
            if (!at) {
                for (st = nt.child; st;) {
                    if (st === et) {
                        at = !0, et = nt, tt = rt;
                        break
                    }
                    if (st === tt) {
                        at = !0, tt = nt, et = rt;
                        break
                    }
                    st = st.sibling
                }
                if (!at) throw Error(y$2(189))
            }
        }
        if (et.alternate !== tt) throw Error(y$2(190))
    }
    if (et.tag !== 3) throw Error(y$2(188));
    return et.stateNode.current === et ? _ : _e
}

function cc(_) {
    if (_ = bc(_), !_) return null;
    for (var _e = _;;) {
        if (_e.tag === 5 || _e.tag === 6) return _e;
        if (_e.child) _e.child.return = _e, _e = _e.child;
        else {
            if (_e === _) break;
            for (; !_e.sibling;) {
                if (!_e.return || _e.return === _) return null;
                _e = _e.return
            }
            _e.sibling.return = _e.return, _e = _e.sibling
        }
    }
    return null
}

function dc(_, _e) {
    for (var et = _.alternate; _e !== null;) {
        if (_e === _ || _e === et) return !0;
        _e = _e.return
    }
    return !1
}
var ec, fc, gc, hc, ic = !1,
    jc = [],
    kc = null,
    lc = null,
    mc = null,
    nc = new Map,
    oc = new Map,
    pc = [],
    qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

function rc(_, _e, et, tt, rt) {
    return {
        blockedOn: _,
        domEventName: _e,
        eventSystemFlags: et | 16,
        nativeEvent: rt,
        targetContainers: [tt]
    }
}

function sc(_, _e) {
    switch (_) {
        case "focusin":
        case "focusout":
            kc = null;
            break;
        case "dragenter":
        case "dragleave":
            lc = null;
            break;
        case "mouseover":
        case "mouseout":
            mc = null;
            break;
        case "pointerover":
        case "pointerout":
            nc.delete(_e.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            oc.delete(_e.pointerId)
    }
}

function tc(_, _e, et, tt, rt, nt) {
    return _ === null || _.nativeEvent !== nt ? (_ = rc(_e, et, tt, rt, nt), _e !== null && (_e = Cb(_e), _e !== null && fc(_e)), _) : (_.eventSystemFlags |= tt, _e = _.targetContainers, rt !== null && _e.indexOf(rt) === -1 && _e.push(rt), _)
}

function uc(_, _e, et, tt, rt) {
    switch (_e) {
        case "focusin":
            return kc = tc(kc, _, _e, et, tt, rt), !0;
        case "dragenter":
            return lc = tc(lc, _, _e, et, tt, rt), !0;
        case "mouseover":
            return mc = tc(mc, _, _e, et, tt, rt), !0;
        case "pointerover":
            var nt = rt.pointerId;
            return nc.set(nt, tc(nc.get(nt) || null, _, _e, et, tt, rt)), !0;
        case "gotpointercapture":
            return nt = rt.pointerId, oc.set(nt, tc(oc.get(nt) || null, _, _e, et, tt, rt)), !0
    }
    return !1
}

function vc(_) {
    var _e = wc(_.target);
    if (_e !== null) {
        var et = Zb(_e);
        if (et !== null) {
            if (_e = et.tag, _e === 13) {
                if (_e = $b(et), _e !== null) {
                    _.blockedOn = _e, hc(_.lanePriority, function() {
                        r$4.unstable_runWithPriority(_.priority, function() {
                            gc(et)
                        })
                    });
                    return
                }
            } else if (_e === 3 && et.stateNode.hydrate) {
                _.blockedOn = et.tag === 3 ? et.stateNode.containerInfo : null;
                return
            }
        }
    }
    _.blockedOn = null
}

function xc(_) {
    if (_.blockedOn !== null) return !1;
    for (var _e = _.targetContainers; 0 < _e.length;) {
        var et = yc(_.domEventName, _.eventSystemFlags, _e[0], _.nativeEvent);
        if (et !== null) return _e = Cb(et), _e !== null && fc(_e), _.blockedOn = et, !1;
        _e.shift()
    }
    return !0
}

function zc(_, _e, et) {
    xc(_) && et.delete(_e)
}

function Ac() {
    for (ic = !1; 0 < jc.length;) {
        var _ = jc[0];
        if (_.blockedOn !== null) {
            _ = Cb(_.blockedOn), _ !== null && ec(_);
            break
        }
        for (var _e = _.targetContainers; 0 < _e.length;) {
            var et = yc(_.domEventName, _.eventSystemFlags, _e[0], _.nativeEvent);
            if (et !== null) {
                _.blockedOn = et;
                break
            }
            _e.shift()
        }
        _.blockedOn === null && jc.shift()
    }
    kc !== null && xc(kc) && (kc = null), lc !== null && xc(lc) && (lc = null), mc !== null && xc(mc) && (mc = null), nc.forEach(zc), oc.forEach(zc)
}

function Bc(_, _e) {
    _.blockedOn === _e && (_.blockedOn = null, ic || (ic = !0, r$4.unstable_scheduleCallback(r$4.unstable_NormalPriority, Ac)))
}

function Cc(_) {
    function _e(rt) {
        return Bc(rt, _)
    }
    if (0 < jc.length) {
        Bc(jc[0], _);
        for (var et = 1; et < jc.length; et++) {
            var tt = jc[et];
            tt.blockedOn === _ && (tt.blockedOn = null)
        }
    }
    for (kc !== null && Bc(kc, _), lc !== null && Bc(lc, _), mc !== null && Bc(mc, _), nc.forEach(_e), oc.forEach(_e), et = 0; et < pc.length; et++) tt = pc[et], tt.blockedOn === _ && (tt.blockedOn = null);
    for (; 0 < pc.length && (et = pc[0], et.blockedOn === null);) vc(et), et.blockedOn === null && pc.shift()
}

function Dc(_, _e) {
    var et = {};
    return et[_.toLowerCase()] = _e.toLowerCase(), et["Webkit" + _] = "webkit" + _e, et["Moz" + _] = "moz" + _e, et
}
var Ec = {
        animationend: Dc("Animation", "AnimationEnd"),
        animationiteration: Dc("Animation", "AnimationIteration"),
        animationstart: Dc("Animation", "AnimationStart"),
        transitionend: Dc("Transition", "TransitionEnd")
    },
    Fc = {},
    Gc = {};
fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);

function Hc(_) {
    if (Fc[_]) return Fc[_];
    if (!Ec[_]) return _;
    var _e = Ec[_],
        et;
    for (et in _e)
        if (_e.hasOwnProperty(et) && et in Gc) return Fc[_] = _e[et];
    return _
}
var Ic = Hc("animationend"),
    Jc = Hc("animationiteration"),
    Kc = Hc("animationstart"),
    Lc = Hc("transitionend"),
    Mc = new Map,
    Nc = new Map,
    Oc = ["abort", "abort", Ic, "animationEnd", Jc, "animationIteration", Kc, "animationStart", "canplay", "canPlay", "canplaythrough", "canPlayThrough", "durationchange", "durationChange", "emptied", "emptied", "encrypted", "encrypted", "ended", "ended", "error", "error", "gotpointercapture", "gotPointerCapture", "load", "load", "loadeddata", "loadedData", "loadedmetadata", "loadedMetadata", "loadstart", "loadStart", "lostpointercapture", "lostPointerCapture", "playing", "playing", "progress", "progress", "seeking", "seeking", "stalled", "stalled", "suspend", "suspend", "timeupdate", "timeUpdate", Lc, "transitionEnd", "waiting", "waiting"];

function Pc(_, _e) {
    for (var et = 0; et < _.length; et += 2) {
        var tt = _[et],
            rt = _[et + 1];
        rt = "on" + (rt[0].toUpperCase() + rt.slice(1)), Nc.set(tt, _e), Mc.set(tt, rt), da(rt, [tt])
    }
}
var Qc = r$4.unstable_now;
Qc();
var F$3 = 8;

function Rc(_) {
    if (1 & _) return F$3 = 15, 1;
    if (2 & _) return F$3 = 14, 2;
    if (4 & _) return F$3 = 13, 4;
    var _e = 24 & _;
    return _e !== 0 ? (F$3 = 12, _e) : _ & 32 ? (F$3 = 11, 32) : (_e = 192 & _, _e !== 0 ? (F$3 = 10, _e) : _ & 256 ? (F$3 = 9, 256) : (_e = 3584 & _, _e !== 0 ? (F$3 = 8, _e) : _ & 4096 ? (F$3 = 7, 4096) : (_e = 4186112 & _, _e !== 0 ? (F$3 = 6, _e) : (_e = 62914560 & _, _e !== 0 ? (F$3 = 5, _e) : _ & 67108864 ? (F$3 = 4, 67108864) : _ & 134217728 ? (F$3 = 3, 134217728) : (_e = 805306368 & _, _e !== 0 ? (F$3 = 2, _e) : 1073741824 & _ ? (F$3 = 1, 1073741824) : (F$3 = 8, _))))))
}

function Sc(_) {
    switch (_) {
        case 99:
            return 15;
        case 98:
            return 10;
        case 97:
        case 96:
            return 8;
        case 95:
            return 2;
        default:
            return 0
    }
}

function Tc(_) {
    switch (_) {
        case 15:
        case 14:
            return 99;
        case 13:
        case 12:
        case 11:
        case 10:
            return 98;
        case 9:
        case 8:
        case 7:
        case 6:
        case 4:
        case 5:
            return 97;
        case 3:
        case 2:
        case 1:
            return 95;
        case 0:
            return 90;
        default:
            throw Error(y$2(358, _))
    }
}

function Uc(_, _e) {
    var et = _.pendingLanes;
    if (et === 0) return F$3 = 0;
    var tt = 0,
        rt = 0,
        nt = _.expiredLanes,
        at = _.suspendedLanes,
        st = _.pingedLanes;
    if (nt !== 0) tt = nt, rt = F$3 = 15;
    else if (nt = et & 134217727, nt !== 0) {
        var it = nt & ~at;
        it !== 0 ? (tt = Rc(it), rt = F$3) : (st &= nt, st !== 0 && (tt = Rc(st), rt = F$3))
    } else nt = et & ~at, nt !== 0 ? (tt = Rc(nt), rt = F$3) : st !== 0 && (tt = Rc(st), rt = F$3);
    if (tt === 0) return 0;
    if (tt = 31 - Vc(tt), tt = et & ((0 > tt ? 0 : 1 << tt) << 1) - 1, _e !== 0 && _e !== tt && !(_e & at)) {
        if (Rc(_e), rt <= F$3) return _e;
        F$3 = rt
    }
    if (_e = _.entangledLanes, _e !== 0)
        for (_ = _.entanglements, _e &= tt; 0 < _e;) et = 31 - Vc(_e), rt = 1 << et, tt |= _[et], _e &= ~rt;
    return tt
}

function Wc(_) {
    return _ = _.pendingLanes & -1073741825, _ !== 0 ? _ : _ & 1073741824 ? 1073741824 : 0
}

function Xc(_, _e) {
    switch (_) {
        case 15:
            return 1;
        case 14:
            return 2;
        case 12:
            return _ = Yc(24 & ~_e), _ === 0 ? Xc(10, _e) : _;
        case 10:
            return _ = Yc(192 & ~_e), _ === 0 ? Xc(8, _e) : _;
        case 8:
            return _ = Yc(3584 & ~_e), _ === 0 && (_ = Yc(4186112 & ~_e), _ === 0 && (_ = 512)), _;
        case 2:
            return _e = Yc(805306368 & ~_e), _e === 0 && (_e = 268435456), _e
    }
    throw Error(y$2(358, _))
}

function Yc(_) {
    return _ & -_
}

function Zc(_) {
    for (var _e = [], et = 0; 31 > et; et++) _e.push(_);
    return _e
}

function $c(_, _e, et) {
    _.pendingLanes |= _e;
    var tt = _e - 1;
    _.suspendedLanes &= tt, _.pingedLanes &= tt, _ = _.eventTimes, _e = 31 - Vc(_e), _[_e] = et
}
var Vc = Math.clz32 ? Math.clz32 : ad,
    bd = Math.log,
    cd = Math.LN2;

function ad(_) {
    return _ === 0 ? 32 : 31 - (bd(_) / cd | 0) | 0
}
var dd = r$4.unstable_UserBlockingPriority,
    ed = r$4.unstable_runWithPriority,
    fd = !0;

function gd(_, _e, et, tt) {
    Kb || Ib();
    var rt = hd,
        nt = Kb;
    Kb = !0;
    try {
        Hb(rt, _, _e, et, tt)
    } finally {
        (Kb = nt) || Mb()
    }
}

function id(_, _e, et, tt) {
    ed(dd, hd.bind(null, _, _e, et, tt))
}

function hd(_, _e, et, tt) {
    if (fd) {
        var rt;
        if ((rt = (_e & 4) === 0) && 0 < jc.length && -1 < qc.indexOf(_)) _ = rc(null, _, _e, et, tt), jc.push(_);
        else {
            var nt = yc(_, _e, et, tt);
            if (nt === null) rt && sc(_, tt);
            else {
                if (rt) {
                    if (-1 < qc.indexOf(_)) {
                        _ = rc(nt, _, _e, et, tt), jc.push(_);
                        return
                    }
                    if (uc(nt, _, _e, et, tt)) return;
                    sc(_, tt)
                }
                jd(_, _e, tt, null, et)
            }
        }
    }
}

function yc(_, _e, et, tt) {
    var rt = xb(tt);
    if (rt = wc(rt), rt !== null) {
        var nt = Zb(rt);
        if (nt === null) rt = null;
        else {
            var at = nt.tag;
            if (at === 13) {
                if (rt = $b(nt), rt !== null) return rt;
                rt = null
            } else if (at === 3) {
                if (nt.stateNode.hydrate) return nt.tag === 3 ? nt.stateNode.containerInfo : null;
                rt = null
            } else nt !== rt && (rt = null)
        }
    }
    return jd(_, _e, tt, rt, et), null
}
var kd = null,
    ld = null,
    md = null;

function nd() {
    if (md) return md;
    var _, _e = ld,
        et = _e.length,
        tt, rt = "value" in kd ? kd.value : kd.textContent,
        nt = rt.length;
    for (_ = 0; _ < et && _e[_] === rt[_]; _++);
    var at = et - _;
    for (tt = 1; tt <= at && _e[et - tt] === rt[nt - tt]; tt++);
    return md = rt.slice(_, 1 < tt ? 1 - tt : void 0)
}

function od(_) {
    var _e = _.keyCode;
    return "charCode" in _ ? (_ = _.charCode, _ === 0 && _e === 13 && (_ = 13)) : _ = _e, _ === 10 && (_ = 13), 32 <= _ || _ === 13 ? _ : 0
}

function pd() {
    return !0
}

function qd() {
    return !1
}

function rd(_) {
    function _e(et, tt, rt, nt, at) {
        this._reactName = et, this._targetInst = rt, this.type = tt, this.nativeEvent = nt, this.target = at, this.currentTarget = null;
        for (var st in _) _.hasOwnProperty(st) && (et = _[st], this[st] = et ? et(nt) : nt[st]);
        return this.isDefaultPrevented = (nt.defaultPrevented != null ? nt.defaultPrevented : nt.returnValue === !1) ? pd : qd, this.isPropagationStopped = qd, this
    }
    return m$4(_e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var et = this.nativeEvent;
            et && (et.preventDefault ? et.preventDefault() : typeof et.returnValue != "unknown" && (et.returnValue = !1), this.isDefaultPrevented = pd)
        },
        stopPropagation: function() {
            var et = this.nativeEvent;
            et && (et.stopPropagation ? et.stopPropagation() : typeof et.cancelBubble != "unknown" && (et.cancelBubble = !0), this.isPropagationStopped = pd)
        },
        persist: function() {},
        isPersistent: pd
    }), _e
}
var sd = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(_) {
            return _.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    },
    td = rd(sd),
    ud = m$4({}, sd, {
        view: 0,
        detail: 0
    }),
    vd = rd(ud),
    wd, xd, yd, Ad = m$4({}, ud, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: zd,
        button: 0,
        buttons: 0,
        relatedTarget: function(_) {
            return _.relatedTarget === void 0 ? _.fromElement === _.srcElement ? _.toElement : _.fromElement : _.relatedTarget
        },
        movementX: function(_) {
            return "movementX" in _ ? _.movementX : (_ !== yd && (yd && _.type === "mousemove" ? (wd = _.screenX - yd.screenX, xd = _.screenY - yd.screenY) : xd = wd = 0, yd = _), wd)
        },
        movementY: function(_) {
            return "movementY" in _ ? _.movementY : xd
        }
    }),
    Bd = rd(Ad),
    Cd = m$4({}, Ad, {
        dataTransfer: 0
    }),
    Dd = rd(Cd),
    Ed = m$4({}, ud, {
        relatedTarget: 0
    }),
    Fd = rd(Ed),
    Gd = m$4({}, sd, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    Hd = rd(Gd),
    Id = m$4({}, sd, {
        clipboardData: function(_) {
            return "clipboardData" in _ ? _.clipboardData : window.clipboardData
        }
    }),
    Jd = rd(Id),
    Kd = m$4({}, sd, {
        data: 0
    }),
    Ld = rd(Kd),
    Md = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    },
    Nd = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    },
    Od = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };

function Pd(_) {
    var _e = this.nativeEvent;
    return _e.getModifierState ? _e.getModifierState(_) : (_ = Od[_]) ? !!_e[_] : !1
}

function zd() {
    return Pd
}
var Qd = m$4({}, ud, {
        key: function(_) {
            if (_.key) {
                var _e = Md[_.key] || _.key;
                if (_e !== "Unidentified") return _e
            }
            return _.type === "keypress" ? (_ = od(_), _ === 13 ? "Enter" : String.fromCharCode(_)) : _.type === "keydown" || _.type === "keyup" ? Nd[_.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: zd,
        charCode: function(_) {
            return _.type === "keypress" ? od(_) : 0
        },
        keyCode: function(_) {
            return _.type === "keydown" || _.type === "keyup" ? _.keyCode : 0
        },
        which: function(_) {
            return _.type === "keypress" ? od(_) : _.type === "keydown" || _.type === "keyup" ? _.keyCode : 0
        }
    }),
    Rd = rd(Qd),
    Sd = m$4({}, Ad, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    }),
    Td = rd(Sd),
    Ud = m$4({}, ud, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: zd
    }),
    Vd = rd(Ud),
    Wd = m$4({}, sd, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    Xd = rd(Wd),
    Yd = m$4({}, Ad, {
        deltaX: function(_) {
            return "deltaX" in _ ? _.deltaX : "wheelDeltaX" in _ ? -_.wheelDeltaX : 0
        },
        deltaY: function(_) {
            return "deltaY" in _ ? _.deltaY : "wheelDeltaY" in _ ? -_.wheelDeltaY : "wheelDelta" in _ ? -_.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    }),
    Zd = rd(Yd),
    $d = [9, 13, 27, 32],
    ae = fa && "CompositionEvent" in window,
    be$1 = null;
fa && "documentMode" in document && (be$1 = document.documentMode);
var ce = fa && "TextEvent" in window && !be$1,
    de = fa && (!ae || be$1 && 8 < be$1 && 11 >= be$1),
    ee = String.fromCharCode(32),
    fe = !1;

function ge$1(_, _e) {
    switch (_) {
        case "keyup":
            return $d.indexOf(_e.keyCode) !== -1;
        case "keydown":
            return _e.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
    }
}

function he(_) {
    return _ = _.detail, typeof _ == "object" && "data" in _ ? _.data : null
}
var ie$1 = !1;

function je$1(_, _e) {
    switch (_) {
        case "compositionend":
            return he(_e);
        case "keypress":
            return _e.which !== 32 ? null : (fe = !0, ee);
        case "textInput":
            return _ = _e.data, _ === ee && fe ? null : _;
        default:
            return null
    }
}

function ke(_, _e) {
    if (ie$1) return _ === "compositionend" || !ae && ge$1(_, _e) ? (_ = nd(), md = ld = kd = null, ie$1 = !1, _) : null;
    switch (_) {
        case "paste":
            return null;
        case "keypress":
            if (!(_e.ctrlKey || _e.altKey || _e.metaKey) || _e.ctrlKey && _e.altKey) {
                if (_e.char && 1 < _e.char.length) return _e.char;
                if (_e.which) return String.fromCharCode(_e.which)
            }
            return null;
        case "compositionend":
            return de && _e.locale !== "ko" ? null : _e.data;
        default:
            return null
    }
}
var le = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};

function me(_) {
    var _e = _ && _.nodeName && _.nodeName.toLowerCase();
    return _e === "input" ? !!le[_.type] : _e === "textarea"
}

function ne$1(_, _e, et, tt) {
    Eb(tt), _e = oe$1(_e, "onChange"), 0 < _e.length && (et = new td("onChange", "change", null, et, tt), _.push({
        event: et,
        listeners: _e
    }))
}
var pe = null,
    qe$1 = null;

function re$1(_) {
    se(_, 0)
}

function te(_) {
    var _e = ue(_);
    if (Wa(_e)) return _
}

function ve(_, _e) {
    if (_ === "change") return _e
}
var we = !1;
if (fa) {
    var xe$1;
    if (fa) {
        var ye$1 = "oninput" in document;
        if (!ye$1) {
            var ze$1 = document.createElement("div");
            ze$1.setAttribute("oninput", "return;"), ye$1 = typeof ze$1.oninput == "function"
        }
        xe$1 = ye$1
    } else xe$1 = !1;
    we = xe$1 && (!document.documentMode || 9 < document.documentMode)
}

function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be$1), qe$1 = pe = null)
}

function Be$1(_) {
    if (_.propertyName === "value" && te(qe$1)) {
        var _e = [];
        if (ne$1(_e, qe$1, _, xb(_)), _ = re$1, Kb) _(_e);
        else {
            Kb = !0;
            try {
                Gb(_, _e)
            } finally {
                Kb = !1, Mb()
            }
        }
    }
}

function Ce$1(_, _e, et) {
    _ === "focusin" ? (Ae(), pe = _e, qe$1 = et, pe.attachEvent("onpropertychange", Be$1)) : _ === "focusout" && Ae()
}

function De(_) {
    if (_ === "selectionchange" || _ === "keyup" || _ === "keydown") return te(qe$1)
}

function Ee$1(_, _e) {
    if (_ === "click") return te(_e)
}

function Fe(_, _e) {
    if (_ === "input" || _ === "change") return te(_e)
}

function Ge$1(_, _e) {
    return _ === _e && (_ !== 0 || 1 / _ === 1 / _e) || _ !== _ && _e !== _e
}
var He$1 = typeof Object.is == "function" ? Object.is : Ge$1,
    Ie = Object.prototype.hasOwnProperty;

function Je$2(_, _e) {
    if (He$1(_, _e)) return !0;
    if (typeof _ != "object" || _ === null || typeof _e != "object" || _e === null) return !1;
    var et = Object.keys(_),
        tt = Object.keys(_e);
    if (et.length !== tt.length) return !1;
    for (tt = 0; tt < et.length; tt++)
        if (!Ie.call(_e, et[tt]) || !He$1(_[et[tt]], _e[et[tt]])) return !1;
    return !0
}

function Ke$1(_) {
    for (; _ && _.firstChild;) _ = _.firstChild;
    return _
}

function Le(_, _e) {
    var et = Ke$1(_);
    _ = 0;
    for (var tt; et;) {
        if (et.nodeType === 3) {
            if (tt = _ + et.textContent.length, _ <= _e && tt >= _e) return {
                node: et,
                offset: _e - _
            };
            _ = tt
        }
        e: {
            for (; et;) {
                if (et.nextSibling) {
                    et = et.nextSibling;
                    break e
                }
                et = et.parentNode
            }
            et = void 0
        }
        et = Ke$1(et)
    }
}

function Me(_, _e) {
    return _ && _e ? _ === _e ? !0 : _ && _.nodeType === 3 ? !1 : _e && _e.nodeType === 3 ? Me(_, _e.parentNode) : "contains" in _ ? _.contains(_e) : _.compareDocumentPosition ? !!(_.compareDocumentPosition(_e) & 16) : !1 : !1
}

function Ne$1() {
    for (var _ = window, _e = Xa(); _e instanceof _.HTMLIFrameElement;) {
        try {
            var et = typeof _e.contentWindow.location.href == "string"
        } catch {
            et = !1
        }
        if (et) _ = _e.contentWindow;
        else break;
        _e = Xa(_.document)
    }
    return _e
}

function Oe(_) {
    var _e = _ && _.nodeName && _.nodeName.toLowerCase();
    return _e && (_e === "input" && (_.type === "text" || _.type === "search" || _.type === "tel" || _.type === "url" || _.type === "password") || _e === "textarea" || _.contentEditable === "true")
}
var Pe$1 = fa && "documentMode" in document && 11 >= document.documentMode,
    Qe$1 = null,
    Re = null,
    Se$1 = null,
    Te = !1;

function Ue$1(_, _e, et) {
    var tt = et.window === et ? et.document : et.nodeType === 9 ? et : et.ownerDocument;
    Te || Qe$1 == null || Qe$1 !== Xa(tt) || (tt = Qe$1, "selectionStart" in tt && Oe(tt) ? tt = {
        start: tt.selectionStart,
        end: tt.selectionEnd
    } : (tt = (tt.ownerDocument && tt.ownerDocument.defaultView || window).getSelection(), tt = {
        anchorNode: tt.anchorNode,
        anchorOffset: tt.anchorOffset,
        focusNode: tt.focusNode,
        focusOffset: tt.focusOffset
    }), Se$1 && Je$2(Se$1, tt) || (Se$1 = tt, tt = oe$1(Re, "onSelect"), 0 < tt.length && (_e = new td("onSelect", "select", null, _e, et), _.push({
        event: _e,
        listeners: tt
    }), _e.target = Qe$1)))
}
Pc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0);
Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
Pc(Oc, 2);
for (var Ve$1 = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We$1 = 0; We$1 < Ve$1.length; We$1++) Nc.set(Ve$1[We$1], 0);
ea("onMouseEnter", ["mouseout", "mouseover"]);
ea("onMouseLeave", ["mouseout", "mouseover"]);
ea("onPointerEnter", ["pointerout", "pointerover"]);
ea("onPointerLeave", ["pointerout", "pointerover"]);
da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Xe$1 = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    Ye$1 = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe$1));

function Ze$1(_, _e, et) {
    var tt = _.type || "unknown-event";
    _.currentTarget = et, Yb(tt, _e, void 0, _), _.currentTarget = null
}

function se(_, _e) {
    _e = (_e & 4) !== 0;
    for (var et = 0; et < _.length; et++) {
        var tt = _[et],
            rt = tt.event;
        tt = tt.listeners;
        e: {
            var nt = void 0;
            if (_e)
                for (var at = tt.length - 1; 0 <= at; at--) {
                    var st = tt[at],
                        it = st.instance,
                        ut = st.currentTarget;
                    if (st = st.listener, it !== nt && rt.isPropagationStopped()) break e;
                    Ze$1(rt, st, ut), nt = it
                } else
                    for (at = 0; at < tt.length; at++) {
                        if (st = tt[at], it = st.instance, ut = st.currentTarget, st = st.listener, it !== nt && rt.isPropagationStopped()) break e;
                        Ze$1(rt, st, ut), nt = it
                    }
        }
    }
    if (Ub) throw _ = Vb, Ub = !1, Vb = null, _
}

function G(_, _e) {
    var et = $e$1(_e),
        tt = _ + "__bubble";
    et.has(tt) || (af(_e, _, 2, !1), et.add(tt))
}
var bf = "_reactListening" + Math.random().toString(36).slice(2);

function cf(_) {
    _[bf] || (_[bf] = !0, ba.forEach(function(_e) {
        Ye$1.has(_e) || df(_e, !1, _, null), df(_e, !0, _, null)
    }))
}

function df(_, _e, et, tt) {
    var rt = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 0,
        nt = et;
    if (_ === "selectionchange" && et.nodeType !== 9 && (nt = et.ownerDocument), tt !== null && !_e && Ye$1.has(_)) {
        if (_ !== "scroll") return;
        rt |= 2, nt = tt
    }
    var at = $e$1(nt),
        st = _ + "__" + (_e ? "capture" : "bubble");
    at.has(st) || (_e && (rt |= 4), af(nt, _, rt, _e), at.add(st))
}

function af(_, _e, et, tt) {
    var rt = Nc.get(_e);
    switch (rt === void 0 ? 2 : rt) {
        case 0:
            rt = gd;
            break;
        case 1:
            rt = id;
            break;
        default:
            rt = hd
    }
    et = rt.bind(null, _e, et, _), rt = void 0, !Pb || _e !== "touchstart" && _e !== "touchmove" && _e !== "wheel" || (rt = !0), tt ? rt !== void 0 ? _.addEventListener(_e, et, {
        capture: !0,
        passive: rt
    }) : _.addEventListener(_e, et, !0) : rt !== void 0 ? _.addEventListener(_e, et, {
        passive: rt
    }) : _.addEventListener(_e, et, !1)
}

function jd(_, _e, et, tt, rt) {
    var nt = tt;
    if (!(_e & 1) && !(_e & 2) && tt !== null) e: for (;;) {
        if (tt === null) return;
        var at = tt.tag;
        if (at === 3 || at === 4) {
            var st = tt.stateNode.containerInfo;
            if (st === rt || st.nodeType === 8 && st.parentNode === rt) break;
            if (at === 4)
                for (at = tt.return; at !== null;) {
                    var it = at.tag;
                    if ((it === 3 || it === 4) && (it = at.stateNode.containerInfo, it === rt || it.nodeType === 8 && it.parentNode === rt)) return;
                    at = at.return
                }
            for (; st !== null;) {
                if (at = wc(st), at === null) return;
                if (it = at.tag, it === 5 || it === 6) {
                    tt = nt = at;
                    continue e
                }
                st = st.parentNode
            }
        }
        tt = tt.return
    }
    Nb(function() {
        var ut = nt,
            lt = xb(et),
            bt = [];
        e: {
            var pt = Mc.get(_);
            if (pt !== void 0) {
                var It = td,
                    At = _;
                switch (_) {
                    case "keypress":
                        if (od(et) === 0) break e;
                    case "keydown":
                    case "keyup":
                        It = Rd;
                        break;
                    case "focusin":
                        At = "focus", It = Fd;
                        break;
                    case "focusout":
                        At = "blur", It = Fd;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        It = Fd;
                        break;
                    case "click":
                        if (et.button === 2) break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        It = Bd;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        It = Dd;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        It = Vd;
                        break;
                    case Ic:
                    case Jc:
                    case Kc:
                        It = Hd;
                        break;
                    case Lc:
                        It = Xd;
                        break;
                    case "scroll":
                        It = vd;
                        break;
                    case "wheel":
                        It = Zd;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        It = Jd;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        It = Td
                }
                var Ct = (_e & 4) !== 0,
                    ht = !Ct && _ === "scroll",
                    ot = Ct ? pt !== null ? pt + "Capture" : null : pt;
                Ct = [];
                for (var ct = ut, Et; ct !== null;) {
                    Et = ct;
                    var Dt = Et.stateNode;
                    if (Et.tag === 5 && Dt !== null && (Et = Dt, ot !== null && (Dt = Ob(ct, ot), Dt != null && Ct.push(ef(ct, Dt, Et)))), ht) break;
                    ct = ct.return
                }
                0 < Ct.length && (pt = new It(pt, At, null, et, lt), bt.push({
                    event: pt,
                    listeners: Ct
                }))
            }
        }
        if (!(_e & 7)) {
            e: {
                if (pt = _ === "mouseover" || _ === "pointerover", It = _ === "mouseout" || _ === "pointerout", pt && !(_e & 16) && (At = et.relatedTarget || et.fromElement) && (wc(At) || At[ff])) break e;
                if ((It || pt) && (pt = lt.window === lt ? lt : (pt = lt.ownerDocument) ? pt.defaultView || pt.parentWindow : window, It ? (At = et.relatedTarget || et.toElement, It = ut, At = At ? wc(At) : null, At !== null && (ht = Zb(At), At !== ht || At.tag !== 5 && At.tag !== 6) && (At = null)) : (It = null, At = ut), It !== At)) {
                    if (Ct = Bd, Dt = "onMouseLeave", ot = "onMouseEnter", ct = "mouse", (_ === "pointerout" || _ === "pointerover") && (Ct = Td, Dt = "onPointerLeave", ot = "onPointerEnter", ct = "pointer"), ht = It == null ? pt : ue(It), Et = At == null ? pt : ue(At), pt = new Ct(Dt, ct + "leave", It, et, lt), pt.target = ht, pt.relatedTarget = Et, Dt = null, wc(lt) === ut && (Ct = new Ct(ot, ct + "enter", At, et, lt), Ct.target = Et, Ct.relatedTarget = ht, Dt = Ct), ht = Dt, It && At) t: {
                        for (Ct = It, ot = At, ct = 0, Et = Ct; Et; Et = gf(Et)) ct++;
                        for (Et = 0, Dt = ot; Dt; Dt = gf(Dt)) Et++;
                        for (; 0 < ct - Et;) Ct = gf(Ct),
                        ct--;
                        for (; 0 < Et - ct;) ot = gf(ot),
                        Et--;
                        for (; ct--;) {
                            if (Ct === ot || ot !== null && Ct === ot.alternate) break t;
                            Ct = gf(Ct), ot = gf(ot)
                        }
                        Ct = null
                    }
                    else Ct = null;
                    It !== null && hf(bt, pt, It, Ct, !1), At !== null && ht !== null && hf(bt, ht, At, Ct, !0)
                }
            }
            e: {
                if (pt = ut ? ue(ut) : window, It = pt.nodeName && pt.nodeName.toLowerCase(), It === "select" || It === "input" && pt.type === "file") var Pt = ve;
                else if (me(pt))
                    if (we) Pt = Fe;
                    else {
                        Pt = De;
                        var gt = Ce$1
                    }
                else(It = pt.nodeName) && It.toLowerCase() === "input" && (pt.type === "checkbox" || pt.type === "radio") && (Pt = Ee$1);
                if (Pt && (Pt = Pt(_, ut))) {
                    ne$1(bt, Pt, et, lt);
                    break e
                }
                gt && gt(_, pt, ut),
                _ === "focusout" && (gt = pt._wrapperState) && gt.controlled && pt.type === "number" && bb(pt, "number", pt.value)
            }
            switch (gt = ut ? ue(ut) : window, _) {
                case "focusin":
                    (me(gt) || gt.contentEditable === "true") && (Qe$1 = gt, Re = ut, Se$1 = null);
                    break;
                case "focusout":
                    Se$1 = Re = Qe$1 = null;
                    break;
                case "mousedown":
                    Te = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    Te = !1, Ue$1(bt, et, lt);
                    break;
                case "selectionchange":
                    if (Pe$1) break;
                case "keydown":
                case "keyup":
                    Ue$1(bt, et, lt)
            }
            var ft;
            if (ae) e: {
                switch (_) {
                    case "compositionstart":
                        var dt = "onCompositionStart";
                        break e;
                    case "compositionend":
                        dt = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        dt = "onCompositionUpdate";
                        break e
                }
                dt = void 0
            }
            else ie$1 ? ge$1(_, et) && (dt = "onCompositionEnd") : _ === "keydown" && et.keyCode === 229 && (dt = "onCompositionStart");dt && (de && et.locale !== "ko" && (ie$1 || dt !== "onCompositionStart" ? dt === "onCompositionEnd" && ie$1 && (ft = nd()) : (kd = lt, ld = "value" in kd ? kd.value : kd.textContent, ie$1 = !0)), gt = oe$1(ut, dt), 0 < gt.length && (dt = new Ld(dt, _, null, et, lt), bt.push({
                event: dt,
                listeners: gt
            }), ft ? dt.data = ft : (ft = he(et), ft !== null && (dt.data = ft)))),
            (ft = ce ? je$1(_, et) : ke(_, et)) && (ut = oe$1(ut, "onBeforeInput"), 0 < ut.length && (lt = new Ld("onBeforeInput", "beforeinput", null, et, lt), bt.push({
                event: lt,
                listeners: ut
            }), lt.data = ft))
        }
        se(bt, _e)
    })
}

function ef(_, _e, et) {
    return {
        instance: _,
        listener: _e,
        currentTarget: et
    }
}

function oe$1(_, _e) {
    for (var et = _e + "Capture", tt = []; _ !== null;) {
        var rt = _,
            nt = rt.stateNode;
        rt.tag === 5 && nt !== null && (rt = nt, nt = Ob(_, et), nt != null && tt.unshift(ef(_, nt, rt)), nt = Ob(_, _e), nt != null && tt.push(ef(_, nt, rt))), _ = _.return
    }
    return tt
}

function gf(_) {
    if (_ === null) return null;
    do _ = _.return; while (_ && _.tag !== 5);
    return _ || null
}

function hf(_, _e, et, tt, rt) {
    for (var nt = _e._reactName, at = []; et !== null && et !== tt;) {
        var st = et,
            it = st.alternate,
            ut = st.stateNode;
        if (it !== null && it === tt) break;
        st.tag === 5 && ut !== null && (st = ut, rt ? (it = Ob(et, nt), it != null && at.unshift(ef(et, it, st))) : rt || (it = Ob(et, nt), it != null && at.push(ef(et, it, st)))), et = et.return
    }
    at.length !== 0 && _.push({
        event: _e,
        listeners: at
    })
}

function jf() {}
var kf = null,
    lf = null;

function mf(_, _e) {
    switch (_) {
        case "button":
        case "input":
        case "select":
        case "textarea":
            return !!_e.autoFocus
    }
    return !1
}

function nf(_, _e) {
    return _ === "textarea" || _ === "option" || _ === "noscript" || typeof _e.children == "string" || typeof _e.children == "number" || typeof _e.dangerouslySetInnerHTML == "object" && _e.dangerouslySetInnerHTML !== null && _e.dangerouslySetInnerHTML.__html != null
}
var of = typeof setTimeout == "function" ? setTimeout : void 0, pf = typeof clearTimeout == "function" ? clearTimeout : void 0;

function qf(_) {
    _.nodeType === 1 ? _.textContent = "" : _.nodeType === 9 && (_ = _.body, _ != null && (_.textContent = ""))
}

function rf(_) {
    for (; _ != null; _ = _.nextSibling) {
        var _e = _.nodeType;
        if (_e === 1 || _e === 3) break
    }
    return _
}

function sf(_) {
    _ = _.previousSibling;
    for (var _e = 0; _;) {
        if (_.nodeType === 8) {
            var et = _.data;
            if (et === "$" || et === "$!" || et === "$?") {
                if (_e === 0) return _;
                _e--
            } else et === "/$" && _e++
        }
        _ = _.previousSibling
    }
    return null
}
var tf = 0;

function uf(_) {
    return {
        $$typeof: Ga,
        toString: _,
        valueOf: _
    }
}
var vf = Math.random().toString(36).slice(2),
    wf = "__reactFiber$" + vf,
    xf = "__reactProps$" + vf,
    ff = "__reactContainer$" + vf,
    yf = "__reactEvents$" + vf;

function wc(_) {
    var _e = _[wf];
    if (_e) return _e;
    for (var et = _.parentNode; et;) {
        if (_e = et[ff] || et[wf]) {
            if (et = _e.alternate, _e.child !== null || et !== null && et.child !== null)
                for (_ = sf(_); _ !== null;) {
                    if (et = _[wf]) return et;
                    _ = sf(_)
                }
            return _e
        }
        _ = et, et = _.parentNode
    }
    return null
}

function Cb(_) {
    return _ = _[wf] || _[ff], !_ || _.tag !== 5 && _.tag !== 6 && _.tag !== 13 && _.tag !== 3 ? null : _
}

function ue(_) {
    if (_.tag === 5 || _.tag === 6) return _.stateNode;
    throw Error(y$2(33))
}

function Db(_) {
    return _[xf] || null
}

function $e$1(_) {
    var _e = _[yf];
    return _e === void 0 && (_e = _[yf] = new Set), _e
}
var zf = [],
    Af = -1;

function Bf(_) {
    return {
        current: _
    }
}

function H$1(_) {
    0 > Af || (_.current = zf[Af], zf[Af] = null, Af--)
}

function I$2(_, _e) {
    Af++, zf[Af] = _.current, _.current = _e
}
var Cf = {},
    M$3 = Bf(Cf),
    N$1 = Bf(!1),
    Df = Cf;

function Ef(_, _e) {
    var et = _.type.contextTypes;
    if (!et) return Cf;
    var tt = _.stateNode;
    if (tt && tt.__reactInternalMemoizedUnmaskedChildContext === _e) return tt.__reactInternalMemoizedMaskedChildContext;
    var rt = {},
        nt;
    for (nt in et) rt[nt] = _e[nt];
    return tt && (_ = _.stateNode, _.__reactInternalMemoizedUnmaskedChildContext = _e, _.__reactInternalMemoizedMaskedChildContext = rt), rt
}

function Ff(_) {
    return _ = _.childContextTypes, _ != null
}

function Gf() {
    H$1(N$1), H$1(M$3)
}

function Hf(_, _e, et) {
    if (M$3.current !== Cf) throw Error(y$2(168));
    I$2(M$3, _e), I$2(N$1, et)
}

function If(_, _e, et) {
    var tt = _.stateNode;
    if (_ = _e.childContextTypes, typeof tt.getChildContext != "function") return et;
    tt = tt.getChildContext();
    for (var rt in tt)
        if (!(rt in _)) throw Error(y$2(108, Ra(_e) || "Unknown", rt));
    return m$4({}, et, tt)
}

function Jf(_) {
    return _ = (_ = _.stateNode) && _.__reactInternalMemoizedMergedChildContext || Cf, Df = M$3.current, I$2(M$3, _), I$2(N$1, N$1.current), !0
}

function Kf(_, _e, et) {
    var tt = _.stateNode;
    if (!tt) throw Error(y$2(169));
    et ? (_ = If(_, _e, Df), tt.__reactInternalMemoizedMergedChildContext = _, H$1(N$1), H$1(M$3), I$2(M$3, _)) : H$1(N$1), I$2(N$1, et)
}
var Lf = null,
    Mf = null,
    Nf = r$4.unstable_runWithPriority,
    Of = r$4.unstable_scheduleCallback,
    Pf = r$4.unstable_cancelCallback,
    Qf = r$4.unstable_shouldYield,
    Rf = r$4.unstable_requestPaint,
    Sf = r$4.unstable_now,
    Tf = r$4.unstable_getCurrentPriorityLevel,
    Uf = r$4.unstable_ImmediatePriority,
    Vf = r$4.unstable_UserBlockingPriority,
    Wf = r$4.unstable_NormalPriority,
    Xf = r$4.unstable_LowPriority,
    Yf = r$4.unstable_IdlePriority,
    Zf = {},
    $f = Rf !== void 0 ? Rf : function() {},
    ag = null,
    bg = null,
    cg = !1,
    dg = Sf(),
    O = 1e4 > dg ? Sf : function() {
        return Sf() - dg
    };

function eg() {
    switch (Tf()) {
        case Uf:
            return 99;
        case Vf:
            return 98;
        case Wf:
            return 97;
        case Xf:
            return 96;
        case Yf:
            return 95;
        default:
            throw Error(y$2(332))
    }
}

function fg(_) {
    switch (_) {
        case 99:
            return Uf;
        case 98:
            return Vf;
        case 97:
            return Wf;
        case 96:
            return Xf;
        case 95:
            return Yf;
        default:
            throw Error(y$2(332))
    }
}

function gg(_, _e) {
    return _ = fg(_), Nf(_, _e)
}

function hg(_, _e, et) {
    return _ = fg(_), Of(_, _e, et)
}

function ig() {
    if (bg !== null) {
        var _ = bg;
        bg = null, Pf(_)
    }
    jg()
}

function jg() {
    if (!cg && ag !== null) {
        cg = !0;
        var _ = 0;
        try {
            var _e = ag;
            gg(99, function() {
                for (; _ < _e.length; _++) {
                    var et = _e[_];
                    do et = et(!0); while (et !== null)
                }
            }), ag = null
        } catch (et) {
            throw ag !== null && (ag = ag.slice(_ + 1)), Of(Uf, ig), et
        } finally {
            cg = !1
        }
    }
}
var kg = ra.ReactCurrentBatchConfig;

function lg(_, _e) {
    if (_ && _.defaultProps) {
        _e = m$4({}, _e), _ = _.defaultProps;
        for (var et in _) _e[et] === void 0 && (_e[et] = _[et]);
        return _e
    }
    return _e
}
var mg = Bf(null),
    ng = null,
    og = null,
    pg = null;

function qg() {
    pg = og = ng = null
}

function rg(_) {
    var _e = mg.current;
    H$1(mg), _.type._context._currentValue = _e
}

function sg(_, _e) {
    for (; _ !== null;) {
        var et = _.alternate;
        if ((_.childLanes & _e) === _e) {
            if (et === null || (et.childLanes & _e) === _e) break;
            et.childLanes |= _e
        } else _.childLanes |= _e, et !== null && (et.childLanes |= _e);
        _ = _.return
    }
}

function tg(_, _e) {
    ng = _, pg = og = null, _ = _.dependencies, _ !== null && _.firstContext !== null && (_.lanes & _e && (ug = !0), _.firstContext = null)
}

function vg(_, _e) {
    if (pg !== _ && _e !== !1 && _e !== 0)
        if ((typeof _e != "number" || _e === 1073741823) && (pg = _, _e = 1073741823), _e = {
                context: _,
                observedBits: _e,
                next: null
            }, og === null) {
            if (ng === null) throw Error(y$2(308));
            og = _e, ng.dependencies = {
                lanes: 0,
                firstContext: _e,
                responders: null
            }
        } else og = og.next = _e;
    return _._currentValue
}
var wg = !1;

function xg(_) {
    _.updateQueue = {
        baseState: _.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null
        },
        effects: null
    }
}

function yg(_, _e) {
    _ = _.updateQueue, _e.updateQueue === _ && (_e.updateQueue = {
        baseState: _.baseState,
        firstBaseUpdate: _.firstBaseUpdate,
        lastBaseUpdate: _.lastBaseUpdate,
        shared: _.shared,
        effects: _.effects
    })
}

function zg(_, _e) {
    return {
        eventTime: _,
        lane: _e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}

function Ag(_, _e) {
    if (_ = _.updateQueue, _ !== null) {
        _ = _.shared;
        var et = _.pending;
        et === null ? _e.next = _e : (_e.next = et.next, et.next = _e), _.pending = _e
    }
}

function Bg(_, _e) {
    var et = _.updateQueue,
        tt = _.alternate;
    if (tt !== null && (tt = tt.updateQueue, et === tt)) {
        var rt = null,
            nt = null;
        if (et = et.firstBaseUpdate, et !== null) {
            do {
                var at = {
                    eventTime: et.eventTime,
                    lane: et.lane,
                    tag: et.tag,
                    payload: et.payload,
                    callback: et.callback,
                    next: null
                };
                nt === null ? rt = nt = at : nt = nt.next = at, et = et.next
            } while (et !== null);
            nt === null ? rt = nt = _e : nt = nt.next = _e
        } else rt = nt = _e;
        et = {
            baseState: tt.baseState,
            firstBaseUpdate: rt,
            lastBaseUpdate: nt,
            shared: tt.shared,
            effects: tt.effects
        }, _.updateQueue = et;
        return
    }
    _ = et.lastBaseUpdate, _ === null ? et.firstBaseUpdate = _e : _.next = _e, et.lastBaseUpdate = _e
}

function Cg(_, _e, et, tt) {
    var rt = _.updateQueue;
    wg = !1;
    var nt = rt.firstBaseUpdate,
        at = rt.lastBaseUpdate,
        st = rt.shared.pending;
    if (st !== null) {
        rt.shared.pending = null;
        var it = st,
            ut = it.next;
        it.next = null, at === null ? nt = ut : at.next = ut, at = it;
        var lt = _.alternate;
        if (lt !== null) {
            lt = lt.updateQueue;
            var bt = lt.lastBaseUpdate;
            bt !== at && (bt === null ? lt.firstBaseUpdate = ut : bt.next = ut, lt.lastBaseUpdate = it)
        }
    }
    if (nt !== null) {
        bt = rt.baseState, at = 0, lt = ut = it = null;
        do {
            st = nt.lane;
            var pt = nt.eventTime;
            if ((tt & st) === st) {
                lt !== null && (lt = lt.next = {
                    eventTime: pt,
                    lane: 0,
                    tag: nt.tag,
                    payload: nt.payload,
                    callback: nt.callback,
                    next: null
                });
                e: {
                    var It = _,
                        At = nt;
                    switch (st = _e, pt = et, At.tag) {
                        case 1:
                            if (It = At.payload, typeof It == "function") {
                                bt = It.call(pt, bt, st);
                                break e
                            }
                            bt = It;
                            break e;
                        case 3:
                            It.flags = It.flags & -4097 | 64;
                        case 0:
                            if (It = At.payload, st = typeof It == "function" ? It.call(pt, bt, st) : It, st == null) break e;
                            bt = m$4({}, bt, st);
                            break e;
                        case 2:
                            wg = !0
                    }
                }
                nt.callback !== null && (_.flags |= 32, st = rt.effects, st === null ? rt.effects = [nt] : st.push(nt))
            } else pt = {
                eventTime: pt,
                lane: st,
                tag: nt.tag,
                payload: nt.payload,
                callback: nt.callback,
                next: null
            }, lt === null ? (ut = lt = pt, it = bt) : lt = lt.next = pt, at |= st;
            if (nt = nt.next, nt === null) {
                if (st = rt.shared.pending, st === null) break;
                nt = st.next, st.next = null, rt.lastBaseUpdate = st, rt.shared.pending = null
            }
        } while (1);
        lt === null && (it = bt), rt.baseState = it, rt.firstBaseUpdate = ut, rt.lastBaseUpdate = lt, Dg |= at, _.lanes = at, _.memoizedState = bt
    }
}

function Eg(_, _e, et) {
    if (_ = _e.effects, _e.effects = null, _ !== null)
        for (_e = 0; _e < _.length; _e++) {
            var tt = _[_e],
                rt = tt.callback;
            if (rt !== null) {
                if (tt.callback = null, tt = et, typeof rt != "function") throw Error(y$2(191, rt));
                rt.call(tt)
            }
        }
}
var Fg = new aa.Component().refs;

function Gg(_, _e, et, tt) {
    _e = _.memoizedState, et = et(tt, _e), et = et == null ? _e : m$4({}, _e, et), _.memoizedState = et, _.lanes === 0 && (_.updateQueue.baseState = et)
}
var Kg = {
    isMounted: function(_) {
        return (_ = _._reactInternals) ? Zb(_) === _ : !1
    },
    enqueueSetState: function(_, _e, et) {
        _ = _._reactInternals;
        var tt = Hg(),
            rt = Ig(_),
            nt = zg(tt, rt);
        nt.payload = _e, et != null && (nt.callback = et), Ag(_, nt), Jg(_, rt, tt)
    },
    enqueueReplaceState: function(_, _e, et) {
        _ = _._reactInternals;
        var tt = Hg(),
            rt = Ig(_),
            nt = zg(tt, rt);
        nt.tag = 1, nt.payload = _e, et != null && (nt.callback = et), Ag(_, nt), Jg(_, rt, tt)
    },
    enqueueForceUpdate: function(_, _e) {
        _ = _._reactInternals;
        var et = Hg(),
            tt = Ig(_),
            rt = zg(et, tt);
        rt.tag = 2, _e != null && (rt.callback = _e), Ag(_, rt), Jg(_, tt, et)
    }
};

function Lg(_, _e, et, tt, rt, nt, at) {
    return _ = _.stateNode, typeof _.shouldComponentUpdate == "function" ? _.shouldComponentUpdate(tt, nt, at) : _e.prototype && _e.prototype.isPureReactComponent ? !Je$2(et, tt) || !Je$2(rt, nt) : !0
}

function Mg(_, _e, et) {
    var tt = !1,
        rt = Cf,
        nt = _e.contextType;
    return typeof nt == "object" && nt !== null ? nt = vg(nt) : (rt = Ff(_e) ? Df : M$3.current, tt = _e.contextTypes, nt = (tt = tt != null) ? Ef(_, rt) : Cf), _e = new _e(et, nt), _.memoizedState = _e.state !== null && _e.state !== void 0 ? _e.state : null, _e.updater = Kg, _.stateNode = _e, _e._reactInternals = _, tt && (_ = _.stateNode, _.__reactInternalMemoizedUnmaskedChildContext = rt, _.__reactInternalMemoizedMaskedChildContext = nt), _e
}

function Ng(_, _e, et, tt) {
    _ = _e.state, typeof _e.componentWillReceiveProps == "function" && _e.componentWillReceiveProps(et, tt), typeof _e.UNSAFE_componentWillReceiveProps == "function" && _e.UNSAFE_componentWillReceiveProps(et, tt), _e.state !== _ && Kg.enqueueReplaceState(_e, _e.state, null)
}

function Og(_, _e, et, tt) {
    var rt = _.stateNode;
    rt.props = et, rt.state = _.memoizedState, rt.refs = Fg, xg(_);
    var nt = _e.contextType;
    typeof nt == "object" && nt !== null ? rt.context = vg(nt) : (nt = Ff(_e) ? Df : M$3.current, rt.context = Ef(_, nt)), Cg(_, et, rt, tt), rt.state = _.memoizedState, nt = _e.getDerivedStateFromProps, typeof nt == "function" && (Gg(_, _e, nt, et), rt.state = _.memoizedState), typeof _e.getDerivedStateFromProps == "function" || typeof rt.getSnapshotBeforeUpdate == "function" || typeof rt.UNSAFE_componentWillMount != "function" && typeof rt.componentWillMount != "function" || (_e = rt.state, typeof rt.componentWillMount == "function" && rt.componentWillMount(), typeof rt.UNSAFE_componentWillMount == "function" && rt.UNSAFE_componentWillMount(), _e !== rt.state && Kg.enqueueReplaceState(rt, rt.state, null), Cg(_, et, rt, tt), rt.state = _.memoizedState), typeof rt.componentDidMount == "function" && (_.flags |= 4)
}
var Pg = Array.isArray;

function Qg(_, _e, et) {
    if (_ = et.ref, _ !== null && typeof _ != "function" && typeof _ != "object") {
        if (et._owner) {
            if (et = et._owner, et) {
                if (et.tag !== 1) throw Error(y$2(309));
                var tt = et.stateNode
            }
            if (!tt) throw Error(y$2(147, _));
            var rt = "" + _;
            return _e !== null && _e.ref !== null && typeof _e.ref == "function" && _e.ref._stringRef === rt ? _e.ref : (_e = function(nt) {
                var at = tt.refs;
                at === Fg && (at = tt.refs = {}), nt === null ? delete at[rt] : at[rt] = nt
            }, _e._stringRef = rt, _e)
        }
        if (typeof _ != "string") throw Error(y$2(284));
        if (!et._owner) throw Error(y$2(290, _))
    }
    return _
}

function Rg(_, _e) {
    if (_.type !== "textarea") throw Error(y$2(31, Object.prototype.toString.call(_e) === "[object Object]" ? "object with keys {" + Object.keys(_e).join(", ") + "}" : _e))
}

function Sg(_) {
    function _e(ht, ot) {
        if (_) {
            var ct = ht.lastEffect;
            ct !== null ? (ct.nextEffect = ot, ht.lastEffect = ot) : ht.firstEffect = ht.lastEffect = ot, ot.nextEffect = null, ot.flags = 8
        }
    }

    function et(ht, ot) {
        if (!_) return null;
        for (; ot !== null;) _e(ht, ot), ot = ot.sibling;
        return null
    }

    function tt(ht, ot) {
        for (ht = new Map; ot !== null;) ot.key !== null ? ht.set(ot.key, ot) : ht.set(ot.index, ot), ot = ot.sibling;
        return ht
    }

    function rt(ht, ot) {
        return ht = Tg(ht, ot), ht.index = 0, ht.sibling = null, ht
    }

    function nt(ht, ot, ct) {
        return ht.index = ct, _ ? (ct = ht.alternate, ct !== null ? (ct = ct.index, ct < ot ? (ht.flags = 2, ot) : ct) : (ht.flags = 2, ot)) : ot
    }

    function at(ht) {
        return _ && ht.alternate === null && (ht.flags = 2), ht
    }

    function st(ht, ot, ct, Et) {
        return ot === null || ot.tag !== 6 ? (ot = Ug(ct, ht.mode, Et), ot.return = ht, ot) : (ot = rt(ot, ct), ot.return = ht, ot)
    }

    function it(ht, ot, ct, Et) {
        return ot !== null && ot.elementType === ct.type ? (Et = rt(ot, ct.props), Et.ref = Qg(ht, ot, ct), Et.return = ht, Et) : (Et = Vg(ct.type, ct.key, ct.props, null, ht.mode, Et), Et.ref = Qg(ht, ot, ct), Et.return = ht, Et)
    }

    function ut(ht, ot, ct, Et) {
        return ot === null || ot.tag !== 4 || ot.stateNode.containerInfo !== ct.containerInfo || ot.stateNode.implementation !== ct.implementation ? (ot = Wg(ct, ht.mode, Et), ot.return = ht, ot) : (ot = rt(ot, ct.children || []), ot.return = ht, ot)
    }

    function lt(ht, ot, ct, Et, Dt) {
        return ot === null || ot.tag !== 7 ? (ot = Xg(ct, ht.mode, Et, Dt), ot.return = ht, ot) : (ot = rt(ot, ct), ot.return = ht, ot)
    }

    function bt(ht, ot, ct) {
        if (typeof ot == "string" || typeof ot == "number") return ot = Ug("" + ot, ht.mode, ct), ot.return = ht, ot;
        if (typeof ot == "object" && ot !== null) {
            switch (ot.$$typeof) {
                case sa:
                    return ct = Vg(ot.type, ot.key, ot.props, null, ht.mode, ct), ct.ref = Qg(ht, null, ot), ct.return = ht, ct;
                case ta:
                    return ot = Wg(ot, ht.mode, ct), ot.return = ht, ot
            }
            if (Pg(ot) || La(ot)) return ot = Xg(ot, ht.mode, ct, null), ot.return = ht, ot;
            Rg(ht, ot)
        }
        return null
    }

    function pt(ht, ot, ct, Et) {
        var Dt = ot !== null ? ot.key : null;
        if (typeof ct == "string" || typeof ct == "number") return Dt !== null ? null : st(ht, ot, "" + ct, Et);
        if (typeof ct == "object" && ct !== null) {
            switch (ct.$$typeof) {
                case sa:
                    return ct.key === Dt ? ct.type === ua ? lt(ht, ot, ct.props.children, Et, Dt) : it(ht, ot, ct, Et) : null;
                case ta:
                    return ct.key === Dt ? ut(ht, ot, ct, Et) : null
            }
            if (Pg(ct) || La(ct)) return Dt !== null ? null : lt(ht, ot, ct, Et, null);
            Rg(ht, ct)
        }
        return null
    }

    function It(ht, ot, ct, Et, Dt) {
        if (typeof Et == "string" || typeof Et == "number") return ht = ht.get(ct) || null, st(ot, ht, "" + Et, Dt);
        if (typeof Et == "object" && Et !== null) {
            switch (Et.$$typeof) {
                case sa:
                    return ht = ht.get(Et.key === null ? ct : Et.key) || null, Et.type === ua ? lt(ot, ht, Et.props.children, Dt, Et.key) : it(ot, ht, Et, Dt);
                case ta:
                    return ht = ht.get(Et.key === null ? ct : Et.key) || null, ut(ot, ht, Et, Dt)
            }
            if (Pg(Et) || La(Et)) return ht = ht.get(ct) || null, lt(ot, ht, Et, Dt, null);
            Rg(ot, Et)
        }
        return null
    }

    function At(ht, ot, ct, Et) {
        for (var Dt = null, Pt = null, gt = ot, ft = ot = 0, dt = null; gt !== null && ft < ct.length; ft++) {
            gt.index > ft ? (dt = gt, gt = null) : dt = gt.sibling;
            var St = pt(ht, gt, ct[ft], Et);
            if (St === null) {
                gt === null && (gt = dt);
                break
            }
            _ && gt && St.alternate === null && _e(ht, gt), ot = nt(St, ot, ft), Pt === null ? Dt = St : Pt.sibling = St, Pt = St, gt = dt
        }
        if (ft === ct.length) return et(ht, gt), Dt;
        if (gt === null) {
            for (; ft < ct.length; ft++) gt = bt(ht, ct[ft], Et), gt !== null && (ot = nt(gt, ot, ft), Pt === null ? Dt = gt : Pt.sibling = gt, Pt = gt);
            return Dt
        }
        for (gt = tt(ht, gt); ft < ct.length; ft++) dt = It(gt, ht, ft, ct[ft], Et), dt !== null && (_ && dt.alternate !== null && gt.delete(dt.key === null ? ft : dt.key), ot = nt(dt, ot, ft), Pt === null ? Dt = dt : Pt.sibling = dt, Pt = dt);
        return _ && gt.forEach(function(_t) {
            return _e(ht, _t)
        }), Dt
    }

    function Ct(ht, ot, ct, Et) {
        var Dt = La(ct);
        if (typeof Dt != "function") throw Error(y$2(150));
        if (ct = Dt.call(ct), ct == null) throw Error(y$2(151));
        for (var Pt = Dt = null, gt = ot, ft = ot = 0, dt = null, St = ct.next(); gt !== null && !St.done; ft++, St = ct.next()) {
            gt.index > ft ? (dt = gt, gt = null) : dt = gt.sibling;
            var _t = pt(ht, gt, St.value, Et);
            if (_t === null) {
                gt === null && (gt = dt);
                break
            }
            _ && gt && _t.alternate === null && _e(ht, gt), ot = nt(_t, ot, ft), Pt === null ? Dt = _t : Pt.sibling = _t, Pt = _t, gt = dt
        }
        if (St.done) return et(ht, gt), Dt;
        if (gt === null) {
            for (; !St.done; ft++, St = ct.next()) St = bt(ht, St.value, Et), St !== null && (ot = nt(St, ot, ft), Pt === null ? Dt = St : Pt.sibling = St, Pt = St);
            return Dt
        }
        for (gt = tt(ht, gt); !St.done; ft++, St = ct.next()) St = It(gt, ht, ft, St.value, Et), St !== null && (_ && St.alternate !== null && gt.delete(St.key === null ? ft : St.key), ot = nt(St, ot, ft), Pt === null ? Dt = St : Pt.sibling = St, Pt = St);
        return _ && gt.forEach(function(vt) {
            return _e(ht, vt)
        }), Dt
    }
    return function(ht, ot, ct, Et) {
        var Dt = typeof ct == "object" && ct !== null && ct.type === ua && ct.key === null;
        Dt && (ct = ct.props.children);
        var Pt = typeof ct == "object" && ct !== null;
        if (Pt) switch (ct.$$typeof) {
            case sa:
                e: {
                    for (Pt = ct.key, Dt = ot; Dt !== null;) {
                        if (Dt.key === Pt) {
                            switch (Dt.tag) {
                                case 7:
                                    if (ct.type === ua) {
                                        et(ht, Dt.sibling), ot = rt(Dt, ct.props.children), ot.return = ht, ht = ot;
                                        break e
                                    }
                                    break;
                                default:
                                    if (Dt.elementType === ct.type) {
                                        et(ht, Dt.sibling), ot = rt(Dt, ct.props), ot.ref = Qg(ht, Dt, ct), ot.return = ht, ht = ot;
                                        break e
                                    }
                            }
                            et(ht, Dt);
                            break
                        } else _e(ht, Dt);
                        Dt = Dt.sibling
                    }
                    ct.type === ua ? (ot = Xg(ct.props.children, ht.mode, Et, ct.key), ot.return = ht, ht = ot) : (Et = Vg(ct.type, ct.key, ct.props, null, ht.mode, Et), Et.ref = Qg(ht, ot, ct), Et.return = ht, ht = Et)
                }
                return at(ht);
            case ta:
                e: {
                    for (Dt = ct.key; ot !== null;) {
                        if (ot.key === Dt)
                            if (ot.tag === 4 && ot.stateNode.containerInfo === ct.containerInfo && ot.stateNode.implementation === ct.implementation) {
                                et(ht, ot.sibling), ot = rt(ot, ct.children || []), ot.return = ht, ht = ot;
                                break e
                            } else {
                                et(ht, ot);
                                break
                            }
                        else _e(ht, ot);
                        ot = ot.sibling
                    }
                    ot = Wg(ct, ht.mode, Et),
                    ot.return = ht,
                    ht = ot
                }
                return at(ht)
        }
        if (typeof ct == "string" || typeof ct == "number") return ct = "" + ct, ot !== null && ot.tag === 6 ? (et(ht, ot.sibling), ot = rt(ot, ct), ot.return = ht, ht = ot) : (et(ht, ot), ot = Ug(ct, ht.mode, Et), ot.return = ht, ht = ot), at(ht);
        if (Pg(ct)) return At(ht, ot, ct, Et);
        if (La(ct)) return Ct(ht, ot, ct, Et);
        if (Pt && Rg(ht, ct), typeof ct > "u" && !Dt) switch (ht.tag) {
            case 1:
            case 22:
            case 0:
            case 11:
            case 15:
                throw Error(y$2(152, Ra(ht.type) || "Component"))
        }
        return et(ht, ot)
    }
}
var Yg = Sg(!0),
    Zg = Sg(!1),
    $g = {},
    ah = Bf($g),
    bh = Bf($g),
    ch = Bf($g);

function dh(_) {
    if (_ === $g) throw Error(y$2(174));
    return _
}

function eh(_, _e) {
    switch (I$2(ch, _e), I$2(bh, _), I$2(ah, $g), _ = _e.nodeType, _) {
        case 9:
        case 11:
            _e = (_e = _e.documentElement) ? _e.namespaceURI : mb(null, "");
            break;
        default:
            _ = _ === 8 ? _e.parentNode : _e, _e = _.namespaceURI || null, _ = _.tagName, _e = mb(_e, _)
    }
    H$1(ah), I$2(ah, _e)
}

function fh() {
    H$1(ah), H$1(bh), H$1(ch)
}

function gh(_) {
    dh(ch.current);
    var _e = dh(ah.current),
        et = mb(_e, _.type);
    _e !== et && (I$2(bh, _), I$2(ah, et))
}

function hh(_) {
    bh.current === _ && (H$1(ah), H$1(bh))
}
var P$1 = Bf(0);

function ih(_) {
    for (var _e = _; _e !== null;) {
        if (_e.tag === 13) {
            var et = _e.memoizedState;
            if (et !== null && (et = et.dehydrated, et === null || et.data === "$?" || et.data === "$!")) return _e
        } else if (_e.tag === 19 && _e.memoizedProps.revealOrder !== void 0) {
            if (_e.flags & 64) return _e
        } else if (_e.child !== null) {
            _e.child.return = _e, _e = _e.child;
            continue
        }
        if (_e === _) break;
        for (; _e.sibling === null;) {
            if (_e.return === null || _e.return === _) return null;
            _e = _e.return
        }
        _e.sibling.return = _e.return, _e = _e.sibling
    }
    return null
}
var jh = null,
    kh = null,
    lh = !1;

function mh(_, _e) {
    var et = nh(5, null, null, 0);
    et.elementType = "DELETED", et.type = "DELETED", et.stateNode = _e, et.return = _, et.flags = 8, _.lastEffect !== null ? (_.lastEffect.nextEffect = et, _.lastEffect = et) : _.firstEffect = _.lastEffect = et
}

function oh(_, _e) {
    switch (_.tag) {
        case 5:
            var et = _.type;
            return _e = _e.nodeType !== 1 || et.toLowerCase() !== _e.nodeName.toLowerCase() ? null : _e, _e !== null ? (_.stateNode = _e, !0) : !1;
        case 6:
            return _e = _.pendingProps === "" || _e.nodeType !== 3 ? null : _e, _e !== null ? (_.stateNode = _e, !0) : !1;
        case 13:
            return !1;
        default:
            return !1
    }
}

function ph(_) {
    if (lh) {
        var _e = kh;
        if (_e) {
            var et = _e;
            if (!oh(_, _e)) {
                if (_e = rf(et.nextSibling), !_e || !oh(_, _e)) {
                    _.flags = _.flags & -1025 | 2, lh = !1, jh = _;
                    return
                }
                mh(jh, et)
            }
            jh = _, kh = rf(_e.firstChild)
        } else _.flags = _.flags & -1025 | 2, lh = !1, jh = _
    }
}

function qh(_) {
    for (_ = _.return; _ !== null && _.tag !== 5 && _.tag !== 3 && _.tag !== 13;) _ = _.return;
    jh = _
}

function rh(_) {
    if (_ !== jh) return !1;
    if (!lh) return qh(_), lh = !0, !1;
    var _e = _.type;
    if (_.tag !== 5 || _e !== "head" && _e !== "body" && !nf(_e, _.memoizedProps))
        for (_e = kh; _e;) mh(_, _e), _e = rf(_e.nextSibling);
    if (qh(_), _.tag === 13) {
        if (_ = _.memoizedState, _ = _ !== null ? _.dehydrated : null, !_) throw Error(y$2(317));
        e: {
            for (_ = _.nextSibling, _e = 0; _;) {
                if (_.nodeType === 8) {
                    var et = _.data;
                    if (et === "/$") {
                        if (_e === 0) {
                            kh = rf(_.nextSibling);
                            break e
                        }
                        _e--
                    } else et !== "$" && et !== "$!" && et !== "$?" || _e++
                }
                _ = _.nextSibling
            }
            kh = null
        }
    } else kh = jh ? rf(_.stateNode.nextSibling) : null;
    return !0
}

function sh() {
    kh = jh = null, lh = !1
}
var th = [];

function uh() {
    for (var _ = 0; _ < th.length; _++) th[_]._workInProgressVersionPrimary = null;
    th.length = 0
}
var vh = ra.ReactCurrentDispatcher,
    wh = ra.ReactCurrentBatchConfig,
    xh = 0,
    R = null,
    S$2 = null,
    T$3 = null,
    yh = !1,
    zh = !1;

function Ah() {
    throw Error(y$2(321))
}

function Bh(_, _e) {
    if (_e === null) return !1;
    for (var et = 0; et < _e.length && et < _.length; et++)
        if (!He$1(_[et], _e[et])) return !1;
    return !0
}

function Ch(_, _e, et, tt, rt, nt) {
    if (xh = nt, R = _e, _e.memoizedState = null, _e.updateQueue = null, _e.lanes = 0, vh.current = _ === null || _.memoizedState === null ? Dh : Eh, _ = et(tt, rt), zh) {
        nt = 0;
        do {
            if (zh = !1, !(25 > nt)) throw Error(y$2(301));
            nt += 1, T$3 = S$2 = null, _e.updateQueue = null, vh.current = Fh, _ = et(tt, rt)
        } while (zh)
    }
    if (vh.current = Gh, _e = S$2 !== null && S$2.next !== null, xh = 0, T$3 = S$2 = R = null, yh = !1, _e) throw Error(y$2(300));
    return _
}

function Hh() {
    var _ = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return T$3 === null ? R.memoizedState = T$3 = _ : T$3 = T$3.next = _, T$3
}

function Ih() {
    if (S$2 === null) {
        var _ = R.alternate;
        _ = _ !== null ? _.memoizedState : null
    } else _ = S$2.next;
    var _e = T$3 === null ? R.memoizedState : T$3.next;
    if (_e !== null) T$3 = _e, S$2 = _;
    else {
        if (_ === null) throw Error(y$2(310));
        S$2 = _, _ = {
            memoizedState: S$2.memoizedState,
            baseState: S$2.baseState,
            baseQueue: S$2.baseQueue,
            queue: S$2.queue,
            next: null
        }, T$3 === null ? R.memoizedState = T$3 = _ : T$3 = T$3.next = _
    }
    return T$3
}

function Jh(_, _e) {
    return typeof _e == "function" ? _e(_) : _e
}

function Kh(_) {
    var _e = Ih(),
        et = _e.queue;
    if (et === null) throw Error(y$2(311));
    et.lastRenderedReducer = _;
    var tt = S$2,
        rt = tt.baseQueue,
        nt = et.pending;
    if (nt !== null) {
        if (rt !== null) {
            var at = rt.next;
            rt.next = nt.next, nt.next = at
        }
        tt.baseQueue = rt = nt, et.pending = null
    }
    if (rt !== null) {
        rt = rt.next, tt = tt.baseState;
        var st = at = nt = null,
            it = rt;
        do {
            var ut = it.lane;
            if ((xh & ut) === ut) st !== null && (st = st.next = {
                lane: 0,
                action: it.action,
                eagerReducer: it.eagerReducer,
                eagerState: it.eagerState,
                next: null
            }), tt = it.eagerReducer === _ ? it.eagerState : _(tt, it.action);
            else {
                var lt = {
                    lane: ut,
                    action: it.action,
                    eagerReducer: it.eagerReducer,
                    eagerState: it.eagerState,
                    next: null
                };
                st === null ? (at = st = lt, nt = tt) : st = st.next = lt, R.lanes |= ut, Dg |= ut
            }
            it = it.next
        } while (it !== null && it !== rt);
        st === null ? nt = tt : st.next = at, He$1(tt, _e.memoizedState) || (ug = !0), _e.memoizedState = tt, _e.baseState = nt, _e.baseQueue = st, et.lastRenderedState = tt
    }
    return [_e.memoizedState, et.dispatch]
}

function Lh(_) {
    var _e = Ih(),
        et = _e.queue;
    if (et === null) throw Error(y$2(311));
    et.lastRenderedReducer = _;
    var tt = et.dispatch,
        rt = et.pending,
        nt = _e.memoizedState;
    if (rt !== null) {
        et.pending = null;
        var at = rt = rt.next;
        do nt = _(nt, at.action), at = at.next; while (at !== rt);
        He$1(nt, _e.memoizedState) || (ug = !0), _e.memoizedState = nt, _e.baseQueue === null && (_e.baseState = nt), et.lastRenderedState = nt
    }
    return [nt, tt]
}

function Mh(_, _e, et) {
    var tt = _e._getVersion;
    tt = tt(_e._source);
    var rt = _e._workInProgressVersionPrimary;
    if (rt !== null ? _ = rt === tt : (_ = _.mutableReadLanes, (_ = (xh & _) === _) && (_e._workInProgressVersionPrimary = tt, th.push(_e))), _) return et(_e._source);
    throw th.push(_e), Error(y$2(350))
}

function Nh(_, _e, et, tt) {
    var rt = U;
    if (rt === null) throw Error(y$2(349));
    var nt = _e._getVersion,
        at = nt(_e._source),
        st = vh.current,
        it = st.useState(function() {
            return Mh(rt, _e, et)
        }),
        ut = it[1],
        lt = it[0];
    it = T$3;
    var bt = _.memoizedState,
        pt = bt.refs,
        It = pt.getSnapshot,
        At = bt.source;
    bt = bt.subscribe;
    var Ct = R;
    return _.memoizedState = {
        refs: pt,
        source: _e,
        subscribe: tt
    }, st.useEffect(function() {
        pt.getSnapshot = et, pt.setSnapshot = ut;
        var ht = nt(_e._source);
        if (!He$1(at, ht)) {
            ht = et(_e._source), He$1(lt, ht) || (ut(ht), ht = Ig(Ct), rt.mutableReadLanes |= ht & rt.pendingLanes), ht = rt.mutableReadLanes, rt.entangledLanes |= ht;
            for (var ot = rt.entanglements, ct = ht; 0 < ct;) {
                var Et = 31 - Vc(ct),
                    Dt = 1 << Et;
                ot[Et] |= ht, ct &= ~Dt
            }
        }
    }, [et, _e, tt]), st.useEffect(function() {
        return tt(_e._source, function() {
            var ht = pt.getSnapshot,
                ot = pt.setSnapshot;
            try {
                ot(ht(_e._source));
                var ct = Ig(Ct);
                rt.mutableReadLanes |= ct & rt.pendingLanes
            } catch (Et) {
                ot(function() {
                    throw Et
                })
            }
        })
    }, [_e, tt]), He$1(It, et) && He$1(At, _e) && He$1(bt, tt) || (_ = {
        pending: null,
        dispatch: null,
        lastRenderedReducer: Jh,
        lastRenderedState: lt
    }, _.dispatch = ut = Oh.bind(null, R, _), it.queue = _, it.baseQueue = null, lt = Mh(rt, _e, et), it.memoizedState = it.baseState = lt), lt
}

function Ph(_, _e, et) {
    var tt = Ih();
    return Nh(tt, _, _e, et)
}

function Qh(_) {
    var _e = Hh();
    return typeof _ == "function" && (_ = _()), _e.memoizedState = _e.baseState = _, _ = _e.queue = {
        pending: null,
        dispatch: null,
        lastRenderedReducer: Jh,
        lastRenderedState: _
    }, _ = _.dispatch = Oh.bind(null, R, _), [_e.memoizedState, _]
}

function Rh(_, _e, et, tt) {
    return _ = {
        tag: _,
        create: _e,
        destroy: et,
        deps: tt,
        next: null
    }, _e = R.updateQueue, _e === null ? (_e = {
        lastEffect: null
    }, R.updateQueue = _e, _e.lastEffect = _.next = _) : (et = _e.lastEffect, et === null ? _e.lastEffect = _.next = _ : (tt = et.next, et.next = _, _.next = tt, _e.lastEffect = _)), _
}

function Sh(_) {
    var _e = Hh();
    return _ = {
        current: _
    }, _e.memoizedState = _
}

function Th() {
    return Ih().memoizedState
}

function Uh(_, _e, et, tt) {
    var rt = Hh();
    R.flags |= _, rt.memoizedState = Rh(1 | _e, et, void 0, tt === void 0 ? null : tt)
}

function Vh(_, _e, et, tt) {
    var rt = Ih();
    tt = tt === void 0 ? null : tt;
    var nt = void 0;
    if (S$2 !== null) {
        var at = S$2.memoizedState;
        if (nt = at.destroy, tt !== null && Bh(tt, at.deps)) {
            Rh(_e, et, nt, tt);
            return
        }
    }
    R.flags |= _, rt.memoizedState = Rh(1 | _e, et, nt, tt)
}

function Wh(_, _e) {
    return Uh(516, 4, _, _e)
}

function Xh(_, _e) {
    return Vh(516, 4, _, _e)
}

function Yh(_, _e) {
    return Vh(4, 2, _, _e)
}

function Zh(_, _e) {
    if (typeof _e == "function") return _ = _(), _e(_),
        function() {
            _e(null)
        };
    if (_e != null) return _ = _(), _e.current = _,
        function() {
            _e.current = null
        }
}

function $h(_, _e, et) {
    return et = et != null ? et.concat([_]) : null, Vh(4, 2, Zh.bind(null, _e, _), et)
}

function ai() {}

function bi(_, _e) {
    var et = Ih();
    _e = _e === void 0 ? null : _e;
    var tt = et.memoizedState;
    return tt !== null && _e !== null && Bh(_e, tt[1]) ? tt[0] : (et.memoizedState = [_, _e], _)
}

function ci(_, _e) {
    var et = Ih();
    _e = _e === void 0 ? null : _e;
    var tt = et.memoizedState;
    return tt !== null && _e !== null && Bh(_e, tt[1]) ? tt[0] : (_ = _(), et.memoizedState = [_, _e], _)
}

function di(_, _e) {
    var et = eg();
    gg(98 > et ? 98 : et, function() {
        _(!0)
    }), gg(97 < et ? 97 : et, function() {
        var tt = wh.transition;
        wh.transition = 1;
        try {
            _(!1), _e()
        } finally {
            wh.transition = tt
        }
    })
}

function Oh(_, _e, et) {
    var tt = Hg(),
        rt = Ig(_),
        nt = {
            lane: rt,
            action: et,
            eagerReducer: null,
            eagerState: null,
            next: null
        },
        at = _e.pending;
    if (at === null ? nt.next = nt : (nt.next = at.next, at.next = nt), _e.pending = nt, at = _.alternate, _ === R || at !== null && at === R) zh = yh = !0;
    else {
        if (_.lanes === 0 && (at === null || at.lanes === 0) && (at = _e.lastRenderedReducer, at !== null)) try {
            var st = _e.lastRenderedState,
                it = at(st, et);
            if (nt.eagerReducer = at, nt.eagerState = it, He$1(it, st)) return
        } catch {} finally {}
        Jg(_, rt, tt)
    }
}
var Gh = {
        readContext: vg,
        useCallback: Ah,
        useContext: Ah,
        useEffect: Ah,
        useImperativeHandle: Ah,
        useLayoutEffect: Ah,
        useMemo: Ah,
        useReducer: Ah,
        useRef: Ah,
        useState: Ah,
        useDebugValue: Ah,
        useDeferredValue: Ah,
        useTransition: Ah,
        useMutableSource: Ah,
        useOpaqueIdentifier: Ah,
        unstable_isNewReconciler: !1
    },
    Dh = {
        readContext: vg,
        useCallback: function(_, _e) {
            return Hh().memoizedState = [_, _e === void 0 ? null : _e], _
        },
        useContext: vg,
        useEffect: Wh,
        useImperativeHandle: function(_, _e, et) {
            return et = et != null ? et.concat([_]) : null, Uh(4, 2, Zh.bind(null, _e, _), et)
        },
        useLayoutEffect: function(_, _e) {
            return Uh(4, 2, _, _e)
        },
        useMemo: function(_, _e) {
            var et = Hh();
            return _e = _e === void 0 ? null : _e, _ = _(), et.memoizedState = [_, _e], _
        },
        useReducer: function(_, _e, et) {
            var tt = Hh();
            return _e = et !== void 0 ? et(_e) : _e, tt.memoizedState = tt.baseState = _e, _ = tt.queue = {
                pending: null,
                dispatch: null,
                lastRenderedReducer: _,
                lastRenderedState: _e
            }, _ = _.dispatch = Oh.bind(null, R, _), [tt.memoizedState, _]
        },
        useRef: Sh,
        useState: Qh,
        useDebugValue: ai,
        useDeferredValue: function(_) {
            var _e = Qh(_),
                et = _e[0],
                tt = _e[1];
            return Wh(function() {
                var rt = wh.transition;
                wh.transition = 1;
                try {
                    tt(_)
                } finally {
                    wh.transition = rt
                }
            }, [_]), et
        },
        useTransition: function() {
            var _ = Qh(!1),
                _e = _[0];
            return _ = di.bind(null, _[1]), Sh(_), [_, _e]
        },
        useMutableSource: function(_, _e, et) {
            var tt = Hh();
            return tt.memoizedState = {
                refs: {
                    getSnapshot: _e,
                    setSnapshot: null
                },
                source: _,
                subscribe: et
            }, Nh(tt, _, _e, et)
        },
        useOpaqueIdentifier: function() {
            if (lh) {
                var _ = !1,
                    _e = uf(function() {
                        throw _ || (_ = !0, et("r:" + (tf++).toString(36))), Error(y$2(355))
                    }),
                    et = Qh(_e)[1];
                return !(R.mode & 2) && (R.flags |= 516, Rh(5, function() {
                    et("r:" + (tf++).toString(36))
                }, void 0, null)), _e
            }
            return _e = "r:" + (tf++).toString(36), Qh(_e), _e
        },
        unstable_isNewReconciler: !1
    },
    Eh = {
        readContext: vg,
        useCallback: bi,
        useContext: vg,
        useEffect: Xh,
        useImperativeHandle: $h,
        useLayoutEffect: Yh,
        useMemo: ci,
        useReducer: Kh,
        useRef: Th,
        useState: function() {
            return Kh(Jh)
        },
        useDebugValue: ai,
        useDeferredValue: function(_) {
            var _e = Kh(Jh),
                et = _e[0],
                tt = _e[1];
            return Xh(function() {
                var rt = wh.transition;
                wh.transition = 1;
                try {
                    tt(_)
                } finally {
                    wh.transition = rt
                }
            }, [_]), et
        },
        useTransition: function() {
            var _ = Kh(Jh)[0];
            return [Th().current, _]
        },
        useMutableSource: Ph,
        useOpaqueIdentifier: function() {
            return Kh(Jh)[0]
        },
        unstable_isNewReconciler: !1
    },
    Fh = {
        readContext: vg,
        useCallback: bi,
        useContext: vg,
        useEffect: Xh,
        useImperativeHandle: $h,
        useLayoutEffect: Yh,
        useMemo: ci,
        useReducer: Lh,
        useRef: Th,
        useState: function() {
            return Lh(Jh)
        },
        useDebugValue: ai,
        useDeferredValue: function(_) {
            var _e = Lh(Jh),
                et = _e[0],
                tt = _e[1];
            return Xh(function() {
                var rt = wh.transition;
                wh.transition = 1;
                try {
                    tt(_)
                } finally {
                    wh.transition = rt
                }
            }, [_]), et
        },
        useTransition: function() {
            var _ = Lh(Jh)[0];
            return [Th().current, _]
        },
        useMutableSource: Ph,
        useOpaqueIdentifier: function() {
            return Lh(Jh)[0]
        },
        unstable_isNewReconciler: !1
    },
    ei = ra.ReactCurrentOwner,
    ug = !1;

function fi(_, _e, et, tt) {
    _e.child = _ === null ? Zg(_e, null, et, tt) : Yg(_e, _.child, et, tt)
}

function gi(_, _e, et, tt, rt) {
    et = et.render;
    var nt = _e.ref;
    return tg(_e, rt), tt = Ch(_, _e, et, tt, nt, rt), _ !== null && !ug ? (_e.updateQueue = _.updateQueue, _e.flags &= -517, _.lanes &= ~rt, hi(_, _e, rt)) : (_e.flags |= 1, fi(_, _e, tt, rt), _e.child)
}

function ii(_, _e, et, tt, rt, nt) {
    if (_ === null) {
        var at = et.type;
        return typeof at == "function" && !ji(at) && at.defaultProps === void 0 && et.compare === null && et.defaultProps === void 0 ? (_e.tag = 15, _e.type = at, ki(_, _e, at, tt, rt, nt)) : (_ = Vg(et.type, null, tt, _e, _e.mode, nt), _.ref = _e.ref, _.return = _e, _e.child = _)
    }
    return at = _.child, !(rt & nt) && (rt = at.memoizedProps, et = et.compare, et = et !== null ? et : Je$2, et(rt, tt) && _.ref === _e.ref) ? hi(_, _e, nt) : (_e.flags |= 1, _ = Tg(at, tt), _.ref = _e.ref, _.return = _e, _e.child = _)
}

function ki(_, _e, et, tt, rt, nt) {
    if (_ !== null && Je$2(_.memoizedProps, tt) && _.ref === _e.ref)
        if (ug = !1, (nt & rt) !== 0) _.flags & 16384 && (ug = !0);
        else return _e.lanes = _.lanes, hi(_, _e, nt);
    return li(_, _e, et, tt, nt)
}

function mi(_, _e, et) {
    var tt = _e.pendingProps,
        rt = tt.children,
        nt = _ !== null ? _.memoizedState : null;
    if (tt.mode === "hidden" || tt.mode === "unstable-defer-without-hiding")
        if (!(_e.mode & 4)) _e.memoizedState = {
            baseLanes: 0
        }, ni(_e, et);
        else if (et & 1073741824) _e.memoizedState = {
        baseLanes: 0
    }, ni(_e, nt !== null ? nt.baseLanes : et);
    else return _ = nt !== null ? nt.baseLanes | et : et, _e.lanes = _e.childLanes = 1073741824, _e.memoizedState = {
        baseLanes: _
    }, ni(_e, _), null;
    else nt !== null ? (tt = nt.baseLanes | et, _e.memoizedState = null) : tt = et, ni(_e, tt);
    return fi(_, _e, rt, et), _e.child
}

function oi(_, _e) {
    var et = _e.ref;
    (_ === null && et !== null || _ !== null && _.ref !== et) && (_e.flags |= 128)
}

function li(_, _e, et, tt, rt) {
    var nt = Ff(et) ? Df : M$3.current;
    return nt = Ef(_e, nt), tg(_e, rt), et = Ch(_, _e, et, tt, nt, rt), _ !== null && !ug ? (_e.updateQueue = _.updateQueue, _e.flags &= -517, _.lanes &= ~rt, hi(_, _e, rt)) : (_e.flags |= 1, fi(_, _e, et, rt), _e.child)
}

function pi(_, _e, et, tt, rt) {
    if (Ff(et)) {
        var nt = !0;
        Jf(_e)
    } else nt = !1;
    if (tg(_e, rt), _e.stateNode === null) _ !== null && (_.alternate = null, _e.alternate = null, _e.flags |= 2), Mg(_e, et, tt), Og(_e, et, tt, rt), tt = !0;
    else if (_ === null) {
        var at = _e.stateNode,
            st = _e.memoizedProps;
        at.props = st;
        var it = at.context,
            ut = et.contextType;
        typeof ut == "object" && ut !== null ? ut = vg(ut) : (ut = Ff(et) ? Df : M$3.current, ut = Ef(_e, ut));
        var lt = et.getDerivedStateFromProps,
            bt = typeof lt == "function" || typeof at.getSnapshotBeforeUpdate == "function";
        bt || typeof at.UNSAFE_componentWillReceiveProps != "function" && typeof at.componentWillReceiveProps != "function" || (st !== tt || it !== ut) && Ng(_e, at, tt, ut), wg = !1;
        var pt = _e.memoizedState;
        at.state = pt, Cg(_e, tt, at, rt), it = _e.memoizedState, st !== tt || pt !== it || N$1.current || wg ? (typeof lt == "function" && (Gg(_e, et, lt, tt), it = _e.memoizedState), (st = wg || Lg(_e, et, st, tt, pt, it, ut)) ? (bt || typeof at.UNSAFE_componentWillMount != "function" && typeof at.componentWillMount != "function" || (typeof at.componentWillMount == "function" && at.componentWillMount(), typeof at.UNSAFE_componentWillMount == "function" && at.UNSAFE_componentWillMount()), typeof at.componentDidMount == "function" && (_e.flags |= 4)) : (typeof at.componentDidMount == "function" && (_e.flags |= 4), _e.memoizedProps = tt, _e.memoizedState = it), at.props = tt, at.state = it, at.context = ut, tt = st) : (typeof at.componentDidMount == "function" && (_e.flags |= 4), tt = !1)
    } else {
        at = _e.stateNode, yg(_, _e), st = _e.memoizedProps, ut = _e.type === _e.elementType ? st : lg(_e.type, st), at.props = ut, bt = _e.pendingProps, pt = at.context, it = et.contextType, typeof it == "object" && it !== null ? it = vg(it) : (it = Ff(et) ? Df : M$3.current, it = Ef(_e, it));
        var It = et.getDerivedStateFromProps;
        (lt = typeof It == "function" || typeof at.getSnapshotBeforeUpdate == "function") || typeof at.UNSAFE_componentWillReceiveProps != "function" && typeof at.componentWillReceiveProps != "function" || (st !== bt || pt !== it) && Ng(_e, at, tt, it), wg = !1, pt = _e.memoizedState, at.state = pt, Cg(_e, tt, at, rt);
        var At = _e.memoizedState;
        st !== bt || pt !== At || N$1.current || wg ? (typeof It == "function" && (Gg(_e, et, It, tt), At = _e.memoizedState), (ut = wg || Lg(_e, et, ut, tt, pt, At, it)) ? (lt || typeof at.UNSAFE_componentWillUpdate != "function" && typeof at.componentWillUpdate != "function" || (typeof at.componentWillUpdate == "function" && at.componentWillUpdate(tt, At, it), typeof at.UNSAFE_componentWillUpdate == "function" && at.UNSAFE_componentWillUpdate(tt, At, it)), typeof at.componentDidUpdate == "function" && (_e.flags |= 4), typeof at.getSnapshotBeforeUpdate == "function" && (_e.flags |= 256)) : (typeof at.componentDidUpdate != "function" || st === _.memoizedProps && pt === _.memoizedState || (_e.flags |= 4), typeof at.getSnapshotBeforeUpdate != "function" || st === _.memoizedProps && pt === _.memoizedState || (_e.flags |= 256), _e.memoizedProps = tt, _e.memoizedState = At), at.props = tt, at.state = At, at.context = it, tt = ut) : (typeof at.componentDidUpdate != "function" || st === _.memoizedProps && pt === _.memoizedState || (_e.flags |= 4), typeof at.getSnapshotBeforeUpdate != "function" || st === _.memoizedProps && pt === _.memoizedState || (_e.flags |= 256), tt = !1)
    }
    return qi(_, _e, et, tt, nt, rt)
}

function qi(_, _e, et, tt, rt, nt) {
    oi(_, _e);
    var at = (_e.flags & 64) !== 0;
    if (!tt && !at) return rt && Kf(_e, et, !1), hi(_, _e, nt);
    tt = _e.stateNode, ei.current = _e;
    var st = at && typeof et.getDerivedStateFromError != "function" ? null : tt.render();
    return _e.flags |= 1, _ !== null && at ? (_e.child = Yg(_e, _.child, null, nt), _e.child = Yg(_e, null, st, nt)) : fi(_, _e, st, nt), _e.memoizedState = tt.state, rt && Kf(_e, et, !0), _e.child
}

function ri(_) {
    var _e = _.stateNode;
    _e.pendingContext ? Hf(_, _e.pendingContext, _e.pendingContext !== _e.context) : _e.context && Hf(_, _e.context, !1), eh(_, _e.containerInfo)
}
var si = {
    dehydrated: null,
    retryLane: 0
};

function ti(_, _e, et) {
    var tt = _e.pendingProps,
        rt = P$1.current,
        nt = !1,
        at;
    return (at = (_e.flags & 64) !== 0) || (at = _ !== null && _.memoizedState === null ? !1 : (rt & 2) !== 0), at ? (nt = !0, _e.flags &= -65) : _ !== null && _.memoizedState === null || tt.fallback === void 0 || tt.unstable_avoidThisFallback === !0 || (rt |= 1), I$2(P$1, rt & 1), _ === null ? (tt.fallback !== void 0 && ph(_e), _ = tt.children, rt = tt.fallback, nt ? (_ = ui(_e, _, rt, et), _e.child.memoizedState = {
        baseLanes: et
    }, _e.memoizedState = si, _) : typeof tt.unstable_expectedLoadTime == "number" ? (_ = ui(_e, _, rt, et), _e.child.memoizedState = {
        baseLanes: et
    }, _e.memoizedState = si, _e.lanes = 33554432, _) : (et = vi({
        mode: "visible",
        children: _
    }, _e.mode, et, null), et.return = _e, _e.child = et)) : _.memoizedState !== null ? nt ? (tt = wi(_, _e, tt.children, tt.fallback, et), nt = _e.child, rt = _.child.memoizedState, nt.memoizedState = rt === null ? {
        baseLanes: et
    } : {
        baseLanes: rt.baseLanes | et
    }, nt.childLanes = _.childLanes & ~et, _e.memoizedState = si, tt) : (et = xi(_, _e, tt.children, et), _e.memoizedState = null, et) : nt ? (tt = wi(_, _e, tt.children, tt.fallback, et), nt = _e.child, rt = _.child.memoizedState, nt.memoizedState = rt === null ? {
        baseLanes: et
    } : {
        baseLanes: rt.baseLanes | et
    }, nt.childLanes = _.childLanes & ~et, _e.memoizedState = si, tt) : (et = xi(_, _e, tt.children, et), _e.memoizedState = null, et)
}

function ui(_, _e, et, tt) {
    var rt = _.mode,
        nt = _.child;
    return _e = {
        mode: "hidden",
        children: _e
    }, !(rt & 2) && nt !== null ? (nt.childLanes = 0, nt.pendingProps = _e) : nt = vi(_e, rt, 0, null), et = Xg(et, rt, tt, null), nt.return = _, et.return = _, nt.sibling = et, _.child = nt, et
}

function xi(_, _e, et, tt) {
    var rt = _.child;
    return _ = rt.sibling, et = Tg(rt, {
        mode: "visible",
        children: et
    }), !(_e.mode & 2) && (et.lanes = tt), et.return = _e, et.sibling = null, _ !== null && (_.nextEffect = null, _.flags = 8, _e.firstEffect = _e.lastEffect = _), _e.child = et
}

function wi(_, _e, et, tt, rt) {
    var nt = _e.mode,
        at = _.child;
    _ = at.sibling;
    var st = {
        mode: "hidden",
        children: et
    };
    return !(nt & 2) && _e.child !== at ? (et = _e.child, et.childLanes = 0, et.pendingProps = st, at = et.lastEffect, at !== null ? (_e.firstEffect = et.firstEffect, _e.lastEffect = at, at.nextEffect = null) : _e.firstEffect = _e.lastEffect = null) : et = Tg(at, st), _ !== null ? tt = Tg(_, tt) : (tt = Xg(tt, nt, rt, null), tt.flags |= 2), tt.return = _e, et.return = _e, et.sibling = tt, _e.child = et, tt
}

function yi(_, _e) {
    _.lanes |= _e;
    var et = _.alternate;
    et !== null && (et.lanes |= _e), sg(_.return, _e)
}

function zi(_, _e, et, tt, rt, nt) {
    var at = _.memoizedState;
    at === null ? _.memoizedState = {
        isBackwards: _e,
        rendering: null,
        renderingStartTime: 0,
        last: tt,
        tail: et,
        tailMode: rt,
        lastEffect: nt
    } : (at.isBackwards = _e, at.rendering = null, at.renderingStartTime = 0, at.last = tt, at.tail = et, at.tailMode = rt, at.lastEffect = nt)
}

function Ai(_, _e, et) {
    var tt = _e.pendingProps,
        rt = tt.revealOrder,
        nt = tt.tail;
    if (fi(_, _e, tt.children, et), tt = P$1.current, tt & 2) tt = tt & 1 | 2, _e.flags |= 64;
    else {
        if (_ !== null && _.flags & 64) e: for (_ = _e.child; _ !== null;) {
            if (_.tag === 13) _.memoizedState !== null && yi(_, et);
            else if (_.tag === 19) yi(_, et);
            else if (_.child !== null) {
                _.child.return = _, _ = _.child;
                continue
            }
            if (_ === _e) break e;
            for (; _.sibling === null;) {
                if (_.return === null || _.return === _e) break e;
                _ = _.return
            }
            _.sibling.return = _.return, _ = _.sibling
        }
        tt &= 1
    }
    if (I$2(P$1, tt), !(_e.mode & 2)) _e.memoizedState = null;
    else switch (rt) {
        case "forwards":
            for (et = _e.child, rt = null; et !== null;) _ = et.alternate, _ !== null && ih(_) === null && (rt = et), et = et.sibling;
            et = rt, et === null ? (rt = _e.child, _e.child = null) : (rt = et.sibling, et.sibling = null), zi(_e, !1, rt, et, nt, _e.lastEffect);
            break;
        case "backwards":
            for (et = null, rt = _e.child, _e.child = null; rt !== null;) {
                if (_ = rt.alternate, _ !== null && ih(_) === null) {
                    _e.child = rt;
                    break
                }
                _ = rt.sibling, rt.sibling = et, et = rt, rt = _
            }
            zi(_e, !0, et, null, nt, _e.lastEffect);
            break;
        case "together":
            zi(_e, !1, null, null, void 0, _e.lastEffect);
            break;
        default:
            _e.memoizedState = null
    }
    return _e.child
}

function hi(_, _e, et) {
    if (_ !== null && (_e.dependencies = _.dependencies), Dg |= _e.lanes, et & _e.childLanes) {
        if (_ !== null && _e.child !== _.child) throw Error(y$2(153));
        if (_e.child !== null) {
            for (_ = _e.child, et = Tg(_, _.pendingProps), _e.child = et, et.return = _e; _.sibling !== null;) _ = _.sibling, et = et.sibling = Tg(_, _.pendingProps), et.return = _e;
            et.sibling = null
        }
        return _e.child
    }
    return null
}
var Bi, Ci, Di, Ei;
Bi = function(_, _e) {
    for (var et = _e.child; et !== null;) {
        if (et.tag === 5 || et.tag === 6) _.appendChild(et.stateNode);
        else if (et.tag !== 4 && et.child !== null) {
            et.child.return = et, et = et.child;
            continue
        }
        if (et === _e) break;
        for (; et.sibling === null;) {
            if (et.return === null || et.return === _e) return;
            et = et.return
        }
        et.sibling.return = et.return, et = et.sibling
    }
};
Ci = function() {};
Di = function(_, _e, et, tt) {
    var rt = _.memoizedProps;
    if (rt !== tt) {
        _ = _e.stateNode, dh(ah.current);
        var nt = null;
        switch (et) {
            case "input":
                rt = Ya(_, rt), tt = Ya(_, tt), nt = [];
                break;
            case "option":
                rt = eb(_, rt), tt = eb(_, tt), nt = [];
                break;
            case "select":
                rt = m$4({}, rt, {
                    value: void 0
                }), tt = m$4({}, tt, {
                    value: void 0
                }), nt = [];
                break;
            case "textarea":
                rt = gb(_, rt), tt = gb(_, tt), nt = [];
                break;
            default:
                typeof rt.onClick != "function" && typeof tt.onClick == "function" && (_.onclick = jf)
        }
        vb(et, tt);
        var at;
        et = null;
        for (ut in rt)
            if (!tt.hasOwnProperty(ut) && rt.hasOwnProperty(ut) && rt[ut] != null)
                if (ut === "style") {
                    var st = rt[ut];
                    for (at in st) st.hasOwnProperty(at) && (et || (et = {}), et[at] = "")
                } else ut !== "dangerouslySetInnerHTML" && ut !== "children" && ut !== "suppressContentEditableWarning" && ut !== "suppressHydrationWarning" && ut !== "autoFocus" && (ca.hasOwnProperty(ut) ? nt || (nt = []) : (nt = nt || []).push(ut, null));
        for (ut in tt) {
            var it = tt[ut];
            if (st = rt != null ? rt[ut] : void 0, tt.hasOwnProperty(ut) && it !== st && (it != null || st != null))
                if (ut === "style")
                    if (st) {
                        for (at in st) !st.hasOwnProperty(at) || it && it.hasOwnProperty(at) || (et || (et = {}), et[at] = "");
                        for (at in it) it.hasOwnProperty(at) && st[at] !== it[at] && (et || (et = {}), et[at] = it[at])
                    } else et || (nt || (nt = []), nt.push(ut, et)), et = it;
            else ut === "dangerouslySetInnerHTML" ? (it = it ? it.__html : void 0, st = st ? st.__html : void 0, it != null && st !== it && (nt = nt || []).push(ut, it)) : ut === "children" ? typeof it != "string" && typeof it != "number" || (nt = nt || []).push(ut, "" + it) : ut !== "suppressContentEditableWarning" && ut !== "suppressHydrationWarning" && (ca.hasOwnProperty(ut) ? (it != null && ut === "onScroll" && G("scroll", _), nt || st === it || (nt = [])) : typeof it == "object" && it !== null && it.$$typeof === Ga ? it.toString() : (nt = nt || []).push(ut, it))
        }
        et && (nt = nt || []).push("style", et);
        var ut = nt;
        (_e.updateQueue = ut) && (_e.flags |= 4)
    }
};
Ei = function(_, _e, et, tt) {
    et !== tt && (_e.flags |= 4)
};

function Fi(_, _e) {
    if (!lh) switch (_.tailMode) {
        case "hidden":
            _e = _.tail;
            for (var et = null; _e !== null;) _e.alternate !== null && (et = _e), _e = _e.sibling;
            et === null ? _.tail = null : et.sibling = null;
            break;
        case "collapsed":
            et = _.tail;
            for (var tt = null; et !== null;) et.alternate !== null && (tt = et), et = et.sibling;
            tt === null ? _e || _.tail === null ? _.tail = null : _.tail.sibling = null : tt.sibling = null
    }
}

function Gi(_, _e, et) {
    var tt = _e.pendingProps;
    switch (_e.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return null;
        case 1:
            return Ff(_e.type) && Gf(), null;
        case 3:
            return fh(), H$1(N$1), H$1(M$3), uh(), tt = _e.stateNode, tt.pendingContext && (tt.context = tt.pendingContext, tt.pendingContext = null), (_ === null || _.child === null) && (rh(_e) ? _e.flags |= 4 : tt.hydrate || (_e.flags |= 256)), Ci(_e), null;
        case 5:
            hh(_e);
            var rt = dh(ch.current);
            if (et = _e.type, _ !== null && _e.stateNode != null) Di(_, _e, et, tt, rt), _.ref !== _e.ref && (_e.flags |= 128);
            else {
                if (!tt) {
                    if (_e.stateNode === null) throw Error(y$2(166));
                    return null
                }
                if (_ = dh(ah.current), rh(_e)) {
                    tt = _e.stateNode, et = _e.type;
                    var nt = _e.memoizedProps;
                    switch (tt[wf] = _e, tt[xf] = nt, et) {
                        case "dialog":
                            G("cancel", tt), G("close", tt);
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            G("load", tt);
                            break;
                        case "video":
                        case "audio":
                            for (_ = 0; _ < Xe$1.length; _++) G(Xe$1[_], tt);
                            break;
                        case "source":
                            G("error", tt);
                            break;
                        case "img":
                        case "image":
                        case "link":
                            G("error", tt), G("load", tt);
                            break;
                        case "details":
                            G("toggle", tt);
                            break;
                        case "input":
                            Za(tt, nt), G("invalid", tt);
                            break;
                        case "select":
                            tt._wrapperState = {
                                wasMultiple: !!nt.multiple
                            }, G("invalid", tt);
                            break;
                        case "textarea":
                            hb(tt, nt), G("invalid", tt)
                    }
                    vb(et, nt), _ = null;
                    for (var at in nt) nt.hasOwnProperty(at) && (rt = nt[at], at === "children" ? typeof rt == "string" ? tt.textContent !== rt && (_ = ["children", rt]) : typeof rt == "number" && tt.textContent !== "" + rt && (_ = ["children", "" + rt]) : ca.hasOwnProperty(at) && rt != null && at === "onScroll" && G("scroll", tt));
                    switch (et) {
                        case "input":
                            Va(tt), cb(tt, nt, !0);
                            break;
                        case "textarea":
                            Va(tt), jb(tt);
                            break;
                        case "select":
                        case "option":
                            break;
                        default:
                            typeof nt.onClick == "function" && (tt.onclick = jf)
                    }
                    tt = _, _e.updateQueue = tt, tt !== null && (_e.flags |= 4)
                } else {
                    switch (at = rt.nodeType === 9 ? rt : rt.ownerDocument, _ === kb.html && (_ = lb(et)), _ === kb.html ? et === "script" ? (_ = at.createElement("div"), _.innerHTML = "<script></script>", _ = _.removeChild(_.firstChild)) : typeof tt.is == "string" ? _ = at.createElement(et, {
                            is: tt.is
                        }) : (_ = at.createElement(et), et === "select" && (at = _, tt.multiple ? at.multiple = !0 : tt.size && (at.size = tt.size))) : _ = at.createElementNS(_, et), _[wf] = _e, _[xf] = tt, Bi(_, _e, !1, !1), _e.stateNode = _, at = wb(et, tt), et) {
                        case "dialog":
                            G("cancel", _), G("close", _), rt = tt;
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            G("load", _), rt = tt;
                            break;
                        case "video":
                        case "audio":
                            for (rt = 0; rt < Xe$1.length; rt++) G(Xe$1[rt], _);
                            rt = tt;
                            break;
                        case "source":
                            G("error", _), rt = tt;
                            break;
                        case "img":
                        case "image":
                        case "link":
                            G("error", _), G("load", _), rt = tt;
                            break;
                        case "details":
                            G("toggle", _), rt = tt;
                            break;
                        case "input":
                            Za(_, tt), rt = Ya(_, tt), G("invalid", _);
                            break;
                        case "option":
                            rt = eb(_, tt);
                            break;
                        case "select":
                            _._wrapperState = {
                                wasMultiple: !!tt.multiple
                            }, rt = m$4({}, tt, {
                                value: void 0
                            }), G("invalid", _);
                            break;
                        case "textarea":
                            hb(_, tt), rt = gb(_, tt), G("invalid", _);
                            break;
                        default:
                            rt = tt
                    }
                    vb(et, rt);
                    var st = rt;
                    for (nt in st)
                        if (st.hasOwnProperty(nt)) {
                            var it = st[nt];
                            nt === "style" ? tb(_, it) : nt === "dangerouslySetInnerHTML" ? (it = it ? it.__html : void 0, it != null && ob(_, it)) : nt === "children" ? typeof it == "string" ? (et !== "textarea" || it !== "") && pb(_, it) : typeof it == "number" && pb(_, "" + it) : nt !== "suppressContentEditableWarning" && nt !== "suppressHydrationWarning" && nt !== "autoFocus" && (ca.hasOwnProperty(nt) ? it != null && nt === "onScroll" && G("scroll", _) : it != null && qa(_, nt, it, at))
                        } switch (et) {
                        case "input":
                            Va(_), cb(_, tt, !1);
                            break;
                        case "textarea":
                            Va(_), jb(_);
                            break;
                        case "option":
                            tt.value != null && _.setAttribute("value", "" + Sa(tt.value));
                            break;
                        case "select":
                            _.multiple = !!tt.multiple, nt = tt.value, nt != null ? fb(_, !!tt.multiple, nt, !1) : tt.defaultValue != null && fb(_, !!tt.multiple, tt.defaultValue, !0);
                            break;
                        default:
                            typeof rt.onClick == "function" && (_.onclick = jf)
                    }
                    mf(et, tt) && (_e.flags |= 4)
                }
                _e.ref !== null && (_e.flags |= 128)
            }
            return null;
        case 6:
            if (_ && _e.stateNode != null) Ei(_, _e, _.memoizedProps, tt);
            else {
                if (typeof tt != "string" && _e.stateNode === null) throw Error(y$2(166));
                et = dh(ch.current), dh(ah.current), rh(_e) ? (tt = _e.stateNode, et = _e.memoizedProps, tt[wf] = _e, tt.nodeValue !== et && (_e.flags |= 4)) : (tt = (et.nodeType === 9 ? et : et.ownerDocument).createTextNode(tt), tt[wf] = _e, _e.stateNode = tt)
            }
            return null;
        case 13:
            return H$1(P$1), tt = _e.memoizedState, _e.flags & 64 ? (_e.lanes = et, _e) : (tt = tt !== null, et = !1, _ === null ? _e.memoizedProps.fallback !== void 0 && rh(_e) : et = _.memoizedState !== null, tt && !et && _e.mode & 2 && (_ === null && _e.memoizedProps.unstable_avoidThisFallback !== !0 || P$1.current & 1 ? V === 0 && (V = 3) : ((V === 0 || V === 3) && (V = 4), U === null || !(Dg & 134217727) && !(Hi & 134217727) || Ii(U, W))), (tt || et) && (_e.flags |= 4), null);
        case 4:
            return fh(), Ci(_e), _ === null && cf(_e.stateNode.containerInfo), null;
        case 10:
            return rg(_e), null;
        case 17:
            return Ff(_e.type) && Gf(), null;
        case 19:
            if (H$1(P$1), tt = _e.memoizedState, tt === null) return null;
            if (nt = (_e.flags & 64) !== 0, at = tt.rendering, at === null)
                if (nt) Fi(tt, !1);
                else {
                    if (V !== 0 || _ !== null && _.flags & 64)
                        for (_ = _e.child; _ !== null;) {
                            if (at = ih(_), at !== null) {
                                for (_e.flags |= 64, Fi(tt, !1), nt = at.updateQueue, nt !== null && (_e.updateQueue = nt, _e.flags |= 4), tt.lastEffect === null && (_e.firstEffect = null), _e.lastEffect = tt.lastEffect, tt = et, et = _e.child; et !== null;) nt = et, _ = tt, nt.flags &= 2, nt.nextEffect = null, nt.firstEffect = null, nt.lastEffect = null, at = nt.alternate, at === null ? (nt.childLanes = 0, nt.lanes = _, nt.child = null, nt.memoizedProps = null, nt.memoizedState = null, nt.updateQueue = null, nt.dependencies = null, nt.stateNode = null) : (nt.childLanes = at.childLanes, nt.lanes = at.lanes, nt.child = at.child, nt.memoizedProps = at.memoizedProps, nt.memoizedState = at.memoizedState, nt.updateQueue = at.updateQueue, nt.type = at.type, _ = at.dependencies, nt.dependencies = _ === null ? null : {
                                    lanes: _.lanes,
                                    firstContext: _.firstContext
                                }), et = et.sibling;
                                return I$2(P$1, P$1.current & 1 | 2), _e.child
                            }
                            _ = _.sibling
                        }
                    tt.tail !== null && O() > Ji && (_e.flags |= 64, nt = !0, Fi(tt, !1), _e.lanes = 33554432)
                }
            else {
                if (!nt)
                    if (_ = ih(at), _ !== null) {
                        if (_e.flags |= 64, nt = !0, et = _.updateQueue, et !== null && (_e.updateQueue = et, _e.flags |= 4), Fi(tt, !0), tt.tail === null && tt.tailMode === "hidden" && !at.alternate && !lh) return _e = _e.lastEffect = tt.lastEffect, _e !== null && (_e.nextEffect = null), null
                    } else 2 * O() - tt.renderingStartTime > Ji && et !== 1073741824 && (_e.flags |= 64, nt = !0, Fi(tt, !1), _e.lanes = 33554432);
                tt.isBackwards ? (at.sibling = _e.child, _e.child = at) : (et = tt.last, et !== null ? et.sibling = at : _e.child = at, tt.last = at)
            }
            return tt.tail !== null ? (et = tt.tail, tt.rendering = et, tt.tail = et.sibling, tt.lastEffect = _e.lastEffect, tt.renderingStartTime = O(), et.sibling = null, _e = P$1.current, I$2(P$1, nt ? _e & 1 | 2 : _e & 1), et) : null;
        case 23:
        case 24:
            return Ki(), _ !== null && _.memoizedState !== null != (_e.memoizedState !== null) && tt.mode !== "unstable-defer-without-hiding" && (_e.flags |= 4), null
    }
    throw Error(y$2(156, _e.tag))
}

function Li(_) {
    switch (_.tag) {
        case 1:
            Ff(_.type) && Gf();
            var _e = _.flags;
            return _e & 4096 ? (_.flags = _e & -4097 | 64, _) : null;
        case 3:
            if (fh(), H$1(N$1), H$1(M$3), uh(), _e = _.flags, _e & 64) throw Error(y$2(285));
            return _.flags = _e & -4097 | 64, _;
        case 5:
            return hh(_), null;
        case 13:
            return H$1(P$1), _e = _.flags, _e & 4096 ? (_.flags = _e & -4097 | 64, _) : null;
        case 19:
            return H$1(P$1), null;
        case 4:
            return fh(), null;
        case 10:
            return rg(_), null;
        case 23:
        case 24:
            return Ki(), null;
        default:
            return null
    }
}

function Mi(_, _e) {
    try {
        var et = "",
            tt = _e;
        do et += Qa(tt), tt = tt.return; while (tt);
        var rt = et
    } catch (nt) {
        rt = `
Error generating stack: ` + nt.message + `
` + nt.stack
    }
    return {
        value: _,
        source: _e,
        stack: rt
    }
}

function Ni(_, _e) {
    try {
        console.error(_e.value)
    } catch (et) {
        setTimeout(function() {
            throw et
        })
    }
}
var Oi = typeof WeakMap == "function" ? WeakMap : Map;

function Pi(_, _e, et) {
    et = zg(-1, et), et.tag = 3, et.payload = {
        element: null
    };
    var tt = _e.value;
    return et.callback = function() {
        Qi || (Qi = !0, Ri = tt), Ni(_, _e)
    }, et
}

function Si(_, _e, et) {
    et = zg(-1, et), et.tag = 3;
    var tt = _.type.getDerivedStateFromError;
    if (typeof tt == "function") {
        var rt = _e.value;
        et.payload = function() {
            return Ni(_, _e), tt(rt)
        }
    }
    var nt = _.stateNode;
    return nt !== null && typeof nt.componentDidCatch == "function" && (et.callback = function() {
        typeof tt != "function" && (Ti === null ? Ti = new Set([this]) : Ti.add(this), Ni(_, _e));
        var at = _e.stack;
        this.componentDidCatch(_e.value, {
            componentStack: at !== null ? at : ""
        })
    }), et
}
var Ui = typeof WeakSet == "function" ? WeakSet : Set;

function Vi(_) {
    var _e = _.ref;
    if (_e !== null)
        if (typeof _e == "function") try {
            _e(null)
        } catch (et) {
            Wi(_, et)
        } else _e.current = null
}

function Xi(_, _e) {
    switch (_e.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
            return;
        case 1:
            if (_e.flags & 256 && _ !== null) {
                var et = _.memoizedProps,
                    tt = _.memoizedState;
                _ = _e.stateNode, _e = _.getSnapshotBeforeUpdate(_e.elementType === _e.type ? et : lg(_e.type, et), tt), _.__reactInternalSnapshotBeforeUpdate = _e
            }
            return;
        case 3:
            _e.flags & 256 && qf(_e.stateNode.containerInfo);
            return;
        case 5:
        case 6:
        case 4:
        case 17:
            return
    }
    throw Error(y$2(163))
}

function Yi(_, _e, et) {
    switch (et.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
            if (_e = et.updateQueue, _e = _e !== null ? _e.lastEffect : null, _e !== null) {
                _ = _e = _e.next;
                do {
                    if ((_.tag & 3) === 3) {
                        var tt = _.create;
                        _.destroy = tt()
                    }
                    _ = _.next
                } while (_ !== _e)
            }
            if (_e = et.updateQueue, _e = _e !== null ? _e.lastEffect : null, _e !== null) {
                _ = _e = _e.next;
                do {
                    var rt = _;
                    tt = rt.next, rt = rt.tag, rt & 4 && rt & 1 && (Zi(et, _), $i(et, _)), _ = tt
                } while (_ !== _e)
            }
            return;
        case 1:
            _ = et.stateNode, et.flags & 4 && (_e === null ? _.componentDidMount() : (tt = et.elementType === et.type ? _e.memoizedProps : lg(et.type, _e.memoizedProps), _.componentDidUpdate(tt, _e.memoizedState, _.__reactInternalSnapshotBeforeUpdate))), _e = et.updateQueue, _e !== null && Eg(et, _e, _);
            return;
        case 3:
            if (_e = et.updateQueue, _e !== null) {
                if (_ = null, et.child !== null) switch (et.child.tag) {
                    case 5:
                        _ = et.child.stateNode;
                        break;
                    case 1:
                        _ = et.child.stateNode
                }
                Eg(et, _e, _)
            }
            return;
        case 5:
            _ = et.stateNode, _e === null && et.flags & 4 && mf(et.type, et.memoizedProps) && _.focus();
            return;
        case 6:
            return;
        case 4:
            return;
        case 12:
            return;
        case 13:
            et.memoizedState === null && (et = et.alternate, et !== null && (et = et.memoizedState, et !== null && (et = et.dehydrated, et !== null && Cc(et))));
            return;
        case 19:
        case 17:
        case 20:
        case 21:
        case 23:
        case 24:
            return
    }
    throw Error(y$2(163))
}

function aj(_, _e) {
    for (var et = _;;) {
        if (et.tag === 5) {
            var tt = et.stateNode;
            if (_e) tt = tt.style, typeof tt.setProperty == "function" ? tt.setProperty("display", "none", "important") : tt.display = "none";
            else {
                tt = et.stateNode;
                var rt = et.memoizedProps.style;
                rt = rt != null && rt.hasOwnProperty("display") ? rt.display : null, tt.style.display = sb("display", rt)
            }
        } else if (et.tag === 6) et.stateNode.nodeValue = _e ? "" : et.memoizedProps;
        else if ((et.tag !== 23 && et.tag !== 24 || et.memoizedState === null || et === _) && et.child !== null) {
            et.child.return = et, et = et.child;
            continue
        }
        if (et === _) break;
        for (; et.sibling === null;) {
            if (et.return === null || et.return === _) return;
            et = et.return
        }
        et.sibling.return = et.return, et = et.sibling
    }
}

function bj(_, _e) {
    if (Mf && typeof Mf.onCommitFiberUnmount == "function") try {
        Mf.onCommitFiberUnmount(Lf, _e)
    } catch {}
    switch (_e.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
            if (_ = _e.updateQueue, _ !== null && (_ = _.lastEffect, _ !== null)) {
                var et = _ = _.next;
                do {
                    var tt = et,
                        rt = tt.destroy;
                    if (tt = tt.tag, rt !== void 0)
                        if (tt & 4) Zi(_e, et);
                        else {
                            tt = _e;
                            try {
                                rt()
                            } catch (nt) {
                                Wi(tt, nt)
                            }
                        } et = et.next
                } while (et !== _)
            }
            break;
        case 1:
            if (Vi(_e), _ = _e.stateNode, typeof _.componentWillUnmount == "function") try {
                _.props = _e.memoizedProps, _.state = _e.memoizedState, _.componentWillUnmount()
            } catch (nt) {
                Wi(_e, nt)
            }
            break;
        case 5:
            Vi(_e);
            break;
        case 4:
            cj(_, _e)
    }
}

function dj(_) {
    _.alternate = null, _.child = null, _.dependencies = null, _.firstEffect = null, _.lastEffect = null, _.memoizedProps = null, _.memoizedState = null, _.pendingProps = null, _.return = null, _.updateQueue = null
}

function ej(_) {
    return _.tag === 5 || _.tag === 3 || _.tag === 4
}

function fj(_) {
    e: {
        for (var _e = _.return; _e !== null;) {
            if (ej(_e)) break e;
            _e = _e.return
        }
        throw Error(y$2(160))
    }
    var et = _e;
    switch (_e = et.stateNode, et.tag) {
        case 5:
            var tt = !1;
            break;
        case 3:
            _e = _e.containerInfo, tt = !0;
            break;
        case 4:
            _e = _e.containerInfo, tt = !0;
            break;
        default:
            throw Error(y$2(161))
    }
    et.flags & 16 && (pb(_e, ""), et.flags &= -17);e: t: for (et = _;;) {
        for (; et.sibling === null;) {
            if (et.return === null || ej(et.return)) {
                et = null;
                break e
            }
            et = et.return
        }
        for (et.sibling.return = et.return, et = et.sibling; et.tag !== 5 && et.tag !== 6 && et.tag !== 18;) {
            if (et.flags & 2 || et.child === null || et.tag === 4) continue t;
            et.child.return = et, et = et.child
        }
        if (!(et.flags & 2)) {
            et = et.stateNode;
            break e
        }
    }
    tt ? gj(_, et, _e) : hj(_, et, _e)
}

function gj(_, _e, et) {
    var tt = _.tag,
        rt = tt === 5 || tt === 6;
    if (rt) _ = rt ? _.stateNode : _.stateNode.instance, _e ? et.nodeType === 8 ? et.parentNode.insertBefore(_, _e) : et.insertBefore(_, _e) : (et.nodeType === 8 ? (_e = et.parentNode, _e.insertBefore(_, et)) : (_e = et, _e.appendChild(_)), et = et._reactRootContainer, et != null || _e.onclick !== null || (_e.onclick = jf));
    else if (tt !== 4 && (_ = _.child, _ !== null))
        for (gj(_, _e, et), _ = _.sibling; _ !== null;) gj(_, _e, et), _ = _.sibling
}

function hj(_, _e, et) {
    var tt = _.tag,
        rt = tt === 5 || tt === 6;
    if (rt) _ = rt ? _.stateNode : _.stateNode.instance, _e ? et.insertBefore(_, _e) : et.appendChild(_);
    else if (tt !== 4 && (_ = _.child, _ !== null))
        for (hj(_, _e, et), _ = _.sibling; _ !== null;) hj(_, _e, et), _ = _.sibling
}

function cj(_, _e) {
    for (var et = _e, tt = !1, rt, nt;;) {
        if (!tt) {
            tt = et.return;
            e: for (;;) {
                if (tt === null) throw Error(y$2(160));
                switch (rt = tt.stateNode, tt.tag) {
                    case 5:
                        nt = !1;
                        break e;
                    case 3:
                        rt = rt.containerInfo, nt = !0;
                        break e;
                    case 4:
                        rt = rt.containerInfo, nt = !0;
                        break e
                }
                tt = tt.return
            }
            tt = !0
        }
        if (et.tag === 5 || et.tag === 6) {
            e: for (var at = _, st = et, it = st;;)
                if (bj(at, it), it.child !== null && it.tag !== 4) it.child.return = it, it = it.child;
                else {
                    if (it === st) break e;
                    for (; it.sibling === null;) {
                        if (it.return === null || it.return === st) break e;
                        it = it.return
                    }
                    it.sibling.return = it.return, it = it.sibling
                }nt ? (at = rt, st = et.stateNode, at.nodeType === 8 ? at.parentNode.removeChild(st) : at.removeChild(st)) : rt.removeChild(et.stateNode)
        }
        else if (et.tag === 4) {
            if (et.child !== null) {
                rt = et.stateNode.containerInfo, nt = !0, et.child.return = et, et = et.child;
                continue
            }
        } else if (bj(_, et), et.child !== null) {
            et.child.return = et, et = et.child;
            continue
        }
        if (et === _e) break;
        for (; et.sibling === null;) {
            if (et.return === null || et.return === _e) return;
            et = et.return, et.tag === 4 && (tt = !1)
        }
        et.sibling.return = et.return, et = et.sibling
    }
}

function ij(_, _e) {
    switch (_e.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
            var et = _e.updateQueue;
            if (et = et !== null ? et.lastEffect : null, et !== null) {
                var tt = et = et.next;
                do(tt.tag & 3) === 3 && (_ = tt.destroy, tt.destroy = void 0, _ !== void 0 && _()), tt = tt.next; while (tt !== et)
            }
            return;
        case 1:
            return;
        case 5:
            if (et = _e.stateNode, et != null) {
                tt = _e.memoizedProps;
                var rt = _ !== null ? _.memoizedProps : tt;
                _ = _e.type;
                var nt = _e.updateQueue;
                if (_e.updateQueue = null, nt !== null) {
                    for (et[xf] = tt, _ === "input" && tt.type === "radio" && tt.name != null && $a(et, tt), wb(_, rt), _e = wb(_, tt), rt = 0; rt < nt.length; rt += 2) {
                        var at = nt[rt],
                            st = nt[rt + 1];
                        at === "style" ? tb(et, st) : at === "dangerouslySetInnerHTML" ? ob(et, st) : at === "children" ? pb(et, st) : qa(et, at, st, _e)
                    }
                    switch (_) {
                        case "input":
                            ab(et, tt);
                            break;
                        case "textarea":
                            ib(et, tt);
                            break;
                        case "select":
                            _ = et._wrapperState.wasMultiple, et._wrapperState.wasMultiple = !!tt.multiple, nt = tt.value, nt != null ? fb(et, !!tt.multiple, nt, !1) : _ !== !!tt.multiple && (tt.defaultValue != null ? fb(et, !!tt.multiple, tt.defaultValue, !0) : fb(et, !!tt.multiple, tt.multiple ? [] : "", !1))
                    }
                }
            }
            return;
        case 6:
            if (_e.stateNode === null) throw Error(y$2(162));
            _e.stateNode.nodeValue = _e.memoizedProps;
            return;
        case 3:
            et = _e.stateNode, et.hydrate && (et.hydrate = !1, Cc(et.containerInfo));
            return;
        case 12:
            return;
        case 13:
            _e.memoizedState !== null && (jj = O(), aj(_e.child, !0)), kj(_e);
            return;
        case 19:
            kj(_e);
            return;
        case 17:
            return;
        case 23:
        case 24:
            aj(_e, _e.memoizedState !== null);
            return
    }
    throw Error(y$2(163))
}

function kj(_) {
    var _e = _.updateQueue;
    if (_e !== null) {
        _.updateQueue = null;
        var et = _.stateNode;
        et === null && (et = _.stateNode = new Ui), _e.forEach(function(tt) {
            var rt = lj.bind(null, _, tt);
            et.has(tt) || (et.add(tt), tt.then(rt, rt))
        })
    }
}

function mj(_, _e) {
    return _ !== null && (_ = _.memoizedState, _ === null || _.dehydrated !== null) ? (_e = _e.memoizedState, _e !== null && _e.dehydrated === null) : !1
}
var nj = Math.ceil,
    oj = ra.ReactCurrentDispatcher,
    pj = ra.ReactCurrentOwner,
    X$1 = 0,
    U = null,
    Y = null,
    W = 0,
    qj = 0,
    rj = Bf(0),
    V = 0,
    sj = null,
    tj = 0,
    Dg = 0,
    Hi = 0,
    uj = 0,
    vj = null,
    jj = 0,
    Ji = 1 / 0;

function wj() {
    Ji = O() + 500
}
var Z = null,
    Qi = !1,
    Ri = null,
    Ti = null,
    xj = !1,
    yj = null,
    zj = 90,
    Aj = [],
    Bj = [],
    Cj = null,
    Dj = 0,
    Ej = null,
    Fj = -1,
    Gj = 0,
    Hj = 0,
    Ij = null,
    Jj = !1;

function Hg() {
    return X$1 & 48 ? O() : Fj !== -1 ? Fj : Fj = O()
}

function Ig(_) {
    if (_ = _.mode, !(_ & 2)) return 1;
    if (!(_ & 4)) return eg() === 99 ? 1 : 2;
    if (Gj === 0 && (Gj = tj), kg.transition !== 0) {
        Hj !== 0 && (Hj = vj !== null ? vj.pendingLanes : 0), _ = Gj;
        var _e = 4186112 & ~Hj;
        return _e &= -_e, _e === 0 && (_ = 4186112 & ~_, _e = _ & -_, _e === 0 && (_e = 8192)), _e
    }
    return _ = eg(), X$1 & 4 && _ === 98 ? _ = Xc(12, Gj) : (_ = Sc(_), _ = Xc(_, Gj)), _
}

function Jg(_, _e, et) {
    if (50 < Dj) throw Dj = 0, Ej = null, Error(y$2(185));
    if (_ = Kj(_, _e), _ === null) return null;
    $c(_, _e, et), _ === U && (Hi |= _e, V === 4 && Ii(_, W));
    var tt = eg();
    _e === 1 ? X$1 & 8 && !(X$1 & 48) ? Lj(_) : (Mj(_, et), X$1 === 0 && (wj(), ig())) : (!(X$1 & 4) || tt !== 98 && tt !== 99 || (Cj === null ? Cj = new Set([_]) : Cj.add(_)), Mj(_, et)), vj = _
}

function Kj(_, _e) {
    _.lanes |= _e;
    var et = _.alternate;
    for (et !== null && (et.lanes |= _e), et = _, _ = _.return; _ !== null;) _.childLanes |= _e, et = _.alternate, et !== null && (et.childLanes |= _e), et = _, _ = _.return;
    return et.tag === 3 ? et.stateNode : null
}

function Mj(_, _e) {
    for (var et = _.callbackNode, tt = _.suspendedLanes, rt = _.pingedLanes, nt = _.expirationTimes, at = _.pendingLanes; 0 < at;) {
        var st = 31 - Vc(at),
            it = 1 << st,
            ut = nt[st];
        if (ut === -1) {
            if (!(it & tt) || it & rt) {
                ut = _e, Rc(it);
                var lt = F$3;
                nt[st] = 10 <= lt ? ut + 250 : 6 <= lt ? ut + 5e3 : -1
            }
        } else ut <= _e && (_.expiredLanes |= it);
        at &= ~it
    }
    if (tt = Uc(_, _ === U ? W : 0), _e = F$3, tt === 0) et !== null && (et !== Zf && Pf(et), _.callbackNode = null, _.callbackPriority = 0);
    else {
        if (et !== null) {
            if (_.callbackPriority === _e) return;
            et !== Zf && Pf(et)
        }
        _e === 15 ? (et = Lj.bind(null, _), ag === null ? (ag = [et], bg = Of(Uf, jg)) : ag.push(et), et = Zf) : _e === 14 ? et = hg(99, Lj.bind(null, _)) : (et = Tc(_e), et = hg(et, Nj.bind(null, _))), _.callbackPriority = _e, _.callbackNode = et
    }
}

function Nj(_) {
    if (Fj = -1, Hj = Gj = 0, X$1 & 48) throw Error(y$2(327));
    var _e = _.callbackNode;
    if (Oj() && _.callbackNode !== _e) return null;
    var et = Uc(_, _ === U ? W : 0);
    if (et === 0) return null;
    var tt = et,
        rt = X$1;
    X$1 |= 16;
    var nt = Pj();
    (U !== _ || W !== tt) && (wj(), Qj(_, tt));
    do try {
        Rj();
        break
    } catch (st) {
        Sj(_, st)
    }
    while (1);
    if (qg(), oj.current = nt, X$1 = rt, Y !== null ? tt = 0 : (U = null, W = 0, tt = V), tj & Hi) Qj(_, 0);
    else if (tt !== 0) {
        if (tt === 2 && (X$1 |= 64, _.hydrate && (_.hydrate = !1, qf(_.containerInfo)), et = Wc(_), et !== 0 && (tt = Tj(_, et))), tt === 1) throw _e = sj, Qj(_, 0), Ii(_, et), Mj(_, O()), _e;
        switch (_.finishedWork = _.current.alternate, _.finishedLanes = et, tt) {
            case 0:
            case 1:
                throw Error(y$2(345));
            case 2:
                Uj(_);
                break;
            case 3:
                if (Ii(_, et), (et & 62914560) === et && (tt = jj + 500 - O(), 10 < tt)) {
                    if (Uc(_, 0) !== 0) break;
                    if (rt = _.suspendedLanes, (rt & et) !== et) {
                        Hg(), _.pingedLanes |= _.suspendedLanes & rt;
                        break
                    }
                    _.timeoutHandle = of(Uj.bind(null, _), tt);
                    break
                }
                Uj(_);
                break;
            case 4:
                if (Ii(_, et), (et & 4186112) === et) break;
                for (tt = _.eventTimes, rt = -1; 0 < et;) {
                    var at = 31 - Vc(et);
                    nt = 1 << at, at = tt[at], at > rt && (rt = at), et &= ~nt
                }
                if (et = rt, et = O() - et, et = (120 > et ? 120 : 480 > et ? 480 : 1080 > et ? 1080 : 1920 > et ? 1920 : 3e3 > et ? 3e3 : 4320 > et ? 4320 : 1960 * nj(et / 1960)) - et, 10 < et) {
                    _.timeoutHandle = of(Uj.bind(null, _), et);
                    break
                }
                Uj(_);
                break;
            case 5:
                Uj(_);
                break;
            default:
                throw Error(y$2(329))
        }
    }
    return Mj(_, O()), _.callbackNode === _e ? Nj.bind(null, _) : null
}

function Ii(_, _e) {
    for (_e &= ~uj, _e &= ~Hi, _.suspendedLanes |= _e, _.pingedLanes &= ~_e, _ = _.expirationTimes; 0 < _e;) {
        var et = 31 - Vc(_e),
            tt = 1 << et;
        _[et] = -1, _e &= ~tt
    }
}

function Lj(_) {
    if (X$1 & 48) throw Error(y$2(327));
    if (Oj(), _ === U && _.expiredLanes & W) {
        var _e = W,
            et = Tj(_, _e);
        tj & Hi && (_e = Uc(_, _e), et = Tj(_, _e))
    } else _e = Uc(_, 0), et = Tj(_, _e);
    if (_.tag !== 0 && et === 2 && (X$1 |= 64, _.hydrate && (_.hydrate = !1, qf(_.containerInfo)), _e = Wc(_), _e !== 0 && (et = Tj(_, _e))), et === 1) throw et = sj, Qj(_, 0), Ii(_, _e), Mj(_, O()), et;
    return _.finishedWork = _.current.alternate, _.finishedLanes = _e, Uj(_), Mj(_, O()), null
}

function Vj() {
    if (Cj !== null) {
        var _ = Cj;
        Cj = null, _.forEach(function(_e) {
            _e.expiredLanes |= 24 & _e.pendingLanes, Mj(_e, O())
        })
    }
    ig()
}

function Wj(_, _e) {
    var et = X$1;
    X$1 |= 1;
    try {
        return _(_e)
    } finally {
        X$1 = et, X$1 === 0 && (wj(), ig())
    }
}

function Xj(_, _e) {
    var et = X$1;
    X$1 &= -2, X$1 |= 8;
    try {
        return _(_e)
    } finally {
        X$1 = et, X$1 === 0 && (wj(), ig())
    }
}

function ni(_, _e) {
    I$2(rj, qj), qj |= _e, tj |= _e
}

function Ki() {
    qj = rj.current, H$1(rj)
}

function Qj(_, _e) {
    _.finishedWork = null, _.finishedLanes = 0;
    var et = _.timeoutHandle;
    if (et !== -1 && (_.timeoutHandle = -1, pf(et)), Y !== null)
        for (et = Y.return; et !== null;) {
            var tt = et;
            switch (tt.tag) {
                case 1:
                    tt = tt.type.childContextTypes, tt != null && Gf();
                    break;
                case 3:
                    fh(), H$1(N$1), H$1(M$3), uh();
                    break;
                case 5:
                    hh(tt);
                    break;
                case 4:
                    fh();
                    break;
                case 13:
                    H$1(P$1);
                    break;
                case 19:
                    H$1(P$1);
                    break;
                case 10:
                    rg(tt);
                    break;
                case 23:
                case 24:
                    Ki()
            }
            et = et.return
        }
    U = _, Y = Tg(_.current, null), W = qj = tj = _e, V = 0, sj = null, uj = Hi = Dg = 0
}

function Sj(_, _e) {
    do {
        var et = Y;
        try {
            if (qg(), vh.current = Gh, yh) {
                for (var tt = R.memoizedState; tt !== null;) {
                    var rt = tt.queue;
                    rt !== null && (rt.pending = null), tt = tt.next
                }
                yh = !1
            }
            if (xh = 0, T$3 = S$2 = R = null, zh = !1, pj.current = null, et === null || et.return === null) {
                V = 1, sj = _e, Y = null;
                break
            }
            e: {
                var nt = _,
                    at = et.return,
                    st = et,
                    it = _e;
                if (_e = W, st.flags |= 2048, st.firstEffect = st.lastEffect = null, it !== null && typeof it == "object" && typeof it.then == "function") {
                    var ut = it;
                    if (!(st.mode & 2)) {
                        var lt = st.alternate;
                        lt ? (st.updateQueue = lt.updateQueue, st.memoizedState = lt.memoizedState, st.lanes = lt.lanes) : (st.updateQueue = null, st.memoizedState = null)
                    }
                    var bt = (P$1.current & 1) !== 0,
                        pt = at;
                    do {
                        var It;
                        if (It = pt.tag === 13) {
                            var At = pt.memoizedState;
                            if (At !== null) It = At.dehydrated !== null;
                            else {
                                var Ct = pt.memoizedProps;
                                It = Ct.fallback === void 0 ? !1 : Ct.unstable_avoidThisFallback !== !0 ? !0 : !bt
                            }
                        }
                        if (It) {
                            var ht = pt.updateQueue;
                            if (ht === null) {
                                var ot = new Set;
                                ot.add(ut), pt.updateQueue = ot
                            } else ht.add(ut);
                            if (!(pt.mode & 2)) {
                                if (pt.flags |= 64, st.flags |= 16384, st.flags &= -2981, st.tag === 1)
                                    if (st.alternate === null) st.tag = 17;
                                    else {
                                        var ct = zg(-1, 1);
                                        ct.tag = 2, Ag(st, ct)
                                    } st.lanes |= 1;
                                break e
                            }
                            it = void 0, st = _e;
                            var Et = nt.pingCache;
                            if (Et === null ? (Et = nt.pingCache = new Oi, it = new Set, Et.set(ut, it)) : (it = Et.get(ut), it === void 0 && (it = new Set, Et.set(ut, it))), !it.has(st)) {
                                it.add(st);
                                var Dt = Yj.bind(null, nt, ut, st);
                                ut.then(Dt, Dt)
                            }
                            pt.flags |= 4096, pt.lanes = _e;
                            break e
                        }
                        pt = pt.return
                    } while (pt !== null);
                    it = Error((Ra(st.type) || "A React component") + ` suspended while rendering, but no fallback UI was specified.

Add a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.`)
                }
                V !== 5 && (V = 2),
                it = Mi(it, st),
                pt = at;do {
                    switch (pt.tag) {
                        case 3:
                            nt = it, pt.flags |= 4096, _e &= -_e, pt.lanes |= _e;
                            var Pt = Pi(pt, nt, _e);
                            Bg(pt, Pt);
                            break e;
                        case 1:
                            nt = it;
                            var gt = pt.type,
                                ft = pt.stateNode;
                            if (!(pt.flags & 64) && (typeof gt.getDerivedStateFromError == "function" || ft !== null && typeof ft.componentDidCatch == "function" && (Ti === null || !Ti.has(ft)))) {
                                pt.flags |= 4096, _e &= -_e, pt.lanes |= _e;
                                var dt = Si(pt, nt, _e);
                                Bg(pt, dt);
                                break e
                            }
                    }
                    pt = pt.return
                } while (pt !== null)
            }
            Zj(et)
        } catch (St) {
            _e = St, Y === et && et !== null && (Y = et = et.return);
            continue
        }
        break
    } while (1)
}

function Pj() {
    var _ = oj.current;
    return oj.current = Gh, _ === null ? Gh : _
}

function Tj(_, _e) {
    var et = X$1;
    X$1 |= 16;
    var tt = Pj();
    U === _ && W === _e || Qj(_, _e);
    do try {
        ak();
        break
    } catch (rt) {
        Sj(_, rt)
    }
    while (1);
    if (qg(), X$1 = et, oj.current = tt, Y !== null) throw Error(y$2(261));
    return U = null, W = 0, V
}

function ak() {
    for (; Y !== null;) bk(Y)
}

function Rj() {
    for (; Y !== null && !Qf();) bk(Y)
}

function bk(_) {
    var _e = ck(_.alternate, _, qj);
    _.memoizedProps = _.pendingProps, _e === null ? Zj(_) : Y = _e, pj.current = null
}

function Zj(_) {
    var _e = _;
    do {
        var et = _e.alternate;
        if (_ = _e.return, _e.flags & 2048) {
            if (et = Li(_e), et !== null) {
                et.flags &= 2047, Y = et;
                return
            }
            _ !== null && (_.firstEffect = _.lastEffect = null, _.flags |= 2048)
        } else {
            if (et = Gi(et, _e, qj), et !== null) {
                Y = et;
                return
            }
            if (et = _e, et.tag !== 24 && et.tag !== 23 || et.memoizedState === null || qj & 1073741824 || !(et.mode & 4)) {
                for (var tt = 0, rt = et.child; rt !== null;) tt |= rt.lanes | rt.childLanes, rt = rt.sibling;
                et.childLanes = tt
            }
            _ !== null && !(_.flags & 2048) && (_.firstEffect === null && (_.firstEffect = _e.firstEffect), _e.lastEffect !== null && (_.lastEffect !== null && (_.lastEffect.nextEffect = _e.firstEffect), _.lastEffect = _e.lastEffect), 1 < _e.flags && (_.lastEffect !== null ? _.lastEffect.nextEffect = _e : _.firstEffect = _e, _.lastEffect = _e))
        }
        if (_e = _e.sibling, _e !== null) {
            Y = _e;
            return
        }
        Y = _e = _
    } while (_e !== null);
    V === 0 && (V = 5)
}

function Uj(_) {
    var _e = eg();
    return gg(99, dk.bind(null, _, _e)), null
}

function dk(_, _e) {
    do Oj(); while (yj !== null);
    if (X$1 & 48) throw Error(y$2(327));
    var et = _.finishedWork;
    if (et === null) return null;
    if (_.finishedWork = null, _.finishedLanes = 0, et === _.current) throw Error(y$2(177));
    _.callbackNode = null;
    var tt = et.lanes | et.childLanes,
        rt = tt,
        nt = _.pendingLanes & ~rt;
    _.pendingLanes = rt, _.suspendedLanes = 0, _.pingedLanes = 0, _.expiredLanes &= rt, _.mutableReadLanes &= rt, _.entangledLanes &= rt, rt = _.entanglements;
    for (var at = _.eventTimes, st = _.expirationTimes; 0 < nt;) {
        var it = 31 - Vc(nt),
            ut = 1 << it;
        rt[it] = 0, at[it] = -1, st[it] = -1, nt &= ~ut
    }
    if (Cj !== null && !(tt & 24) && Cj.has(_) && Cj.delete(_), _ === U && (Y = U = null, W = 0), 1 < et.flags ? et.lastEffect !== null ? (et.lastEffect.nextEffect = et, tt = et.firstEffect) : tt = et : tt = et.firstEffect, tt !== null) {
        if (rt = X$1, X$1 |= 32, pj.current = null, kf = fd, at = Ne$1(), Oe(at)) {
            if ("selectionStart" in at) st = {
                start: at.selectionStart,
                end: at.selectionEnd
            };
            else e: if (st = (st = at.ownerDocument) && st.defaultView || window, (ut = st.getSelection && st.getSelection()) && ut.rangeCount !== 0) {
                st = ut.anchorNode, nt = ut.anchorOffset, it = ut.focusNode, ut = ut.focusOffset;
                try {
                    st.nodeType, it.nodeType
                } catch {
                    st = null;
                    break e
                }
                var lt = 0,
                    bt = -1,
                    pt = -1,
                    It = 0,
                    At = 0,
                    Ct = at,
                    ht = null;
                t: for (;;) {
                    for (var ot; Ct !== st || nt !== 0 && Ct.nodeType !== 3 || (bt = lt + nt), Ct !== it || ut !== 0 && Ct.nodeType !== 3 || (pt = lt + ut), Ct.nodeType === 3 && (lt += Ct.nodeValue.length), (ot = Ct.firstChild) !== null;) ht = Ct, Ct = ot;
                    for (;;) {
                        if (Ct === at) break t;
                        if (ht === st && ++It === nt && (bt = lt), ht === it && ++At === ut && (pt = lt), (ot = Ct.nextSibling) !== null) break;
                        Ct = ht, ht = Ct.parentNode
                    }
                    Ct = ot
                }
                st = bt === -1 || pt === -1 ? null : {
                    start: bt,
                    end: pt
                }
            } else st = null;
            st = st || {
                start: 0,
                end: 0
            }
        } else st = null;
        lf = {
            focusedElem: at,
            selectionRange: st
        }, fd = !1, Ij = null, Jj = !1, Z = tt;
        do try {
            ek()
        } catch (St) {
            if (Z === null) throw Error(y$2(330));
            Wi(Z, St), Z = Z.nextEffect
        }
        while (Z !== null);
        Ij = null, Z = tt;
        do try {
            for (at = _; Z !== null;) {
                var ct = Z.flags;
                if (ct & 16 && pb(Z.stateNode, ""), ct & 128) {
                    var Et = Z.alternate;
                    if (Et !== null) {
                        var Dt = Et.ref;
                        Dt !== null && (typeof Dt == "function" ? Dt(null) : Dt.current = null)
                    }
                }
                switch (ct & 1038) {
                    case 2:
                        fj(Z), Z.flags &= -3;
                        break;
                    case 6:
                        fj(Z), Z.flags &= -3, ij(Z.alternate, Z);
                        break;
                    case 1024:
                        Z.flags &= -1025;
                        break;
                    case 1028:
                        Z.flags &= -1025, ij(Z.alternate, Z);
                        break;
                    case 4:
                        ij(Z.alternate, Z);
                        break;
                    case 8:
                        st = Z, cj(at, st);
                        var Pt = st.alternate;
                        dj(st), Pt !== null && dj(Pt)
                }
                Z = Z.nextEffect
            }
        } catch (St) {
            if (Z === null) throw Error(y$2(330));
            Wi(Z, St), Z = Z.nextEffect
        }
        while (Z !== null);
        if (Dt = lf, Et = Ne$1(), ct = Dt.focusedElem, at = Dt.selectionRange, Et !== ct && ct && ct.ownerDocument && Me(ct.ownerDocument.documentElement, ct)) {
            for (at !== null && Oe(ct) && (Et = at.start, Dt = at.end, Dt === void 0 && (Dt = Et), "selectionStart" in ct ? (ct.selectionStart = Et, ct.selectionEnd = Math.min(Dt, ct.value.length)) : (Dt = (Et = ct.ownerDocument || document) && Et.defaultView || window, Dt.getSelection && (Dt = Dt.getSelection(), st = ct.textContent.length, Pt = Math.min(at.start, st), at = at.end === void 0 ? Pt : Math.min(at.end, st), !Dt.extend && Pt > at && (st = at, at = Pt, Pt = st), st = Le(ct, Pt), nt = Le(ct, at), st && nt && (Dt.rangeCount !== 1 || Dt.anchorNode !== st.node || Dt.anchorOffset !== st.offset || Dt.focusNode !== nt.node || Dt.focusOffset !== nt.offset) && (Et = Et.createRange(), Et.setStart(st.node, st.offset), Dt.removeAllRanges(), Pt > at ? (Dt.addRange(Et), Dt.extend(nt.node, nt.offset)) : (Et.setEnd(nt.node, nt.offset), Dt.addRange(Et)))))), Et = [], Dt = ct; Dt = Dt.parentNode;) Dt.nodeType === 1 && Et.push({
                element: Dt,
                left: Dt.scrollLeft,
                top: Dt.scrollTop
            });
            for (typeof ct.focus == "function" && ct.focus(), ct = 0; ct < Et.length; ct++) Dt = Et[ct], Dt.element.scrollLeft = Dt.left, Dt.element.scrollTop = Dt.top
        }
        fd = !!kf, lf = kf = null, _.current = et, Z = tt;
        do try {
            for (ct = _; Z !== null;) {
                var gt = Z.flags;
                if (gt & 36 && Yi(ct, Z.alternate, Z), gt & 128) {
                    Et = void 0;
                    var ft = Z.ref;
                    if (ft !== null) {
                        var dt = Z.stateNode;
                        switch (Z.tag) {
                            case 5:
                                Et = dt;
                                break;
                            default:
                                Et = dt
                        }
                        typeof ft == "function" ? ft(Et) : ft.current = Et
                    }
                }
                Z = Z.nextEffect
            }
        } catch (St) {
            if (Z === null) throw Error(y$2(330));
            Wi(Z, St), Z = Z.nextEffect
        }
        while (Z !== null);
        Z = null, $f(), X$1 = rt
    } else _.current = et;
    if (xj) xj = !1, yj = _, zj = _e;
    else
        for (Z = tt; Z !== null;) _e = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (gt = Z, gt.sibling = null, gt.stateNode = null), Z = _e;
    if (tt = _.pendingLanes, tt === 0 && (Ti = null), tt === 1 ? _ === Ej ? Dj++ : (Dj = 0, Ej = _) : Dj = 0, et = et.stateNode, Mf && typeof Mf.onCommitFiberRoot == "function") try {
        Mf.onCommitFiberRoot(Lf, et, void 0, (et.current.flags & 64) === 64)
    } catch {}
    if (Mj(_, O()), Qi) throw Qi = !1, _ = Ri, Ri = null, _;
    return X$1 & 8 || ig(), null
}

function ek() {
    for (; Z !== null;) {
        var _ = Z.alternate;
        Jj || Ij === null || (Z.flags & 8 ? dc(Z, Ij) && (Jj = !0) : Z.tag === 13 && mj(_, Z) && dc(Z, Ij) && (Jj = !0));
        var _e = Z.flags;
        _e & 256 && Xi(_, Z), !(_e & 512) || xj || (xj = !0, hg(97, function() {
            return Oj(), null
        })), Z = Z.nextEffect
    }
}

function Oj() {
    if (zj !== 90) {
        var _ = 97 < zj ? 97 : zj;
        return zj = 90, gg(_, fk)
    }
    return !1
}

function $i(_, _e) {
    Aj.push(_e, _), xj || (xj = !0, hg(97, function() {
        return Oj(), null
    }))
}

function Zi(_, _e) {
    Bj.push(_e, _), xj || (xj = !0, hg(97, function() {
        return Oj(), null
    }))
}

function fk() {
    if (yj === null) return !1;
    var _ = yj;
    if (yj = null, X$1 & 48) throw Error(y$2(331));
    var _e = X$1;
    X$1 |= 32;
    var et = Bj;
    Bj = [];
    for (var tt = 0; tt < et.length; tt += 2) {
        var rt = et[tt],
            nt = et[tt + 1],
            at = rt.destroy;
        if (rt.destroy = void 0, typeof at == "function") try {
            at()
        } catch (it) {
            if (nt === null) throw Error(y$2(330));
            Wi(nt, it)
        }
    }
    for (et = Aj, Aj = [], tt = 0; tt < et.length; tt += 2) {
        rt = et[tt], nt = et[tt + 1];
        try {
            var st = rt.create;
            rt.destroy = st()
        } catch (it) {
            if (nt === null) throw Error(y$2(330));
            Wi(nt, it)
        }
    }
    for (st = _.current.firstEffect; st !== null;) _ = st.nextEffect, st.nextEffect = null, st.flags & 8 && (st.sibling = null, st.stateNode = null), st = _;
    return X$1 = _e, ig(), !0
}

function gk(_, _e, et) {
    _e = Mi(et, _e), _e = Pi(_, _e, 1), Ag(_, _e), _e = Hg(), _ = Kj(_, 1), _ !== null && ($c(_, 1, _e), Mj(_, _e))
}

function Wi(_, _e) {
    if (_.tag === 3) gk(_, _, _e);
    else
        for (var et = _.return; et !== null;) {
            if (et.tag === 3) {
                gk(et, _, _e);
                break
            } else if (et.tag === 1) {
                var tt = et.stateNode;
                if (typeof et.type.getDerivedStateFromError == "function" || typeof tt.componentDidCatch == "function" && (Ti === null || !Ti.has(tt))) {
                    _ = Mi(_e, _);
                    var rt = Si(et, _, 1);
                    if (Ag(et, rt), rt = Hg(), et = Kj(et, 1), et !== null) $c(et, 1, rt), Mj(et, rt);
                    else if (typeof tt.componentDidCatch == "function" && (Ti === null || !Ti.has(tt))) try {
                        tt.componentDidCatch(_e, _)
                    } catch {}
                    break
                }
            }
            et = et.return
        }
}

function Yj(_, _e, et) {
    var tt = _.pingCache;
    tt !== null && tt.delete(_e), _e = Hg(), _.pingedLanes |= _.suspendedLanes & et, U === _ && (W & et) === et && (V === 4 || V === 3 && (W & 62914560) === W && 500 > O() - jj ? Qj(_, 0) : uj |= et), Mj(_, _e)
}

function lj(_, _e) {
    var et = _.stateNode;
    et !== null && et.delete(_e), _e = 0, _e === 0 && (_e = _.mode, _e & 2 ? _e & 4 ? (Gj === 0 && (Gj = tj), _e = Yc(62914560 & ~Gj), _e === 0 && (_e = 4194304)) : _e = eg() === 99 ? 1 : 2 : _e = 1), et = Hg(), _ = Kj(_, _e), _ !== null && ($c(_, _e, et), Mj(_, et))
}
var ck;
ck = function(_, _e, et) {
    var tt = _e.lanes;
    if (_ !== null)
        if (_.memoizedProps !== _e.pendingProps || N$1.current) ug = !0;
        else if (et & tt) ug = !!(_.flags & 16384);
    else {
        switch (ug = !1, _e.tag) {
            case 3:
                ri(_e), sh();
                break;
            case 5:
                gh(_e);
                break;
            case 1:
                Ff(_e.type) && Jf(_e);
                break;
            case 4:
                eh(_e, _e.stateNode.containerInfo);
                break;
            case 10:
                tt = _e.memoizedProps.value;
                var rt = _e.type._context;
                I$2(mg, rt._currentValue), rt._currentValue = tt;
                break;
            case 13:
                if (_e.memoizedState !== null) return et & _e.child.childLanes ? ti(_, _e, et) : (I$2(P$1, P$1.current & 1), _e = hi(_, _e, et), _e !== null ? _e.sibling : null);
                I$2(P$1, P$1.current & 1);
                break;
            case 19:
                if (tt = (et & _e.childLanes) !== 0, _.flags & 64) {
                    if (tt) return Ai(_, _e, et);
                    _e.flags |= 64
                }
                if (rt = _e.memoizedState, rt !== null && (rt.rendering = null, rt.tail = null, rt.lastEffect = null), I$2(P$1, P$1.current), tt) break;
                return null;
            case 23:
            case 24:
                return _e.lanes = 0, mi(_, _e, et)
        }
        return hi(_, _e, et)
    } else ug = !1;
    switch (_e.lanes = 0, _e.tag) {
        case 2:
            if (tt = _e.type, _ !== null && (_.alternate = null, _e.alternate = null, _e.flags |= 2), _ = _e.pendingProps, rt = Ef(_e, M$3.current), tg(_e, et), rt = Ch(null, _e, tt, _, rt, et), _e.flags |= 1, typeof rt == "object" && rt !== null && typeof rt.render == "function" && rt.$$typeof === void 0) {
                if (_e.tag = 1, _e.memoizedState = null, _e.updateQueue = null, Ff(tt)) {
                    var nt = !0;
                    Jf(_e)
                } else nt = !1;
                _e.memoizedState = rt.state !== null && rt.state !== void 0 ? rt.state : null, xg(_e);
                var at = tt.getDerivedStateFromProps;
                typeof at == "function" && Gg(_e, tt, at, _), rt.updater = Kg, _e.stateNode = rt, rt._reactInternals = _e, Og(_e, tt, _, et), _e = qi(null, _e, tt, !0, nt, et)
            } else _e.tag = 0, fi(null, _e, rt, et), _e = _e.child;
            return _e;
        case 16:
            rt = _e.elementType;
            e: {
                switch (_ !== null && (_.alternate = null, _e.alternate = null, _e.flags |= 2), _ = _e.pendingProps, nt = rt._init, rt = nt(rt._payload), _e.type = rt, nt = _e.tag = hk(rt), _ = lg(rt, _), nt) {
                    case 0:
                        _e = li(null, _e, rt, _, et);
                        break e;
                    case 1:
                        _e = pi(null, _e, rt, _, et);
                        break e;
                    case 11:
                        _e = gi(null, _e, rt, _, et);
                        break e;
                    case 14:
                        _e = ii(null, _e, rt, lg(rt.type, _), tt, et);
                        break e
                }
                throw Error(y$2(306, rt, ""))
            }
            return _e;
        case 0:
            return tt = _e.type, rt = _e.pendingProps, rt = _e.elementType === tt ? rt : lg(tt, rt), li(_, _e, tt, rt, et);
        case 1:
            return tt = _e.type, rt = _e.pendingProps, rt = _e.elementType === tt ? rt : lg(tt, rt), pi(_, _e, tt, rt, et);
        case 3:
            if (ri(_e), tt = _e.updateQueue, _ === null || tt === null) throw Error(y$2(282));
            if (tt = _e.pendingProps, rt = _e.memoizedState, rt = rt !== null ? rt.element : null, yg(_, _e), Cg(_e, tt, null, et), tt = _e.memoizedState.element, tt === rt) sh(), _e = hi(_, _e, et);
            else {
                if (rt = _e.stateNode, (nt = rt.hydrate) && (kh = rf(_e.stateNode.containerInfo.firstChild), jh = _e, nt = lh = !0), nt) {
                    if (_ = rt.mutableSourceEagerHydrationData, _ != null)
                        for (rt = 0; rt < _.length; rt += 2) nt = _[rt], nt._workInProgressVersionPrimary = _[rt + 1], th.push(nt);
                    for (et = Zg(_e, null, tt, et), _e.child = et; et;) et.flags = et.flags & -3 | 1024, et = et.sibling
                } else fi(_, _e, tt, et), sh();
                _e = _e.child
            }
            return _e;
        case 5:
            return gh(_e), _ === null && ph(_e), tt = _e.type, rt = _e.pendingProps, nt = _ !== null ? _.memoizedProps : null, at = rt.children, nf(tt, rt) ? at = null : nt !== null && nf(tt, nt) && (_e.flags |= 16), oi(_, _e), fi(_, _e, at, et), _e.child;
        case 6:
            return _ === null && ph(_e), null;
        case 13:
            return ti(_, _e, et);
        case 4:
            return eh(_e, _e.stateNode.containerInfo), tt = _e.pendingProps, _ === null ? _e.child = Yg(_e, null, tt, et) : fi(_, _e, tt, et), _e.child;
        case 11:
            return tt = _e.type, rt = _e.pendingProps, rt = _e.elementType === tt ? rt : lg(tt, rt), gi(_, _e, tt, rt, et);
        case 7:
            return fi(_, _e, _e.pendingProps, et), _e.child;
        case 8:
            return fi(_, _e, _e.pendingProps.children, et), _e.child;
        case 12:
            return fi(_, _e, _e.pendingProps.children, et), _e.child;
        case 10:
            e: {
                tt = _e.type._context,
                rt = _e.pendingProps,
                at = _e.memoizedProps,
                nt = rt.value;
                var st = _e.type._context;
                if (I$2(mg, st._currentValue), st._currentValue = nt, at !== null)
                    if (st = at.value, nt = He$1(st, nt) ? 0 : (typeof tt._calculateChangedBits == "function" ? tt._calculateChangedBits(st, nt) : 1073741823) | 0, nt === 0) {
                        if (at.children === rt.children && !N$1.current) {
                            _e = hi(_, _e, et);
                            break e
                        }
                    } else
                        for (st = _e.child, st !== null && (st.return = _e); st !== null;) {
                            var it = st.dependencies;
                            if (it !== null) {
                                at = st.child;
                                for (var ut = it.firstContext; ut !== null;) {
                                    if (ut.context === tt && ut.observedBits & nt) {
                                        st.tag === 1 && (ut = zg(-1, et & -et), ut.tag = 2, Ag(st, ut)), st.lanes |= et, ut = st.alternate, ut !== null && (ut.lanes |= et), sg(st.return, et), it.lanes |= et;
                                        break
                                    }
                                    ut = ut.next
                                }
                            } else at = st.tag === 10 && st.type === _e.type ? null : st.child;
                            if (at !== null) at.return = st;
                            else
                                for (at = st; at !== null;) {
                                    if (at === _e) {
                                        at = null;
                                        break
                                    }
                                    if (st = at.sibling, st !== null) {
                                        st.return = at.return, at = st;
                                        break
                                    }
                                    at = at.return
                                }
                            st = at
                        }
                fi(_, _e, rt.children, et),
                _e = _e.child
            }
            return _e;
        case 9:
            return rt = _e.type, nt = _e.pendingProps, tt = nt.children, tg(_e, et), rt = vg(rt, nt.unstable_observedBits), tt = tt(rt), _e.flags |= 1, fi(_, _e, tt, et), _e.child;
        case 14:
            return rt = _e.type, nt = lg(rt, _e.pendingProps), nt = lg(rt.type, nt), ii(_, _e, rt, nt, tt, et);
        case 15:
            return ki(_, _e, _e.type, _e.pendingProps, tt, et);
        case 17:
            return tt = _e.type, rt = _e.pendingProps, rt = _e.elementType === tt ? rt : lg(tt, rt), _ !== null && (_.alternate = null, _e.alternate = null, _e.flags |= 2), _e.tag = 1, Ff(tt) ? (_ = !0, Jf(_e)) : _ = !1, tg(_e, et), Mg(_e, tt, rt), Og(_e, tt, rt, et), qi(null, _e, tt, !0, _, et);
        case 19:
            return Ai(_, _e, et);
        case 23:
            return mi(_, _e, et);
        case 24:
            return mi(_, _e, et)
    }
    throw Error(y$2(156, _e.tag))
};

function ik(_, _e, et, tt) {
    this.tag = _, this.key = et, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = _e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = tt, this.flags = 0, this.lastEffect = this.firstEffect = this.nextEffect = null, this.childLanes = this.lanes = 0, this.alternate = null
}

function nh(_, _e, et, tt) {
    return new ik(_, _e, et, tt)
}

function ji(_) {
    return _ = _.prototype, !(!_ || !_.isReactComponent)
}

function hk(_) {
    if (typeof _ == "function") return ji(_) ? 1 : 0;
    if (_ != null) {
        if (_ = _.$$typeof, _ === Aa) return 11;
        if (_ === Da) return 14
    }
    return 2
}

function Tg(_, _e) {
    var et = _.alternate;
    return et === null ? (et = nh(_.tag, _e, _.key, _.mode), et.elementType = _.elementType, et.type = _.type, et.stateNode = _.stateNode, et.alternate = _, _.alternate = et) : (et.pendingProps = _e, et.type = _.type, et.flags = 0, et.nextEffect = null, et.firstEffect = null, et.lastEffect = null), et.childLanes = _.childLanes, et.lanes = _.lanes, et.child = _.child, et.memoizedProps = _.memoizedProps, et.memoizedState = _.memoizedState, et.updateQueue = _.updateQueue, _e = _.dependencies, et.dependencies = _e === null ? null : {
        lanes: _e.lanes,
        firstContext: _e.firstContext
    }, et.sibling = _.sibling, et.index = _.index, et.ref = _.ref, et
}

function Vg(_, _e, et, tt, rt, nt) {
    var at = 2;
    if (tt = _, typeof _ == "function") ji(_) && (at = 1);
    else if (typeof _ == "string") at = 5;
    else e: switch (_) {
        case ua:
            return Xg(et.children, rt, nt, _e);
        case Ha:
            at = 8, rt |= 16;
            break;
        case wa:
            at = 8, rt |= 1;
            break;
        case xa:
            return _ = nh(12, et, _e, rt | 8), _.elementType = xa, _.type = xa, _.lanes = nt, _;
        case Ba:
            return _ = nh(13, et, _e, rt), _.type = Ba, _.elementType = Ba, _.lanes = nt, _;
        case Ca:
            return _ = nh(19, et, _e, rt), _.elementType = Ca, _.lanes = nt, _;
        case Ia:
            return vi(et, rt, nt, _e);
        case Ja:
            return _ = nh(24, et, _e, rt), _.elementType = Ja, _.lanes = nt, _;
        default:
            if (typeof _ == "object" && _ !== null) switch (_.$$typeof) {
                case ya:
                    at = 10;
                    break e;
                case za:
                    at = 9;
                    break e;
                case Aa:
                    at = 11;
                    break e;
                case Da:
                    at = 14;
                    break e;
                case Ea:
                    at = 16, tt = null;
                    break e;
                case Fa:
                    at = 22;
                    break e
            }
            throw Error(y$2(130, _ == null ? _ : typeof _, ""))
    }
    return _e = nh(at, et, _e, rt), _e.elementType = _, _e.type = tt, _e.lanes = nt, _e
}

function Xg(_, _e, et, tt) {
    return _ = nh(7, _, tt, _e), _.lanes = et, _
}

function vi(_, _e, et, tt) {
    return _ = nh(23, _, tt, _e), _.elementType = Ia, _.lanes = et, _
}

function Ug(_, _e, et) {
    return _ = nh(6, _, null, _e), _.lanes = et, _
}

function Wg(_, _e, et) {
    return _e = nh(4, _.children !== null ? _.children : [], _.key, _e), _e.lanes = et, _e.stateNode = {
        containerInfo: _.containerInfo,
        pendingChildren: null,
        implementation: _.implementation
    }, _e
}

function jk(_, _e, et) {
    this.tag = _e, this.containerInfo = _, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.pendingContext = this.context = null, this.hydrate = et, this.callbackNode = null, this.callbackPriority = 0, this.eventTimes = Zc(0), this.expirationTimes = Zc(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Zc(0), this.mutableSourceEagerHydrationData = null
}

function kk(_, _e, et) {
    var tt = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: ta,
        key: tt == null ? null : "" + tt,
        children: _,
        containerInfo: _e,
        implementation: et
    }
}

function lk(_, _e, et, tt) {
    var rt = _e.current,
        nt = Hg(),
        at = Ig(rt);
    e: if (et) {
        et = et._reactInternals;
        t: {
            if (Zb(et) !== et || et.tag !== 1) throw Error(y$2(170));
            var st = et;do {
                switch (st.tag) {
                    case 3:
                        st = st.stateNode.context;
                        break t;
                    case 1:
                        if (Ff(st.type)) {
                            st = st.stateNode.__reactInternalMemoizedMergedChildContext;
                            break t
                        }
                }
                st = st.return
            } while (st !== null);
            throw Error(y$2(171))
        }
        if (et.tag === 1) {
            var it = et.type;
            if (Ff(it)) {
                et = If(et, it, st);
                break e
            }
        }
        et = st
    } else et = Cf;
    return _e.context === null ? _e.context = et : _e.pendingContext = et, _e = zg(nt, at), _e.payload = {
        element: _
    }, tt = tt === void 0 ? null : tt, tt !== null && (_e.callback = tt), Ag(rt, _e), Jg(rt, at, nt), at
}

function mk(_) {
    if (_ = _.current, !_.child) return null;
    switch (_.child.tag) {
        case 5:
            return _.child.stateNode;
        default:
            return _.child.stateNode
    }
}

function nk(_, _e) {
    if (_ = _.memoizedState, _ !== null && _.dehydrated !== null) {
        var et = _.retryLane;
        _.retryLane = et !== 0 && et < _e ? et : _e
    }
}

function ok(_, _e) {
    nk(_, _e), (_ = _.alternate) && nk(_, _e)
}

function pk() {
    return null
}

function qk(_, _e, et) {
    var tt = et != null && et.hydrationOptions != null && et.hydrationOptions.mutableSources || null;
    if (et = new jk(_, _e, et != null && et.hydrate === !0), _e = nh(3, null, null, _e === 2 ? 7 : _e === 1 ? 3 : 0), et.current = _e, _e.stateNode = et, xg(_e), _[ff] = et.current, cf(_.nodeType === 8 ? _.parentNode : _), tt)
        for (_ = 0; _ < tt.length; _++) {
            _e = tt[_];
            var rt = _e._getVersion;
            rt = rt(_e._source), et.mutableSourceEagerHydrationData == null ? et.mutableSourceEagerHydrationData = [_e, rt] : et.mutableSourceEagerHydrationData.push(_e, rt)
        }
    this._internalRoot = et
}
qk.prototype.render = function(_) {
    lk(_, this._internalRoot, null, null)
};
qk.prototype.unmount = function() {
    var _ = this._internalRoot,
        _e = _.containerInfo;
    lk(null, _, null, function() {
        _e[ff] = null
    })
};

function rk(_) {
    return !(!_ || _.nodeType !== 1 && _.nodeType !== 9 && _.nodeType !== 11 && (_.nodeType !== 8 || _.nodeValue !== " react-mount-point-unstable "))
}

function sk(_, _e) {
    if (_e || (_e = _ ? _.nodeType === 9 ? _.documentElement : _.firstChild : null, _e = !(!_e || _e.nodeType !== 1 || !_e.hasAttribute("data-reactroot"))), !_e)
        for (var et; et = _.lastChild;) _.removeChild(et);
    return new qk(_, 0, _e ? {
        hydrate: !0
    } : void 0)
}

function tk(_, _e, et, tt, rt) {
    var nt = et._reactRootContainer;
    if (nt) {
        var at = nt._internalRoot;
        if (typeof rt == "function") {
            var st = rt;
            rt = function() {
                var ut = mk(at);
                st.call(ut)
            }
        }
        lk(_e, at, _, rt)
    } else {
        if (nt = et._reactRootContainer = sk(et, tt), at = nt._internalRoot, typeof rt == "function") {
            var it = rt;
            rt = function() {
                var ut = mk(at);
                it.call(ut)
            }
        }
        Xj(function() {
            lk(_e, at, _, rt)
        })
    }
    return mk(at)
}
ec = function(_) {
    if (_.tag === 13) {
        var _e = Hg();
        Jg(_, 4, _e), ok(_, 4)
    }
};
fc = function(_) {
    if (_.tag === 13) {
        var _e = Hg();
        Jg(_, 67108864, _e), ok(_, 67108864)
    }
};
gc = function(_) {
    if (_.tag === 13) {
        var _e = Hg(),
            et = Ig(_);
        Jg(_, et, _e), ok(_, et)
    }
};
hc = function(_, _e) {
    return _e()
};
yb = function(_, _e, et) {
    switch (_e) {
        case "input":
            if (ab(_, et), _e = et.name, et.type === "radio" && _e != null) {
                for (et = _; et.parentNode;) et = et.parentNode;
                for (et = et.querySelectorAll("input[name=" + JSON.stringify("" + _e) + '][type="radio"]'), _e = 0; _e < et.length; _e++) {
                    var tt = et[_e];
                    if (tt !== _ && tt.form === _.form) {
                        var rt = Db(tt);
                        if (!rt) throw Error(y$2(90));
                        Wa(tt), ab(tt, rt)
                    }
                }
            }
            break;
        case "textarea":
            ib(_, et);
            break;
        case "select":
            _e = et.value, _e != null && fb(_, !!et.multiple, _e, !1)
    }
};
Gb = Wj;
Hb = function(_, _e, et, tt, rt) {
    var nt = X$1;
    X$1 |= 4;
    try {
        return gg(98, _.bind(null, _e, et, tt, rt))
    } finally {
        X$1 = nt, X$1 === 0 && (wj(), ig())
    }
};
Ib = function() {
    !(X$1 & 49) && (Vj(), Oj())
};
Jb = function(_, _e) {
    var et = X$1;
    X$1 |= 2;
    try {
        return _(_e)
    } finally {
        X$1 = et, X$1 === 0 && (wj(), ig())
    }
};

function uk(_, _e) {
    var et = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!rk(_e)) throw Error(y$2(200));
    return kk(_, _e, null, et)
}
var vk = {
        Events: [Cb, ue, Db, Eb, Fb, Oj, {
            current: !1
        }]
    },
    wk = {
        findFiberByHostInstance: wc,
        bundleType: 0,
        version: "17.0.2",
        rendererPackageName: "react-dom"
    },
    xk = {
        bundleType: wk.bundleType,
        version: wk.version,
        rendererPackageName: wk.rendererPackageName,
        rendererConfig: wk.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: ra.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(_) {
            return _ = cc(_), _ === null ? null : _.stateNode
        },
        findFiberByHostInstance: wk.findFiberByHostInstance || pk,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null
    };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!yk.isDisabled && yk.supportsFiber) try {
        Lf = yk.inject(xk), Mf = yk
    } catch {}
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
reactDom_production_min.createPortal = uk;
reactDom_production_min.findDOMNode = function(_) {
    if (_ == null) return null;
    if (_.nodeType === 1) return _;
    var _e = _._reactInternals;
    if (_e === void 0) throw typeof _.render == "function" ? Error(y$2(188)) : Error(y$2(268, Object.keys(_)));
    return _ = cc(_e), _ = _ === null ? null : _.stateNode, _
};
reactDom_production_min.flushSync = function(_, _e) {
    var et = X$1;
    if (et & 48) return _(_e);
    X$1 |= 1;
    try {
        if (_) return gg(99, _.bind(null, _e))
    } finally {
        X$1 = et, ig()
    }
};
reactDom_production_min.hydrate = function(_, _e, et) {
    if (!rk(_e)) throw Error(y$2(200));
    return tk(null, _, _e, !0, et)
};
reactDom_production_min.render = function(_, _e, et) {
    if (!rk(_e)) throw Error(y$2(200));
    return tk(null, _, _e, !1, et)
};
reactDom_production_min.unmountComponentAtNode = function(_) {
    if (!rk(_)) throw Error(y$2(40));
    return _._reactRootContainer ? (Xj(function() {
        tk(null, null, _, !1, function() {
            _._reactRootContainer = null, _[ff] = null
        })
    }), !0) : !1
};
reactDom_production_min.unstable_batchedUpdates = Wj;
reactDom_production_min.unstable_createPortal = function(_, _e) {
    return uk(_, _e, 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null)
};
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(_, _e, et, tt) {
    if (!rk(et)) throw Error(y$2(200));
    if (_ == null || _._reactInternals === void 0) throw Error(y$2(38));
    return tk(_, _e, et, !1, tt)
};
reactDom_production_min.version = "17.0.2";
(function(_) {
    function _e() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(_e)
        } catch (et) {
            console.error(et)
        }
    }
    _e(), _.exports = reactDom_production_min
})(reactDom);
const ReactDOM = getDefaultExportFromCjs(reactDom.exports);

function _setPrototypeOf(_, _e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(tt, rt) {
        return tt.__proto__ = rt, tt
    }, _setPrototypeOf(_, _e)
}

function _inheritsLoose(_, _e) {
    _.prototype = Object.create(_e.prototype), _.prototype.constructor = _, _setPrototypeOf(_, _e)
}
var propTypes = {
        exports: {}
    },
    ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
    ReactPropTypesSecret_1 = ReactPropTypesSecret$1,
    ReactPropTypesSecret = ReactPropTypesSecret_1;

function emptyFunction() {}

function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
    function _(tt, rt, nt, at, st, it) {
        if (it !== ReactPropTypesSecret) {
            var ut = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw ut.name = "Invariant Violation", ut
        }
    }
    _.isRequired = _;

    function _e() {
        return _
    }
    var et = {
        array: _,
        bigint: _,
        bool: _,
        func: _,
        number: _,
        object: _,
        string: _,
        symbol: _,
        any: _,
        arrayOf: _e,
        element: _,
        elementType: _,
        instanceOf: _e,
        node: _,
        objectOf: _e,
        oneOf: _e,
        oneOfType: _e,
        shape: _e,
        exact: _e,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
    };
    return et.PropTypes = et, et
};
propTypes.exports = factoryWithThrowingShims();

function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(_) {
        for (var _e = 1; _e < arguments.length; _e++) {
            var et = arguments[_e];
            for (var tt in et) Object.prototype.hasOwnProperty.call(et, tt) && (_[tt] = et[tt])
        }
        return _
    }, _extends.apply(this, arguments)
}

function isAbsolute(_) {
    return _.charAt(0) === "/"
}

function spliceOne(_, _e) {
    for (var et = _e, tt = et + 1, rt = _.length; tt < rt; et += 1, tt += 1) _[et] = _[tt];
    _.pop()
}

function resolvePathname(_, _e) {
    _e === void 0 && (_e = "");
    var et = _ && _.split("/") || [],
        tt = _e && _e.split("/") || [],
        rt = _ && isAbsolute(_),
        nt = _e && isAbsolute(_e),
        at = rt || nt;
    if (_ && isAbsolute(_) ? tt = et : et.length && (tt.pop(), tt = tt.concat(et)), !tt.length) return "/";
    var st;
    if (tt.length) {
        var it = tt[tt.length - 1];
        st = it === "." || it === ".." || it === ""
    } else st = !1;
    for (var ut = 0, lt = tt.length; lt >= 0; lt--) {
        var bt = tt[lt];
        bt === "." ? spliceOne(tt, lt) : bt === ".." ? (spliceOne(tt, lt), ut++) : ut && (spliceOne(tt, lt), ut--)
    }
    if (!at)
        for (; ut--; ut) tt.unshift("..");
    at && tt[0] !== "" && (!tt[0] || !isAbsolute(tt[0])) && tt.unshift("");
    var pt = tt.join("/");
    return st && pt.substr(-1) !== "/" && (pt += "/"), pt
}

function valueOf(_) {
    return _.valueOf ? _.valueOf() : Object.prototype.valueOf.call(_)
}

function valueEqual(_, _e) {
    if (_ === _e) return !0;
    if (_ == null || _e == null) return !1;
    if (Array.isArray(_)) return Array.isArray(_e) && _.length === _e.length && _.every(function(rt, nt) {
        return valueEqual(rt, _e[nt])
    });
    if (typeof _ == "object" || typeof _e == "object") {
        var et = valueOf(_),
            tt = valueOf(_e);
        return et !== _ || tt !== _e ? valueEqual(et, tt) : Object.keys(Object.assign({}, _, _e)).every(function(rt) {
            return valueEqual(_[rt], _e[rt])
        })
    }
    return !1
}
var isProduction = !0,
    prefix = "Invariant failed";

function invariant(_, _e) {
    if (!_) {
        if (isProduction) throw new Error(prefix);
        var et = typeof _e == "function" ? _e() : _e,
            tt = et ? "".concat(prefix, ": ").concat(et) : prefix;
        throw new Error(tt)
    }
}

function addLeadingSlash$1(_) {
    return _.charAt(0) === "/" ? _ : "/" + _
}

function stripLeadingSlash(_) {
    return _.charAt(0) === "/" ? _.substr(1) : _
}

function hasBasename(_, _e) {
    return _.toLowerCase().indexOf(_e.toLowerCase()) === 0 && "/?#".indexOf(_.charAt(_e.length)) !== -1
}

function stripBasename$1(_, _e) {
    return hasBasename(_, _e) ? _.substr(_e.length) : _
}

function stripTrailingSlash(_) {
    return _.charAt(_.length - 1) === "/" ? _.slice(0, -1) : _
}

function parsePath(_) {
    var _e = _ || "/",
        et = "",
        tt = "",
        rt = _e.indexOf("#");
    rt !== -1 && (tt = _e.substr(rt), _e = _e.substr(0, rt));
    var nt = _e.indexOf("?");
    return nt !== -1 && (et = _e.substr(nt), _e = _e.substr(0, nt)), {
        pathname: _e,
        search: et === "?" ? "" : et,
        hash: tt === "#" ? "" : tt
    }
}

function createPath(_) {
    var _e = _.pathname,
        et = _.search,
        tt = _.hash,
        rt = _e || "/";
    return et && et !== "?" && (rt += et.charAt(0) === "?" ? et : "?" + et), tt && tt !== "#" && (rt += tt.charAt(0) === "#" ? tt : "#" + tt), rt
}

function createLocation(_, _e, et, tt) {
    var rt;
    typeof _ == "string" ? (rt = parsePath(_), rt.state = _e) : (rt = _extends({}, _), rt.pathname === void 0 && (rt.pathname = ""), rt.search ? rt.search.charAt(0) !== "?" && (rt.search = "?" + rt.search) : rt.search = "", rt.hash ? rt.hash.charAt(0) !== "#" && (rt.hash = "#" + rt.hash) : rt.hash = "", _e !== void 0 && rt.state === void 0 && (rt.state = _e));
    try {
        rt.pathname = decodeURI(rt.pathname)
    } catch (nt) {
        throw nt instanceof URIError ? new URIError('Pathname "' + rt.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.') : nt
    }
    return et && (rt.key = et), tt ? rt.pathname ? rt.pathname.charAt(0) !== "/" && (rt.pathname = resolvePathname(rt.pathname, tt.pathname)) : rt.pathname = tt.pathname : rt.pathname || (rt.pathname = "/"), rt
}

function locationsAreEqual(_, _e) {
    return _.pathname === _e.pathname && _.search === _e.search && _.hash === _e.hash && _.key === _e.key && valueEqual(_.state, _e.state)
}

function createTransitionManager() {
    var _ = null;

    function _e(at) {
        return _ = at,
            function() {
                _ === at && (_ = null)
            }
    }

    function et(at, st, it, ut) {
        if (_ != null) {
            var lt = typeof _ == "function" ? _(at, st) : _;
            typeof lt == "string" ? typeof it == "function" ? it(lt, ut) : ut(!0) : ut(lt !== !1)
        } else ut(!0)
    }
    var tt = [];

    function rt(at) {
        var st = !0;

        function it() {
            st && at.apply(void 0, arguments)
        }
        return tt.push(it),
            function() {
                st = !1, tt = tt.filter(function(ut) {
                    return ut !== it
                })
            }
    }

    function nt() {
        for (var at = arguments.length, st = new Array(at), it = 0; it < at; it++) st[it] = arguments[it];
        tt.forEach(function(ut) {
            return ut.apply(void 0, st)
        })
    }
    return {
        setPrompt: _e,
        confirmTransitionTo: et,
        appendListener: rt,
        notifyListeners: nt
    }
}
var canUseDOM = !!(typeof window < "u" && window.document && window.document.createElement);

function getConfirmation(_, _e) {
    _e(window.confirm(_))
}

function supportsHistory() {
    var _ = window.navigator.userAgent;
    return (_.indexOf("Android 2.") !== -1 || _.indexOf("Android 4.0") !== -1) && _.indexOf("Mobile Safari") !== -1 && _.indexOf("Chrome") === -1 && _.indexOf("Windows Phone") === -1 ? !1 : window.history && "pushState" in window.history
}

function supportsPopStateOnHashChange() {
    return window.navigator.userAgent.indexOf("Trident") === -1
}

function supportsGoWithoutReloadUsingHash() {
    return window.navigator.userAgent.indexOf("Firefox") === -1
}

function isExtraneousPopstateEvent(_) {
    return _.state === void 0 && navigator.userAgent.indexOf("CriOS") === -1
}
var PopStateEvent = "popstate",
    HashChangeEvent = "hashchange";

function getHistoryState() {
    try {
        return window.history.state || {}
    } catch {
        return {}
    }
}

function createBrowserHistory(_) {
    _ === void 0 && (_ = {}), canUseDOM || invariant(!1);
    var _e = window.history,
        et = supportsHistory(),
        tt = !supportsPopStateOnHashChange(),
        rt = _,
        nt = rt.forceRefresh,
        at = nt === void 0 ? !1 : nt,
        st = rt.getUserConfirmation,
        it = st === void 0 ? getConfirmation : st,
        ut = rt.keyLength,
        lt = ut === void 0 ? 6 : ut,
        bt = _.basename ? stripTrailingSlash(addLeadingSlash$1(_.basename)) : "";

    function pt(Ot) {
        var Rt = Ot || {},
            Lt = Rt.key,
            Bt = Rt.state,
            Nt = window.location,
            $t = Nt.pathname,
            jt = Nt.search,
            Ut = Nt.hash,
            Ht = $t + jt + Ut;
        return bt && (Ht = stripBasename$1(Ht, bt)), createLocation(Ht, Bt, Lt)
    }

    function It() {
        return Math.random().toString(36).substr(2, lt)
    }
    var At = createTransitionManager();

    function Ct(Ot) {
        _extends(kt, Ot), kt.length = _e.length, At.notifyListeners(kt.location, kt.action)
    }

    function ht(Ot) {
        isExtraneousPopstateEvent(Ot) || Et(pt(Ot.state))
    }

    function ot() {
        Et(pt(getHistoryState()))
    }
    var ct = !1;

    function Et(Ot) {
        if (ct) ct = !1, Ct();
        else {
            var Rt = "POP";
            At.confirmTransitionTo(Ot, Rt, it, function(Lt) {
                Lt ? Ct({
                    action: Rt,
                    location: Ot
                }) : Dt(Ot)
            })
        }
    }

    function Dt(Ot) {
        var Rt = kt.location,
            Lt = gt.indexOf(Rt.key);
        Lt === -1 && (Lt = 0);
        var Bt = gt.indexOf(Ot.key);
        Bt === -1 && (Bt = 0);
        var Nt = Lt - Bt;
        Nt && (ct = !0, _t(Nt))
    }
    var Pt = pt(getHistoryState()),
        gt = [Pt.key];

    function ft(Ot) {
        return bt + createPath(Ot)
    }

    function dt(Ot, Rt) {
        var Lt = "PUSH",
            Bt = createLocation(Ot, Rt, It(), kt.location);
        At.confirmTransitionTo(Bt, Lt, it, function(Nt) {
            if (!!Nt) {
                var $t = ft(Bt),
                    jt = Bt.key,
                    Ut = Bt.state;
                if (et)
                    if (_e.pushState({
                            key: jt,
                            state: Ut
                        }, null, $t), at) window.location.href = $t;
                    else {
                        var Ht = gt.indexOf(kt.location.key),
                            Wt = gt.slice(0, Ht + 1);
                        Wt.push(Bt.key), gt = Wt, Ct({
                            action: Lt,
                            location: Bt
                        })
                    }
                else window.location.href = $t
            }
        })
    }

    function St(Ot, Rt) {
        var Lt = "REPLACE",
            Bt = createLocation(Ot, Rt, It(), kt.location);
        At.confirmTransitionTo(Bt, Lt, it, function(Nt) {
            if (!!Nt) {
                var $t = ft(Bt),
                    jt = Bt.key,
                    Ut = Bt.state;
                if (et)
                    if (_e.replaceState({
                            key: jt,
                            state: Ut
                        }, null, $t), at) window.location.replace($t);
                    else {
                        var Ht = gt.indexOf(kt.location.key);
                        Ht !== -1 && (gt[Ht] = Bt.key), Ct({
                            action: Lt,
                            location: Bt
                        })
                    }
                else window.location.replace($t)
            }
        })
    }

    function _t(Ot) {
        _e.go(Ot)
    }

    function vt() {
        _t(-1)
    }

    function mt() {
        _t(1)
    }
    var xt = 0;

    function yt(Ot) {
        xt += Ot, xt === 1 && Ot === 1 ? (window.addEventListener(PopStateEvent, ht), tt && window.addEventListener(HashChangeEvent, ot)) : xt === 0 && (window.removeEventListener(PopStateEvent, ht), tt && window.removeEventListener(HashChangeEvent, ot))
    }
    var Tt = !1;

    function Ft(Ot) {
        Ot === void 0 && (Ot = !1);
        var Rt = At.setPrompt(Ot);
        return Tt || (yt(1), Tt = !0),
            function() {
                return Tt && (Tt = !1, yt(-1)), Rt()
            }
    }

    function wt(Ot) {
        var Rt = At.appendListener(Ot);
        return yt(1),
            function() {
                yt(-1), Rt()
            }
    }
    var kt = {
        length: _e.length,
        action: "POP",
        location: Pt,
        createHref: ft,
        push: dt,
        replace: St,
        go: _t,
        goBack: vt,
        goForward: mt,
        block: Ft,
        listen: wt
    };
    return kt
}
var HashChangeEvent$1 = "hashchange",
    HashPathCoders = {
        hashbang: {
            encodePath: function(_e) {
                return _e.charAt(0) === "!" ? _e : "!/" + stripLeadingSlash(_e)
            },
            decodePath: function(_e) {
                return _e.charAt(0) === "!" ? _e.substr(1) : _e
            }
        },
        noslash: {
            encodePath: stripLeadingSlash,
            decodePath: addLeadingSlash$1
        },
        slash: {
            encodePath: addLeadingSlash$1,
            decodePath: addLeadingSlash$1
        }
    };

function stripHash(_) {
    var _e = _.indexOf("#");
    return _e === -1 ? _ : _.slice(0, _e)
}

function getHashPath() {
    var _ = window.location.href,
        _e = _.indexOf("#");
    return _e === -1 ? "" : _.substring(_e + 1)
}

function pushHashPath(_) {
    window.location.hash = _
}

function replaceHashPath(_) {
    window.location.replace(stripHash(window.location.href) + "#" + _)
}

function createHashHistory(_) {
    _ === void 0 && (_ = {}), canUseDOM || invariant(!1);
    var _e = window.history;
    supportsGoWithoutReloadUsingHash();
    var et = _,
        tt = et.getUserConfirmation,
        rt = tt === void 0 ? getConfirmation : tt,
        nt = et.hashType,
        at = nt === void 0 ? "slash" : nt,
        st = _.basename ? stripTrailingSlash(addLeadingSlash$1(_.basename)) : "",
        it = HashPathCoders[at],
        ut = it.encodePath,
        lt = it.decodePath;

    function bt() {
        var Rt = lt(getHashPath());
        return st && (Rt = stripBasename$1(Rt, st)), createLocation(Rt)
    }
    var pt = createTransitionManager();

    function It(Rt) {
        _extends(Ot, Rt), Ot.length = _e.length, pt.notifyListeners(Ot.location, Ot.action)
    }
    var At = !1,
        Ct = null;

    function ht(Rt, Lt) {
        return Rt.pathname === Lt.pathname && Rt.search === Lt.search && Rt.hash === Lt.hash
    }

    function ot() {
        var Rt = getHashPath(),
            Lt = ut(Rt);
        if (Rt !== Lt) replaceHashPath(Lt);
        else {
            var Bt = bt(),
                Nt = Ot.location;
            if (!At && ht(Nt, Bt) || Ct === createPath(Bt)) return;
            Ct = null, ct(Bt)
        }
    }

    function ct(Rt) {
        if (At) At = !1, It();
        else {
            var Lt = "POP";
            pt.confirmTransitionTo(Rt, Lt, rt, function(Bt) {
                Bt ? It({
                    action: Lt,
                    location: Rt
                }) : Et(Rt)
            })
        }
    }

    function Et(Rt) {
        var Lt = Ot.location,
            Bt = ft.lastIndexOf(createPath(Lt));
        Bt === -1 && (Bt = 0);
        var Nt = ft.lastIndexOf(createPath(Rt));
        Nt === -1 && (Nt = 0);
        var $t = Bt - Nt;
        $t && (At = !0, vt($t))
    }
    var Dt = getHashPath(),
        Pt = ut(Dt);
    Dt !== Pt && replaceHashPath(Pt);
    var gt = bt(),
        ft = [createPath(gt)];

    function dt(Rt) {
        var Lt = document.querySelector("base"),
            Bt = "";
        return Lt && Lt.getAttribute("href") && (Bt = stripHash(window.location.href)), Bt + "#" + ut(st + createPath(Rt))
    }

    function St(Rt, Lt) {
        var Bt = "PUSH",
            Nt = createLocation(Rt, void 0, void 0, Ot.location);
        pt.confirmTransitionTo(Nt, Bt, rt, function($t) {
            if (!!$t) {
                var jt = createPath(Nt),
                    Ut = ut(st + jt),
                    Ht = getHashPath() !== Ut;
                if (Ht) {
                    Ct = jt, pushHashPath(Ut);
                    var Wt = ft.lastIndexOf(createPath(Ot.location)),
                        Kt = ft.slice(0, Wt + 1);
                    Kt.push(jt), ft = Kt, It({
                        action: Bt,
                        location: Nt
                    })
                } else It()
            }
        })
    }

    function _t(Rt, Lt) {
        var Bt = "REPLACE",
            Nt = createLocation(Rt, void 0, void 0, Ot.location);
        pt.confirmTransitionTo(Nt, Bt, rt, function($t) {
            if (!!$t) {
                var jt = createPath(Nt),
                    Ut = ut(st + jt),
                    Ht = getHashPath() !== Ut;
                Ht && (Ct = jt, replaceHashPath(Ut));
                var Wt = ft.indexOf(createPath(Ot.location));
                Wt !== -1 && (ft[Wt] = jt), It({
                    action: Bt,
                    location: Nt
                })
            }
        })
    }

    function vt(Rt) {
        _e.go(Rt)
    }

    function mt() {
        vt(-1)
    }

    function xt() {
        vt(1)
    }
    var yt = 0;

    function Tt(Rt) {
        yt += Rt, yt === 1 && Rt === 1 ? window.addEventListener(HashChangeEvent$1, ot) : yt === 0 && window.removeEventListener(HashChangeEvent$1, ot)
    }
    var Ft = !1;

    function wt(Rt) {
        Rt === void 0 && (Rt = !1);
        var Lt = pt.setPrompt(Rt);
        return Ft || (Tt(1), Ft = !0),
            function() {
                return Ft && (Ft = !1, Tt(-1)), Lt()
            }
    }

    function kt(Rt) {
        var Lt = pt.appendListener(Rt);
        return Tt(1),
            function() {
                Tt(-1), Lt()
            }
    }
    var Ot = {
        length: _e.length,
        action: "POP",
        location: gt,
        createHref: dt,
        push: St,
        replace: _t,
        go: vt,
        goBack: mt,
        goForward: xt,
        block: wt,
        listen: kt
    };
    return Ot
}

function clamp(_, _e, et) {
    return Math.min(Math.max(_, _e), et)
}

function createMemoryHistory(_) {
    _ === void 0 && (_ = {});
    var _e = _,
        et = _e.getUserConfirmation,
        tt = _e.initialEntries,
        rt = tt === void 0 ? ["/"] : tt,
        nt = _e.initialIndex,
        at = nt === void 0 ? 0 : nt,
        st = _e.keyLength,
        it = st === void 0 ? 6 : st,
        ut = createTransitionManager();

    function lt(dt) {
        _extends(ft, dt), ft.length = ft.entries.length, ut.notifyListeners(ft.location, ft.action)
    }

    function bt() {
        return Math.random().toString(36).substr(2, it)
    }
    var pt = clamp(at, 0, rt.length - 1),
        It = rt.map(function(dt) {
            return typeof dt == "string" ? createLocation(dt, void 0, bt()) : createLocation(dt, void 0, dt.key || bt())
        }),
        At = createPath;

    function Ct(dt, St) {
        var _t = "PUSH",
            vt = createLocation(dt, St, bt(), ft.location);
        ut.confirmTransitionTo(vt, _t, et, function(mt) {
            if (!!mt) {
                var xt = ft.index,
                    yt = xt + 1,
                    Tt = ft.entries.slice(0);
                Tt.length > yt ? Tt.splice(yt, Tt.length - yt, vt) : Tt.push(vt), lt({
                    action: _t,
                    location: vt,
                    index: yt,
                    entries: Tt
                })
            }
        })
    }

    function ht(dt, St) {
        var _t = "REPLACE",
            vt = createLocation(dt, St, bt(), ft.location);
        ut.confirmTransitionTo(vt, _t, et, function(mt) {
            !mt || (ft.entries[ft.index] = vt, lt({
                action: _t,
                location: vt
            }))
        })
    }

    function ot(dt) {
        var St = clamp(ft.index + dt, 0, ft.entries.length - 1),
            _t = "POP",
            vt = ft.entries[St];
        ut.confirmTransitionTo(vt, _t, et, function(mt) {
            mt ? lt({
                action: _t,
                location: vt,
                index: St
            }) : lt()
        })
    }

    function ct() {
        ot(-1)
    }

    function Et() {
        ot(1)
    }

    function Dt(dt) {
        var St = ft.index + dt;
        return St >= 0 && St < ft.entries.length
    }

    function Pt(dt) {
        return dt === void 0 && (dt = !1), ut.setPrompt(dt)
    }

    function gt(dt) {
        return ut.appendListener(dt)
    }
    var ft = {
        length: It.length,
        action: "POP",
        location: It[pt],
        index: pt,
        entries: It,
        createHref: At,
        push: Ct,
        replace: ht,
        go: ot,
        goBack: ct,
        goForward: Et,
        canGo: Dt,
        block: Pt,
        listen: gt
    };
    return ft
}
var pathToRegexp$1 = {
        exports: {}
    },
    isarray$1 = Array.isArray || function(_) {
        return Object.prototype.toString.call(_) == "[object Array]"
    },
    isarray = isarray$1;
pathToRegexp$1.exports = pathToRegexp;
pathToRegexp$1.exports.parse = parse$2;
pathToRegexp$1.exports.compile = compile;
pathToRegexp$1.exports.tokensToFunction = tokensToFunction;
pathToRegexp$1.exports.tokensToRegExp = tokensToRegExp;
var PATH_REGEXP = new RegExp(["(\\\\.)", "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"), "g");

function parse$2(_, _e) {
    for (var et = [], tt = 0, rt = 0, nt = "", at = _e && _e.delimiter || "/", st;
        (st = PATH_REGEXP.exec(_)) != null;) {
        var it = st[0],
            ut = st[1],
            lt = st.index;
        if (nt += _.slice(rt, lt), rt = lt + it.length, ut) {
            nt += ut[1];
            continue
        }
        var bt = _[rt],
            pt = st[2],
            It = st[3],
            At = st[4],
            Ct = st[5],
            ht = st[6],
            ot = st[7];
        nt && (et.push(nt), nt = "");
        var ct = pt != null && bt != null && bt !== pt,
            Et = ht === "+" || ht === "*",
            Dt = ht === "?" || ht === "*",
            Pt = st[2] || at,
            gt = At || Ct;
        et.push({
            name: It || tt++,
            prefix: pt || "",
            delimiter: Pt,
            optional: Dt,
            repeat: Et,
            partial: ct,
            asterisk: !!ot,
            pattern: gt ? escapeGroup(gt) : ot ? ".*" : "[^" + escapeString(Pt) + "]+?"
        })
    }
    return rt < _.length && (nt += _.substr(rt)), nt && et.push(nt), et
}

function compile(_, _e) {
    return tokensToFunction(parse$2(_, _e), _e)
}

function encodeURIComponentPretty(_) {
    return encodeURI(_).replace(/[\/?#]/g, function(_e) {
        return "%" + _e.charCodeAt(0).toString(16).toUpperCase()
    })
}

function encodeAsterisk(_) {
    return encodeURI(_).replace(/[?#]/g, function(_e) {
        return "%" + _e.charCodeAt(0).toString(16).toUpperCase()
    })
}

function tokensToFunction(_, _e) {
    for (var et = new Array(_.length), tt = 0; tt < _.length; tt++) typeof _[tt] == "object" && (et[tt] = new RegExp("^(?:" + _[tt].pattern + ")$", flags(_e)));
    return function(rt, nt) {
        for (var at = "", st = rt || {}, it = nt || {}, ut = it.pretty ? encodeURIComponentPretty : encodeURIComponent, lt = 0; lt < _.length; lt++) {
            var bt = _[lt];
            if (typeof bt == "string") {
                at += bt;
                continue
            }
            var pt = st[bt.name],
                It;
            if (pt == null)
                if (bt.optional) {
                    bt.partial && (at += bt.prefix);
                    continue
                } else throw new TypeError('Expected "' + bt.name + '" to be defined');
            if (isarray(pt)) {
                if (!bt.repeat) throw new TypeError('Expected "' + bt.name + '" to not repeat, but received `' + JSON.stringify(pt) + "`");
                if (pt.length === 0) {
                    if (bt.optional) continue;
                    throw new TypeError('Expected "' + bt.name + '" to not be empty')
                }
                for (var At = 0; At < pt.length; At++) {
                    if (It = ut(pt[At]), !et[lt].test(It)) throw new TypeError('Expected all "' + bt.name + '" to match "' + bt.pattern + '", but received `' + JSON.stringify(It) + "`");
                    at += (At === 0 ? bt.prefix : bt.delimiter) + It
                }
                continue
            }
            if (It = bt.asterisk ? encodeAsterisk(pt) : ut(pt), !et[lt].test(It)) throw new TypeError('Expected "' + bt.name + '" to match "' + bt.pattern + '", but received "' + It + '"');
            at += bt.prefix + It
        }
        return at
    }
}

function escapeString(_) {
    return _.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1")
}

function escapeGroup(_) {
    return _.replace(/([=!:$\/()])/g, "\\$1")
}

function attachKeys(_, _e) {
    return _.keys = _e, _
}

function flags(_) {
    return _ && _.sensitive ? "" : "i"
}

function regexpToRegexp(_, _e) {
    var et = _.source.match(/\((?!\?)/g);
    if (et)
        for (var tt = 0; tt < et.length; tt++) _e.push({
            name: tt,
            prefix: null,
            delimiter: null,
            optional: !1,
            repeat: !1,
            partial: !1,
            asterisk: !1,
            pattern: null
        });
    return attachKeys(_, _e)
}

function arrayToRegexp(_, _e, et) {
    for (var tt = [], rt = 0; rt < _.length; rt++) tt.push(pathToRegexp(_[rt], _e, et).source);
    var nt = new RegExp("(?:" + tt.join("|") + ")", flags(et));
    return attachKeys(nt, _e)
}

function stringToRegexp(_, _e, et) {
    return tokensToRegExp(parse$2(_, et), _e, et)
}

function tokensToRegExp(_, _e, et) {
    isarray(_e) || (et = _e || et, _e = []), et = et || {};
    for (var tt = et.strict, rt = et.end !== !1, nt = "", at = 0; at < _.length; at++) {
        var st = _[at];
        if (typeof st == "string") nt += escapeString(st);
        else {
            var it = escapeString(st.prefix),
                ut = "(?:" + st.pattern + ")";
            _e.push(st), st.repeat && (ut += "(?:" + it + ut + ")*"), st.optional ? st.partial ? ut = it + "(" + ut + ")?" : ut = "(?:" + it + "(" + ut + "))?" : ut = it + "(" + ut + ")", nt += ut
        }
    }
    var lt = escapeString(et.delimiter || "/"),
        bt = nt.slice(-lt.length) === lt;
    return tt || (nt = (bt ? nt.slice(0, -lt.length) : nt) + "(?:" + lt + "(?=$))?"), rt ? nt += "$" : nt += tt && bt ? "" : "(?=" + lt + "|$)", attachKeys(new RegExp("^" + nt, flags(et)), _e)
}

function pathToRegexp(_, _e, et) {
    return isarray(_e) || (et = _e || et, _e = []), et = et || {}, _ instanceof RegExp ? regexpToRegexp(_, _e) : isarray(_) ? arrayToRegexp(_, _e, et) : stringToRegexp(_, _e, et)
}
var reactIs$1 = {
        exports: {}
    },
    reactIs_production_min = {};
var b$1 = typeof Symbol == "function" && Symbol.for,
    c$1 = b$1 ? Symbol.for("react.element") : 60103,
    d$1 = b$1 ? Symbol.for("react.portal") : 60106,
    e$4 = b$1 ? Symbol.for("react.fragment") : 60107,
    f$4 = b$1 ? Symbol.for("react.strict_mode") : 60108,
    g = b$1 ? Symbol.for("react.profiler") : 60114,
    h$1 = b$1 ? Symbol.for("react.provider") : 60109,
    k = b$1 ? Symbol.for("react.context") : 60110,
    l$2 = b$1 ? Symbol.for("react.async_mode") : 60111,
    m$3 = b$1 ? Symbol.for("react.concurrent_mode") : 60111,
    n = b$1 ? Symbol.for("react.forward_ref") : 60112,
    p$3 = b$1 ? Symbol.for("react.suspense") : 60113,
    q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120,
    r$3 = b$1 ? Symbol.for("react.memo") : 60115,
    t$2 = b$1 ? Symbol.for("react.lazy") : 60116,
    v$1 = b$1 ? Symbol.for("react.block") : 60121,
    w$1 = b$1 ? Symbol.for("react.fundamental") : 60117,
    x$1 = b$1 ? Symbol.for("react.responder") : 60118,
    y$1 = b$1 ? Symbol.for("react.scope") : 60119;

function z(_) {
    if (typeof _ == "object" && _ !== null) {
        var _e = _.$$typeof;
        switch (_e) {
            case c$1:
                switch (_ = _.type, _) {
                    case l$2:
                    case m$3:
                    case e$4:
                    case g:
                    case f$4:
                    case p$3:
                        return _;
                    default:
                        switch (_ = _ && _.$$typeof, _) {
                            case k:
                            case n:
                            case t$2:
                            case r$3:
                            case h$1:
                                return _;
                            default:
                                return _e
                        }
                }
            case d$1:
                return _e
        }
    }
}

function A$1(_) {
    return z(_) === m$3
}
reactIs_production_min.AsyncMode = l$2;
reactIs_production_min.ConcurrentMode = m$3;
reactIs_production_min.ContextConsumer = k;
reactIs_production_min.ContextProvider = h$1;
reactIs_production_min.Element = c$1;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e$4;
reactIs_production_min.Lazy = t$2;
reactIs_production_min.Memo = r$3;
reactIs_production_min.Portal = d$1;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f$4;
reactIs_production_min.Suspense = p$3;
reactIs_production_min.isAsyncMode = function(_) {
    return A$1(_) || z(_) === l$2
};
reactIs_production_min.isConcurrentMode = A$1;
reactIs_production_min.isContextConsumer = function(_) {
    return z(_) === k
};
reactIs_production_min.isContextProvider = function(_) {
    return z(_) === h$1
};
reactIs_production_min.isElement = function(_) {
    return typeof _ == "object" && _ !== null && _.$$typeof === c$1
};
reactIs_production_min.isForwardRef = function(_) {
    return z(_) === n
};
reactIs_production_min.isFragment = function(_) {
    return z(_) === e$4
};
reactIs_production_min.isLazy = function(_) {
    return z(_) === t$2
};
reactIs_production_min.isMemo = function(_) {
    return z(_) === r$3
};
reactIs_production_min.isPortal = function(_) {
    return z(_) === d$1
};
reactIs_production_min.isProfiler = function(_) {
    return z(_) === g
};
reactIs_production_min.isStrictMode = function(_) {
    return z(_) === f$4
};
reactIs_production_min.isSuspense = function(_) {
    return z(_) === p$3
};
reactIs_production_min.isValidElementType = function(_) {
    return typeof _ == "string" || typeof _ == "function" || _ === e$4 || _ === m$3 || _ === g || _ === f$4 || _ === p$3 || _ === q$1 || typeof _ == "object" && _ !== null && (_.$$typeof === t$2 || _.$$typeof === r$3 || _.$$typeof === h$1 || _.$$typeof === k || _.$$typeof === n || _.$$typeof === w$1 || _.$$typeof === x$1 || _.$$typeof === y$1 || _.$$typeof === v$1)
};
reactIs_production_min.typeOf = z;
(function(_) {
    _.exports = reactIs_production_min
})(reactIs$1);

function _objectWithoutPropertiesLoose(_, _e) {
    if (_ == null) return {};
    var et = {},
        tt = Object.keys(_),
        rt, nt;
    for (nt = 0; nt < tt.length; nt++) rt = tt[nt], !(_e.indexOf(rt) >= 0) && (et[rt] = _[rt]);
    return et
}
var reactIs = reactIs$1.exports,
    FORWARD_REF_STATICS = {
        $$typeof: !0,
        render: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0
    },
    MEMO_STATICS = {
        $$typeof: !0,
        compare: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0,
        type: !0
    },
    TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var MAX_SIGNED_31_BIT_INT = 1073741823,
    commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {};

function getUniqueId() {
    var _ = "__global_unique_id__";
    return commonjsGlobal[_] = (commonjsGlobal[_] || 0) + 1
}

function objectIs(_, _e) {
    return _ === _e ? _ !== 0 || 1 / _ === 1 / _e : _ !== _ && _e !== _e
}

function createEventEmitter(_) {
    var _e = [];
    return {
        on: function(tt) {
            _e.push(tt)
        },
        off: function(tt) {
            _e = _e.filter(function(rt) {
                return rt !== tt
            })
        },
        get: function() {
            return _
        },
        set: function(tt, rt) {
            _ = tt, _e.forEach(function(nt) {
                return nt(_, rt)
            })
        }
    }
}

function onlyChild(_) {
    return Array.isArray(_) ? _[0] : _
}

function createReactContext(_, _e) {
    var et, tt, rt = "__create-react-context-" + getUniqueId() + "__",
        nt = function(st) {
            _inheritsLoose(it, st);

            function it() {
                for (var lt, bt = arguments.length, pt = new Array(bt), It = 0; It < bt; It++) pt[It] = arguments[It];
                return lt = st.call.apply(st, [this].concat(pt)) || this, lt.emitter = createEventEmitter(lt.props.value), lt
            }
            var ut = it.prototype;
            return ut.getChildContext = function() {
                var bt;
                return bt = {}, bt[rt] = this.emitter, bt
            }, ut.componentWillReceiveProps = function(bt) {
                if (this.props.value !== bt.value) {
                    var pt = this.props.value,
                        It = bt.value,
                        At;
                    objectIs(pt, It) ? At = 0 : (At = typeof _e == "function" ? _e(pt, It) : MAX_SIGNED_31_BIT_INT, At |= 0, At !== 0 && this.emitter.set(bt.value, At))
                }
            }, ut.render = function() {
                return this.props.children
            }, it
        }(React.Component);
    nt.childContextTypes = (et = {}, et[rt] = propTypes.exports.object.isRequired, et);
    var at = function(st) {
        _inheritsLoose(it, st);

        function it() {
            for (var lt, bt = arguments.length, pt = new Array(bt), It = 0; It < bt; It++) pt[It] = arguments[It];
            return lt = st.call.apply(st, [this].concat(pt)) || this, lt.observedBits = void 0, lt.state = {
                value: lt.getValue()
            }, lt.onUpdate = function(At, Ct) {
                var ht = lt.observedBits | 0;
                ht & Ct && lt.setState({
                    value: lt.getValue()
                })
            }, lt
        }
        var ut = it.prototype;
        return ut.componentWillReceiveProps = function(bt) {
            var pt = bt.observedBits;
            this.observedBits = pt ?? MAX_SIGNED_31_BIT_INT
        }, ut.componentDidMount = function() {
            this.context[rt] && this.context[rt].on(this.onUpdate);
            var bt = this.props.observedBits;
            this.observedBits = bt ?? MAX_SIGNED_31_BIT_INT
        }, ut.componentWillUnmount = function() {
            this.context[rt] && this.context[rt].off(this.onUpdate)
        }, ut.getValue = function() {
            return this.context[rt] ? this.context[rt].get() : _
        }, ut.render = function() {
            return onlyChild(this.props.children)(this.state.value)
        }, it
    }(React.Component);
    return at.contextTypes = (tt = {}, tt[rt] = propTypes.exports.object, tt), {
        Provider: nt,
        Consumer: at
    }
}
var createContext = React.createContext || createReactContext,
    createNamedContext = function(_e) {
        var et = createContext();
        return et.displayName = _e, et
    },
    historyContext = createNamedContext("Router-History"),
    context = createNamedContext("Router"),
    Router = function(_) {
        _inheritsLoose(_e, _), _e.computeRootMatch = function(rt) {
            return {
                path: "/",
                url: "/",
                params: {},
                isExact: rt === "/"
            }
        };

        function _e(tt) {
            var rt;
            return rt = _.call(this, tt) || this, rt.state = {
                location: tt.history.location
            }, rt._isMounted = !1, rt._pendingLocation = null, tt.staticContext || (rt.unlisten = tt.history.listen(function(nt) {
                rt._pendingLocation = nt
            })), rt
        }
        var et = _e.prototype;
        return et.componentDidMount = function() {
            var rt = this;
            this._isMounted = !0, this.unlisten && this.unlisten(), this.props.staticContext || (this.unlisten = this.props.history.listen(function(nt) {
                rt._isMounted && rt.setState({
                    location: nt
                })
            })), this._pendingLocation && this.setState({
                location: this._pendingLocation
            })
        }, et.componentWillUnmount = function() {
            this.unlisten && (this.unlisten(), this._isMounted = !1, this._pendingLocation = null)
        }, et.render = function() {
            return React.createElement(context.Provider, {
                value: {
                    history: this.props.history,
                    location: this.state.location,
                    match: _e.computeRootMatch(this.state.location.pathname),
                    staticContext: this.props.staticContext
                }
            }, React.createElement(historyContext.Provider, {
                children: this.props.children || null,
                value: this.props.history
            }))
        }, _e
    }(React.Component);
React.Component;
var Lifecycle = function(_) {
        _inheritsLoose(_e, _);

        function _e() {
            return _.apply(this, arguments) || this
        }
        var et = _e.prototype;
        return et.componentDidMount = function() {
            this.props.onMount && this.props.onMount.call(this, this)
        }, et.componentDidUpdate = function(rt) {
            this.props.onUpdate && this.props.onUpdate.call(this, this, rt)
        }, et.componentWillUnmount = function() {
            this.props.onUnmount && this.props.onUnmount.call(this, this)
        }, et.render = function() {
            return null
        }, _e
    }(React.Component),
    cache = {},
    cacheLimit = 1e4,
    cacheCount = 0;

function compilePath(_) {
    if (cache[_]) return cache[_];
    var _e = pathToRegexp$1.exports.compile(_);
    return cacheCount < cacheLimit && (cache[_] = _e, cacheCount++), _e
}

function generatePath(_, _e) {
    return _ === void 0 && (_ = "/"), _e === void 0 && (_e = {}), _ === "/" ? _ : compilePath(_)(_e, {
        pretty: !0
    })
}

function Redirect(_) {
    var _e = _.computedMatch,
        et = _.to,
        tt = _.push,
        rt = tt === void 0 ? !1 : tt;
    return React.createElement(context.Consumer, null, function(nt) {
        nt || invariant(!1);
        var at = nt.history,
            st = nt.staticContext,
            it = rt ? at.push : at.replace,
            ut = createLocation(_e ? typeof et == "string" ? generatePath(et, _e.params) : _extends({}, et, {
                pathname: generatePath(et.pathname, _e.params)
            }) : et);
        return st ? (it(ut), null) : React.createElement(Lifecycle, {
            onMount: function() {
                it(ut)
            },
            onUpdate: function(bt, pt) {
                var It = createLocation(pt.to);
                locationsAreEqual(It, _extends({}, ut, {
                    key: It.key
                })) || it(ut)
            },
            to: et
        })
    })
}
var cache$1 = {},
    cacheLimit$1 = 1e4,
    cacheCount$1 = 0;

function compilePath$1(_, _e) {
    var et = "" + _e.end + _e.strict + _e.sensitive,
        tt = cache$1[et] || (cache$1[et] = {});
    if (tt[_]) return tt[_];
    var rt = [],
        nt = pathToRegexp$1.exports(_, rt, _e),
        at = {
            regexp: nt,
            keys: rt
        };
    return cacheCount$1 < cacheLimit$1 && (tt[_] = at, cacheCount$1++), at
}

function matchPath(_, _e) {
    _e === void 0 && (_e = {}), (typeof _e == "string" || Array.isArray(_e)) && (_e = {
        path: _e
    });
    var et = _e,
        tt = et.path,
        rt = et.exact,
        nt = rt === void 0 ? !1 : rt,
        at = et.strict,
        st = at === void 0 ? !1 : at,
        it = et.sensitive,
        ut = it === void 0 ? !1 : it,
        lt = [].concat(tt);
    return lt.reduce(function(bt, pt) {
        if (!pt && pt !== "") return null;
        if (bt) return bt;
        var It = compilePath$1(pt, {
                end: nt,
                strict: st,
                sensitive: ut
            }),
            At = It.regexp,
            Ct = It.keys,
            ht = At.exec(_);
        if (!ht) return null;
        var ot = ht[0],
            ct = ht.slice(1),
            Et = _ === ot;
        return nt && !Et ? null : {
            path: pt,
            url: pt === "/" && ot === "" ? "/" : ot,
            isExact: Et,
            params: Ct.reduce(function(Dt, Pt, gt) {
                return Dt[Pt.name] = ct[gt], Dt
            }, {})
        }
    }, null)
}

function isEmptyChildren(_) {
    return React.Children.count(_) === 0
}
var Route = function(_) {
    _inheritsLoose(_e, _);

    function _e() {
        return _.apply(this, arguments) || this
    }
    var et = _e.prototype;
    return et.render = function() {
        var rt = this;
        return React.createElement(context.Consumer, null, function(nt) {
            nt || invariant(!1);
            var at = rt.props.location || nt.location,
                st = rt.props.computedMatch ? rt.props.computedMatch : rt.props.path ? matchPath(at.pathname, rt.props) : nt.match,
                it = _extends({}, nt, {
                    location: at,
                    match: st
                }),
                ut = rt.props,
                lt = ut.children,
                bt = ut.component,
                pt = ut.render;
            return Array.isArray(lt) && isEmptyChildren(lt) && (lt = null), React.createElement(context.Provider, {
                value: it
            }, it.match ? lt ? typeof lt == "function" ? lt(it) : lt : bt ? React.createElement(bt, it) : pt ? pt(it) : null : typeof lt == "function" ? lt(it) : null)
        })
    }, _e
}(React.Component);

function addLeadingSlash(_) {
    return _.charAt(0) === "/" ? _ : "/" + _
}

function addBasename(_, _e) {
    return _ ? _extends({}, _e, {
        pathname: addLeadingSlash(_) + _e.pathname
    }) : _e
}

function stripBasename(_, _e) {
    if (!_) return _e;
    var et = addLeadingSlash(_);
    return _e.pathname.indexOf(et) !== 0 ? _e : _extends({}, _e, {
        pathname: _e.pathname.substr(et.length)
    })
}

function createURL(_) {
    return typeof _ == "string" ? _ : createPath(_)
}

function staticHandler(_) {
    return function() {
        invariant(!1)
    }
}

function noop$1() {}
React.Component;
var Switch = function(_) {
        _inheritsLoose(_e, _);

        function _e() {
            return _.apply(this, arguments) || this
        }
        var et = _e.prototype;
        return et.render = function() {
            var rt = this;
            return React.createElement(context.Consumer, null, function(nt) {
                nt || invariant(!1);
                var at = rt.props.location || nt.location,
                    st, it;
                return React.Children.forEach(rt.props.children, function(ut) {
                    if (it == null && React.isValidElement(ut)) {
                        st = ut;
                        var lt = ut.props.path || ut.props.from;
                        it = lt ? matchPath(at.pathname, _extends({}, ut.props, {
                            path: lt
                        })) : nt.match
                    }
                }), it ? React.cloneElement(st, {
                    location: at,
                    computedMatch: it
                }) : null
            })
        }, _e
    }(React.Component),
    useContext = React.useContext;

function useHistory() {
    return useContext(historyContext)
}

function useLocation() {
    return useContext(context).location
}

function useParams() {
    var _ = useContext(context).match;
    return _ ? _.params : {}
}

function useRouteMatch(_) {
    var _e = useLocation(),
        et = useContext(context).match;
    return _ ? matchPath(_e.pathname, _) : et
}
React.Component;
var HashRouter = function(_) {
        _inheritsLoose(_e, _);

        function _e() {
            for (var tt, rt = arguments.length, nt = new Array(rt), at = 0; at < rt; at++) nt[at] = arguments[at];
            return tt = _.call.apply(_, [this].concat(nt)) || this, tt.history = createHashHistory(tt.props), tt
        }
        var et = _e.prototype;
        return et.render = function() {
            return React.createElement(Router, {
                history: this.history,
                children: this.props.children
            })
        }, _e
    }(React.Component),
    resolveToLocation = function(_e, et) {
        return typeof _e == "function" ? _e(et) : _e
    },
    normalizeToLocation = function(_e, et) {
        return typeof _e == "string" ? createLocation(_e, null, null, et) : _e
    },
    forwardRefShim = function(_e) {
        return _e
    },
    forwardRef = React.forwardRef;
typeof forwardRef > "u" && (forwardRef = forwardRefShim);

function isModifiedEvent(_) {
    return !!(_.metaKey || _.altKey || _.ctrlKey || _.shiftKey)
}
var LinkAnchor = forwardRef(function(_, _e) {
        var et = _.innerRef,
            tt = _.navigate,
            rt = _.onClick,
            nt = _objectWithoutPropertiesLoose(_, ["innerRef", "navigate", "onClick"]),
            at = nt.target,
            st = _extends({}, nt, {
                onClick: function(ut) {
                    try {
                        rt && rt(ut)
                    } catch (lt) {
                        throw ut.preventDefault(), lt
                    }!ut.defaultPrevented && ut.button === 0 && (!at || at === "_self") && !isModifiedEvent(ut) && (ut.preventDefault(), tt())
                }
            });
        return forwardRefShim !== forwardRef ? st.ref = _e || et : st.ref = et, React.createElement("a", st)
    }),
    Link$1 = forwardRef(function(_, _e) {
        var et = _.component,
            tt = et === void 0 ? LinkAnchor : et,
            rt = _.replace,
            nt = _.to,
            at = _.innerRef,
            st = _objectWithoutPropertiesLoose(_, ["component", "replace", "to", "innerRef"]);
        return React.createElement(context.Consumer, null, function(it) {
            it || invariant(!1);
            var ut = it.history,
                lt = normalizeToLocation(resolveToLocation(nt, it.location), it.location),
                bt = lt ? ut.createHref(lt) : "",
                pt = _extends({}, st, {
                    href: bt,
                    navigate: function() {
                        var At = resolveToLocation(nt, it.location),
                            Ct = createPath(it.location) === createPath(normalizeToLocation(At)),
                            ht = rt || Ct ? ut.replace : ut.push;
                        ht(At)
                    }
                });
            return forwardRefShim !== forwardRef ? pt.ref = _e || at : pt.innerRef = at, React.createElement(tt, pt)
        })
    }),
    forwardRefShim$1 = function(_e) {
        return _e
    },
    forwardRef$1 = React.forwardRef;
typeof forwardRef$1 > "u" && (forwardRef$1 = forwardRefShim$1);

function joinClassnames() {
    for (var _ = arguments.length, _e = new Array(_), et = 0; et < _; et++) _e[et] = arguments[et];
    return _e.filter(function(tt) {
        return tt
    }).join(" ")
}
forwardRef$1(function(_, _e) {
    var et = _["aria-current"],
        tt = et === void 0 ? "page" : et,
        rt = _.activeClassName,
        nt = rt === void 0 ? "active" : rt,
        at = _.activeStyle,
        st = _.className,
        it = _.exact,
        ut = _.isActive,
        lt = _.location,
        bt = _.sensitive,
        pt = _.strict,
        It = _.style,
        At = _.to,
        Ct = _.innerRef,
        ht = _objectWithoutPropertiesLoose(_, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);
    return React.createElement(context.Consumer, null, function(ot) {
        ot || invariant(!1);
        var ct = lt || ot.location,
            Et = normalizeToLocation(resolveToLocation(At, ct), ct),
            Dt = Et.pathname,
            Pt = Dt && Dt.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1"),
            gt = Pt ? matchPath(ct.pathname, {
                path: Pt,
                exact: it,
                sensitive: bt,
                strict: pt
            }) : null,
            ft = !!(ut ? ut(gt, ct) : gt),
            dt = typeof st == "function" ? st(ft) : st,
            St = typeof It == "function" ? It(ft) : It;
        ft && (dt = joinClassnames(dt, nt), St = _extends({}, St, at));
        var _t = _extends({
            "aria-current": ft && tt || null,
            className: dt,
            style: St,
            to: Et
        }, ht);
        return forwardRefShim$1 !== forwardRef$1 ? _t.ref = _e || Ct : _t.innerRef = Ct, React.createElement(Link$1, _t)
    })
});
const index = "";
var Icons = (_ => (_.SEARCH = "search", _.BOOKMARK = "bookmark", _.CLOCK = "clock", _.EYE_SLASH = "eyeSlash", _.ARROW_LEFT = "arrowLeft", _.ARROW_RIGHT = "arrowRight", _.CHEVRON_DOWN = "chevronDown", _.CHEVRON_RIGHT = "chevronRight", _.CLAPPER_BOARD = "clapperBoard", _.FILM = "film", _.DRAGON = "dragon", _.WARNING = "warning", _.MOVIE_WEB = "movieWeb", _.DISCORD = "discord", _.GITHUB = "github", _))(Icons || {});
const iconList = {
    search: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M500.3 443.7l-119.7-119.7c27.22-40.41 40.65-90.9 33.46-144.7C401.8 87.79 326.8 13.32 235.2 1.723C99.01-15.51-15.51 99.01 1.724 235.2c11.6 91.64 86.08 166.7 177.6 178.9c53.8 7.189 104.3-6.236 144.7-33.46l119.7 119.7c15.62 15.62 40.95 15.62 56.57 0C515.9 484.7 515.9 459.3 500.3 443.7zM79.1 208c0-70.58 57.42-128 128-128s128 57.42 128 128c0 70.58-57.42 128-128 128S79.1 278.6 79.1 208z"/></svg>',
    bookmark: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 384 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M384 48V512l-192-112L0 512V48C0 21.5 21.5 0 48 0h288C362.5 0 384 21.5 384 48z"/></svg>',
    clock: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawe\\\\some.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M256 512C114.6 512 0 397.4 0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512zM232 256C232 264 236 271.5 242.7 275.1L338.7 339.1C349.7 347.3 364.6 344.3 371.1 333.3C379.3 322.3 376.3 307.4 365.3 300L280 243.2V120C280 106.7 269.3 96 255.1 96C242.7 96 231.1 106.7 231.1 120L232 256z"/></svg>',
    eyeSlash: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 640 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M150.7 92.77C195 58.27 251.8 32 320 32C400.8 32 465.5 68.84 512.6 112.6C559.4 156 590.7 207.1 605.5 243.7C608.8 251.6 608.8 260.4 605.5 268.3C592.1 300.6 565.2 346.1 525.6 386.7L630.8 469.1C641.2 477.3 643.1 492.4 634.9 502.8C626.7 513.2 611.6 515.1 601.2 506.9L9.196 42.89C-1.236 34.71-3.065 19.63 5.112 9.196C13.29-1.236 28.37-3.065 38.81 5.112L150.7 92.77zM223.1 149.5L313.4 220.3C317.6 211.8 320 202.2 320 191.1C320 180.5 316.1 169.7 311.6 160.4C314.4 160.1 317.2 159.1 320 159.1C373 159.1 416 202.1 416 255.1C416 269.7 413.1 282.7 407.1 294.5L446.6 324.7C457.7 304.3 464 280.9 464 255.1C464 176.5 399.5 111.1 320 111.1C282.7 111.1 248.6 126.2 223.1 149.5zM320 480C239.2 480 174.5 443.2 127.4 399.4C80.62 355.1 49.34 304 34.46 268.3C31.18 260.4 31.18 251.6 34.46 243.7C44 220.8 60.29 191.2 83.09 161.5L177.4 235.8C176.5 242.4 176 249.1 176 255.1C176 335.5 240.5 400 320 400C338.7 400 356.6 396.4 373 389.9L446.2 447.5C409.9 467.1 367.8 480 320 480H320z"/></svg>',
    arrowLeft: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>',
    chevronDown: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"></polyline></svg>',
    chevronRight: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline></svg>',
    clapperBoard: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M326.1 160l127.4-127.4C451.7 32.39 449.9 32 448 32h-86.06l-128 128H326.1zM166.1 160l128-128H201.9l-128 128H166.1zM497.7 56.19L393.9 160H512V96C512 80.87 506.5 67.15 497.7 56.19zM134.1 32H64C28.65 32 0 60.65 0 96v64h6.062L134.1 32zM0 416c0 35.35 28.65 64 64 64h384c35.35 0 64-28.65 64-64V192H0V416z"/></svg>',
    film: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M463.1 32h-416C21.49 32-.0001 53.49-.0001 80v352c0 26.51 21.49 48 47.1 48h416c26.51 0 48-21.49 48-48v-352C511.1 53.49 490.5 32 463.1 32zM111.1 408c0 4.418-3.582 8-8 8H55.1c-4.418 0-8-3.582-8-8v-48c0-4.418 3.582-8 8-8h47.1c4.418 0 8 3.582 8 8L111.1 408zM111.1 280c0 4.418-3.582 8-8 8H55.1c-4.418 0-8-3.582-8-8v-48c0-4.418 3.582-8 8-8h47.1c4.418 0 8 3.582 8 8V280zM111.1 152c0 4.418-3.582 8-8 8H55.1c-4.418 0-8-3.582-8-8v-48c0-4.418 3.582-8 8-8h47.1c4.418 0 8 3.582 8 8L111.1 152zM351.1 400c0 8.836-7.164 16-16 16H175.1c-8.836 0-16-7.164-16-16v-96c0-8.838 7.164-16 16-16h160c8.836 0 16 7.162 16 16V400zM351.1 208c0 8.836-7.164 16-16 16H175.1c-8.836 0-16-7.164-16-16v-96c0-8.838 7.164-16 16-16h160c8.836 0 16 7.162 16 16V208zM463.1 408c0 4.418-3.582 8-8 8h-47.1c-4.418 0-7.1-3.582-7.1-8l0-48c0-4.418 3.582-8 8-8h47.1c4.418 0 8 3.582 8 8V408zM463.1 280c0 4.418-3.582 8-8 8h-47.1c-4.418 0-8-3.582-8-8v-48c0-4.418 3.582-8 8-8h47.1c4.418 0 8 3.582 8 8V280zM463.1 152c0 4.418-3.582 8-8 8h-47.1c-4.418 0-8-3.582-8-8l0-48c0-4.418 3.582-8 7.1-8h47.1c4.418 0 8 3.582 8 8V152z"/></svg>',
    dragon: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 640 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M18.43 255.8L192 224L100.8 292.6C90.67 302.8 97.8 320 112 320h222.7c-9.499-26.5-14.75-54.5-14.75-83.38V194.2L200.3 106.8C176.5 90.88 145 92.75 123.3 111.2l-117.5 116.4C-6.562 238 2.436 258 18.43 255.8zM575.2 289.9l-100.7-50.25c-16.25-8.125-26.5-24.75-26.5-43V160h63.99l28.12 22.62C546.1 188.6 554.2 192 562.7 192h30.1c11.1 0 23.12-6.875 28.5-17.75l14.37-28.62c5.374-10.87 4.25-23.75-2.999-33.5l-74.49-99.37C552.1 4.75 543.5 0 533.5 0H296C288.9 0 285.4 8.625 290.4 13.62L351.1 64L292.4 88.75c-5.874 3-5.874 11.37 0 14.37L351.1 128l-.0011 108.6c0 72 35.99 139.4 95.99 179.4c-195.6 6.75-344.4 41-434.1 60.88c-8.124 1.75-13.87 9-13.87 17.38C.0463 504 8.045 512 17.79 512h499.1c63.24 0 119.6-47.5 122.1-110.8C642.3 354 617.1 310.9 575.2 289.9zM489.1 66.25l45.74 11.38c-2.75 11-12.5 18.88-24.12 18.25C497.7 95.25 484.8 83.38 489.1 66.25z"/></svg>',
    warning: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-alert-triangle"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>',
    arrowRight: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>',
    movieWeb: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 20.927 20.927"><path d="M18.186,4.5V6.241H16.445V4.5H9.482V6.241H7.741V4.5H6V20.168H7.741V18.427H9.482v1.741h6.964V18.427h1.741v1.741h1.741V4.5Zm-8.7,12.186H7.741V14.945H9.482Zm0-3.482H7.741V11.464H9.482Zm0-3.482H7.741V7.982H9.482Zm8.7,6.964H16.445V14.945h1.741Zm0-3.482H16.445V11.464h1.741Zm0-3.482H16.445V7.982h1.741Z" transform="translate(10.018 -7.425) rotate(45)" fill="currentColor"/></svg>',
    discord: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 640 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z"/></svg>',
    github: '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 496 512"><!--! Font Awesome Pro 6.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>'
};

function Icon(_) {
    return jsxRuntime.exports.jsx("span", {
        dangerouslySetInnerHTML: {
            __html: iconList[_.icon]
        },
        className: _.className
    })
}

function IconPatch(_) {
    return jsxRuntime.exports.jsx("div", {
        className: _.className || void 0,
        onClick: _.onClick,
        children: jsxRuntime.exports.jsx("div", {
            className: `flex h-12 w-12 items-center justify-center rounded-full border-2 border-transparent bg-denim-300 transition-[color,transform,border-color] duration-75 ${_.clickable?"cursor-pointer hover:scale-110 hover:bg-denim-400 hover:text-white active:scale-125":""} ${_.active?"border-bink-600 bg-bink-100 text-bink-600":""}`,
            children: jsxRuntime.exports.jsx(Icon, {
                icon: _.icon
            })
        })
    })
}

function Link(_) {
    const _e = !!_.url,
        et = !!_.to,
        tt = jsxRuntime.exports.jsx("span", {
            className: "text-bink-600 hover:text-bink-700 cursor-pointer font-bold",
            children: _.children
        });
    return _e ? jsxRuntime.exports.jsx("a", {
        target: _.newTab ? "_blank" : void 0,
        rel: "noreferrer",
        href: _.url,
        children: tt
    }) : et ? jsxRuntime.exports.jsx(Link$1, {
        to: _.to,
        children: tt
    }) : jsxRuntime.exports.jsx("span", {
        onClick: () => _.onClick && _.onClick(),
        children: tt
    })
}

function Title(_) {
    return jsxRuntime.exports.jsx("h1", {
        className: "text-2xl sm:text-3xl md:text-4xl font-bold text-white",
        children: _.children
    })
}
const DISCORD_LINK = "https://discord.gg/Jhqt4Xzpfb",
    GITHUB_LINK = "https://github.com/JamesHawkinss/movie-web",
    APP_VERSION = "2.1.0",
    env = {
        OMDB_API_KEY: {}.VITE_OMDB_API_KEY,
        TMDB_API_KEY: {}.VITE_TMDB_API_KEY,
        APP_VERSION: void 0,
        GITHUB_LINK: void 0,
        DISCORD_LINK: void 0,
        CORS_PROXY_URL: {}.VITE_CORS_PROXY_URL
    },
    alerts = [];

function getKey(_) {
    var tt;
    let _e = (tt = window == null ? void 0 : window.__CONFIG__) == null ? void 0 : tt[`VITE_${_}`];
    _e !== void 0 && _e.length === 0 && (_e = void 0);
    const et = env[_] ?? _e ?? void 0;
    return et === void 0 ? (alerts.includes(_) || (window.alert(`Misconfigured instance, missing key: ${_}`), alerts.push(_)), "") : et
}

function conf() {
    return {
        APP_VERSION,
        GITHUB_LINK,
        DISCORD_LINK,
        OMDB_API_KEY: getKey("OMDB_API_KEY"),
        TMDB_API_KEY: getKey("TMDB_API_KEY"),
        CORS_PROXY_URL: `${getKey("CORS_PROXY_URL")}/?destination=`
    }
}
class ErrorBoundary extends react.exports.Component {
    constructor(_e) {
        super(_e), this.state = {
            hasError: !1
        }
    }
    static getDerivedStateFromError() {
        return {
            hasError: !0
        }
    }
    componentDidCatch(_e, et) {
        if (console.error("Render error caught", _e, et), _e instanceof Error) {
            const tt = _e;
            this.setState(rt => ({
                ...rt,
                hasError: !0,
                error: {
                    name: tt.name,
                    description: tt.message,
                    path: et.componentStack.split(`
`)[1]
                }
            }))
        }
    }
    render() {
        return this.state.hasError ? jsxRuntime.exports.jsxs("div", {
            className: "flex min-h-screen w-full flex-col items-center justify-center px-4 py-12",
            children: [jsxRuntime.exports.jsxs("div", {
                className: "flex flex-col items-center justify-start text-center",
                children: [jsxRuntime.exports.jsx(IconPatch, {
                    icon: Icons.WARNING,
                    className: "mb-6 text-red-400"
                }), jsxRuntime.exports.jsx(Title, {
                    children: "Whoops, it broke"
                }), jsxRuntime.exports.jsxs("p", {
                    className: "my-6 max-w-lg",
                    children: ["The app encountered an error and wasn't able to recover, please report it to the", " ", jsxRuntime.exports.jsx(Link, {
                        url: conf().DISCORD_LINK,
                        newTab: !0,
                        children: "Discord server"
                    }), " ", "or on", " ", jsxRuntime.exports.jsx(Link, {
                        url: conf().GITHUB_LINK,
                        newTab: !0,
                        children: "GitHub"
                    }), "."]
                })]
            }), this.state.error ? jsxRuntime.exports.jsxs("div", {
                className: "w-4xl mt-12 max-w-full rounded bg-denim-300 px-6 py-4",
                children: [jsxRuntime.exports.jsxs("p", {
                    className: "mb-1 break-words font-bold text-white",
                    children: [this.state.error.name, " - ", this.state.error.description]
                }), jsxRuntime.exports.jsx("p", {
                    className: "break-words",
                    children: this.state.error.path
                })]
            }) : null]
        }) : this.props.children
    }
}
var MWMediaType = (_ => (_.MOVIE = "movie", _.SERIES = "series", _.ANIME = "anime", _))(MWMediaType || {});
const getTheFlixUrl$1 = (_, _e) => `https://theflix.to/${_}/trending?${_e}`;

function searchTheFlix(_) {
    const _e = new URLSearchParams;
    return _e.append("search", _.searchQuery), fetch(conf().CORS_PROXY_URL + getTheFlixUrl$1(_.type === MWMediaType.MOVIE ? "movies" : "tv-shows", _e)).then(et => et.text())
}

function getDataFromSearch(_, _e = 10) {
    const et = Array.from(new DOMParser().parseFromString(_, "text/html").querySelectorAll('script[id="__NEXT_DATA__"]'))[0];
    return JSON.parse(et.innerHTML).props.pageProps.mainList.docs.filter(rt => rt.available).slice(0, _e)
}

function turnDataIntoMedia(_) {
    return {
        mediaId: `${_.id}-${_.name.replace(/[^a-z0-9]+|\s+/gim," ").trim().replace(/\s+/g,"-").toLowerCase()}`,
        title: _.name,
        year: new Date(_.releaseDate).getFullYear().toString(),
        seasonCount: _.numberOfSeasons,
        episodeId: _.lastReleasedEpisode ? _.lastReleasedEpisode.episodeNumber.toString() : null,
        seasonId: _.lastReleasedEpisode ? _.lastReleasedEpisode.seasonNumber.toString() : null
    }
}
const getTheFlixUrl = (_, _e) => _.mediaType === MWMediaType.MOVIE ? `https://theflix.to/movie/${_.mediaId}?${_e}` : _.mediaType === MWMediaType.SERIES ? `https://theflix.to/tv-show/${_.mediaId}/season-${_.seasonId}/episode-${_.episodeId}` : "";
async function getDataFromPortableSearch(_) {
    const _e = new URLSearchParams;
    _e.append("movieInfo", _.mediaId);
    const et = await fetch(conf().CORS_PROXY_URL + getTheFlixUrl(_, _e)).then(rt => rt.text()),
        tt = Array.from(new DOMParser().parseFromString(et, "text/html").querySelectorAll('script[id="__NEXT_DATA__"]'))[0];
    return _.mediaType === MWMediaType.MOVIE ? JSON.parse(tt.innerHTML).props.pageProps.movie : JSON.parse(tt.innerHTML).props.pageProps.selectedTv
}
const theFlixScraper = {
    id: "theflix",
    enabled: !1,
    type: [MWMediaType.MOVIE, MWMediaType.SERIES],
    displayName: "theflix",
    async getMediaFromPortable(_) {
        const _e = await getDataFromPortableSearch(_);
        return {
            ..._,
            year: new Date(_e.releaseDate).getFullYear().toString(),
            title: _e.name
        }
    },
    async searchForMedia(_) {
        const _e = await searchTheFlix(_),
            et = await getDataFromSearch(_e, 10),
            tt = [];
        for (const rt of et) tt.push(turnDataIntoMedia(rt));
        return tt
    },
    async getStream(_) {
        let _e = "";
        _.mediaType === MWMediaType.MOVIE ? _e = `${conf().CORS_PROXY_URL}https://theflix.to/movie/${_.mediaId}?movieInfo=${_.mediaId}` : _.mediaType === MWMediaType.SERIES && (_e = `${conf().CORS_PROXY_URL}https://theflix.to/tv-show/${_.mediaId}/season-${_.seasonId}/episode-${_.episodeId}`);
        const et = await fetch(_e).then(nt => nt.text()),
            tt = Array.from(new DOMParser().parseFromString(et, "text/html").querySelectorAll("script")).find(nt => {
                var at;
                return (at = nt.textContent) == null ? void 0 : at.includes("theflixvd.b-cdn")
            });
        if (!tt || !tt.textContent) throw new Error("Could not find stream");
        return {
            url: JSON.parse(tt.textContent).props.pageProps.videoUrl,
            type: "mp4",
            captions: []
        }
    },
    async getSeasonDataFromMedia(_) {
        const _e = `${conf().CORS_PROXY_URL}https://theflix.to/tv-show/${_.mediaId}/season-${_.seasonId}/episode-${_.episodeId}`,
            et = await fetch(_e).then(nt => nt.text()),
            tt = Array.from(new DOMParser().parseFromString(et, "text/html").querySelectorAll('script[id="__NEXT_DATA__"]'))[0];
        let rt = JSON.parse(tt.innerHTML).props.pageProps.selectedTv.seasons;
        return rt = rt.filter(nt => nt.releaseDate != null), rt = rt.map(nt => {
            const at = nt.episodes.filter(st => st.releaseDate != null);
            return {
                ...nt,
                episodes: at
            }
        }), {
            seasons: rt.map(nt => ({
                sort: nt.seasonNumber === 0 ? 999 : nt.seasonNumber,
                id: nt.seasonNumber.toString(),
                type: nt.seasonNumber === 0 ? "special" : "season",
                title: nt.name,
                episodes: nt.episodes.map(at => ({
                    title: at.name,
                    sort: at.episodeNumber,
                    id: at.episodeNumber.toString(),
                    episodeNumber: at.episodeNumber
                }))
            }))
        }
    }
};
var main = {};
Object.defineProperty(main, "__esModule", {
    value: !0
});
var unpack_1 = main.unpack = main.detect = void 0;

function detect(_) {
    return _.replace(" ", "").startsWith("eval(function(p,a,c,k,e,")
}
main.detect = detect;

function unpack(_) {
    let {
        payload: _e,
        symtab: et,
        radix: tt,
        count: rt
    } = st(_);
    if (rt != et.length) throw Error("Malformed p.a.c.k.e.r. symtab.");
    let nt;
    try {
        nt = new Unbaser(tt)
    } catch {
        throw Error("Unknown p.a.c.k.e.r. encoding.")
    }

    function at(ut) {
        const lt = ut;
        let bt;
        return tt == 1 ? bt = et[parseInt(lt)] : bt = et[nt.unbase(lt)], bt || lt
    }
    return _ = _e.replace(/\b\w+\b/g, at), _;

    function st(ut) {
        const lt = [/}\('(.*)', *(\d+|\[\]), *(\d+), *'(.*)'\.split\('\|'\), *(\d+), *(.*)\)\)/, /}\('(.*)', *(\d+|\[\]), *(\d+), *'(.*)'\.split\('\|'\)/];
        for (const bt of lt) {
            const pt = bt.exec(ut);
            if (pt) {
                let It = pt;
                It[2] == "[]";
                try {
                    return {
                        payload: It[1],
                        symtab: It[4].split("|"),
                        radix: parseInt(It[2]),
                        count: parseInt(It[3])
                    }
                } catch {
                    throw Error("Corrupted p.a.c.k.e.r. data.")
                }
            }
        }
        throw Error("Could not make sense of p.a.c.k.e.r data (unexpected code structure)")
    }

    function it(ut) {
        return ut
    }
}
unpack_1 = main.unpack = unpack;
class Unbaser {
    constructor(_e) {
        if (this.ALPHABET = {
                62: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
                95: "' !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'"
            }, this.dictionary = {}, this.base = _e, 36 < _e && _e < 62 && (this.ALPHABET[_e] = this.ALPHABET[_e] || this.ALPHABET[62].substr(0, _e)), 2 <= _e && _e <= 36) this.unbase = et => parseInt(et, _e);
        else {
            try {
                [...this.ALPHABET[_e]].forEach((et, tt) => {
                    this.dictionary[et] = tt
                })
            } catch {
                throw Error("Unsupported base encoding.")
            }
            this.unbase = this._dictunbaser
        }
    }
    _dictunbaser(_e) {
        let et = 0;
        return [..._e].reverse().forEach((tt, rt) => {
            et = et + Math.pow(this.base, rt) * this.dictionary[tt]
        }), et
    }
}
var cryptoJs = {
    exports: {}
};

function commonjsRequire(_) {
    throw new Error('Could not dynamically require "' + _ + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
var core = {
    exports: {}
};
const __viteBrowserExternal = {},
    __viteBrowserExternal$1 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: __viteBrowserExternal
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    require$$0 = getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredCore;

function requireCore() {
    return hasRequiredCore || (hasRequiredCore = 1, function(_, _e) {
        (function(et, tt) {
            _.exports = tt()
        })(commonjsGlobal$1, function() {
            var et = et || function(tt, rt) {
                var nt;
                if (typeof window < "u" && window.crypto && (nt = window.crypto), typeof self < "u" && self.crypto && (nt = self.crypto), typeof globalThis < "u" && globalThis.crypto && (nt = globalThis.crypto), !nt && typeof window < "u" && window.msCrypto && (nt = window.msCrypto), !nt && typeof commonjsGlobal$1 < "u" && commonjsGlobal$1.crypto && (nt = commonjsGlobal$1.crypto), !nt && typeof commonjsRequire == "function") try {
                    nt = require$$0
                } catch {}
                var at = function() {
                        if (nt) {
                            if (typeof nt.getRandomValues == "function") try {
                                return nt.getRandomValues(new Uint32Array(1))[0]
                            } catch {}
                            if (typeof nt.randomBytes == "function") try {
                                return nt.randomBytes(4).readInt32LE()
                            } catch {}
                        }
                        throw new Error("Native crypto module could not be used to get secure random number.")
                    },
                    st = Object.create || function() {
                        function ct() {}
                        return function(Et) {
                            var Dt;
                            return ct.prototype = Et, Dt = new ct, ct.prototype = null, Dt
                        }
                    }(),
                    it = {},
                    ut = it.lib = {},
                    lt = ut.Base = function() {
                        return {
                            extend: function(ct) {
                                var Et = st(this);
                                return ct && Et.mixIn(ct), (!Et.hasOwnProperty("init") || this.init === Et.init) && (Et.init = function() {
                                    Et.$super.init.apply(this, arguments)
                                }), Et.init.prototype = Et, Et.$super = this, Et
                            },
                            create: function() {
                                var ct = this.extend();
                                return ct.init.apply(ct, arguments), ct
                            },
                            init: function() {},
                            mixIn: function(ct) {
                                for (var Et in ct) ct.hasOwnProperty(Et) && (this[Et] = ct[Et]);
                                ct.hasOwnProperty("toString") && (this.toString = ct.toString)
                            },
                            clone: function() {
                                return this.init.prototype.extend(this)
                            }
                        }
                    }(),
                    bt = ut.WordArray = lt.extend({
                        init: function(ct, Et) {
                            ct = this.words = ct || [], Et != rt ? this.sigBytes = Et : this.sigBytes = ct.length * 4
                        },
                        toString: function(ct) {
                            return (ct || It).stringify(this)
                        },
                        concat: function(ct) {
                            var Et = this.words,
                                Dt = ct.words,
                                Pt = this.sigBytes,
                                gt = ct.sigBytes;
                            if (this.clamp(), Pt % 4)
                                for (var ft = 0; ft < gt; ft++) {
                                    var dt = Dt[ft >>> 2] >>> 24 - ft % 4 * 8 & 255;
                                    Et[Pt + ft >>> 2] |= dt << 24 - (Pt + ft) % 4 * 8
                                } else
                                    for (var St = 0; St < gt; St += 4) Et[Pt + St >>> 2] = Dt[St >>> 2];
                            return this.sigBytes += gt, this
                        },
                        clamp: function() {
                            var ct = this.words,
                                Et = this.sigBytes;
                            ct[Et >>> 2] &= 4294967295 << 32 - Et % 4 * 8, ct.length = tt.ceil(Et / 4)
                        },
                        clone: function() {
                            var ct = lt.clone.call(this);
                            return ct.words = this.words.slice(0), ct
                        },
                        random: function(ct) {
                            for (var Et = [], Dt = 0; Dt < ct; Dt += 4) Et.push(at());
                            return new bt.init(Et, ct)
                        }
                    }),
                    pt = it.enc = {},
                    It = pt.Hex = {
                        stringify: function(ct) {
                            for (var Et = ct.words, Dt = ct.sigBytes, Pt = [], gt = 0; gt < Dt; gt++) {
                                var ft = Et[gt >>> 2] >>> 24 - gt % 4 * 8 & 255;
                                Pt.push((ft >>> 4).toString(16)), Pt.push((ft & 15).toString(16))
                            }
                            return Pt.join("")
                        },
                        parse: function(ct) {
                            for (var Et = ct.length, Dt = [], Pt = 0; Pt < Et; Pt += 2) Dt[Pt >>> 3] |= parseInt(ct.substr(Pt, 2), 16) << 24 - Pt % 8 * 4;
                            return new bt.init(Dt, Et / 2)
                        }
                    },
                    At = pt.Latin1 = {
                        stringify: function(ct) {
                            for (var Et = ct.words, Dt = ct.sigBytes, Pt = [], gt = 0; gt < Dt; gt++) {
                                var ft = Et[gt >>> 2] >>> 24 - gt % 4 * 8 & 255;
                                Pt.push(String.fromCharCode(ft))
                            }
                            return Pt.join("")
                        },
                        parse: function(ct) {
                            for (var Et = ct.length, Dt = [], Pt = 0; Pt < Et; Pt++) Dt[Pt >>> 2] |= (ct.charCodeAt(Pt) & 255) << 24 - Pt % 4 * 8;
                            return new bt.init(Dt, Et)
                        }
                    },
                    Ct = pt.Utf8 = {
                        stringify: function(ct) {
                            try {
                                return decodeURIComponent(escape(At.stringify(ct)))
                            } catch {
                                throw new Error("Malformed UTF-8 data")
                            }
                        },
                        parse: function(ct) {
                            return At.parse(unescape(encodeURIComponent(ct)))
                        }
                    },
                    ht = ut.BufferedBlockAlgorithm = lt.extend({
                        reset: function() {
                            this._data = new bt.init, this._nDataBytes = 0
                        },
                        _append: function(ct) {
                            typeof ct == "string" && (ct = Ct.parse(ct)), this._data.concat(ct), this._nDataBytes += ct.sigBytes
                        },
                        _process: function(ct) {
                            var Et, Dt = this._data,
                                Pt = Dt.words,
                                gt = Dt.sigBytes,
                                ft = this.blockSize,
                                dt = ft * 4,
                                St = gt / dt;
                            ct ? St = tt.ceil(St) : St = tt.max((St | 0) - this._minBufferSize, 0);
                            var _t = St * ft,
                                vt = tt.min(_t * 4, gt);
                            if (_t) {
                                for (var mt = 0; mt < _t; mt += ft) this._doProcessBlock(Pt, mt);
                                Et = Pt.splice(0, _t), Dt.sigBytes -= vt
                            }
                            return new bt.init(Et, vt)
                        },
                        clone: function() {
                            var ct = lt.clone.call(this);
                            return ct._data = this._data.clone(), ct
                        },
                        _minBufferSize: 0
                    });
                ut.Hasher = ht.extend({
                    cfg: lt.extend(),
                    init: function(ct) {
                        this.cfg = this.cfg.extend(ct), this.reset()
                    },
                    reset: function() {
                        ht.reset.call(this), this._doReset()
                    },
                    update: function(ct) {
                        return this._append(ct), this._process(), this
                    },
                    finalize: function(ct) {
                        ct && this._append(ct);
                        var Et = this._doFinalize();
                        return Et
                    },
                    blockSize: 16,
                    _createHelper: function(ct) {
                        return function(Et, Dt) {
                            return new ct.init(Dt).finalize(Et)
                        }
                    },
                    _createHmacHelper: function(ct) {
                        return function(Et, Dt) {
                            return new ot.HMAC.init(ct, Dt).finalize(Et)
                        }
                    }
                });
                var ot = it.algo = {};
                return it
            }(Math);
            return et
        })
    }(core)), core.exports
}
var x64Core = {
        exports: {}
    },
    hasRequiredX64Core;

function requireX64Core() {
    return hasRequiredX64Core || (hasRequiredX64Core = 1, function(_, _e) {
        (function(et, tt) {
            _.exports = tt(requireCore())
        })(commonjsGlobal$1, function(et) {
            return function(tt) {
                var rt = et,
                    nt = rt.lib,
                    at = nt.Base,
                    st = nt.WordArray,
                    it = rt.x64 = {};
                it.Word = at.extend({
                    init: function(ut, lt) {
                        this.high = ut, this.low = lt
                    }
                }), it.WordArray = at.extend({
                    init: function(ut, lt) {
                        ut = this.words = ut || [], lt != tt ? this.sigBytes = lt : this.sigBytes = ut.length * 8
                    },
                    toX32: function() {
                        for (var ut = this.words, lt = ut.length, bt = [], pt = 0; pt < lt; pt++) {
                            var It = ut[pt];
                            bt.push(It.high), bt.push(It.low)
                        }
                        return st.create(bt, this.sigBytes)
                    },
                    clone: function() {
                        for (var ut = at.clone.call(this), lt = ut.words = this.words.slice(0), bt = lt.length, pt = 0; pt < bt; pt++) lt[pt] = lt[pt].clone();
                        return ut
                    }
                })
            }(), et
        })
    }(x64Core)), x64Core.exports
}
var libTypedarrays = {
        exports: {}
    },
    hasRequiredLibTypedarrays;

function requireLibTypedarrays() {
    return hasRequiredLibTypedarrays || (hasRequiredLibTypedarrays = 1, function(_, _e) {
        (function(et, tt) {
            _.exports = tt(requireCore())
        })(commonjsGlobal$1, function(et) {
            return function() {
                if (typeof ArrayBuffer == "function") {
                    var tt = et,
                        rt = tt.lib,
                        nt = rt.WordArray,
                        at = nt.init,
                        st = nt.init = function(it) {
                            if (it instanceof ArrayBuffer && (it = new Uint8Array(it)), (it instanceof Int8Array || typeof Uint8ClampedArray < "u" && it instanceof Uint8ClampedArray || it instanceof Int16Array || it instanceof Uint16Array || it instanceof Int32Array || it instanceof Uint32Array || it instanceof Float32Array || it instanceof Float64Array) && (it = new Uint8Array(it.buffer, it.byteOffset, it.byteLength)), it instanceof Uint8Array) {
                                for (var ut = it.byteLength, lt = [], bt = 0; bt < ut; bt++) lt[bt >>> 2] |= it[bt] << 24 - bt % 4 * 8;
                                at.call(this, lt, ut)
                            } else at.apply(this, arguments)
                        };
                    st.prototype = nt
                }
            }(), et.lib.WordArray
        })
    }(libTypedarrays)), libTypedarrays.exports
}
var encUtf16 = {
        exports: {}
    },
    hasRequiredEncUtf16;

function requireEncUtf16() {
    return hasRequiredEncUtf16 || (hasRequiredEncUtf16 = 1, function(_, _e) {
        (function(et, tt) {
            _.exports = tt(requireCore())
        })(commonjsGlobal$1, function(et) {
            return function() {
                var tt = et,
                    rt = tt.lib,
                    nt = rt.WordArray,
                    at = tt.enc;
                at.Utf16 = at.Utf16BE = {
                    stringify: function(it) {
                        for (var ut = it.words, lt = it.sigBytes, bt = [], pt = 0; pt < lt; pt += 2) {
                            var It = ut[pt >>> 2] >>> 16 - pt % 4 * 8 & 65535;
                            bt.push(String.fromCharCode(It))
                        }
                        return bt.join("")
                    },
                    parse: function(it) {
                        for (var ut = it.length, lt = [], bt = 0; bt < ut; bt++) lt[bt >>> 1] |= it.charCodeAt(bt) << 16 - bt % 2 * 16;
                        return nt.create(lt, ut * 2)
                    }
                }, at.Utf16LE = {
                    stringify: function(it) {
                        for (var ut = it.words, lt = it.sigBytes, bt = [], pt = 0; pt < lt; pt += 2) {
                            var It = st(ut[pt >>> 2] >>> 16 - pt % 4 * 8 & 65535);
                            bt.push(String.fromCharCode(It))
                        }
                        return bt.join("")
                    },
                    parse: function(it) {
                        for (var ut = it.length, lt = [], bt = 0; bt < ut; bt++) lt[bt >>> 1] |= st(it.charCodeAt(bt) << 16 - bt % 2 * 16);
                        return nt.create(lt, ut * 2)
                    }
                };

                function st(it) {
                    return it << 8 & 4278255360 | it >>> 8 & 16711935
                }
            }(), et.enc.Utf16
        })
    }(encUtf16)), encUtf16.exports
}
var encBase64 = {
        exports: {}
    },
    hasRequiredEncBase64;

function requireEncBase64() {
    return hasRequiredEncBase64 || (hasRequiredEncBase64 = 1, function(_, _e) {
        (function(et, tt) {
            _.exports = tt(requireCore())
        })(commonjsGlobal$1, function(et) {
            return function() {
                var tt = et,
                    rt = tt.lib,
                    nt = rt.WordArray,
                    at = tt.enc;
                at.Base64 = {
                    stringify: function(it) {
                        var ut = it.words,
                            lt = it.sigBytes,
                            bt = this._map;
                        it.clamp();
                        for (var pt = [], It = 0; It < lt; It += 3)
                            for (var At = ut[It >>> 2] >>> 24 - It % 4 * 8 & 255, Ct = ut[It + 1 >>> 2] >>> 24 - (It + 1) % 4 * 8 & 255, ht = ut[It + 2 >>> 2] >>> 24 - (It + 2) % 4 * 8 & 255, ot = At << 16 | Ct << 8 | ht, ct = 0; ct < 4 && It + ct * .75 < lt; ct++) pt.push(bt.charAt(ot >>> 6 * (3 - ct) & 63));
                        var Et = bt.charAt(64);
                        if (Et)
                            for (; pt.length % 4;) pt.push(Et);
                        return pt.join("")
                    },
                    parse: function(it) {
                        var ut = it.length,
                            lt = this._map,
                            bt = this._reverseMap;
                        if (!bt) {
                            bt = this._reverseMap = [];
                            for (var pt = 0; pt < lt.length; pt++) bt[lt.charCodeAt(pt)] = pt
                        }
                        var It = lt.charAt(64);
                        if (It) {
                            var At = it.indexOf(It);
                            At !== -1 && (ut = At)
                        }
                        return st(it, ut, bt)
                    },
                    _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
                };

                function st(it, ut, lt) {
                    for (var bt = [], pt = 0, It = 0; It < ut; It++)
                        if (It % 4) {
                            var At = lt[it.charCodeAt(It - 1)] << It % 4 * 2,
                                Ct = lt[it.charCodeAt(It)] >>> 6 - It % 4 * 2,
                                ht = At | Ct;
                            bt[pt >>> 2] |= ht << 24 - pt % 4 * 8, pt++
                        } return nt.create(bt, pt)
                }
            }(), et.enc.Base64
        })
    }(encBase64)), encBase64.exports
}
var encBase64url = {
        exports: {}
    },
    hasRequiredEncBase64url;

function requireEncBase64url() {
    return hasRequiredEncBase64url || (hasRequiredEncBase64url = 1, function(_, _e) {
        (function(et, tt) {
            _.exports = tt(requireCore())
        })(commonjsGlobal$1, function(et) {
            return function() {
                var tt = et,
                    rt = tt.lib,
                    nt = rt.WordArray,
                    at = tt.enc;
                at.Base64url = {
                    stringify: function(it, ut = !0) {
                        var lt = it.words,
                            bt = it.sigBytes,
                            pt = ut ? this._safe_map : this._map;
                        it.clamp();
                        for (var It = [], At = 0; At < bt; At += 3)
                            for (var Ct = lt[At >>> 2] >>> 24 - At % 4 * 8 & 255, ht = lt[At + 1 >>> 2] >>> 24 - (At + 1) % 4 * 8 & 255, ot = lt[At + 2 >>> 2] >>> 24 - (At + 2) % 4 * 8 & 255, ct = Ct << 16 | ht << 8 | ot, Et = 0; Et < 4 && At + Et * .75 < bt; Et++) It.push(pt.charAt(ct >>> 6 * (3 - Et) & 63));
                        var Dt = pt.charAt(64);
                        if (Dt)
                            for (; It.length % 4;) It.push(Dt);
                        return It.join("")
                    },
                    parse: function(it, ut = !0) {
                        var lt = it.length,
                            bt = ut ? this._safe_map : this._map,
                            pt = this._reverseMap;
                        if (!pt) {
                            pt = this._reverseMap = [];
                            for (var It = 0; It < bt.length; It++) pt[bt.charCodeAt(It)] = It
                        }
                        var At = bt.charAt(64);
                        if (At) {
                            var Ct = it.indexOf(At);
                            Ct !== -1 && (lt = Ct)
                        }
                        return st(it, lt, pt)
                    },
                    _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                    _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
                };

                function st(it, ut, lt) {
                    for (var bt = [], pt = 0, It = 0; It < ut; It++)
                        if (It % 4) {
                            var At = lt[it.charCodeAt(It - 1)] << It % 4 * 2,
                                Ct = lt[it.charCodeAt(It)] >>> 6 - It % 4 * 2,
                                ht = At | Ct;
                            bt[pt >>> 2] |= ht << 24 - pt % 4 * 8, pt++
                        } return nt.create(bt, pt)
                }
            }(), et.enc.Base64url
        })
    }(encBase64url)), encBase64url.exports
}
var md5 = {
        exports: {}
    },
    hasRequiredMd5;

function requireMd5() {
    return hasRequiredMd5 || (hasRequiredMd5 = 1, function(_, _e) {
        (function(et, tt) {
            _.exports = tt(requireCore())
        })(commonjsGlobal$1, function(et) {
            return function(tt) {
                var rt = et,
                    nt = rt.lib,
                    at = nt.WordArray,
                    st = nt.Hasher,
                    it = rt.algo,
                    ut = [];
                (function() {
                    for (var Ct = 0; Ct < 64; Ct++) ut[Ct] = tt.abs(tt.sin(Ct + 1)) * 4294967296 | 0
                })();
                var lt = it.MD5 = st.extend({
                    _doReset: function() {
                        this._hash = new at.init([1732584193, 4023233417, 2562383102, 271733878])
                    },
                    _doProcessBlock: function(Ct, ht) {
                        for (var ot = 0; ot < 16; ot++) {
                            var ct = ht + ot,
                                Et = Ct[ct];
                            Ct[ct] = (Et << 8 | Et >>> 24) & 16711935 | (Et << 24 | Et >>> 8) & 4278255360
                        }
                        var Dt = this._hash.words,
                            Pt = Ct[ht + 0],
                            gt = Ct[ht + 1],
                            ft = Ct[ht + 2],
                            dt = Ct[ht + 3],
                            St = Ct[ht + 4],
                            _t = Ct[ht + 5],
                            vt = Ct[ht + 6],
                            mt = Ct[ht + 7],
                            xt = Ct[ht + 8],
                            yt = Ct[ht + 9],
                            Tt = Ct[ht + 10],
                            Ft = Ct[ht + 11],
                            wt = Ct[ht + 12],
                            kt = Ct[ht + 13],
                            Ot = Ct[ht + 14],
                            Rt = Ct[ht + 15],
                            Lt = Dt[0],
                            Bt = Dt[1],
                            Nt = Dt[2],
                            $t = Dt[3];
                        Lt = bt(Lt, Bt, Nt, $t, Pt, 7, ut[0]), $t = bt($t, Lt, Bt, Nt, gt, 12, ut[1]), Nt = bt(Nt, $t, Lt, Bt, ft, 17, ut[2]), Bt = bt(Bt, Nt, $t, Lt, dt, 22, ut[3]), Lt = bt(Lt, Bt, Nt, $t, St, 7, ut[4]), $t = bt($t, Lt, Bt, Nt, _t, 12, ut[5]), Nt = bt(Nt, $t, Lt, Bt, vt, 17, ut[6]), Bt = bt(Bt, Nt, $t, Lt, mt, 22, ut[7]), Lt = bt(Lt, Bt, Nt, $t, xt, 7, ut[8]), $t = bt($t, Lt, Bt, Nt, yt, 12, ut[9]), Nt = bt(Nt, $t, Lt, Bt, Tt, 17, ut[10]), Bt = bt(Bt, Nt, $t, Lt, Ft, 22, ut[11]), Lt = bt(Lt, Bt, Nt, $t, wt, 7, ut[12]), $t = bt($t, Lt, Bt, Nt, kt, 12, ut[13]), Nt = bt(Nt, $t, Lt, Bt, Ot, 17, ut[14]), Bt = bt(Bt, Nt, $t, Lt, Rt, 22, ut[15]), Lt = pt(Lt, Bt, Nt, $t, gt, 5, ut[16]), $t = pt($t, Lt, Bt, Nt, vt, 9, ut[17]), Nt = pt(Nt, $t, Lt, Bt, Ft, 14, ut[18]), Bt = pt(Bt, Nt, $t, Lt, Pt, 20, ut[19]), Lt = pt(Lt, Bt, Nt, $t, _t, 5, ut[20]), $t = pt($t, Lt, Bt, Nt, Tt, 9, ut[21]), Nt = pt(Nt, $t, Lt, Bt, Rt, 14, ut[22]), Bt = pt(Bt, Nt, $t, Lt, St, 20, ut[23]), Lt = pt(Lt, Bt, Nt, $t, yt, 5, ut[24]), $t = pt($t, Lt, Bt, Nt, Ot, 9, ut[25]), Nt = pt(Nt, $t, Lt, Bt, dt, 14, ut[26]), Bt = pt(Bt, Nt, $t, Lt, xt, 20, ut[27]), Lt = pt(Lt, Bt, Nt, $t, kt, 5, ut[28]), $t = pt($t, Lt, Bt, Nt, ft, 9, ut[29]), Nt = pt(Nt, $t, Lt, Bt, mt, 14, ut[30]), Bt = pt(Bt, Nt, $t, Lt, wt, 20, ut[31]), Lt = It(Lt, Bt, Nt, $t, _t, 4, ut[32]), $t = It($t, Lt, Bt, Nt, xt, 11, ut[33]), Nt = It(Nt, $t, Lt, Bt, Ft, 16, ut[34]), Bt = It(Bt, Nt, $t, Lt, Ot, 23, ut[35]), Lt = It(Lt, Bt, Nt, $t, gt, 4, ut[36]), $t = It($t, Lt, Bt, Nt, St, 11, ut[37]), Nt = It(Nt, $t, Lt, Bt, mt, 16, ut[38]), Bt = It(Bt, Nt, $t, Lt, Tt, 23, ut[39]), Lt = It(Lt, Bt, Nt, $t, kt, 4, ut[40]), $t = It($t, Lt, Bt, Nt, Pt, 11, ut[41]), Nt = It(Nt, $t, Lt, Bt, dt, 16, ut[42]), Bt = It(Bt, Nt, $t, Lt, vt, 23, ut[43]), Lt = It(Lt, Bt, Nt, $t, yt, 4, ut[44]), $t = It($t, Lt, Bt, Nt, wt, 11, ut[45]), Nt = It(Nt, $t, Lt, Bt, Rt, 16, ut[46]), Bt = It(Bt, Nt, $t, Lt, ft, 23, ut[47]), Lt = At(Lt, Bt, Nt, $t, Pt, 6, ut[48]), $t = At($t, Lt, Bt, Nt, mt, 10, ut[49]), Nt = At(Nt, $t, Lt, Bt, Ot, 15, ut[50]), Bt = At(Bt, Nt, $t, Lt, _t, 21, ut[51]), Lt = At(Lt, Bt, Nt, $t, wt, 6, ut[52]), $t = At($t, Lt, Bt, Nt, dt, 10, ut[53]), Nt = At(Nt, $t, Lt, Bt, Tt, 15, ut[54]), Bt = At(Bt, Nt, $t, Lt, gt, 21, ut[55]), Lt = At(Lt, Bt, Nt, $t, xt, 6, ut[56]), $t = At($t, Lt, Bt, Nt, Rt, 10, ut[57]), Nt = At(Nt, $t, Lt, Bt, vt, 15, ut[58]), Bt = At(Bt, Nt, $t, Lt, kt, 21, ut[59]), Lt = At(Lt, Bt, Nt, $t, St, 6, ut[60]), $t = At($t, Lt, Bt, Nt, Ft, 10, ut[61]), Nt = At(Nt, $t, Lt, Bt, ft, 15, ut[62]), Bt = At(Bt, Nt, $t, Lt, yt, 21, ut[63]), Dt[0] = Dt[0] + Lt | 0, Dt[1] = Dt[1] + Bt | 0, Dt[2] = Dt[2] + Nt | 0, Dt[3] = Dt[3] + $t | 0
                    },
                    _doFinalize: function() {
                        var Ct = this._data,
                            ht = Ct.words,
                            ot = this._nDataBytes * 8,
                            ct = Ct.sigBytes * 8;
                        ht[ct >>> 5] |= 128 << 24 - ct % 32;
                        var Et = tt.floor(ot / 4294967296),
                            Dt = ot;
                        ht[(ct + 64 >>> 9 << 4) + 15] = (Et << 8 | Et >>> 24) & 16711935 | (Et << 24 | Et >>> 8) & 4278255360, ht[(ct + 64 >>> 9 << 4) + 14] = (Dt << 8 | Dt >>> 24) & 16711935 | (Dt << 24 | Dt >>> 8) & 4278255360, Ct.sigBytes = (ht.length + 1) * 4, this._process();
                        for (var Pt = this._hash, gt = Pt.words, ft = 0; ft < 4; ft++) {
                            var dt = gt[ft];
                            gt[ft] = (dt << 8 | dt >>> 24) & 16711935 | (dt << 24 | dt >>> 8) & 4278255360
                        }
                        return Pt
                    },
                    clone: function() {
                        var Ct = st.clone.call(this);
                        return Ct._hash = this._hash.clone(), Ct
                    }
                });

                function bt(Ct, ht, ot, ct, Et, Dt, Pt) {
                    var gt = Ct + (ht & ot | ~ht & ct) + Et + Pt;
                    return (gt << Dt | gt >>> 32 - Dt) + ht
                }

                function pt(Ct, ht, ot, ct, Et, Dt, Pt) {
                    var gt = Ct + (ht & ct | ot & ~ct) + Et + Pt;
                    return (gt << Dt | gt >>> 32 - Dt) + ht
                }

                function It(Ct, ht, ot, ct, Et, Dt, Pt) {
                    var gt = Ct + (ht ^ ot ^ ct) + Et + Pt;
                    return (gt << Dt | gt >>> 32 - Dt) + ht
                }

                function At(Ct, ht, ot, ct, Et, Dt, Pt) {
                    var gt = Ct + (ot ^ (ht | ~ct)) + Et + Pt;
                    return (gt << Dt | gt >>> 32 - Dt) + ht
                }
                rt.MD5 = st._createHelper(lt), rt.HmacMD5 = st._createHmacHelper(lt)
            }(Math), et.MD5
        })
    }(md5)), md5.exports
}
var sha1 = {
        exports: {}
    },
    hasRequiredSha1;

function requireSha1() {
    return hasRequiredSha1 || (hasRequiredSha1 = 1, function(_, _e) {
        (function(et, tt) {
            _.exports = tt(requireCore())
        })(commonjsGlobal$1, function(et) {
            return function() {
                var tt = et,
                    rt = tt.lib,
                    nt = rt.WordArray,
                    at = rt.Hasher,
                    st = tt.algo,
                    it = [],
                    ut = st.SHA1 = at.extend({
                        _doReset: function() {
                            this._hash = new nt.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
                        },
                        _doProcessBlock: function(lt, bt) {
                            for (var pt = this._hash.words, It = pt[0], At = pt[1], Ct = pt[2], ht = pt[3], ot = pt[4], ct = 0; ct < 80; ct++) {
                                if (ct < 16) it[ct] = lt[bt + ct] | 0;
                                else {
                                    var Et = it[ct - 3] ^ it[ct - 8] ^ it[ct - 14] ^ it[ct - 16];
                                    it[ct] = Et << 1 | Et >>> 31
                                }
                                var Dt = (It << 5 | It >>> 27) + ot + it[ct];
                                ct < 20 ? Dt += (At & Ct | ~At & ht) + 1518500249 : ct < 40 ? Dt += (At ^ Ct ^ ht) + 1859775393 : ct < 60 ? Dt += (At & Ct | At & ht | Ct & ht) - 1894007588 : Dt += (At ^ Ct ^ ht) - 899497514, ot = ht, ht = Ct, Ct = At << 30 | At >>> 2, At = It, It = Dt
                            }
                            pt[0] = pt[0] + It | 0, pt[1] = pt[1] + At | 0, pt[2] = pt[2] + Ct | 0, pt[3] = pt[3] + ht | 0, pt[4] = pt[4] + ot | 0
                        },
                        _doFinalize: function() {
                            var lt = this._data,
                                bt = lt.words,
                                pt = this._nDataBytes * 8,
                                It = lt.sigBytes * 8;
                            return bt[It >>> 5] |= 128 << 24 - It % 32, bt[(It + 64 >>> 9 << 4) + 14] = Math.floor(pt / 4294967296), bt[(It + 64 >>> 9 << 4) + 15] = pt, lt.sigBytes = bt.length * 4, this._process(), this._hash
                        },
                        clone: function() {
                            var lt = at.clone.call(this);
                            return lt._hash = this._hash.clone(), lt
                        }
                    });
                tt.SHA1 = at._createHelper(ut), tt.HmacSHA1 = at._createHmacHelper(ut)
            }(), et.SHA1
        })
    }(sha1)), sha1.exports
}
var sha256 = {
        exports: {}
    },
    hasRequiredSha256;

function requireSha256() {
    return hasRequiredSha256 || (hasRequiredSha256 = 1, function(_, _e) {
        (function(et, tt) {
            _.exports = tt(requireCore())
        })(commonjsGlobal$1, function(et) {
            return function(tt) {
                var rt = et,
                    nt = rt.lib,
                    at = nt.WordArray,
                    st = nt.Hasher,
                    it = rt.algo,
                    ut = [],
                    lt = [];
                (function() {
                    function It(ot) {
                        for (var ct = tt.sqrt(ot), Et = 2; Et <= ct; Et++)
                            if (!(ot % Et)) return !1;
                        return !0
                    }

                    function At(ot) {
                        return (ot - (ot | 0)) * 4294967296 | 0
                    }
                    for (var Ct = 2, ht = 0; ht < 64;) It(Ct) && (ht < 8 && (ut[ht] = At(tt.pow(Ct, 1 / 2))), lt[ht] = At(tt.pow(Ct, 1 / 3)), ht++), Ct++
                })();
                var bt = [],
                    pt = it.SHA256 = st.extend({
                        _doReset: function() {
                            this._hash = new at.init(ut.slice(0))
                        },
                        _doProcessBlock: function(It, At) {
                            for (var Ct = this._hash.words, ht = Ct[0], ot = Ct[1], ct = Ct[2], Et = Ct[3], Dt = Ct[4], Pt = Ct[5], gt = Ct[6], ft = Ct[7], dt = 0; dt < 64; dt++) {
                                if (dt < 16) bt[dt] = It[At + dt] | 0;
                                else {
                                    var St = bt[dt - 15],
                                        _t = (St << 25 | St >>> 7) ^ (St << 14 | St >>> 18) ^ St >>> 3,
                                        vt = bt[dt - 2],
                                        mt = (vt << 15 | vt >>> 17) ^ (vt << 13 | vt >>> 19) ^ vt >>> 10;
                                    bt[dt] = _t + bt[dt - 7] + mt + bt[dt - 16]
                                }
                                var xt = Dt & Pt ^ ~Dt & gt,
                                    yt = ht & ot ^ ht & ct ^ ot & ct,
                                    Tt = (ht << 30 | ht >>> 2) ^ (ht << 19 | ht >>> 13) ^ (ht << 10 | ht >>> 22),
                                    Ft = (Dt << 26 | Dt >>> 6) ^ (Dt << 21 | Dt >>> 11) ^ (Dt << 7 | Dt >>> 25),
                                    wt = ft + Ft + xt + lt[dt] + bt[dt],
                                    kt = Tt + yt;
                                ft = gt, gt = Pt, Pt = Dt, Dt = Et + wt | 0, Et = ct, ct = ot, ot = ht, ht = wt + kt | 0
                            }
                            Ct[0] = Ct[0] + ht | 0, Ct[1] = Ct[1] + ot | 0, Ct[2] = Ct[2] + ct | 0, Ct[3] = Ct[3] + Et | 0, Ct[4] = Ct[4] + Dt | 0, Ct[5] = Ct[5] + Pt | 0, Ct[6] = Ct[6] + gt | 0, Ct[7] = Ct[7] + ft | 0
                        },
                        _doFinalize: function() {
                            var It = this._data,
                                At = It.words,
                                Ct = this._nDataBytes * 8,
                                ht = It.sigBytes * 8;
                            return At[ht >>> 5] |= 128 << 24 - ht % 32, At[(ht + 64 >>> 9 << 4) + 14] = tt.floor(Ct / 4294967296), At[(ht + 64 >>> 9 << 4) + 15] = Ct, It.sigBytes = At.length * 4, this._process(), this._hash
                        },
                        clone: function() {
                            var It = st.clone.call(this);
                            return It._hash = this._hash.clone(), It
                        }
                    });
                rt.SHA256 = st._createHelper(pt), rt.HmacSHA256 = st._createHmacHelper(pt)
            }(Math), et.SHA256
        })
    }(sha256)), sha256.exports
}
var sha224 = {
        exports: {}
    },
    hasRequiredSha224;

function requireSha224() {
    return hasRequiredSha224 || (hasRequiredSha224 = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireSha256())
        })(commonjsGlobal$1, function(et) {
            return function() {
                var tt = et,
                    rt = tt.lib,
                    nt = rt.WordArray,
                    at = tt.algo,
                    st = at.SHA256,
                    it = at.SHA224 = st.extend({
                        _doReset: function() {
                            this._hash = new nt.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428])
                        },
                        _doFinalize: function() {
                            var ut = st._doFinalize.call(this);
                            return ut.sigBytes -= 4, ut
                        }
                    });
                tt.SHA224 = st._createHelper(it), tt.HmacSHA224 = st._createHmacHelper(it)
            }(), et.SHA224
        })
    }(sha224)), sha224.exports
}
var sha512 = {
        exports: {}
    },
    hasRequiredSha512;

function requireSha512() {
    return hasRequiredSha512 || (hasRequiredSha512 = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireX64Core())
        })(commonjsGlobal$1, function(et) {
            return function() {
                var tt = et,
                    rt = tt.lib,
                    nt = rt.Hasher,
                    at = tt.x64,
                    st = at.Word,
                    it = at.WordArray,
                    ut = tt.algo;

                function lt() {
                    return st.create.apply(st, arguments)
                }
                var bt = [lt(1116352408, 3609767458), lt(1899447441, 602891725), lt(3049323471, 3964484399), lt(3921009573, 2173295548), lt(961987163, 4081628472), lt(1508970993, 3053834265), lt(2453635748, 2937671579), lt(2870763221, 3664609560), lt(3624381080, 2734883394), lt(310598401, 1164996542), lt(607225278, 1323610764), lt(1426881987, 3590304994), lt(1925078388, 4068182383), lt(2162078206, 991336113), lt(2614888103, 633803317), lt(3248222580, 3479774868), lt(3835390401, 2666613458), lt(4022224774, 944711139), lt(264347078, 2341262773), lt(604807628, 2007800933), lt(770255983, 1495990901), lt(1249150122, 1856431235), lt(1555081692, 3175218132), lt(1996064986, 2198950837), lt(2554220882, 3999719339), lt(2821834349, 766784016), lt(2952996808, 2566594879), lt(3210313671, 3203337956), lt(3336571891, 1034457026), lt(3584528711, 2466948901), lt(113926993, 3758326383), lt(338241895, 168717936), lt(666307205, 1188179964), lt(773529912, 1546045734), lt(1294757372, 1522805485), lt(1396182291, 2643833823), lt(1695183700, 2343527390), lt(1986661051, 1014477480), lt(2177026350, 1206759142), lt(2456956037, 344077627), lt(2730485921, 1290863460), lt(2820302411, 3158454273), lt(3259730800, 3505952657), lt(3345764771, 106217008), lt(3516065817, 3606008344), lt(3600352804, 1432725776), lt(4094571909, 1467031594), lt(275423344, 851169720), lt(430227734, 3100823752), lt(506948616, 1363258195), lt(659060556, 3750685593), lt(883997877, 3785050280), lt(958139571, 3318307427), lt(1322822218, 3812723403), lt(1537002063, 2003034995), lt(1747873779, 3602036899), lt(1955562222, 1575990012), lt(2024104815, 1125592928), lt(2227730452, 2716904306), lt(2361852424, 442776044), lt(2428436474, 593698344), lt(2756734187, 3733110249), lt(3204031479, 2999351573), lt(3329325298, 3815920427), lt(3391569614, 3928383900), lt(3515267271, 566280711), lt(3940187606, 3454069534), lt(4118630271, 4000239992), lt(116418474, 1914138554), lt(174292421, 2731055270), lt(289380356, 3203993006), lt(460393269, 320620315), lt(685471733, 587496836), lt(852142971, 1086792851), lt(1017036298, 365543100), lt(1126000580, 2618297676), lt(1288033470, 3409855158), lt(1501505948, 4234509866), lt(1607167915, 987167468), lt(1816402316, 1246189591)],
                    pt = [];
                (function() {
                    for (var At = 0; At < 80; At++) pt[At] = lt()
                })();
                var It = ut.SHA512 = nt.extend({
                    _doReset: function() {
                        this._hash = new it.init([new st.init(1779033703, 4089235720), new st.init(3144134277, 2227873595), new st.init(1013904242, 4271175723), new st.init(2773480762, 1595750129), new st.init(1359893119, 2917565137), new st.init(2600822924, 725511199), new st.init(528734635, 4215389547), new st.init(1541459225, 327033209)])
                    },
                    _doProcessBlock: function(At, Ct) {
                        for (var ht = this._hash.words, ot = ht[0], ct = ht[1], Et = ht[2], Dt = ht[3], Pt = ht[4], gt = ht[5], ft = ht[6], dt = ht[7], St = ot.high, _t = ot.low, vt = ct.high, mt = ct.low, xt = Et.high, yt = Et.low, Tt = Dt.high, Ft = Dt.low, wt = Pt.high, kt = Pt.low, Ot = gt.high, Rt = gt.low, Lt = ft.high, Bt = ft.low, Nt = dt.high, $t = dt.low, jt = St, Ut = _t, Ht = vt, Wt = mt, Kt = xt, Gt = yt, Vt = Tt, zt = Ft, Xt = wt, Yt = kt, Zt = Ot, qt = Rt, er = Lt, tr = Bt, Qt = Nt, Jt = $t, nr = 0; nr < 80; nr++) {
                            var rr, ir, ur = pt[nr];
                            if (nr < 16) ir = ur.high = At[Ct + nr * 2] | 0, rr = ur.low = At[Ct + nr * 2 + 1] | 0;
                            else {
                                var ar = pt[nr - 15],
                                    lr = ar.high,
                                    or = ar.low,
                                    fr = (lr >>> 1 | or << 31) ^ (lr >>> 8 | or << 24) ^ lr >>> 7,
                                    hr = (or >>> 1 | lr << 31) ^ (or >>> 8 | lr << 24) ^ (or >>> 7 | lr << 25),
                                    xr = pt[nr - 2],
                                    vr = xr.high,
                                    pr = xr.low,
                                    yr = (vr >>> 19 | pr << 13) ^ (vr << 3 | pr >>> 29) ^ vr >>> 6,
                                    _r = (pr >>> 19 | vr << 13) ^ (pr << 3 | vr >>> 29) ^ (pr >>> 6 | vr << 26),
                                    Er = pt[nr - 7],
                                    Rr = Er.high,
                                    cr = Er.low,
                                    dr = pt[nr - 16],
                                    Sr = dr.high,
                                    sr = dr.low;
                                rr = hr + cr, ir = fr + Rr + (rr >>> 0 < hr >>> 0 ? 1 : 0), rr = rr + _r, ir = ir + yr + (rr >>> 0 < _r >>> 0 ? 1 : 0), rr = rr + sr, ir = ir + Sr + (rr >>> 0 < sr >>> 0 ? 1 : 0), ur.high = ir, ur.low = rr
                            }
                            var gr = Xt & Zt ^ ~Xt & er,
                                Dr = Yt & qt ^ ~Yt & tr,
                                Pr = jt & Ht ^ jt & Kt ^ Ht & Kt,
                                Or = Ut & Wt ^ Ut & Gt ^ Wt & Gt,
                                Ir = (jt >>> 28 | Ut << 4) ^ (jt << 30 | Ut >>> 2) ^ (jt << 25 | Ut >>> 7),
                                Tr = (Ut >>> 28 | jt << 4) ^ (Ut << 30 | jt >>> 2) ^ (Ut << 25 | jt >>> 7),
                                Mr = (Xt >>> 14 | Yt << 18) ^ (Xt >>> 18 | Yt << 14) ^ (Xt << 23 | Yt >>> 9),
                                wr = (Yt >>> 14 | Xt << 18) ^ (Yt >>> 18 | Xt << 14) ^ (Yt << 23 | Xt >>> 9),
                                Cr = bt[nr],
                                Fr = Cr.high,
                                Lr = Cr.low,
                                mr = Jt + wr,
                                Ar = Qt + Mr + (mr >>> 0 < Jt >>> 0 ? 1 : 0),
                                mr = mr + Dr,
                                Ar = Ar + gr + (mr >>> 0 < Dr >>> 0 ? 1 : 0),
                                mr = mr + Lr,
                                Ar = Ar + Fr + (mr >>> 0 < Lr >>> 0 ? 1 : 0),
                                mr = mr + rr,
                                Ar = Ar + ir + (mr >>> 0 < rr >>> 0 ? 1 : 0),
                                Br = Tr + Or,
                                Nr = Ir + Pr + (Br >>> 0 < Tr >>> 0 ? 1 : 0);
                            Qt = er, Jt = tr, er = Zt, tr = qt, Zt = Xt, qt = Yt, Yt = zt + mr | 0, Xt = Vt + Ar + (Yt >>> 0 < zt >>> 0 ? 1 : 0) | 0, Vt = Kt, zt = Gt, Kt = Ht, Gt = Wt, Ht = jt, Wt = Ut, Ut = mr + Br | 0, jt = Ar + Nr + (Ut >>> 0 < mr >>> 0 ? 1 : 0) | 0
                        }
                        _t = ot.low = _t + Ut, ot.high = St + jt + (_t >>> 0 < Ut >>> 0 ? 1 : 0), mt = ct.low = mt + Wt, ct.high = vt + Ht + (mt >>> 0 < Wt >>> 0 ? 1 : 0), yt = Et.low = yt + Gt, Et.high = xt + Kt + (yt >>> 0 < Gt >>> 0 ? 1 : 0), Ft = Dt.low = Ft + zt, Dt.high = Tt + Vt + (Ft >>> 0 < zt >>> 0 ? 1 : 0), kt = Pt.low = kt + Yt, Pt.high = wt + Xt + (kt >>> 0 < Yt >>> 0 ? 1 : 0), Rt = gt.low = Rt + qt, gt.high = Ot + Zt + (Rt >>> 0 < qt >>> 0 ? 1 : 0), Bt = ft.low = Bt + tr, ft.high = Lt + er + (Bt >>> 0 < tr >>> 0 ? 1 : 0), $t = dt.low = $t + Jt, dt.high = Nt + Qt + ($t >>> 0 < Jt >>> 0 ? 1 : 0)
                    },
                    _doFinalize: function() {
                        var At = this._data,
                            Ct = At.words,
                            ht = this._nDataBytes * 8,
                            ot = At.sigBytes * 8;
                        Ct[ot >>> 5] |= 128 << 24 - ot % 32, Ct[(ot + 128 >>> 10 << 5) + 30] = Math.floor(ht / 4294967296), Ct[(ot + 128 >>> 10 << 5) + 31] = ht, At.sigBytes = Ct.length * 4, this._process();
                        var ct = this._hash.toX32();
                        return ct
                    },
                    clone: function() {
                        var At = nt.clone.call(this);
                        return At._hash = this._hash.clone(), At
                    },
                    blockSize: 1024 / 32
                });
                tt.SHA512 = nt._createHelper(It), tt.HmacSHA512 = nt._createHmacHelper(It)
            }(), et.SHA512
        })
    }(sha512)), sha512.exports
}
var sha384 = {
        exports: {}
    },
    hasRequiredSha384;

function requireSha384() {
    return hasRequiredSha384 || (hasRequiredSha384 = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireX64Core(), requireSha512())
        })(commonjsGlobal$1, function(et) {
            return function() {
                var tt = et,
                    rt = tt.x64,
                    nt = rt.Word,
                    at = rt.WordArray,
                    st = tt.algo,
                    it = st.SHA512,
                    ut = st.SHA384 = it.extend({
                        _doReset: function() {
                            this._hash = new at.init([new nt.init(3418070365, 3238371032), new nt.init(1654270250, 914150663), new nt.init(2438529370, 812702999), new nt.init(355462360, 4144912697), new nt.init(1731405415, 4290775857), new nt.init(2394180231, 1750603025), new nt.init(3675008525, 1694076839), new nt.init(1203062813, 3204075428)])
                        },
                        _doFinalize: function() {
                            var lt = it._doFinalize.call(this);
                            return lt.sigBytes -= 16, lt
                        }
                    });
                tt.SHA384 = it._createHelper(ut), tt.HmacSHA384 = it._createHmacHelper(ut)
            }(), et.SHA384
        })
    }(sha384)), sha384.exports
}
var sha3 = {
        exports: {}
    },
    hasRequiredSha3;

function requireSha3() {
    return hasRequiredSha3 || (hasRequiredSha3 = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireX64Core())
        })(commonjsGlobal$1, function(et) {
            return function(tt) {
                var rt = et,
                    nt = rt.lib,
                    at = nt.WordArray,
                    st = nt.Hasher,
                    it = rt.x64,
                    ut = it.Word,
                    lt = rt.algo,
                    bt = [],
                    pt = [],
                    It = [];
                (function() {
                    for (var ht = 1, ot = 0, ct = 0; ct < 24; ct++) {
                        bt[ht + 5 * ot] = (ct + 1) * (ct + 2) / 2 % 64;
                        var Et = ot % 5,
                            Dt = (2 * ht + 3 * ot) % 5;
                        ht = Et, ot = Dt
                    }
                    for (var ht = 0; ht < 5; ht++)
                        for (var ot = 0; ot < 5; ot++) pt[ht + 5 * ot] = ot + (2 * ht + 3 * ot) % 5 * 5;
                    for (var Pt = 1, gt = 0; gt < 24; gt++) {
                        for (var ft = 0, dt = 0, St = 0; St < 7; St++) {
                            if (Pt & 1) {
                                var _t = (1 << St) - 1;
                                _t < 32 ? dt ^= 1 << _t : ft ^= 1 << _t - 32
                            }
                            Pt & 128 ? Pt = Pt << 1 ^ 113 : Pt <<= 1
                        }
                        It[gt] = ut.create(ft, dt)
                    }
                })();
                var At = [];
                (function() {
                    for (var ht = 0; ht < 25; ht++) At[ht] = ut.create()
                })();
                var Ct = lt.SHA3 = st.extend({
                    cfg: st.cfg.extend({
                        outputLength: 512
                    }),
                    _doReset: function() {
                        for (var ht = this._state = [], ot = 0; ot < 25; ot++) ht[ot] = new ut.init;
                        this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32
                    },
                    _doProcessBlock: function(ht, ot) {
                        for (var ct = this._state, Et = this.blockSize / 2, Dt = 0; Dt < Et; Dt++) {
                            var Pt = ht[ot + 2 * Dt],
                                gt = ht[ot + 2 * Dt + 1];
                            Pt = (Pt << 8 | Pt >>> 24) & 16711935 | (Pt << 24 | Pt >>> 8) & 4278255360, gt = (gt << 8 | gt >>> 24) & 16711935 | (gt << 24 | gt >>> 8) & 4278255360;
                            var ft = ct[Dt];
                            ft.high ^= gt, ft.low ^= Pt
                        }
                        for (var dt = 0; dt < 24; dt++) {
                            for (var St = 0; St < 5; St++) {
                                for (var _t = 0, vt = 0, mt = 0; mt < 5; mt++) {
                                    var ft = ct[St + 5 * mt];
                                    _t ^= ft.high, vt ^= ft.low
                                }
                                var xt = At[St];
                                xt.high = _t, xt.low = vt
                            }
                            for (var St = 0; St < 5; St++)
                                for (var yt = At[(St + 4) % 5], Tt = At[(St + 1) % 5], Ft = Tt.high, wt = Tt.low, _t = yt.high ^ (Ft << 1 | wt >>> 31), vt = yt.low ^ (wt << 1 | Ft >>> 31), mt = 0; mt < 5; mt++) {
                                    var ft = ct[St + 5 * mt];
                                    ft.high ^= _t, ft.low ^= vt
                                }
                            for (var kt = 1; kt < 25; kt++) {
                                var _t, vt, ft = ct[kt],
                                    Ot = ft.high,
                                    Rt = ft.low,
                                    Lt = bt[kt];
                                Lt < 32 ? (_t = Ot << Lt | Rt >>> 32 - Lt, vt = Rt << Lt | Ot >>> 32 - Lt) : (_t = Rt << Lt - 32 | Ot >>> 64 - Lt, vt = Ot << Lt - 32 | Rt >>> 64 - Lt);
                                var Bt = At[pt[kt]];
                                Bt.high = _t, Bt.low = vt
                            }
                            var Nt = At[0],
                                $t = ct[0];
                            Nt.high = $t.high, Nt.low = $t.low;
                            for (var St = 0; St < 5; St++)
                                for (var mt = 0; mt < 5; mt++) {
                                    var kt = St + 5 * mt,
                                        ft = ct[kt],
                                        jt = At[kt],
                                        Ut = At[(St + 1) % 5 + 5 * mt],
                                        Ht = At[(St + 2) % 5 + 5 * mt];
                                    ft.high = jt.high ^ ~Ut.high & Ht.high, ft.low = jt.low ^ ~Ut.low & Ht.low
                                }
                            var ft = ct[0],
                                Wt = It[dt];
                            ft.high ^= Wt.high, ft.low ^= Wt.low
                        }
                    },
                    _doFinalize: function() {
                        var ht = this._data,
                            ot = ht.words;
                        this._nDataBytes * 8;
                        var ct = ht.sigBytes * 8,
                            Et = this.blockSize * 32;
                        ot[ct >>> 5] |= 1 << 24 - ct % 32, ot[(tt.ceil((ct + 1) / Et) * Et >>> 5) - 1] |= 128, ht.sigBytes = ot.length * 4, this._process();
                        for (var Dt = this._state, Pt = this.cfg.outputLength / 8, gt = Pt / 8, ft = [], dt = 0; dt < gt; dt++) {
                            var St = Dt[dt],
                                _t = St.high,
                                vt = St.low;
                            _t = (_t << 8 | _t >>> 24) & 16711935 | (_t << 24 | _t >>> 8) & 4278255360, vt = (vt << 8 | vt >>> 24) & 16711935 | (vt << 24 | vt >>> 8) & 4278255360, ft.push(vt), ft.push(_t)
                        }
                        return new at.init(ft, Pt)
                    },
                    clone: function() {
                        for (var ht = st.clone.call(this), ot = ht._state = this._state.slice(0), ct = 0; ct < 25; ct++) ot[ct] = ot[ct].clone();
                        return ht
                    }
                });
                rt.SHA3 = st._createHelper(Ct), rt.HmacSHA3 = st._createHmacHelper(Ct)
            }(Math), et.SHA3
        })
    }(sha3)), sha3.exports
}
var ripemd160 = {
        exports: {}
    },
    hasRequiredRipemd160;

function requireRipemd160() {
    return hasRequiredRipemd160 || (hasRequiredRipemd160 = 1, function(_, _e) {
        (function(et, tt) {
            _.exports = tt(requireCore())
        })(commonjsGlobal$1, function(et) {
            return function(tt) {
                var rt = et,
                    nt = rt.lib,
                    at = nt.WordArray,
                    st = nt.Hasher,
                    it = rt.algo,
                    ut = at.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]),
                    lt = at.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]),
                    bt = at.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]),
                    pt = at.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]),
                    It = at.create([0, 1518500249, 1859775393, 2400959708, 2840853838]),
                    At = at.create([1352829926, 1548603684, 1836072691, 2053994217, 0]),
                    Ct = it.RIPEMD160 = st.extend({
                        _doReset: function() {
                            this._hash = at.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
                        },
                        _doProcessBlock: function(gt, ft) {
                            for (var dt = 0; dt < 16; dt++) {
                                var St = ft + dt,
                                    _t = gt[St];
                                gt[St] = (_t << 8 | _t >>> 24) & 16711935 | (_t << 24 | _t >>> 8) & 4278255360
                            }
                            var vt = this._hash.words,
                                mt = It.words,
                                xt = At.words,
                                yt = ut.words,
                                Tt = lt.words,
                                Ft = bt.words,
                                wt = pt.words,
                                kt, Ot, Rt, Lt, Bt, Nt, $t, jt, Ut, Ht;
                            Nt = kt = vt[0], $t = Ot = vt[1], jt = Rt = vt[2], Ut = Lt = vt[3], Ht = Bt = vt[4];
                            for (var Wt, dt = 0; dt < 80; dt += 1) Wt = kt + gt[ft + yt[dt]] | 0, dt < 16 ? Wt += ht(Ot, Rt, Lt) + mt[0] : dt < 32 ? Wt += ot(Ot, Rt, Lt) + mt[1] : dt < 48 ? Wt += ct(Ot, Rt, Lt) + mt[2] : dt < 64 ? Wt += Et(Ot, Rt, Lt) + mt[3] : Wt += Dt(Ot, Rt, Lt) + mt[4], Wt = Wt | 0, Wt = Pt(Wt, Ft[dt]), Wt = Wt + Bt | 0, kt = Bt, Bt = Lt, Lt = Pt(Rt, 10), Rt = Ot, Ot = Wt, Wt = Nt + gt[ft + Tt[dt]] | 0, dt < 16 ? Wt += Dt($t, jt, Ut) + xt[0] : dt < 32 ? Wt += Et($t, jt, Ut) + xt[1] : dt < 48 ? Wt += ct($t, jt, Ut) + xt[2] : dt < 64 ? Wt += ot($t, jt, Ut) + xt[3] : Wt += ht($t, jt, Ut) + xt[4], Wt = Wt | 0, Wt = Pt(Wt, wt[dt]), Wt = Wt + Ht | 0, Nt = Ht, Ht = Ut, Ut = Pt(jt, 10), jt = $t, $t = Wt;
                            Wt = vt[1] + Rt + Ut | 0, vt[1] = vt[2] + Lt + Ht | 0, vt[2] = vt[3] + Bt + Nt | 0, vt[3] = vt[4] + kt + $t | 0, vt[4] = vt[0] + Ot + jt | 0, vt[0] = Wt
                        },
                        _doFinalize: function() {
                            var gt = this._data,
                                ft = gt.words,
                                dt = this._nDataBytes * 8,
                                St = gt.sigBytes * 8;
                            ft[St >>> 5] |= 128 << 24 - St % 32, ft[(St + 64 >>> 9 << 4) + 14] = (dt << 8 | dt >>> 24) & 16711935 | (dt << 24 | dt >>> 8) & 4278255360, gt.sigBytes = (ft.length + 1) * 4, this._process();
                            for (var _t = this._hash, vt = _t.words, mt = 0; mt < 5; mt++) {
                                var xt = vt[mt];
                                vt[mt] = (xt << 8 | xt >>> 24) & 16711935 | (xt << 24 | xt >>> 8) & 4278255360
                            }
                            return _t
                        },
                        clone: function() {
                            var gt = st.clone.call(this);
                            return gt._hash = this._hash.clone(), gt
                        }
                    });

                function ht(gt, ft, dt) {
                    return gt ^ ft ^ dt
                }

                function ot(gt, ft, dt) {
                    return gt & ft | ~gt & dt
                }

                function ct(gt, ft, dt) {
                    return (gt | ~ft) ^ dt
                }

                function Et(gt, ft, dt) {
                    return gt & dt | ft & ~dt
                }

                function Dt(gt, ft, dt) {
                    return gt ^ (ft | ~dt)
                }

                function Pt(gt, ft) {
                    return gt << ft | gt >>> 32 - ft
                }
                rt.RIPEMD160 = st._createHelper(Ct), rt.HmacRIPEMD160 = st._createHmacHelper(Ct)
            }(), et.RIPEMD160
        })
    }(ripemd160)), ripemd160.exports
}
var hmac = {
        exports: {}
    },
    hasRequiredHmac;

function requireHmac() {
    return hasRequiredHmac || (hasRequiredHmac = 1, function(_, _e) {
        (function(et, tt) {
            _.exports = tt(requireCore())
        })(commonjsGlobal$1, function(et) {
            (function() {
                var tt = et,
                    rt = tt.lib,
                    nt = rt.Base,
                    at = tt.enc,
                    st = at.Utf8,
                    it = tt.algo;
                it.HMAC = nt.extend({
                    init: function(ut, lt) {
                        ut = this._hasher = new ut.init, typeof lt == "string" && (lt = st.parse(lt));
                        var bt = ut.blockSize,
                            pt = bt * 4;
                        lt.sigBytes > pt && (lt = ut.finalize(lt)), lt.clamp();
                        for (var It = this._oKey = lt.clone(), At = this._iKey = lt.clone(), Ct = It.words, ht = At.words, ot = 0; ot < bt; ot++) Ct[ot] ^= 1549556828, ht[ot] ^= 909522486;
                        It.sigBytes = At.sigBytes = pt, this.reset()
                    },
                    reset: function() {
                        var ut = this._hasher;
                        ut.reset(), ut.update(this._iKey)
                    },
                    update: function(ut) {
                        return this._hasher.update(ut), this
                    },
                    finalize: function(ut) {
                        var lt = this._hasher,
                            bt = lt.finalize(ut);
                        lt.reset();
                        var pt = lt.finalize(this._oKey.clone().concat(bt));
                        return pt
                    }
                })
            })()
        })
    }(hmac)), hmac.exports
}
var pbkdf2 = {
        exports: {}
    },
    hasRequiredPbkdf2;

function requirePbkdf2() {
    return hasRequiredPbkdf2 || (hasRequiredPbkdf2 = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireSha1(), requireHmac())
        })(commonjsGlobal$1, function(et) {
            return function() {
                var tt = et,
                    rt = tt.lib,
                    nt = rt.Base,
                    at = rt.WordArray,
                    st = tt.algo,
                    it = st.SHA1,
                    ut = st.HMAC,
                    lt = st.PBKDF2 = nt.extend({
                        cfg: nt.extend({
                            keySize: 128 / 32,
                            hasher: it,
                            iterations: 1
                        }),
                        init: function(bt) {
                            this.cfg = this.cfg.extend(bt)
                        },
                        compute: function(bt, pt) {
                            for (var It = this.cfg, At = ut.create(It.hasher, bt), Ct = at.create(), ht = at.create([1]), ot = Ct.words, ct = ht.words, Et = It.keySize, Dt = It.iterations; ot.length < Et;) {
                                var Pt = At.update(pt).finalize(ht);
                                At.reset();
                                for (var gt = Pt.words, ft = gt.length, dt = Pt, St = 1; St < Dt; St++) {
                                    dt = At.finalize(dt), At.reset();
                                    for (var _t = dt.words, vt = 0; vt < ft; vt++) gt[vt] ^= _t[vt]
                                }
                                Ct.concat(Pt), ct[0]++
                            }
                            return Ct.sigBytes = Et * 4, Ct
                        }
                    });
                tt.PBKDF2 = function(bt, pt, It) {
                    return lt.create(It).compute(bt, pt)
                }
            }(), et.PBKDF2
        })
    }(pbkdf2)), pbkdf2.exports
}
var evpkdf = {
        exports: {}
    },
    hasRequiredEvpkdf;

function requireEvpkdf() {
    return hasRequiredEvpkdf || (hasRequiredEvpkdf = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireSha1(), requireHmac())
        })(commonjsGlobal$1, function(et) {
            return function() {
                var tt = et,
                    rt = tt.lib,
                    nt = rt.Base,
                    at = rt.WordArray,
                    st = tt.algo,
                    it = st.MD5,
                    ut = st.EvpKDF = nt.extend({
                        cfg: nt.extend({
                            keySize: 128 / 32,
                            hasher: it,
                            iterations: 1
                        }),
                        init: function(lt) {
                            this.cfg = this.cfg.extend(lt)
                        },
                        compute: function(lt, bt) {
                            for (var pt, It = this.cfg, At = It.hasher.create(), Ct = at.create(), ht = Ct.words, ot = It.keySize, ct = It.iterations; ht.length < ot;) {
                                pt && At.update(pt), pt = At.update(lt).finalize(bt), At.reset();
                                for (var Et = 1; Et < ct; Et++) pt = At.finalize(pt), At.reset();
                                Ct.concat(pt)
                            }
                            return Ct.sigBytes = ot * 4, Ct
                        }
                    });
                tt.EvpKDF = function(lt, bt, pt) {
                    return ut.create(pt).compute(lt, bt)
                }
            }(), et.EvpKDF
        })
    }(evpkdf)), evpkdf.exports
}
var cipherCore = {
        exports: {}
    },
    hasRequiredCipherCore;

function requireCipherCore() {
    return hasRequiredCipherCore || (hasRequiredCipherCore = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireEvpkdf())
        })(commonjsGlobal$1, function(et) {
            et.lib.Cipher || function(tt) {
                var rt = et,
                    nt = rt.lib,
                    at = nt.Base,
                    st = nt.WordArray,
                    it = nt.BufferedBlockAlgorithm,
                    ut = rt.enc;
                ut.Utf8;
                var lt = ut.Base64,
                    bt = rt.algo,
                    pt = bt.EvpKDF,
                    It = nt.Cipher = it.extend({
                        cfg: at.extend(),
                        createEncryptor: function(_t, vt) {
                            return this.create(this._ENC_XFORM_MODE, _t, vt)
                        },
                        createDecryptor: function(_t, vt) {
                            return this.create(this._DEC_XFORM_MODE, _t, vt)
                        },
                        init: function(_t, vt, mt) {
                            this.cfg = this.cfg.extend(mt), this._xformMode = _t, this._key = vt, this.reset()
                        },
                        reset: function() {
                            it.reset.call(this), this._doReset()
                        },
                        process: function(_t) {
                            return this._append(_t), this._process()
                        },
                        finalize: function(_t) {
                            _t && this._append(_t);
                            var vt = this._doFinalize();
                            return vt
                        },
                        keySize: 128 / 32,
                        ivSize: 128 / 32,
                        _ENC_XFORM_MODE: 1,
                        _DEC_XFORM_MODE: 2,
                        _createHelper: function() {
                            function _t(vt) {
                                return typeof vt == "string" ? St : gt
                            }
                            return function(vt) {
                                return {
                                    encrypt: function(mt, xt, yt) {
                                        return _t(xt).encrypt(vt, mt, xt, yt)
                                    },
                                    decrypt: function(mt, xt, yt) {
                                        return _t(xt).decrypt(vt, mt, xt, yt)
                                    }
                                }
                            }
                        }()
                    });
                nt.StreamCipher = It.extend({
                    _doFinalize: function() {
                        var _t = this._process(!0);
                        return _t
                    },
                    blockSize: 1
                });
                var At = rt.mode = {},
                    Ct = nt.BlockCipherMode = at.extend({
                        createEncryptor: function(_t, vt) {
                            return this.Encryptor.create(_t, vt)
                        },
                        createDecryptor: function(_t, vt) {
                            return this.Decryptor.create(_t, vt)
                        },
                        init: function(_t, vt) {
                            this._cipher = _t, this._iv = vt
                        }
                    }),
                    ht = At.CBC = function() {
                        var _t = Ct.extend();
                        _t.Encryptor = _t.extend({
                            processBlock: function(mt, xt) {
                                var yt = this._cipher,
                                    Tt = yt.blockSize;
                                vt.call(this, mt, xt, Tt), yt.encryptBlock(mt, xt), this._prevBlock = mt.slice(xt, xt + Tt)
                            }
                        }), _t.Decryptor = _t.extend({
                            processBlock: function(mt, xt) {
                                var yt = this._cipher,
                                    Tt = yt.blockSize,
                                    Ft = mt.slice(xt, xt + Tt);
                                yt.decryptBlock(mt, xt), vt.call(this, mt, xt, Tt), this._prevBlock = Ft
                            }
                        });

                        function vt(mt, xt, yt) {
                            var Tt, Ft = this._iv;
                            Ft ? (Tt = Ft, this._iv = tt) : Tt = this._prevBlock;
                            for (var wt = 0; wt < yt; wt++) mt[xt + wt] ^= Tt[wt]
                        }
                        return _t
                    }(),
                    ot = rt.pad = {},
                    ct = ot.Pkcs7 = {
                        pad: function(_t, vt) {
                            for (var mt = vt * 4, xt = mt - _t.sigBytes % mt, yt = xt << 24 | xt << 16 | xt << 8 | xt, Tt = [], Ft = 0; Ft < xt; Ft += 4) Tt.push(yt);
                            var wt = st.create(Tt, xt);
                            _t.concat(wt)
                        },
                        unpad: function(_t) {
                            var vt = _t.words[_t.sigBytes - 1 >>> 2] & 255;
                            _t.sigBytes -= vt
                        }
                    };
                nt.BlockCipher = It.extend({
                    cfg: It.cfg.extend({
                        mode: ht,
                        padding: ct
                    }),
                    reset: function() {
                        var _t;
                        It.reset.call(this);
                        var vt = this.cfg,
                            mt = vt.iv,
                            xt = vt.mode;
                        this._xformMode == this._ENC_XFORM_MODE ? _t = xt.createEncryptor : (_t = xt.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == _t ? this._mode.init(this, mt && mt.words) : (this._mode = _t.call(xt, this, mt && mt.words), this._mode.__creator = _t)
                    },
                    _doProcessBlock: function(_t, vt) {
                        this._mode.processBlock(_t, vt)
                    },
                    _doFinalize: function() {
                        var _t, vt = this.cfg.padding;
                        return this._xformMode == this._ENC_XFORM_MODE ? (vt.pad(this._data, this.blockSize), _t = this._process(!0)) : (_t = this._process(!0), vt.unpad(_t)), _t
                    },
                    blockSize: 128 / 32
                });
                var Et = nt.CipherParams = at.extend({
                        init: function(_t) {
                            this.mixIn(_t)
                        },
                        toString: function(_t) {
                            return (_t || this.formatter).stringify(this)
                        }
                    }),
                    Dt = rt.format = {},
                    Pt = Dt.OpenSSL = {
                        stringify: function(_t) {
                            var vt, mt = _t.ciphertext,
                                xt = _t.salt;
                            return xt ? vt = st.create([1398893684, 1701076831]).concat(xt).concat(mt) : vt = mt, vt.toString(lt)
                        },
                        parse: function(_t) {
                            var vt, mt = lt.parse(_t),
                                xt = mt.words;
                            return xt[0] == 1398893684 && xt[1] == 1701076831 && (vt = st.create(xt.slice(2, 4)), xt.splice(0, 4), mt.sigBytes -= 16), Et.create({
                                ciphertext: mt,
                                salt: vt
                            })
                        }
                    },
                    gt = nt.SerializableCipher = at.extend({
                        cfg: at.extend({
                            format: Pt
                        }),
                        encrypt: function(_t, vt, mt, xt) {
                            xt = this.cfg.extend(xt);
                            var yt = _t.createEncryptor(mt, xt),
                                Tt = yt.finalize(vt),
                                Ft = yt.cfg;
                            return Et.create({
                                ciphertext: Tt,
                                key: mt,
                                iv: Ft.iv,
                                algorithm: _t,
                                mode: Ft.mode,
                                padding: Ft.padding,
                                blockSize: _t.blockSize,
                                formatter: xt.format
                            })
                        },
                        decrypt: function(_t, vt, mt, xt) {
                            xt = this.cfg.extend(xt), vt = this._parse(vt, xt.format);
                            var yt = _t.createDecryptor(mt, xt).finalize(vt.ciphertext);
                            return yt
                        },
                        _parse: function(_t, vt) {
                            return typeof _t == "string" ? vt.parse(_t, this) : _t
                        }
                    }),
                    ft = rt.kdf = {},
                    dt = ft.OpenSSL = {
                        execute: function(_t, vt, mt, xt) {
                            xt || (xt = st.random(64 / 8));
                            var yt = pt.create({
                                    keySize: vt + mt
                                }).compute(_t, xt),
                                Tt = st.create(yt.words.slice(vt), mt * 4);
                            return yt.sigBytes = vt * 4, Et.create({
                                key: yt,
                                iv: Tt,
                                salt: xt
                            })
                        }
                    },
                    St = nt.PasswordBasedCipher = gt.extend({
                        cfg: gt.cfg.extend({
                            kdf: dt
                        }),
                        encrypt: function(_t, vt, mt, xt) {
                            xt = this.cfg.extend(xt);
                            var yt = xt.kdf.execute(mt, _t.keySize, _t.ivSize);
                            xt.iv = yt.iv;
                            var Tt = gt.encrypt.call(this, _t, vt, yt.key, xt);
                            return Tt.mixIn(yt), Tt
                        },
                        decrypt: function(_t, vt, mt, xt) {
                            xt = this.cfg.extend(xt), vt = this._parse(vt, xt.format);
                            var yt = xt.kdf.execute(mt, _t.keySize, _t.ivSize, vt.salt);
                            xt.iv = yt.iv;
                            var Tt = gt.decrypt.call(this, _t, vt, yt.key, xt);
                            return Tt
                        }
                    })
            }()
        })
    }(cipherCore)), cipherCore.exports
}
var modeCfb = {
        exports: {}
    },
    hasRequiredModeCfb;

function requireModeCfb() {
    return hasRequiredModeCfb || (hasRequiredModeCfb = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireCipherCore())
        })(commonjsGlobal$1, function(et) {
            return et.mode.CFB = function() {
                var tt = et.lib.BlockCipherMode.extend();
                tt.Encryptor = tt.extend({
                    processBlock: function(nt, at) {
                        var st = this._cipher,
                            it = st.blockSize;
                        rt.call(this, nt, at, it, st), this._prevBlock = nt.slice(at, at + it)
                    }
                }), tt.Decryptor = tt.extend({
                    processBlock: function(nt, at) {
                        var st = this._cipher,
                            it = st.blockSize,
                            ut = nt.slice(at, at + it);
                        rt.call(this, nt, at, it, st), this._prevBlock = ut
                    }
                });

                function rt(nt, at, st, it) {
                    var ut, lt = this._iv;
                    lt ? (ut = lt.slice(0), this._iv = void 0) : ut = this._prevBlock, it.encryptBlock(ut, 0);
                    for (var bt = 0; bt < st; bt++) nt[at + bt] ^= ut[bt]
                }
                return tt
            }(), et.mode.CFB
        })
    }(modeCfb)), modeCfb.exports
}
var modeCtr = {
        exports: {}
    },
    hasRequiredModeCtr;

function requireModeCtr() {
    return hasRequiredModeCtr || (hasRequiredModeCtr = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireCipherCore())
        })(commonjsGlobal$1, function(et) {
            return et.mode.CTR = function() {
                var tt = et.lib.BlockCipherMode.extend(),
                    rt = tt.Encryptor = tt.extend({
                        processBlock: function(nt, at) {
                            var st = this._cipher,
                                it = st.blockSize,
                                ut = this._iv,
                                lt = this._counter;
                            ut && (lt = this._counter = ut.slice(0), this._iv = void 0);
                            var bt = lt.slice(0);
                            st.encryptBlock(bt, 0), lt[it - 1] = lt[it - 1] + 1 | 0;
                            for (var pt = 0; pt < it; pt++) nt[at + pt] ^= bt[pt]
                        }
                    });
                return tt.Decryptor = rt, tt
            }(), et.mode.CTR
        })
    }(modeCtr)), modeCtr.exports
}
var modeCtrGladman = {
        exports: {}
    },
    hasRequiredModeCtrGladman;

function requireModeCtrGladman() {
    return hasRequiredModeCtrGladman || (hasRequiredModeCtrGladman = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireCipherCore())
        })(commonjsGlobal$1, function(et) {
            return et.mode.CTRGladman = function() {
                var tt = et.lib.BlockCipherMode.extend();

                function rt(st) {
                    if ((st >> 24 & 255) === 255) {
                        var it = st >> 16 & 255,
                            ut = st >> 8 & 255,
                            lt = st & 255;
                        it === 255 ? (it = 0, ut === 255 ? (ut = 0, lt === 255 ? lt = 0 : ++lt) : ++ut) : ++it, st = 0, st += it << 16, st += ut << 8, st += lt
                    } else st += 1 << 24;
                    return st
                }

                function nt(st) {
                    return (st[0] = rt(st[0])) === 0 && (st[1] = rt(st[1])), st
                }
                var at = tt.Encryptor = tt.extend({
                    processBlock: function(st, it) {
                        var ut = this._cipher,
                            lt = ut.blockSize,
                            bt = this._iv,
                            pt = this._counter;
                        bt && (pt = this._counter = bt.slice(0), this._iv = void 0), nt(pt);
                        var It = pt.slice(0);
                        ut.encryptBlock(It, 0);
                        for (var At = 0; At < lt; At++) st[it + At] ^= It[At]
                    }
                });
                return tt.Decryptor = at, tt
            }(), et.mode.CTRGladman
        })
    }(modeCtrGladman)), modeCtrGladman.exports
}
var modeOfb = {
        exports: {}
    },
    hasRequiredModeOfb;

function requireModeOfb() {
    return hasRequiredModeOfb || (hasRequiredModeOfb = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireCipherCore())
        })(commonjsGlobal$1, function(et) {
            return et.mode.OFB = function() {
                var tt = et.lib.BlockCipherMode.extend(),
                    rt = tt.Encryptor = tt.extend({
                        processBlock: function(nt, at) {
                            var st = this._cipher,
                                it = st.blockSize,
                                ut = this._iv,
                                lt = this._keystream;
                            ut && (lt = this._keystream = ut.slice(0), this._iv = void 0), st.encryptBlock(lt, 0);
                            for (var bt = 0; bt < it; bt++) nt[at + bt] ^= lt[bt]
                        }
                    });
                return tt.Decryptor = rt, tt
            }(), et.mode.OFB
        })
    }(modeOfb)), modeOfb.exports
}
var modeEcb = {
        exports: {}
    },
    hasRequiredModeEcb;

function requireModeEcb() {
    return hasRequiredModeEcb || (hasRequiredModeEcb = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireCipherCore())
        })(commonjsGlobal$1, function(et) {
            return et.mode.ECB = function() {
                var tt = et.lib.BlockCipherMode.extend();
                return tt.Encryptor = tt.extend({
                    processBlock: function(rt, nt) {
                        this._cipher.encryptBlock(rt, nt)
                    }
                }), tt.Decryptor = tt.extend({
                    processBlock: function(rt, nt) {
                        this._cipher.decryptBlock(rt, nt)
                    }
                }), tt
            }(), et.mode.ECB
        })
    }(modeEcb)), modeEcb.exports
}
var padAnsix923 = {
        exports: {}
    },
    hasRequiredPadAnsix923;

function requirePadAnsix923() {
    return hasRequiredPadAnsix923 || (hasRequiredPadAnsix923 = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireCipherCore())
        })(commonjsGlobal$1, function(et) {
            return et.pad.AnsiX923 = {
                pad: function(tt, rt) {
                    var nt = tt.sigBytes,
                        at = rt * 4,
                        st = at - nt % at,
                        it = nt + st - 1;
                    tt.clamp(), tt.words[it >>> 2] |= st << 24 - it % 4 * 8, tt.sigBytes += st
                },
                unpad: function(tt) {
                    var rt = tt.words[tt.sigBytes - 1 >>> 2] & 255;
                    tt.sigBytes -= rt
                }
            }, et.pad.Ansix923
        })
    }(padAnsix923)), padAnsix923.exports
}
var padIso10126 = {
        exports: {}
    },
    hasRequiredPadIso10126;

function requirePadIso10126() {
    return hasRequiredPadIso10126 || (hasRequiredPadIso10126 = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireCipherCore())
        })(commonjsGlobal$1, function(et) {
            return et.pad.Iso10126 = {
                pad: function(tt, rt) {
                    var nt = rt * 4,
                        at = nt - tt.sigBytes % nt;
                    tt.concat(et.lib.WordArray.random(at - 1)).concat(et.lib.WordArray.create([at << 24], 1))
                },
                unpad: function(tt) {
                    var rt = tt.words[tt.sigBytes - 1 >>> 2] & 255;
                    tt.sigBytes -= rt
                }
            }, et.pad.Iso10126
        })
    }(padIso10126)), padIso10126.exports
}
var padIso97971 = {
        exports: {}
    },
    hasRequiredPadIso97971;

function requirePadIso97971() {
    return hasRequiredPadIso97971 || (hasRequiredPadIso97971 = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireCipherCore())
        })(commonjsGlobal$1, function(et) {
            return et.pad.Iso97971 = {
                pad: function(tt, rt) {
                    tt.concat(et.lib.WordArray.create([2147483648], 1)), et.pad.ZeroPadding.pad(tt, rt)
                },
                unpad: function(tt) {
                    et.pad.ZeroPadding.unpad(tt), tt.sigBytes--
                }
            }, et.pad.Iso97971
        })
    }(padIso97971)), padIso97971.exports
}
var padZeropadding = {
        exports: {}
    },
    hasRequiredPadZeropadding;

function requirePadZeropadding() {
    return hasRequiredPadZeropadding || (hasRequiredPadZeropadding = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireCipherCore())
        })(commonjsGlobal$1, function(et) {
            return et.pad.ZeroPadding = {
                pad: function(tt, rt) {
                    var nt = rt * 4;
                    tt.clamp(), tt.sigBytes += nt - (tt.sigBytes % nt || nt)
                },
                unpad: function(tt) {
                    for (var rt = tt.words, nt = tt.sigBytes - 1, nt = tt.sigBytes - 1; nt >= 0; nt--)
                        if (rt[nt >>> 2] >>> 24 - nt % 4 * 8 & 255) {
                            tt.sigBytes = nt + 1;
                            break
                        }
                }
            }, et.pad.ZeroPadding
        })
    }(padZeropadding)), padZeropadding.exports
}
var padNopadding = {
        exports: {}
    },
    hasRequiredPadNopadding;

function requirePadNopadding() {
    return hasRequiredPadNopadding || (hasRequiredPadNopadding = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireCipherCore())
        })(commonjsGlobal$1, function(et) {
            return et.pad.NoPadding = {
                pad: function() {},
                unpad: function() {}
            }, et.pad.NoPadding
        })
    }(padNopadding)), padNopadding.exports
}
var formatHex = {
        exports: {}
    },
    hasRequiredFormatHex;

function requireFormatHex() {
    return hasRequiredFormatHex || (hasRequiredFormatHex = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireCipherCore())
        })(commonjsGlobal$1, function(et) {
            return function(tt) {
                var rt = et,
                    nt = rt.lib,
                    at = nt.CipherParams,
                    st = rt.enc,
                    it = st.Hex,
                    ut = rt.format;
                ut.Hex = {
                    stringify: function(lt) {
                        return lt.ciphertext.toString(it)
                    },
                    parse: function(lt) {
                        var bt = it.parse(lt);
                        return at.create({
                            ciphertext: bt
                        })
                    }
                }
            }(), et.format.Hex
        })
    }(formatHex)), formatHex.exports
}
var aes = {
        exports: {}
    },
    hasRequiredAes;

function requireAes() {
    return hasRequiredAes || (hasRequiredAes = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore())
        })(commonjsGlobal$1, function(et) {
            return function() {
                var tt = et,
                    rt = tt.lib,
                    nt = rt.BlockCipher,
                    at = tt.algo,
                    st = [],
                    it = [],
                    ut = [],
                    lt = [],
                    bt = [],
                    pt = [],
                    It = [],
                    At = [],
                    Ct = [],
                    ht = [];
                (function() {
                    for (var Et = [], Dt = 0; Dt < 256; Dt++) Dt < 128 ? Et[Dt] = Dt << 1 : Et[Dt] = Dt << 1 ^ 283;
                    for (var Pt = 0, gt = 0, Dt = 0; Dt < 256; Dt++) {
                        var ft = gt ^ gt << 1 ^ gt << 2 ^ gt << 3 ^ gt << 4;
                        ft = ft >>> 8 ^ ft & 255 ^ 99, st[Pt] = ft, it[ft] = Pt;
                        var dt = Et[Pt],
                            St = Et[dt],
                            _t = Et[St],
                            vt = Et[ft] * 257 ^ ft * 16843008;
                        ut[Pt] = vt << 24 | vt >>> 8, lt[Pt] = vt << 16 | vt >>> 16, bt[Pt] = vt << 8 | vt >>> 24, pt[Pt] = vt;
                        var vt = _t * 16843009 ^ St * 65537 ^ dt * 257 ^ Pt * 16843008;
                        It[ft] = vt << 24 | vt >>> 8, At[ft] = vt << 16 | vt >>> 16, Ct[ft] = vt << 8 | vt >>> 24, ht[ft] = vt, Pt ? (Pt = dt ^ Et[Et[Et[_t ^ dt]]], gt ^= Et[Et[gt]]) : Pt = gt = 1
                    }
                })();
                var ot = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
                    ct = at.AES = nt.extend({
                        _doReset: function() {
                            var Et;
                            if (!(this._nRounds && this._keyPriorReset === this._key)) {
                                for (var Dt = this._keyPriorReset = this._key, Pt = Dt.words, gt = Dt.sigBytes / 4, ft = this._nRounds = gt + 6, dt = (ft + 1) * 4, St = this._keySchedule = [], _t = 0; _t < dt; _t++) _t < gt ? St[_t] = Pt[_t] : (Et = St[_t - 1], _t % gt ? gt > 6 && _t % gt == 4 && (Et = st[Et >>> 24] << 24 | st[Et >>> 16 & 255] << 16 | st[Et >>> 8 & 255] << 8 | st[Et & 255]) : (Et = Et << 8 | Et >>> 24, Et = st[Et >>> 24] << 24 | st[Et >>> 16 & 255] << 16 | st[Et >>> 8 & 255] << 8 | st[Et & 255], Et ^= ot[_t / gt | 0] << 24), St[_t] = St[_t - gt] ^ Et);
                                for (var vt = this._invKeySchedule = [], mt = 0; mt < dt; mt++) {
                                    var _t = dt - mt;
                                    if (mt % 4) var Et = St[_t];
                                    else var Et = St[_t - 4];
                                    mt < 4 || _t <= 4 ? vt[mt] = Et : vt[mt] = It[st[Et >>> 24]] ^ At[st[Et >>> 16 & 255]] ^ Ct[st[Et >>> 8 & 255]] ^ ht[st[Et & 255]]
                                }
                            }
                        },
                        encryptBlock: function(Et, Dt) {
                            this._doCryptBlock(Et, Dt, this._keySchedule, ut, lt, bt, pt, st)
                        },
                        decryptBlock: function(Et, Dt) {
                            var Pt = Et[Dt + 1];
                            Et[Dt + 1] = Et[Dt + 3], Et[Dt + 3] = Pt, this._doCryptBlock(Et, Dt, this._invKeySchedule, It, At, Ct, ht, it);
                            var Pt = Et[Dt + 1];
                            Et[Dt + 1] = Et[Dt + 3], Et[Dt + 3] = Pt
                        },
                        _doCryptBlock: function(Et, Dt, Pt, gt, ft, dt, St, _t) {
                            for (var vt = this._nRounds, mt = Et[Dt] ^ Pt[0], xt = Et[Dt + 1] ^ Pt[1], yt = Et[Dt + 2] ^ Pt[2], Tt = Et[Dt + 3] ^ Pt[3], Ft = 4, wt = 1; wt < vt; wt++) {
                                var kt = gt[mt >>> 24] ^ ft[xt >>> 16 & 255] ^ dt[yt >>> 8 & 255] ^ St[Tt & 255] ^ Pt[Ft++],
                                    Ot = gt[xt >>> 24] ^ ft[yt >>> 16 & 255] ^ dt[Tt >>> 8 & 255] ^ St[mt & 255] ^ Pt[Ft++],
                                    Rt = gt[yt >>> 24] ^ ft[Tt >>> 16 & 255] ^ dt[mt >>> 8 & 255] ^ St[xt & 255] ^ Pt[Ft++],
                                    Lt = gt[Tt >>> 24] ^ ft[mt >>> 16 & 255] ^ dt[xt >>> 8 & 255] ^ St[yt & 255] ^ Pt[Ft++];
                                mt = kt, xt = Ot, yt = Rt, Tt = Lt
                            }
                            var kt = (_t[mt >>> 24] << 24 | _t[xt >>> 16 & 255] << 16 | _t[yt >>> 8 & 255] << 8 | _t[Tt & 255]) ^ Pt[Ft++],
                                Ot = (_t[xt >>> 24] << 24 | _t[yt >>> 16 & 255] << 16 | _t[Tt >>> 8 & 255] << 8 | _t[mt & 255]) ^ Pt[Ft++],
                                Rt = (_t[yt >>> 24] << 24 | _t[Tt >>> 16 & 255] << 16 | _t[mt >>> 8 & 255] << 8 | _t[xt & 255]) ^ Pt[Ft++],
                                Lt = (_t[Tt >>> 24] << 24 | _t[mt >>> 16 & 255] << 16 | _t[xt >>> 8 & 255] << 8 | _t[yt & 255]) ^ Pt[Ft++];
                            Et[Dt] = kt, Et[Dt + 1] = Ot, Et[Dt + 2] = Rt, Et[Dt + 3] = Lt
                        },
                        keySize: 256 / 32
                    });
                tt.AES = nt._createHelper(ct)
            }(), et.AES
        })
    }(aes)), aes.exports
}
var tripledes = {
        exports: {}
    },
    hasRequiredTripledes;

function requireTripledes() {
    return hasRequiredTripledes || (hasRequiredTripledes = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore())
        })(commonjsGlobal$1, function(et) {
            return function() {
                var tt = et,
                    rt = tt.lib,
                    nt = rt.WordArray,
                    at = rt.BlockCipher,
                    st = tt.algo,
                    it = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4],
                    ut = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32],
                    lt = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28],
                    bt = [{
                        0: 8421888,
                        268435456: 32768,
                        536870912: 8421378,
                        805306368: 2,
                        1073741824: 512,
                        1342177280: 8421890,
                        1610612736: 8389122,
                        1879048192: 8388608,
                        2147483648: 514,
                        2415919104: 8389120,
                        2684354560: 33280,
                        2952790016: 8421376,
                        3221225472: 32770,
                        3489660928: 8388610,
                        3758096384: 0,
                        4026531840: 33282,
                        134217728: 0,
                        402653184: 8421890,
                        671088640: 33282,
                        939524096: 32768,
                        1207959552: 8421888,
                        1476395008: 512,
                        1744830464: 8421378,
                        2013265920: 2,
                        2281701376: 8389120,
                        2550136832: 33280,
                        2818572288: 8421376,
                        3087007744: 8389122,
                        3355443200: 8388610,
                        3623878656: 32770,
                        3892314112: 514,
                        4160749568: 8388608,
                        1: 32768,
                        268435457: 2,
                        536870913: 8421888,
                        805306369: 8388608,
                        1073741825: 8421378,
                        1342177281: 33280,
                        1610612737: 512,
                        1879048193: 8389122,
                        2147483649: 8421890,
                        2415919105: 8421376,
                        2684354561: 8388610,
                        2952790017: 33282,
                        3221225473: 514,
                        3489660929: 8389120,
                        3758096385: 32770,
                        4026531841: 0,
                        134217729: 8421890,
                        402653185: 8421376,
                        671088641: 8388608,
                        939524097: 512,
                        1207959553: 32768,
                        1476395009: 8388610,
                        1744830465: 2,
                        2013265921: 33282,
                        2281701377: 32770,
                        2550136833: 8389122,
                        2818572289: 514,
                        3087007745: 8421888,
                        3355443201: 8389120,
                        3623878657: 0,
                        3892314113: 33280,
                        4160749569: 8421378
                    }, {
                        0: 1074282512,
                        16777216: 16384,
                        33554432: 524288,
                        50331648: 1074266128,
                        67108864: 1073741840,
                        83886080: 1074282496,
                        100663296: 1073758208,
                        117440512: 16,
                        134217728: 540672,
                        150994944: 1073758224,
                        167772160: 1073741824,
                        184549376: 540688,
                        201326592: 524304,
                        218103808: 0,
                        234881024: 16400,
                        251658240: 1074266112,
                        8388608: 1073758208,
                        25165824: 540688,
                        41943040: 16,
                        58720256: 1073758224,
                        75497472: 1074282512,
                        92274688: 1073741824,
                        109051904: 524288,
                        125829120: 1074266128,
                        142606336: 524304,
                        159383552: 0,
                        176160768: 16384,
                        192937984: 1074266112,
                        209715200: 1073741840,
                        226492416: 540672,
                        243269632: 1074282496,
                        260046848: 16400,
                        268435456: 0,
                        285212672: 1074266128,
                        301989888: 1073758224,
                        318767104: 1074282496,
                        335544320: 1074266112,
                        352321536: 16,
                        369098752: 540688,
                        385875968: 16384,
                        402653184: 16400,
                        419430400: 524288,
                        436207616: 524304,
                        452984832: 1073741840,
                        469762048: 540672,
                        486539264: 1073758208,
                        503316480: 1073741824,
                        520093696: 1074282512,
                        276824064: 540688,
                        293601280: 524288,
                        310378496: 1074266112,
                        327155712: 16384,
                        343932928: 1073758208,
                        360710144: 1074282512,
                        377487360: 16,
                        394264576: 1073741824,
                        411041792: 1074282496,
                        427819008: 1073741840,
                        444596224: 1073758224,
                        461373440: 524304,
                        478150656: 0,
                        494927872: 16400,
                        511705088: 1074266128,
                        528482304: 540672
                    }, {
                        0: 260,
                        1048576: 0,
                        2097152: 67109120,
                        3145728: 65796,
                        4194304: 65540,
                        5242880: 67108868,
                        6291456: 67174660,
                        7340032: 67174400,
                        8388608: 67108864,
                        9437184: 67174656,
                        10485760: 65792,
                        11534336: 67174404,
                        12582912: 67109124,
                        13631488: 65536,
                        14680064: 4,
                        15728640: 256,
                        524288: 67174656,
                        1572864: 67174404,
                        2621440: 0,
                        3670016: 67109120,
                        4718592: 67108868,
                        5767168: 65536,
                        6815744: 65540,
                        7864320: 260,
                        8912896: 4,
                        9961472: 256,
                        11010048: 67174400,
                        12058624: 65796,
                        13107200: 65792,
                        14155776: 67109124,
                        15204352: 67174660,
                        16252928: 67108864,
                        16777216: 67174656,
                        17825792: 65540,
                        18874368: 65536,
                        19922944: 67109120,
                        20971520: 256,
                        22020096: 67174660,
                        23068672: 67108868,
                        24117248: 0,
                        25165824: 67109124,
                        26214400: 67108864,
                        27262976: 4,
                        28311552: 65792,
                        29360128: 67174400,
                        30408704: 260,
                        31457280: 65796,
                        32505856: 67174404,
                        17301504: 67108864,
                        18350080: 260,
                        19398656: 67174656,
                        20447232: 0,
                        21495808: 65540,
                        22544384: 67109120,
                        23592960: 256,
                        24641536: 67174404,
                        25690112: 65536,
                        26738688: 67174660,
                        27787264: 65796,
                        28835840: 67108868,
                        29884416: 67109124,
                        30932992: 67174400,
                        31981568: 4,
                        33030144: 65792
                    }, {
                        0: 2151682048,
                        65536: 2147487808,
                        131072: 4198464,
                        196608: 2151677952,
                        262144: 0,
                        327680: 4198400,
                        393216: 2147483712,
                        458752: 4194368,
                        524288: 2147483648,
                        589824: 4194304,
                        655360: 64,
                        720896: 2147487744,
                        786432: 2151678016,
                        851968: 4160,
                        917504: 4096,
                        983040: 2151682112,
                        32768: 2147487808,
                        98304: 64,
                        163840: 2151678016,
                        229376: 2147487744,
                        294912: 4198400,
                        360448: 2151682112,
                        425984: 0,
                        491520: 2151677952,
                        557056: 4096,
                        622592: 2151682048,
                        688128: 4194304,
                        753664: 4160,
                        819200: 2147483648,
                        884736: 4194368,
                        950272: 4198464,
                        1015808: 2147483712,
                        1048576: 4194368,
                        1114112: 4198400,
                        1179648: 2147483712,
                        1245184: 0,
                        1310720: 4160,
                        1376256: 2151678016,
                        1441792: 2151682048,
                        1507328: 2147487808,
                        1572864: 2151682112,
                        1638400: 2147483648,
                        1703936: 2151677952,
                        1769472: 4198464,
                        1835008: 2147487744,
                        1900544: 4194304,
                        1966080: 64,
                        2031616: 4096,
                        1081344: 2151677952,
                        1146880: 2151682112,
                        1212416: 0,
                        1277952: 4198400,
                        1343488: 4194368,
                        1409024: 2147483648,
                        1474560: 2147487808,
                        1540096: 64,
                        1605632: 2147483712,
                        1671168: 4096,
                        1736704: 2147487744,
                        1802240: 2151678016,
                        1867776: 4160,
                        1933312: 2151682048,
                        1998848: 4194304,
                        2064384: 4198464
                    }, {
                        0: 128,
                        4096: 17039360,
                        8192: 262144,
                        12288: 536870912,
                        16384: 537133184,
                        20480: 16777344,
                        24576: 553648256,
                        28672: 262272,
                        32768: 16777216,
                        36864: 537133056,
                        40960: 536871040,
                        45056: 553910400,
                        49152: 553910272,
                        53248: 0,
                        57344: 17039488,
                        61440: 553648128,
                        2048: 17039488,
                        6144: 553648256,
                        10240: 128,
                        14336: 17039360,
                        18432: 262144,
                        22528: 537133184,
                        26624: 553910272,
                        30720: 536870912,
                        34816: 537133056,
                        38912: 0,
                        43008: 553910400,
                        47104: 16777344,
                        51200: 536871040,
                        55296: 553648128,
                        59392: 16777216,
                        63488: 262272,
                        65536: 262144,
                        69632: 128,
                        73728: 536870912,
                        77824: 553648256,
                        81920: 16777344,
                        86016: 553910272,
                        90112: 537133184,
                        94208: 16777216,
                        98304: 553910400,
                        102400: 553648128,
                        106496: 17039360,
                        110592: 537133056,
                        114688: 262272,
                        118784: 536871040,
                        122880: 0,
                        126976: 17039488,
                        67584: 553648256,
                        71680: 16777216,
                        75776: 17039360,
                        79872: 537133184,
                        83968: 536870912,
                        88064: 17039488,
                        92160: 128,
                        96256: 553910272,
                        100352: 262272,
                        104448: 553910400,
                        108544: 0,
                        112640: 553648128,
                        116736: 16777344,
                        120832: 262144,
                        124928: 537133056,
                        129024: 536871040
                    }, {
                        0: 268435464,
                        256: 8192,
                        512: 270532608,
                        768: 270540808,
                        1024: 268443648,
                        1280: 2097152,
                        1536: 2097160,
                        1792: 268435456,
                        2048: 0,
                        2304: 268443656,
                        2560: 2105344,
                        2816: 8,
                        3072: 270532616,
                        3328: 2105352,
                        3584: 8200,
                        3840: 270540800,
                        128: 270532608,
                        384: 270540808,
                        640: 8,
                        896: 2097152,
                        1152: 2105352,
                        1408: 268435464,
                        1664: 268443648,
                        1920: 8200,
                        2176: 2097160,
                        2432: 8192,
                        2688: 268443656,
                        2944: 270532616,
                        3200: 0,
                        3456: 270540800,
                        3712: 2105344,
                        3968: 268435456,
                        4096: 268443648,
                        4352: 270532616,
                        4608: 270540808,
                        4864: 8200,
                        5120: 2097152,
                        5376: 268435456,
                        5632: 268435464,
                        5888: 2105344,
                        6144: 2105352,
                        6400: 0,
                        6656: 8,
                        6912: 270532608,
                        7168: 8192,
                        7424: 268443656,
                        7680: 270540800,
                        7936: 2097160,
                        4224: 8,
                        4480: 2105344,
                        4736: 2097152,
                        4992: 268435464,
                        5248: 268443648,
                        5504: 8200,
                        5760: 270540808,
                        6016: 270532608,
                        6272: 270540800,
                        6528: 270532616,
                        6784: 8192,
                        7040: 2105352,
                        7296: 2097160,
                        7552: 0,
                        7808: 268435456,
                        8064: 268443656
                    }, {
                        0: 1048576,
                        16: 33555457,
                        32: 1024,
                        48: 1049601,
                        64: 34604033,
                        80: 0,
                        96: 1,
                        112: 34603009,
                        128: 33555456,
                        144: 1048577,
                        160: 33554433,
                        176: 34604032,
                        192: 34603008,
                        208: 1025,
                        224: 1049600,
                        240: 33554432,
                        8: 34603009,
                        24: 0,
                        40: 33555457,
                        56: 34604032,
                        72: 1048576,
                        88: 33554433,
                        104: 33554432,
                        120: 1025,
                        136: 1049601,
                        152: 33555456,
                        168: 34603008,
                        184: 1048577,
                        200: 1024,
                        216: 34604033,
                        232: 1,
                        248: 1049600,
                        256: 33554432,
                        272: 1048576,
                        288: 33555457,
                        304: 34603009,
                        320: 1048577,
                        336: 33555456,
                        352: 34604032,
                        368: 1049601,
                        384: 1025,
                        400: 34604033,
                        416: 1049600,
                        432: 1,
                        448: 0,
                        464: 34603008,
                        480: 33554433,
                        496: 1024,
                        264: 1049600,
                        280: 33555457,
                        296: 34603009,
                        312: 1,
                        328: 33554432,
                        344: 1048576,
                        360: 1025,
                        376: 34604032,
                        392: 33554433,
                        408: 34603008,
                        424: 0,
                        440: 34604033,
                        456: 1049601,
                        472: 1024,
                        488: 33555456,
                        504: 1048577
                    }, {
                        0: 134219808,
                        1: 131072,
                        2: 134217728,
                        3: 32,
                        4: 131104,
                        5: 134350880,
                        6: 134350848,
                        7: 2048,
                        8: 134348800,
                        9: 134219776,
                        10: 133120,
                        11: 134348832,
                        12: 2080,
                        13: 0,
                        14: 134217760,
                        15: 133152,
                        2147483648: 2048,
                        2147483649: 134350880,
                        2147483650: 134219808,
                        2147483651: 134217728,
                        2147483652: 134348800,
                        2147483653: 133120,
                        2147483654: 133152,
                        2147483655: 32,
                        2147483656: 134217760,
                        2147483657: 2080,
                        2147483658: 131104,
                        2147483659: 134350848,
                        2147483660: 0,
                        2147483661: 134348832,
                        2147483662: 134219776,
                        2147483663: 131072,
                        16: 133152,
                        17: 134350848,
                        18: 32,
                        19: 2048,
                        20: 134219776,
                        21: 134217760,
                        22: 134348832,
                        23: 131072,
                        24: 0,
                        25: 131104,
                        26: 134348800,
                        27: 134219808,
                        28: 134350880,
                        29: 133120,
                        30: 2080,
                        31: 134217728,
                        2147483664: 131072,
                        2147483665: 2048,
                        2147483666: 134348832,
                        2147483667: 133152,
                        2147483668: 32,
                        2147483669: 134348800,
                        2147483670: 134217728,
                        2147483671: 134219808,
                        2147483672: 134350880,
                        2147483673: 134217760,
                        2147483674: 134219776,
                        2147483675: 0,
                        2147483676: 133120,
                        2147483677: 2080,
                        2147483678: 131104,
                        2147483679: 134350848
                    }],
                    pt = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679],
                    It = st.DES = at.extend({
                        _doReset: function() {
                            for (var ot = this._key, ct = ot.words, Et = [], Dt = 0; Dt < 56; Dt++) {
                                var Pt = it[Dt] - 1;
                                Et[Dt] = ct[Pt >>> 5] >>> 31 - Pt % 32 & 1
                            }
                            for (var gt = this._subKeys = [], ft = 0; ft < 16; ft++) {
                                for (var dt = gt[ft] = [], St = lt[ft], Dt = 0; Dt < 24; Dt++) dt[Dt / 6 | 0] |= Et[(ut[Dt] - 1 + St) % 28] << 31 - Dt % 6, dt[4 + (Dt / 6 | 0)] |= Et[28 + (ut[Dt + 24] - 1 + St) % 28] << 31 - Dt % 6;
                                dt[0] = dt[0] << 1 | dt[0] >>> 31;
                                for (var Dt = 1; Dt < 7; Dt++) dt[Dt] = dt[Dt] >>> (Dt - 1) * 4 + 3;
                                dt[7] = dt[7] << 5 | dt[7] >>> 27
                            }
                            for (var _t = this._invSubKeys = [], Dt = 0; Dt < 16; Dt++) _t[Dt] = gt[15 - Dt]
                        },
                        encryptBlock: function(ot, ct) {
                            this._doCryptBlock(ot, ct, this._subKeys)
                        },
                        decryptBlock: function(ot, ct) {
                            this._doCryptBlock(ot, ct, this._invSubKeys)
                        },
                        _doCryptBlock: function(ot, ct, Et) {
                            this._lBlock = ot[ct], this._rBlock = ot[ct + 1], At.call(this, 4, 252645135), At.call(this, 16, 65535), Ct.call(this, 2, 858993459), Ct.call(this, 8, 16711935), At.call(this, 1, 1431655765);
                            for (var Dt = 0; Dt < 16; Dt++) {
                                for (var Pt = Et[Dt], gt = this._lBlock, ft = this._rBlock, dt = 0, St = 0; St < 8; St++) dt |= bt[St][((ft ^ Pt[St]) & pt[St]) >>> 0];
                                this._lBlock = ft, this._rBlock = gt ^ dt
                            }
                            var _t = this._lBlock;
                            this._lBlock = this._rBlock, this._rBlock = _t, At.call(this, 1, 1431655765), Ct.call(this, 8, 16711935), Ct.call(this, 2, 858993459), At.call(this, 16, 65535), At.call(this, 4, 252645135), ot[ct] = this._lBlock, ot[ct + 1] = this._rBlock
                        },
                        keySize: 64 / 32,
                        ivSize: 64 / 32,
                        blockSize: 64 / 32
                    });

                function At(ot, ct) {
                    var Et = (this._lBlock >>> ot ^ this._rBlock) & ct;
                    this._rBlock ^= Et, this._lBlock ^= Et << ot
                }

                function Ct(ot, ct) {
                    var Et = (this._rBlock >>> ot ^ this._lBlock) & ct;
                    this._lBlock ^= Et, this._rBlock ^= Et << ot
                }
                tt.DES = at._createHelper(It);
                var ht = st.TripleDES = at.extend({
                    _doReset: function() {
                        var ot = this._key,
                            ct = ot.words;
                        if (ct.length !== 2 && ct.length !== 4 && ct.length < 6) throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
                        var Et = ct.slice(0, 2),
                            Dt = ct.length < 4 ? ct.slice(0, 2) : ct.slice(2, 4),
                            Pt = ct.length < 6 ? ct.slice(0, 2) : ct.slice(4, 6);
                        this._des1 = It.createEncryptor(nt.create(Et)), this._des2 = It.createEncryptor(nt.create(Dt)), this._des3 = It.createEncryptor(nt.create(Pt))
                    },
                    encryptBlock: function(ot, ct) {
                        this._des1.encryptBlock(ot, ct), this._des2.decryptBlock(ot, ct), this._des3.encryptBlock(ot, ct)
                    },
                    decryptBlock: function(ot, ct) {
                        this._des3.decryptBlock(ot, ct), this._des2.encryptBlock(ot, ct), this._des1.decryptBlock(ot, ct)
                    },
                    keySize: 192 / 32,
                    ivSize: 64 / 32,
                    blockSize: 64 / 32
                });
                tt.TripleDES = at._createHelper(ht)
            }(), et.TripleDES
        })
    }(tripledes)), tripledes.exports
}
var rc4 = {
        exports: {}
    },
    hasRequiredRc4;

function requireRc4() {
    return hasRequiredRc4 || (hasRequiredRc4 = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore())
        })(commonjsGlobal$1, function(et) {
            return function() {
                var tt = et,
                    rt = tt.lib,
                    nt = rt.StreamCipher,
                    at = tt.algo,
                    st = at.RC4 = nt.extend({
                        _doReset: function() {
                            for (var lt = this._key, bt = lt.words, pt = lt.sigBytes, It = this._S = [], At = 0; At < 256; At++) It[At] = At;
                            for (var At = 0, Ct = 0; At < 256; At++) {
                                var ht = At % pt,
                                    ot = bt[ht >>> 2] >>> 24 - ht % 4 * 8 & 255;
                                Ct = (Ct + It[At] + ot) % 256;
                                var ct = It[At];
                                It[At] = It[Ct], It[Ct] = ct
                            }
                            this._i = this._j = 0
                        },
                        _doProcessBlock: function(lt, bt) {
                            lt[bt] ^= it.call(this)
                        },
                        keySize: 256 / 32,
                        ivSize: 0
                    });

                function it() {
                    for (var lt = this._S, bt = this._i, pt = this._j, It = 0, At = 0; At < 4; At++) {
                        bt = (bt + 1) % 256, pt = (pt + lt[bt]) % 256;
                        var Ct = lt[bt];
                        lt[bt] = lt[pt], lt[pt] = Ct, It |= lt[(lt[bt] + lt[pt]) % 256] << 24 - At * 8
                    }
                    return this._i = bt, this._j = pt, It
                }
                tt.RC4 = nt._createHelper(st);
                var ut = at.RC4Drop = st.extend({
                    cfg: st.cfg.extend({
                        drop: 192
                    }),
                    _doReset: function() {
                        st._doReset.call(this);
                        for (var lt = this.cfg.drop; lt > 0; lt--) it.call(this)
                    }
                });
                tt.RC4Drop = nt._createHelper(ut)
            }(), et.RC4
        })
    }(rc4)), rc4.exports
}
var rabbit = {
        exports: {}
    },
    hasRequiredRabbit;

function requireRabbit() {
    return hasRequiredRabbit || (hasRequiredRabbit = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore())
        })(commonjsGlobal$1, function(et) {
            return function() {
                var tt = et,
                    rt = tt.lib,
                    nt = rt.StreamCipher,
                    at = tt.algo,
                    st = [],
                    it = [],
                    ut = [],
                    lt = at.Rabbit = nt.extend({
                        _doReset: function() {
                            for (var pt = this._key.words, It = this.cfg.iv, At = 0; At < 4; At++) pt[At] = (pt[At] << 8 | pt[At] >>> 24) & 16711935 | (pt[At] << 24 | pt[At] >>> 8) & 4278255360;
                            var Ct = this._X = [pt[0], pt[3] << 16 | pt[2] >>> 16, pt[1], pt[0] << 16 | pt[3] >>> 16, pt[2], pt[1] << 16 | pt[0] >>> 16, pt[3], pt[2] << 16 | pt[1] >>> 16],
                                ht = this._C = [pt[2] << 16 | pt[2] >>> 16, pt[0] & 4294901760 | pt[1] & 65535, pt[3] << 16 | pt[3] >>> 16, pt[1] & 4294901760 | pt[2] & 65535, pt[0] << 16 | pt[0] >>> 16, pt[2] & 4294901760 | pt[3] & 65535, pt[1] << 16 | pt[1] >>> 16, pt[3] & 4294901760 | pt[0] & 65535];
                            this._b = 0;
                            for (var At = 0; At < 4; At++) bt.call(this);
                            for (var At = 0; At < 8; At++) ht[At] ^= Ct[At + 4 & 7];
                            if (It) {
                                var ot = It.words,
                                    ct = ot[0],
                                    Et = ot[1],
                                    Dt = (ct << 8 | ct >>> 24) & 16711935 | (ct << 24 | ct >>> 8) & 4278255360,
                                    Pt = (Et << 8 | Et >>> 24) & 16711935 | (Et << 24 | Et >>> 8) & 4278255360,
                                    gt = Dt >>> 16 | Pt & 4294901760,
                                    ft = Pt << 16 | Dt & 65535;
                                ht[0] ^= Dt, ht[1] ^= gt, ht[2] ^= Pt, ht[3] ^= ft, ht[4] ^= Dt, ht[5] ^= gt, ht[6] ^= Pt, ht[7] ^= ft;
                                for (var At = 0; At < 4; At++) bt.call(this)
                            }
                        },
                        _doProcessBlock: function(pt, It) {
                            var At = this._X;
                            bt.call(this), st[0] = At[0] ^ At[5] >>> 16 ^ At[3] << 16, st[1] = At[2] ^ At[7] >>> 16 ^ At[5] << 16, st[2] = At[4] ^ At[1] >>> 16 ^ At[7] << 16, st[3] = At[6] ^ At[3] >>> 16 ^ At[1] << 16;
                            for (var Ct = 0; Ct < 4; Ct++) st[Ct] = (st[Ct] << 8 | st[Ct] >>> 24) & 16711935 | (st[Ct] << 24 | st[Ct] >>> 8) & 4278255360, pt[It + Ct] ^= st[Ct]
                        },
                        blockSize: 128 / 32,
                        ivSize: 64 / 32
                    });

                function bt() {
                    for (var pt = this._X, It = this._C, At = 0; At < 8; At++) it[At] = It[At];
                    It[0] = It[0] + 1295307597 + this._b | 0, It[1] = It[1] + 3545052371 + (It[0] >>> 0 < it[0] >>> 0 ? 1 : 0) | 0, It[2] = It[2] + 886263092 + (It[1] >>> 0 < it[1] >>> 0 ? 1 : 0) | 0, It[3] = It[3] + 1295307597 + (It[2] >>> 0 < it[2] >>> 0 ? 1 : 0) | 0, It[4] = It[4] + 3545052371 + (It[3] >>> 0 < it[3] >>> 0 ? 1 : 0) | 0, It[5] = It[5] + 886263092 + (It[4] >>> 0 < it[4] >>> 0 ? 1 : 0) | 0, It[6] = It[6] + 1295307597 + (It[5] >>> 0 < it[5] >>> 0 ? 1 : 0) | 0, It[7] = It[7] + 3545052371 + (It[6] >>> 0 < it[6] >>> 0 ? 1 : 0) | 0, this._b = It[7] >>> 0 < it[7] >>> 0 ? 1 : 0;
                    for (var At = 0; At < 8; At++) {
                        var Ct = pt[At] + It[At],
                            ht = Ct & 65535,
                            ot = Ct >>> 16,
                            ct = ((ht * ht >>> 17) + ht * ot >>> 15) + ot * ot,
                            Et = ((Ct & 4294901760) * Ct | 0) + ((Ct & 65535) * Ct | 0);
                        ut[At] = ct ^ Et
                    }
                    pt[0] = ut[0] + (ut[7] << 16 | ut[7] >>> 16) + (ut[6] << 16 | ut[6] >>> 16) | 0, pt[1] = ut[1] + (ut[0] << 8 | ut[0] >>> 24) + ut[7] | 0, pt[2] = ut[2] + (ut[1] << 16 | ut[1] >>> 16) + (ut[0] << 16 | ut[0] >>> 16) | 0, pt[3] = ut[3] + (ut[2] << 8 | ut[2] >>> 24) + ut[1] | 0, pt[4] = ut[4] + (ut[3] << 16 | ut[3] >>> 16) + (ut[2] << 16 | ut[2] >>> 16) | 0, pt[5] = ut[5] + (ut[4] << 8 | ut[4] >>> 24) + ut[3] | 0, pt[6] = ut[6] + (ut[5] << 16 | ut[5] >>> 16) + (ut[4] << 16 | ut[4] >>> 16) | 0, pt[7] = ut[7] + (ut[6] << 8 | ut[6] >>> 24) + ut[5] | 0
                }
                tt.Rabbit = nt._createHelper(lt)
            }(), et.Rabbit
        })
    }(rabbit)), rabbit.exports
}
var rabbitLegacy = {
        exports: {}
    },
    hasRequiredRabbitLegacy;

function requireRabbitLegacy() {
    return hasRequiredRabbitLegacy || (hasRequiredRabbitLegacy = 1, function(_, _e) {
        (function(et, tt, rt) {
            _.exports = tt(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore())
        })(commonjsGlobal$1, function(et) {
            return function() {
                var tt = et,
                    rt = tt.lib,
                    nt = rt.StreamCipher,
                    at = tt.algo,
                    st = [],
                    it = [],
                    ut = [],
                    lt = at.RabbitLegacy = nt.extend({
                        _doReset: function() {
                            var pt = this._key.words,
                                It = this.cfg.iv,
                                At = this._X = [pt[0], pt[3] << 16 | pt[2] >>> 16, pt[1], pt[0] << 16 | pt[3] >>> 16, pt[2], pt[1] << 16 | pt[0] >>> 16, pt[3], pt[2] << 16 | pt[1] >>> 16],
                                Ct = this._C = [pt[2] << 16 | pt[2] >>> 16, pt[0] & 4294901760 | pt[1] & 65535, pt[3] << 16 | pt[3] >>> 16, pt[1] & 4294901760 | pt[2] & 65535, pt[0] << 16 | pt[0] >>> 16, pt[2] & 4294901760 | pt[3] & 65535, pt[1] << 16 | pt[1] >>> 16, pt[3] & 4294901760 | pt[0] & 65535];
                            this._b = 0;
                            for (var ht = 0; ht < 4; ht++) bt.call(this);
                            for (var ht = 0; ht < 8; ht++) Ct[ht] ^= At[ht + 4 & 7];
                            if (It) {
                                var ot = It.words,
                                    ct = ot[0],
                                    Et = ot[1],
                                    Dt = (ct << 8 | ct >>> 24) & 16711935 | (ct << 24 | ct >>> 8) & 4278255360,
                                    Pt = (Et << 8 | Et >>> 24) & 16711935 | (Et << 24 | Et >>> 8) & 4278255360,
                                    gt = Dt >>> 16 | Pt & 4294901760,
                                    ft = Pt << 16 | Dt & 65535;
                                Ct[0] ^= Dt, Ct[1] ^= gt, Ct[2] ^= Pt, Ct[3] ^= ft, Ct[4] ^= Dt, Ct[5] ^= gt, Ct[6] ^= Pt, Ct[7] ^= ft;
                                for (var ht = 0; ht < 4; ht++) bt.call(this)
                            }
                        },
                        _doProcessBlock: function(pt, It) {
                            var At = this._X;
                            bt.call(this), st[0] = At[0] ^ At[5] >>> 16 ^ At[3] << 16, st[1] = At[2] ^ At[7] >>> 16 ^ At[5] << 16, st[2] = At[4] ^ At[1] >>> 16 ^ At[7] << 16, st[3] = At[6] ^ At[3] >>> 16 ^ At[1] << 16;
                            for (var Ct = 0; Ct < 4; Ct++) st[Ct] = (st[Ct] << 8 | st[Ct] >>> 24) & 16711935 | (st[Ct] << 24 | st[Ct] >>> 8) & 4278255360, pt[It + Ct] ^= st[Ct]
                        },
                        blockSize: 128 / 32,
                        ivSize: 64 / 32
                    });

                function bt() {
                    for (var pt = this._X, It = this._C, At = 0; At < 8; At++) it[At] = It[At];
                    It[0] = It[0] + 1295307597 + this._b | 0, It[1] = It[1] + 3545052371 + (It[0] >>> 0 < it[0] >>> 0 ? 1 : 0) | 0, It[2] = It[2] + 886263092 + (It[1] >>> 0 < it[1] >>> 0 ? 1 : 0) | 0, It[3] = It[3] + 1295307597 + (It[2] >>> 0 < it[2] >>> 0 ? 1 : 0) | 0, It[4] = It[4] + 3545052371 + (It[3] >>> 0 < it[3] >>> 0 ? 1 : 0) | 0, It[5] = It[5] + 886263092 + (It[4] >>> 0 < it[4] >>> 0 ? 1 : 0) | 0, It[6] = It[6] + 1295307597 + (It[5] >>> 0 < it[5] >>> 0 ? 1 : 0) | 0, It[7] = It[7] + 3545052371 + (It[6] >>> 0 < it[6] >>> 0 ? 1 : 0) | 0, this._b = It[7] >>> 0 < it[7] >>> 0 ? 1 : 0;
                    for (var At = 0; At < 8; At++) {
                        var Ct = pt[At] + It[At],
                            ht = Ct & 65535,
                            ot = Ct >>> 16,
                            ct = ((ht * ht >>> 17) + ht * ot >>> 15) + ot * ot,
                            Et = ((Ct & 4294901760) * Ct | 0) + ((Ct & 65535) * Ct | 0);
                        ut[At] = ct ^ Et
                    }
                    pt[0] = ut[0] + (ut[7] << 16 | ut[7] >>> 16) + (ut[6] << 16 | ut[6] >>> 16) | 0, pt[1] = ut[1] + (ut[0] << 8 | ut[0] >>> 24) + ut[7] | 0, pt[2] = ut[2] + (ut[1] << 16 | ut[1] >>> 16) + (ut[0] << 16 | ut[0] >>> 16) | 0, pt[3] = ut[3] + (ut[2] << 8 | ut[2] >>> 24) + ut[1] | 0, pt[4] = ut[4] + (ut[3] << 16 | ut[3] >>> 16) + (ut[2] << 16 | ut[2] >>> 16) | 0, pt[5] = ut[5] + (ut[4] << 8 | ut[4] >>> 24) + ut[3] | 0, pt[6] = ut[6] + (ut[5] << 16 | ut[5] >>> 16) + (ut[4] << 16 | ut[4] >>> 16) | 0, pt[7] = ut[7] + (ut[6] << 8 | ut[6] >>> 24) + ut[5] | 0
                }
                tt.RabbitLegacy = nt._createHelper(lt)
            }(), et.RabbitLegacy
        })
    }(rabbitLegacy)), rabbitLegacy.exports
}(function(_, _e) {
    (function(et, tt, rt) {
        _.exports = tt(requireCore(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireEncBase64url(), requireMd5(), requireSha1(), requireSha256(), requireSha224(), requireSha512(), requireSha384(), requireSha3(), requireRipemd160(), requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy())
    })(commonjsGlobal$1, function(et) {
        return et
    })
})(cryptoJs);
const CryptoJS = cryptoJs.exports,
    format$1 = {
        stringify: _ => {
            const _e = _.ciphertext.toString(CryptoJS.enc.Base64),
                et = _.iv.toString() || "",
                tt = _.salt.toString() || "";
            return JSON.stringify({
                ct: _e,
                iv: et,
                salt: tt
            })
        },
        parse: _ => {
            const _e = JSON.parse(_),
                et = CryptoJS.enc.Base64.parse(_e.ct),
                tt = CryptoJS.enc.Hex.parse(_e.iv) || "",
                rt = CryptoJS.enc.Hex.parse(_e.s) || "";
            return CryptoJS.lib.CipherParams.create({
                ciphertext: et,
                iv: tt,
                salt: rt
            })
        }
    },
    gDrivePlayerScraper = {
        id: "gdriveplayer",
        enabled: !0,
        type: [MWMediaType.MOVIE],
        displayName: "gdriveplayer",
        async getMediaFromPortable(_) {
            const _e = await fetch(`${conf().CORS_PROXY_URL}https://api.gdriveplayer.us/v1/imdb/${_.mediaId}`).then(et => et.json());
            return {
                ..._,
                title: _e.Title,
                year: _e.Year
            }
        },
        async searchForMedia(_) {
            return (await fetch(`${conf().CORS_PROXY_URL}https://api.gdriveplayer.us/v1/movie/search?title=${_.searchQuery}`).then(tt => tt.json()) || []).map(tt => ({
                title: tt.title,
                year: tt.year,
                mediaId: tt.imdb
            }))
        },
        async getStream(media) {
            const streamRes = await fetch(`${conf().CORS_PROXY_URL}https://database.gdriveplayer.us/player.php?imdb=${media.mediaId}`).then(_ => _.text()),
                page = new DOMParser().parseFromString(streamRes, "text/html"),
                script = Array.from(page.querySelectorAll("script")).find(_ => {
                    var _e;
                    return (_e = _.textContent) == null ? void 0 : _e.includes("eval")
                });
            if (!script || !script.textContent) throw new Error("Could not find stream");
            const data = unpack_1(script.textContent).split("var data=\\'")[1].split("\\'")[0].replace(/\\/g, ""),
                decryptedData = unpack_1(CryptoJS.AES.decrypt(data, "alsfheafsjklNIWORNiolNIOWNKLNXakjsfwnBdwjbwfkjbJjkopfjweopjASoiwnrflakefneiofrt", {
                    format: format$1
                }).toString(CryptoJS.enc.Utf8)),
                sources = JSON.parse(JSON.stringify(eval(decryptedData.split("sources:")[1].split(",image")[0].replace(/\\/g, "").replace(/document\.referrer/g, '""')))),
                source = sources[sources.length - 1];
            return {
                url: `https:${source.file}`,
                type: source.type,
                captions: []
            }
        }
    };
class SimpleCache {
    constructor() {
        kr(this, "INTERVAL_MS", 2 * 60 * 1e3);
        kr(this, "_interval", null);
        kr(this, "_compare", null);
        kr(this, "_storage", [])
    }
    initialize() {
        if (this._interval) throw new Error("cache is already initialized");
        this._interval = setInterval(() => {
            const _e = new Date;
            this._storage.filter(et => !(et.expiry < _e))
        }, this.INTERVAL_MS)
    }
    destroy() {
        this._interval && clearInterval(this._interval), this.clear()
    }
    setCompare(_e) {
        this._compare = _e
    }
    has(_e) {
        return !!this.get(_e)
    }
    get(_e) {
        if (!this._compare) throw new Error("Compare function not set");
        const et = this._storage.find(tt => this._compare && this._compare(tt.key, _e));
        if (!!et) return et.value
    }
    set(_e, et, tt) {
        if (!this._compare) throw new Error("Compare function not set");
        const rt = this._storage.find(at => this._compare && this._compare(at.key, _e)),
            nt = new Date(new Date().getTime() + tt * 1e3);
        if (rt) {
            rt.key = _e, rt.value = et, rt.expiry = nt;
            return
        }
        this._storage.push({
            key: _e,
            value: et,
            expiry: nt
        })
    }
    remove(_e) {
        if (!this._compare) throw new Error("Compare function not set");
        this._storage.filter(et => !(this._compare && this._compare(et.key, _e)))
    }
    clear() {
        this._storage = []
    }
}
const contentCache = new SimpleCache;
contentCache.setCompare((_, _e) => _.mediaId === _e.mediaId && _.providerId === _e.providerId);
contentCache.initialize();

function WrapProvider(_) {
    return {
        ..._,
        async getMediaFromPortable(_e) {
            const et = contentCache.get(_e);
            if (et) return et.seasonId = _e.seasonId, et.episodeId = _e.episodeId, et;
            const tt = {
                ...await _.getMediaFromPortable(_e),
                providerId: _.id,
                mediaType: _e.mediaType
            };
            return contentCache.set(_e, tt, 60 * 60), tt
        },
        async searchForMedia(_e) {
            return (await _.searchForMedia(_e)).map(et => ({
                ...et,
                providerId: _.id,
                mediaType: _e.type
            }))
        }
    }
}
var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/,
    ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/,
    ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/,
    unicode = {
        Space_Separator,
        ID_Start,
        ID_Continue
    },
    util = {
        isSpaceSeparator(_) {
            return typeof _ == "string" && unicode.Space_Separator.test(_)
        },
        isIdStartChar(_) {
            return typeof _ == "string" && (_ >= "a" && _ <= "z" || _ >= "A" && _ <= "Z" || _ === "$" || _ === "_" || unicode.ID_Start.test(_))
        },
        isIdContinueChar(_) {
            return typeof _ == "string" && (_ >= "a" && _ <= "z" || _ >= "A" && _ <= "Z" || _ >= "0" && _ <= "9" || _ === "$" || _ === "_" || _ === "" || _ === "" || unicode.ID_Continue.test(_))
        },
        isDigit(_) {
            return typeof _ == "string" && /[0-9]/.test(_)
        },
        isHexDigit(_) {
            return typeof _ == "string" && /[0-9A-Fa-f]/.test(_)
        }
    };
let source, parseState, stack, pos, line, column, token, key$1, root;
var parse$1 = function _(_e, et) {
    source = String(_e), parseState = "start", stack = [], pos = 0, line = 1, column = 0, token = void 0, key$1 = void 0, root = void 0;
    do token = lex(), parseStates[parseState](); while (token.type !== "eof");
    return typeof et == "function" ? internalize({
        "": root
    }, "", et) : root
};

function internalize(_, _e, et) {
    const tt = _[_e];
    if (tt != null && typeof tt == "object")
        for (const rt in tt) {
            const nt = internalize(tt, rt, et);
            nt === void 0 ? delete tt[rt] : tt[rt] = nt
        }
    return et.call(_, _e, tt)
}
let lexState, buffer, doubleQuote, sign, c;

function lex() {
    for (lexState = "default", buffer = "", doubleQuote = !1, sign = 1;;) {
        c = peek();
        const _ = lexStates[lexState]();
        if (_) return _
    }
}

function peek() {
    if (source[pos]) return String.fromCodePoint(source.codePointAt(pos))
}

function read() {
    const _ = peek();
    return _ === `
` ? (line++, column = 0) : _ ? column += _.length : column++, _ && (pos += _.length), _
}
const lexStates = {
    default () {
        switch (c) {
            case "	":
            case "\v":
            case "\f":
            case " ":
            case " ":
            case "\uFEFF":
            case `
`:
            case "\r":
            case "\u2028":
            case "\u2029":
                read();
                return;
            case "/":
                read(), lexState = "comment";
                return;
            case void 0:
                return read(), newToken("eof")
        }
        if (util.isSpaceSeparator(c)) {
            read();
            return
        }
        return lexStates[parseState]()
    },
    comment() {
        switch (c) {
            case "*":
                read(), lexState = "multiLineComment";
                return;
            case "/":
                read(), lexState = "singleLineComment";
                return
        }
        throw invalidChar(read())
    },
    multiLineComment() {
        switch (c) {
            case "*":
                read(), lexState = "multiLineCommentAsterisk";
                return;
            case void 0:
                throw invalidChar(read())
        }
        read()
    },
    multiLineCommentAsterisk() {
        switch (c) {
            case "*":
                read();
                return;
            case "/":
                read(), lexState = "default";
                return;
            case void 0:
                throw invalidChar(read())
        }
        read(), lexState = "multiLineComment"
    },
    singleLineComment() {
        switch (c) {
            case `
`:
            case "\r":
            case "\u2028":
            case "\u2029":
                read(), lexState = "default";
                return;
            case void 0:
                return read(), newToken("eof")
        }
        read()
    },
    value() {
        switch (c) {
            case "{":
            case "[":
                return newToken("punctuator", read());
            case "n":
                return read(), literal("ull"), newToken("null", null);
            case "t":
                return read(), literal("rue"), newToken("boolean", !0);
            case "f":
                return read(), literal("alse"), newToken("boolean", !1);
            case "-":
            case "+":
                read() === "-" && (sign = -1), lexState = "sign";
                return;
            case ".":
                buffer = read(), lexState = "decimalPointLeading";
                return;
            case "0":
                buffer = read(), lexState = "zero";
                return;
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
                buffer = read(), lexState = "decimalInteger";
                return;
            case "I":
                return read(), literal("nfinity"), newToken("numeric", 1 / 0);
            case "N":
                return read(), literal("aN"), newToken("numeric", NaN);
            case '"':
            case "'":
                doubleQuote = read() === '"', buffer = "", lexState = "string";
                return
        }
        throw invalidChar(read())
    },
    identifierNameStartEscape() {
        if (c !== "u") throw invalidChar(read());
        read();
        const _ = unicodeEscape();
        switch (_) {
            case "$":
            case "_":
                break;
            default:
                if (!util.isIdStartChar(_)) throw invalidIdentifier();
                break
        }
        buffer += _, lexState = "identifierName"
    },
    identifierName() {
        switch (c) {
            case "$":
            case "_":
            case "":
            case "":
                buffer += read();
                return;
            case "\\":
                read(), lexState = "identifierNameEscape";
                return
        }
        if (util.isIdContinueChar(c)) {
            buffer += read();
            return
        }
        return newToken("identifier", buffer)
    },
    identifierNameEscape() {
        if (c !== "u") throw invalidChar(read());
        read();
        const _ = unicodeEscape();
        switch (_) {
            case "$":
            case "_":
            case "":
            case "":
                break;
            default:
                if (!util.isIdContinueChar(_)) throw invalidIdentifier();
                break
        }
        buffer += _, lexState = "identifierName"
    },
    sign() {
        switch (c) {
            case ".":
                buffer = read(), lexState = "decimalPointLeading";
                return;
            case "0":
                buffer = read(), lexState = "zero";
                return;
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
                buffer = read(), lexState = "decimalInteger";
                return;
            case "I":
                return read(), literal("nfinity"), newToken("numeric", sign * (1 / 0));
            case "N":
                return read(), literal("aN"), newToken("numeric", NaN)
        }
        throw invalidChar(read())
    },
    zero() {
        switch (c) {
            case ".":
                buffer += read(), lexState = "decimalPoint";
                return;
            case "e":
            case "E":
                buffer += read(), lexState = "decimalExponent";
                return;
            case "x":
            case "X":
                buffer += read(), lexState = "hexadecimal";
                return
        }
        return newToken("numeric", sign * 0)
    },
    decimalInteger() {
        switch (c) {
            case ".":
                buffer += read(), lexState = "decimalPoint";
                return;
            case "e":
            case "E":
                buffer += read(), lexState = "decimalExponent";
                return
        }
        if (util.isDigit(c)) {
            buffer += read();
            return
        }
        return newToken("numeric", sign * Number(buffer))
    },
    decimalPointLeading() {
        if (util.isDigit(c)) {
            buffer += read(), lexState = "decimalFraction";
            return
        }
        throw invalidChar(read())
    },
    decimalPoint() {
        switch (c) {
            case "e":
            case "E":
                buffer += read(), lexState = "decimalExponent";
                return
        }
        if (util.isDigit(c)) {
            buffer += read(), lexState = "decimalFraction";
            return
        }
        return newToken("numeric", sign * Number(buffer))
    },
    decimalFraction() {
        switch (c) {
            case "e":
            case "E":
                buffer += read(), lexState = "decimalExponent";
                return
        }
        if (util.isDigit(c)) {
            buffer += read();
            return
        }
        return newToken("numeric", sign * Number(buffer))
    },
    decimalExponent() {
        switch (c) {
            case "+":
            case "-":
                buffer += read(), lexState = "decimalExponentSign";
                return
        }
        if (util.isDigit(c)) {
            buffer += read(), lexState = "decimalExponentInteger";
            return
        }
        throw invalidChar(read())
    },
    decimalExponentSign() {
        if (util.isDigit(c)) {
            buffer += read(), lexState = "decimalExponentInteger";
            return
        }
        throw invalidChar(read())
    },
    decimalExponentInteger() {
        if (util.isDigit(c)) {
            buffer += read();
            return
        }
        return newToken("numeric", sign * Number(buffer))
    },
    hexadecimal() {
        if (util.isHexDigit(c)) {
            buffer += read(), lexState = "hexadecimalInteger";
            return
        }
        throw invalidChar(read())
    },
    hexadecimalInteger() {
        if (util.isHexDigit(c)) {
            buffer += read();
            return
        }
        return newToken("numeric", sign * Number(buffer))
    },
    string() {
        switch (c) {
            case "\\":
                read(), buffer += escape$2();
                return;
            case '"':
                if (doubleQuote) return read(), newToken("string", buffer);
                buffer += read();
                return;
            case "'":
                if (!doubleQuote) return read(), newToken("string", buffer);
                buffer += read();
                return;
            case `
`:
            case "\r":
                throw invalidChar(read());
            case "\u2028":
            case "\u2029":
                separatorChar(c);
                break;
            case void 0:
                throw invalidChar(read())
        }
        buffer += read()
    },
    start() {
        switch (c) {
            case "{":
            case "[":
                return newToken("punctuator", read())
        }
        lexState = "value"
    },
    beforePropertyName() {
        switch (c) {
            case "$":
            case "_":
                buffer = read(), lexState = "identifierName";
                return;
            case "\\":
                read(), lexState = "identifierNameStartEscape";
                return;
            case "}":
                return newToken("punctuator", read());
            case '"':
            case "'":
                doubleQuote = read() === '"', lexState = "string";
                return
        }
        if (util.isIdStartChar(c)) {
            buffer += read(), lexState = "identifierName";
            return
        }
        throw invalidChar(read())
    },
    afterPropertyName() {
        if (c === ":") return newToken("punctuator", read());
        throw invalidChar(read())
    },
    beforePropertyValue() {
        lexState = "value"
    },
    afterPropertyValue() {
        switch (c) {
            case ",":
            case "}":
                return newToken("punctuator", read())
        }
        throw invalidChar(read())
    },
    beforeArrayValue() {
        if (c === "]") return newToken("punctuator", read());
        lexState = "value"
    },
    afterArrayValue() {
        switch (c) {
            case ",":
            case "]":
                return newToken("punctuator", read())
        }
        throw invalidChar(read())
    },
    end() {
        throw invalidChar(read())
    }
};

function newToken(_, _e) {
    return {
        type: _,
        value: _e,
        line,
        column
    }
}

function literal(_) {
    for (const _e of _) {
        if (peek() !== _e) throw invalidChar(read());
        read()
    }
}

function escape$2() {
    switch (peek()) {
        case "b":
            return read(), "\b";
        case "f":
            return read(), "\f";
        case "n":
            return read(), `
`;
        case "r":
            return read(), "\r";
        case "t":
            return read(), "	";
        case "v":
            return read(), "\v";
        case "0":
            if (read(), util.isDigit(peek())) throw invalidChar(read());
            return "\0";
        case "x":
            return read(), hexEscape();
        case "u":
            return read(), unicodeEscape();
        case `
`:
        case "\u2028":
        case "\u2029":
            return read(), "";
        case "\r":
            return read(), peek() === `
` && read(), "";
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
            throw invalidChar(read());
        case void 0:
            throw invalidChar(read())
    }
    return read()
}

function hexEscape() {
    let _ = "",
        _e = peek();
    if (!util.isHexDigit(_e) || (_ += read(), _e = peek(), !util.isHexDigit(_e))) throw invalidChar(read());
    return _ += read(), String.fromCodePoint(parseInt(_, 16))
}

function unicodeEscape() {
    let _ = "",
        _e = 4;
    for (; _e-- > 0;) {
        const et = peek();
        if (!util.isHexDigit(et)) throw invalidChar(read());
        _ += read()
    }
    return String.fromCodePoint(parseInt(_, 16))
}
const parseStates = {
    start() {
        if (token.type === "eof") throw invalidEOF();
        push()
    },
    beforePropertyName() {
        switch (token.type) {
            case "identifier":
            case "string":
                key$1 = token.value, parseState = "afterPropertyName";
                return;
            case "punctuator":
                pop();
                return;
            case "eof":
                throw invalidEOF()
        }
    },
    afterPropertyName() {
        if (token.type === "eof") throw invalidEOF();
        parseState = "beforePropertyValue"
    },
    beforePropertyValue() {
        if (token.type === "eof") throw invalidEOF();
        push()
    },
    beforeArrayValue() {
        if (token.type === "eof") throw invalidEOF();
        if (token.type === "punctuator" && token.value === "]") {
            pop();
            return
        }
        push()
    },
    afterPropertyValue() {
        if (token.type === "eof") throw invalidEOF();
        switch (token.value) {
            case ",":
                parseState = "beforePropertyName";
                return;
            case "}":
                pop()
        }
    },
    afterArrayValue() {
        if (token.type === "eof") throw invalidEOF();
        switch (token.value) {
            case ",":
                parseState = "beforeArrayValue";
                return;
            case "]":
                pop()
        }
    },
    end() {}
};

function push() {
    let _;
    switch (token.type) {
        case "punctuator":
            switch (token.value) {
                case "{":
                    _ = {};
                    break;
                case "[":
                    _ = [];
                    break
            }
            break;
        case "null":
        case "boolean":
        case "numeric":
        case "string":
            _ = token.value;
            break
    }
    if (root === void 0) root = _;
    else {
        const _e = stack[stack.length - 1];
        Array.isArray(_e) ? _e.push(_) : _e[key$1] = _
    }
    if (_ !== null && typeof _ == "object") stack.push(_), Array.isArray(_) ? parseState = "beforeArrayValue" : parseState = "beforePropertyName";
    else {
        const _e = stack[stack.length - 1];
        _e == null ? parseState = "end" : Array.isArray(_e) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue"
    }
}

function pop() {
    stack.pop();
    const _ = stack[stack.length - 1];
    _ == null ? parseState = "end" : Array.isArray(_) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue"
}

function invalidChar(_) {
    return syntaxError(_ === void 0 ? `JSON5: invalid end of input at ${line}:${column}` : `JSON5: invalid character '${formatChar(_)}' at ${line}:${column}`)
}

function invalidEOF() {
    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
}

function invalidIdentifier() {
    return column -= 5, syntaxError(`JSON5: invalid identifier character at ${line}:${column}`)
}

function separatorChar(_) {
    console.warn(`JSON5: '${formatChar(_)}' in strings is not valid ECMAScript; consider escaping`)
}

function formatChar(_) {
    const _e = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
    };
    if (_e[_]) return _e[_];
    if (_ < " ") {
        const et = _.charCodeAt(0).toString(16);
        return "\\x" + ("00" + et).substring(et.length)
    }
    return _
}

function syntaxError(_) {
    const _e = new SyntaxError(_);
    return _e.lineNumber = line, _e.columnNumber = column, _e
}
var stringify = function _(_e, et, tt) {
    const rt = [];
    let nt = "",
        at, st, it = "",
        ut;
    if (et != null && typeof et == "object" && !Array.isArray(et) && (tt = et.space, ut = et.quote, et = et.replacer), typeof et == "function") st = et;
    else if (Array.isArray(et)) {
        at = [];
        for (const Ct of et) {
            let ht;
            typeof Ct == "string" ? ht = Ct : (typeof Ct == "number" || Ct instanceof String || Ct instanceof Number) && (ht = String(Ct)), ht !== void 0 && at.indexOf(ht) < 0 && at.push(ht)
        }
    }
    return tt instanceof Number ? tt = Number(tt) : tt instanceof String && (tt = String(tt)), typeof tt == "number" ? tt > 0 && (tt = Math.min(10, Math.floor(tt)), it = "          ".substr(0, tt)) : typeof tt == "string" && (it = tt.substr(0, 10)), lt("", {
        "": _e
    });

    function lt(Ct, ht) {
        let ot = ht[Ct];
        switch (ot != null && (typeof ot.toJSON5 == "function" ? ot = ot.toJSON5(Ct) : typeof ot.toJSON == "function" && (ot = ot.toJSON(Ct))), st && (ot = st.call(ht, Ct, ot)), ot instanceof Number ? ot = Number(ot) : ot instanceof String ? ot = String(ot) : ot instanceof Boolean && (ot = ot.valueOf()), ot) {
            case null:
                return "null";
            case !0:
                return "true";
            case !1:
                return "false"
        }
        if (typeof ot == "string") return bt(ot);
        if (typeof ot == "number") return String(ot);
        if (typeof ot == "object") return Array.isArray(ot) ? At(ot) : pt(ot)
    }

    function bt(Ct) {
        const ht = {
                "'": .1,
                '"': .2
            },
            ot = {
                "'": "\\'",
                '"': '\\"',
                "\\": "\\\\",
                "\b": "\\b",
                "\f": "\\f",
                "\n": "\\n",
                "\r": "\\r",
                "	": "\\t",
                "\v": "\\v",
                "\0": "\\0",
                "\u2028": "\\u2028",
                "\u2029": "\\u2029"
            };
        let ct = "";
        for (let Dt = 0; Dt < Ct.length; Dt++) {
            const Pt = Ct[Dt];
            switch (Pt) {
                case "'":
                case '"':
                    ht[Pt]++, ct += Pt;
                    continue;
                case "\0":
                    if (util.isDigit(Ct[Dt + 1])) {
                        ct += "\\x00";
                        continue
                    }
            }
            if (ot[Pt]) {
                ct += ot[Pt];
                continue
            }
            if (Pt < " ") {
                let gt = Pt.charCodeAt(0).toString(16);
                ct += "\\x" + ("00" + gt).substring(gt.length);
                continue
            }
            ct += Pt
        }
        const Et = ut || Object.keys(ht).reduce((Dt, Pt) => ht[Dt] < ht[Pt] ? Dt : Pt);
        return ct = ct.replace(new RegExp(Et, "g"), ot[Et]), Et + ct + Et
    }

    function pt(Ct) {
        if (rt.indexOf(Ct) >= 0) throw TypeError("Converting circular structure to JSON5");
        rt.push(Ct);
        let ht = nt;
        nt = nt + it;
        let ot = at || Object.keys(Ct),
            ct = [];
        for (const Dt of ot) {
            const Pt = lt(Dt, Ct);
            if (Pt !== void 0) {
                let gt = It(Dt) + ":";
                it !== "" && (gt += " "), gt += Pt, ct.push(gt)
            }
        }
        let Et;
        if (ct.length === 0) Et = "{}";
        else {
            let Dt;
            if (it === "") Dt = ct.join(","), Et = "{" + Dt + "}";
            else {
                let Pt = `,
` + nt;
                Dt = ct.join(Pt), Et = `{
` + nt + Dt + `,
` + ht + "}"
            }
        }
        return rt.pop(), nt = ht, Et
    }

    function It(Ct) {
        if (Ct.length === 0) return bt(Ct);
        const ht = String.fromCodePoint(Ct.codePointAt(0));
        if (!util.isIdStartChar(ht)) return bt(Ct);
        for (let ot = ht.length; ot < Ct.length; ot++)
            if (!util.isIdContinueChar(String.fromCodePoint(Ct.codePointAt(ot)))) return bt(Ct);
        return Ct
    }

    function At(Ct) {
        if (rt.indexOf(Ct) >= 0) throw TypeError("Converting circular structure to JSON5");
        rt.push(Ct);
        let ht = nt;
        nt = nt + it;
        let ot = [];
        for (let Et = 0; Et < Ct.length; Et++) {
            const Dt = lt(String(Et), Ct);
            ot.push(Dt !== void 0 ? Dt : "null")
        }
        let ct;
        if (ot.length === 0) ct = "[]";
        else if (it === "") ct = "[" + ot.join(",") + "]";
        else {
            let Et = `,
` + nt,
                Dt = ot.join(Et);
            ct = `[
` + nt + Dt + `,
` + ht + "]"
        }
        return rt.pop(), nt = ht, ct
    }
};
const JSON5 = {
    parse: parse$1,
    stringify
};
var lib$1 = JSON5;
const gomostreamScraper = {
        id: "gomostream",
        enabled: !0,
        type: [MWMediaType.MOVIE],
        displayName: "gomostream",
        async getMediaFromPortable(_) {
            const _e = new URLSearchParams({
                    apikey: conf().OMDB_API_KEY,
                    i: _.mediaId,
                    type: _.mediaType
                }),
                et = await fetch(`${conf().CORS_PROXY_URL}http://www.omdbapi.com/?${encodeURIComponent(_e.toString())}`).then(tt => tt.json());
            return {
                ..._,
                title: et.Title,
                year: et.Year
            }
        },
        async searchForMedia(_) {
            const _e = _.searchQuery.toLowerCase(),
                et = new URLSearchParams({
                    apikey: conf().OMDB_API_KEY,
                    s: _e,
                    type: _.type
                });
            return ((await fetch(`${conf().CORS_PROXY_URL}http://www.omdbapi.com/?${encodeURIComponent(et.toString())}`).then(nt => nt.json())).Search || []).map(nt => ({
                title: nt.Title,
                year: nt.Year,
                mediaId: nt.imdbID
            }))
        },
        async getStream(_) {
            var ot, ct, Et;
            const _e = _.mediaType === MWMediaType.SERIES ? "show" : _.mediaType,
                et = await fetch(`${conf().CORS_PROXY_URL}https://gomo.to/${_e}/${_.mediaId}`).then(Dt => Dt.text());
            if (et === "Movie not available." || et === "Episode not available.") throw new Error(et);
            const tt = ((ot = et.match(/var tc = '(.+)';/)) == null ? void 0 : ot[1]) || "",
                rt = ((ct = et.match(/"_token": "(.+)",/)) == null ? void 0 : ct[1]) || "",
                nt = new FormData;
            nt.append("tokenCode", tt), nt.append("_token", rt);
            const it = (await fetch(`${conf().CORS_PROXY_URL}https://gomo.to/decoding_v3.php`, {
                    method: "POST",
                    body: nt,
                    headers: {
                        "x-token": `${tt.slice(5,13).split("").reverse().join("")}13574199`
                    }
                }).then(Dt => Dt.json())).filter(Dt => Dt.includes("gomo.to"))[1],
                ut = await fetch(`${conf().CORS_PROXY_URL}${it}`).then(Dt => Dt.text()),
                lt = new DOMParser().parseFromString(ut, "text/html");
            if (lt.body.innerText === "File was deleted") throw new Error("File was deleted");
            const bt = (Et = Array.from(lt.querySelectorAll("script")).find(Dt => Dt.innerHTML.includes("eval(function(p,a,c,k,e,d"))) == null ? void 0 : Et.innerHTML;
            if (!bt) throw new Error("Could not get packed data");
            const pt = unpack_1(bt),
                It = /sources:(\[.*?\])/.exec(pt);
            if (!It) throw new Error("Could not get rawSources");
            const Ct = lib$1.parse(It[1])[0].file,
                ht = Ct.split(".").at(-1);
            if (ht !== "mp4" && ht !== "m3u8") throw new Error("Unsupported stream type");
            return {
                url: Ct,
                type: ht,
                captions: []
            }
        }
    },
    xemovieScraper = {
        id: "xemovie",
        enabled: !1,
        type: [MWMediaType.MOVIE],
        displayName: "xemovie",
        async getMediaFromPortable(_) {
            var nt, at;
            const _e = await fetch(`${conf().CORS_PROXY_URL}https://xemovie.co/movies/${_.mediaId}/watch`).then(st => st.text()),
                et = new DOMParser().parseFromString(_e, "text/html"),
                tt = ((nt = et.querySelector(".text-primary.text-lg.font-extrabold")) == null ? void 0 : nt.textContent) || "",
                rt = ((at = et.querySelector("div.justify-between:nth-child(3) > div:nth-child(2)")) == null ? void 0 : at.textContent) || "";
            return {
                ..._,
                title: tt,
                year: rt
            }
        },
        async searchForMedia(_) {
            const _e = _.searchQuery.toLowerCase(),
                et = `${conf().CORS_PROXY_URL}https://xemovie.co/search?q=${encodeURIComponent(_e)}`,
                tt = await fetch(et).then(ut => ut.text()),
                at = new DOMParser().parseFromString(tt, "text/html").querySelectorAll(".py-10")[0].querySelector(".grid");
            return at ? Array.from(at.querySelectorAll("a")).filter(ut => !ut.className).map(ut => {
                var pt, It;
                const lt = ut.parentElement;
                if (!lt) return;
                const bt = lt.querySelector("a");
                if (!!bt) return {
                    title: (pt = lt.querySelector("div > div > a > h6")) == null ? void 0 : pt.textContent,
                    year: (It = lt.querySelector("div.float-right")) == null ? void 0 : It.textContent,
                    mediaId: bt.href.split("/").pop() || ""
                }
            }).filter(ut => !!ut) : []
        },
        async getStream(media) {
            if (media.mediaType !== MWMediaType.MOVIE) throw new Error("Incorrect type");
            const url = `${conf().CORS_PROXY_URL}https://xemovie.co/movies/${media.mediaId}/watch`;
            let streamUrl = "";
            const subtitles = [],
                res = await fetch(url).then(_ => _.text()),
                scripts = Array.from(new DOMParser().parseFromString(res, "text/html").querySelectorAll("script"));
            for (const script of scripts)
                if (!!script.textContent && script.textContent.match(/https:\/\/[a-z][0-9]\.xemovie\.com/)) {
                    const data = JSON.parse(JSON.stringify(eval(`(${script.textContent.replace("const data = ","").split("};")[0]}})`)));
                    streamUrl = data.playlist[0].file;
                    for (const [_, _e] of data.playlist[0].tracks.entries()) {
                        const et = URL.createObjectURL(await fetch(`${conf().CORS_PROXY_URL}${_e.file}`).then(tt => tt.blob()));
                        subtitles.push({
                            id: _,
                            url: et,
                            label: _e.label
                        })
                    }
                } const streamType = streamUrl.split(".").at(-1);
            if (streamType !== "mp4" && streamType !== "m3u8") throw new Error("Unsupported stream type");
            return {
                url: streamUrl,
                type: streamType,
                captions: subtitles
            }
        }
    },
    flixhqProvider = {
        id: "flixhq",
        enabled: !0,
        type: [MWMediaType.MOVIE],
        displayName: "flixhq",
        async getMediaFromPortable(_) {
            const _e = await fetch(`${conf().CORS_PROXY_URL}https://api.consumet.org/movies/flixhq/info?id=${encodeURIComponent(_.mediaId)}`).then(et => et.json());
            return {
                ..._,
                title: _e.title,
                year: _e.releaseDate
            }
        },
        async searchForMedia(_) {
            return (await fetch(`${conf().CORS_PROXY_URL}https://api.consumet.org/movies/flixhq/${encodeURIComponent(_.searchQuery)}`).then(tt => tt.json()) || []).results.map(tt => ({
                title: tt.title,
                year: tt.releaseDate,
                mediaId: tt.id,
                type: MWMediaType.MOVIE
            }))
        },
        async getStream(_) {
            const _e = await fetch(`${conf().CORS_PROXY_URL}https://api.consumet.org/movies/flixhq/info?id=${encodeURIComponent(_.mediaId)}`).then(nt => nt.json()),
                et = new URLSearchParams({
                    episodeId: _e.episodes[0].id,
                    mediaId: _.mediaId
                }),
                rt = (await fetch(`${conf().CORS_PROXY_URL}https://api.consumet.org/movies/flixhq/watch?${encodeURIComponent(et.toString())}`).then(nt => nt.json())).sources.reduce((nt, at) => at.quality > nt.quality ? at : nt);
            return {
                url: rt.url,
                type: rt.isM3U8 ? "m3u8" : "mp4",
                captions: []
            }
        }
    };
let random = _ => crypto.getRandomValues(new Uint8Array(_)),
    customRandom = (_, _e, et) => {
        let tt = (2 << Math.log(_.length - 1) / Math.LN2) - 1,
            rt = -~(1.6 * tt * _e / _.length);
        return (nt = _e) => {
            let at = "";
            for (;;) {
                let st = et(rt),
                    it = rt;
                for (; it--;)
                    if (at += _[st[it] & tt] || "", at.length === nt) return at
            }
        }
    },
    customAlphabet = (_, _e = 21) => customRandom(_, _e, random);
var lib = {};
(function(_) {
    var _e = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(st, it, ut, lt) {
            function bt(pt) {
                return pt instanceof ut ? pt : new ut(function(It) {
                    It(pt)
                })
            }
            return new(ut || (ut = Promise))(function(pt, It) {
                function At(ot) {
                    try {
                        ht(lt.next(ot))
                    } catch (ct) {
                        It(ct)
                    }
                }

                function Ct(ot) {
                    try {
                        ht(lt.throw(ot))
                    } catch (ct) {
                        It(ct)
                    }
                }

                function ht(ot) {
                    ot.done ? pt(ot.value) : bt(ot.value).then(At, Ct)
                }
                ht((lt = lt.apply(st, it || [])).next())
            })
        },
        et = commonjsGlobal$1 && commonjsGlobal$1.__generator || function(st, it) {
            var ut = {
                    label: 0,
                    sent: function() {
                        if (pt[0] & 1) throw pt[1];
                        return pt[1]
                    },
                    trys: [],
                    ops: []
                },
                lt, bt, pt, It;
            return It = {
                next: At(0),
                throw: At(1),
                return: At(2)
            }, typeof Symbol == "function" && (It[Symbol.iterator] = function() {
                return this
            }), It;

            function At(ht) {
                return function(ot) {
                    return Ct([ht, ot])
                }
            }

            function Ct(ht) {
                if (lt) throw new TypeError("Generator is already executing.");
                for (; ut;) try {
                    if (lt = 1, bt && (pt = ht[0] & 2 ? bt.return : ht[0] ? bt.throw || ((pt = bt.return) && pt.call(bt), 0) : bt.next) && !(pt = pt.call(bt, ht[1])).done) return pt;
                    switch (bt = 0, pt && (ht = [ht[0] & 2, pt.value]), ht[0]) {
                        case 0:
                        case 1:
                            pt = ht;
                            break;
                        case 4:
                            return ut.label++, {
                                value: ht[1],
                                done: !1
                            };
                        case 5:
                            ut.label++, bt = ht[1], ht = [0];
                            continue;
                        case 7:
                            ht = ut.ops.pop(), ut.trys.pop();
                            continue;
                        default:
                            if (pt = ut.trys, !(pt = pt.length > 0 && pt[pt.length - 1]) && (ht[0] === 6 || ht[0] === 2)) {
                                ut = 0;
                                continue
                            }
                            if (ht[0] === 3 && (!pt || ht[1] > pt[0] && ht[1] < pt[3])) {
                                ut.label = ht[1];
                                break
                            }
                            if (ht[0] === 6 && ut.label < pt[1]) {
                                ut.label = pt[1], pt = ht;
                                break
                            }
                            if (pt && ut.label < pt[2]) {
                                ut.label = pt[2], ut.ops.push(ht);
                                break
                            }
                            pt[2] && ut.ops.pop(), ut.trys.pop();
                            continue
                    }
                    ht = it.call(st, ut)
                } catch (ot) {
                    ht = [6, ot], bt = 0
                } finally {
                    lt = pt = 0
                }
                if (ht[0] & 5) throw ht[1];
                return {
                    value: ht[0] ? ht[1] : void 0,
                    done: !0
                }
            }
        };
    Object.defineProperty(_, "__esModule", {
        value: !0
    }), _.moduleName = void 0, _.moduleName = "toWebVTT";
    var tt = function(st, it) {
            return new Promise(function(ut, lt) {
                var bt = new FileReader,
                    pt = function(At) {
                        var Ct = At.target.result;
                        bt.removeEventListener("loadend", pt), ut(it !== "string" ? new Uint8Array(Ct) : Ct)
                    },
                    It = function() {
                        bt.removeEventListener("error", It), lt(new Error(_.moduleName + ": Error while reading the Blob object"))
                    };
                bt.addEventListener("loadend", pt), bt.addEventListener("error", It), it !== "string" ? bt.readAsArrayBuffer(st) : bt.readAsText(st)
            })
        },
        rt = function(st) {
            return URL.createObjectURL(new Blob([st], {
                type: "text/vtt"
            }))
        },
        nt = function(st) {
            return st.replace(/\{\\([ibu])\}/g, "</$1>").replace(/\{\\([ibu])1\}/g, "<$1>").replace(/\{([ibu])\}/g, "<$1>").replace(/\{\/([ibu])\}/g, "</$1>").replace(/(\d\d:\d\d:\d\d),(\d\d\d)/g, "$1.$2").concat(`\r
\r
`)
        },
        at = function(st) {
            return _e(void 0, void 0, void 0, function() {
                var it, ut, lt, lt, bt;
                return et(this, function(pt) {
                    switch (pt.label) {
                        case 0:
                            if (!FileReader) throw new Error(_.moduleName + ": No FileReader constructor found");
                            if (!TextDecoder) throw new Error(_.moduleName + ": No TextDecoder constructor found");
                            if (!(st instanceof Blob)) throw new Error(_.moduleName + ": Expecting resource to be a Blob but something else found.");
                            ut = `WEBVTT FILE\r
\r
`, pt.label = 1;
                        case 1:
                            return pt.trys.push([1, 3, , 5]), [4, tt(st, "string")];
                        case 2:
                            return lt = pt.sent(), it = ut.concat(nt(lt)), [3, 5];
                        case 3:
                            return pt.sent(), [4, tt(st, "buffer")];
                        case 4:
                            return lt = pt.sent(), bt = new TextDecoder("utf-8").decode(lt), it = ut.concat(nt(bt)), [3, 5];
                        case 5:
                            return [2, Promise.resolve(rt(it))]
                    }
                })
            })
        };
    _.default = at
})(lib);
const toWebVTT = getDefaultExportFromCjs(lib),
    nanoid = customAlphabet("0123456789abcdef", 32),
    iv = atob("d0VpcGhUbiE="),
    key = atob("MTIzZDZjZWRmNjI2ZHk1NDIzM2FhMXc2"),
    apiUrls = [atob("aHR0cHM6Ly9zaG93Ym94LnNoZWd1Lm5ldC9hcGkvYXBpX2NsaWVudC9pbmRleC8="), atob("aHR0cHM6Ly9tYnBhcGkuc2hlZ3UubmV0L2FwaS9hcGlfY2xpZW50L2luZGV4Lw==")],
    appKey = atob("bW92aWVib3g="),
    appId = atob("Y29tLnRkby5zaG93Ym94"),
    crypto$1 = {
        encrypt(_) {
            return CryptoJS.TripleDES.encrypt(_, CryptoJS.enc.Utf8.parse(key), {
                iv: CryptoJS.enc.Utf8.parse(iv)
            }).toString()
        },
        getVerify(_, _e, et) {
            return _ ? CryptoJS.MD5(CryptoJS.MD5(_e).toString() + et + _).toString() : null
        }
    },
    expiry = () => Math.floor(Date.now() / 1e3 + 60 * 60 * 12),
    get$2 = (_, _e = !1) => {
        const et = {
                childmode: "0",
                app_version: "11.5",
                appid: appId,
                lang: "en",
                expired_date: `${expiry()}`,
                platform: "android",
                channel: "Website"
            },
            tt = crypto$1.encrypt(JSON.stringify({
                ...et,
                ..._
            })),
            rt = CryptoJS.MD5(appKey).toString(),
            nt = crypto$1.getVerify(tt, appKey, key),
            at = JSON.stringify({
                app_key: rt,
                verify: nt,
                encrypt_data: tt
            }),
            st = btoa(at),
            it = new URLSearchParams;
        it.append("data", st), it.append("appid", "27"), it.append("platform", "android"), it.append("version", "129"), it.append("medium", "Website");
        const ut = _e ? apiUrls[1] : apiUrls[0];
        return fetch(`${conf().CORS_PROXY_URL}${ut}`, {
            method: "POST",
            headers: {
                Platform: "android",
                "Content-Type": "application/x-www-form-urlencoded"
            },
            body: `${it.toString()}&token${nanoid()}`
        })
    },
    superStreamScraper = {
        id: "superstream",
        enabled: !0,
        type: [MWMediaType.MOVIE, MWMediaType.SERIES],
        displayName: "SuperStream",
        async getMediaFromPortable(_) {
            var tt;
            let _e;
            _.mediaType === MWMediaType.SERIES ? _e = {
                module: "TV_detail_1",
                display_all: "1",
                tid: _.mediaId
            } : _e = {
                module: "Movie_detail",
                mid: _.mediaId
            };
            const et = (await get$2(_e, !0).then(rt => rt.json())).data;
            return {
                ..._,
                title: et.title,
                year: et.year,
                seasonCount: (tt = et == null ? void 0 : et.season) == null ? void 0 : tt.length
            }
        },
        async searchForMedia(_) {
            const _e = {
                    module: "Search3",
                    page: "1",
                    type: "all",
                    keyword: _.searchQuery,
                    pagelimit: "20"
                },
                et = (await get$2(_e, !0).then(nt => nt.json())).data,
                tt = (et || []).filter(nt => nt.box_type === 1).map(nt => ({
                    title: nt.title,
                    year: nt.year,
                    mediaId: nt.id
                })),
                rt = (et || []).filter(nt => nt.box_type === 2).map(nt => ({
                    title: nt.title,
                    year: nt.year,
                    mediaId: nt.id,
                    seasonId: "1",
                    episodeId: "1"
                }));
            if (_.type === MWMediaType.MOVIE) return tt;
            if (_.type === MWMediaType.SERIES) return rt;
            throw new Error("Invalid media type used.")
        },
        async getStream(_) {
            if (_.mediaType === MWMediaType.MOVIE) {
                const st = {
                        uid: "",
                        module: "Movie_downloadurl_v3",
                        mid: _.mediaId,
                        oss: "1",
                        group: ""
                    },
                    it = (await get$2(st).then(It => It.json())).data,
                    ut = it.list.find(It => It.quality === "1080p" && It.path) ?? it.list.find(It => It.quality === "720p" && It.path) ?? it.list.find(It => It.quality === "480p" && It.path) ?? it.list.find(It => It.quality === "360p" && It.path);
                if (!ut) throw new Error("No quality could be found.");
                const lt = {
                        fid: ut.fid,
                        uid: "",
                        module: "Movie_srt_list_v2",
                        mid: _.mediaId
                    },
                    bt = (await get$2(lt).then(It => It.json())).data,
                    pt = await Promise.all(bt.list.map(async It => {
                        const At = await fetch(`${conf().CORS_PROXY_URL}${It.subtitles[0].file_path}`).then(ht => ht.blob()),
                            Ct = await toWebVTT(At);
                        return {
                            id: It.language,
                            url: Ct,
                            label: It.language
                        }
                    }));
                return {
                    url: ut.path,
                    type: "mp4",
                    captions: pt
                }
            }
            const _e = {
                    uid: "",
                    module: "TV_downloadurl_v3",
                    episode: _.episodeId,
                    tid: _.mediaId,
                    season: _.seasonId,
                    oss: "1",
                    group: ""
                },
                et = (await get$2(_e).then(st => st.json())).data,
                tt = et.list.find(st => st.quality === "1080p" && st.path) ?? et.list.find(st => st.quality === "720p" && st.path) ?? et.list.find(st => st.quality === "480p" && st.path) ?? et.list.find(st => st.quality === "360p" && st.path);
            if (!tt) throw new Error("No quality could be found.");
            const rt = {
                    fid: tt.fid,
                    uid: "",
                    module: "TV_srt_list_v2",
                    episode: _.episodeId,
                    tid: _.mediaId,
                    season: _.seasonId
                },
                nt = (await get$2(rt).then(st => st.json())).data,
                at = await Promise.all(nt.list.map(async st => {
                    const it = await fetch(`${conf().CORS_PROXY_URL}${st.subtitles[0].file_path}`).then(lt => lt.blob()),
                        ut = await toWebVTT(it);
                    return {
                        id: st.language,
                        url: ut,
                        label: st.language
                    }
                }));
            return {
                url: tt.path,
                type: "mp4",
                captions: at
            }
        },
        async getSeasonDataFromMedia(_) {
            const _e = {
                    module: "TV_detail_1",
                    display_all: "1",
                    tid: _.mediaId
                },
                et = (await get$2(_e, !0).then(nt => nt.json())).data,
                tt = (await fetch(`https://api.themoviedb.org/3/search/tv?api_key=${conf().TMDB_API_KEY}&language=en-US&page=1&query=${et.title}&include_adult=false`).then(nt => nt.json())).results[0];
            return {
                seasons: (await fetch(`https://api.themoviedb.org/3/tv/${tt.id}?api_key=${conf().TMDB_API_KEY}`).then(nt => nt.json())).seasons.map(nt => ({
                    sort: nt.season_number,
                    id: nt.season_number.toString(),
                    type: nt.season_number === 0 ? "special" : "season",
                    episodes: Array.from({
                        length: nt.episode_count
                    }).map((at, st) => ({
                        title: `Episode ${st+1}`,
                        sort: st + 1,
                        id: (st + 1).toString(),
                        episodeNumber: st + 1
                    }))
                }))
            }
        }
    },
    mediaProvidersUnchecked = [WrapProvider(superStreamScraper), WrapProvider(theFlixScraper), WrapProvider(gDrivePlayerScraper), WrapProvider(gomostreamScraper), WrapProvider(xemovieScraper), WrapProvider(flixhqProvider)],
    mediaProviders = mediaProvidersUnchecked.filter(_ => _.enabled);

function GetProvidersForType(_) {
    return mediaProviders.filter(_e => _e.type.includes(_))
}

function getProviderFromId(_) {
    return mediaProviders.find(_e => _e.id === _)
}

function getProviderMetadata(_) {
    const _e = mediaProvidersUnchecked.find(et => et.id === _);
    return _e ? {
        exists: !0,
        type: _e.type,
        enabled: _e.enabled,
        id: _,
        provider: _e
    } : {
        exists: !1,
        type: [],
        enabled: !1,
        id: _
    }
}

function getEpisodeFromMedia(_) {
    if (_.seasonId === void 0 || _.episodeId === void 0 || _.seriesData === void 0) return null;
    const _e = _.seriesData.seasons.find(tt => tt.id === _.seasonId);
    if (!_e) return null;
    const et = _e == null ? void 0 : _e.episodes.find(tt => tt.id === _.episodeId);
    return et ? {
        season: _e,
        episode: et
    } : null
}

function isArray(_) {
    return Array.isArray ? Array.isArray(_) : getTag(_) === "[object Array]"
}
const INFINITY = 1 / 0;

function baseToString(_) {
    if (typeof _ == "string") return _;
    let _e = _ + "";
    return _e == "0" && 1 / _ == -INFINITY ? "-0" : _e
}

function toString(_) {
    return _ == null ? "" : baseToString(_)
}

function isString(_) {
    return typeof _ == "string"
}

function isNumber(_) {
    return typeof _ == "number"
}

function isBoolean(_) {
    return _ === !0 || _ === !1 || isObjectLike(_) && getTag(_) == "[object Boolean]"
}

function isObject(_) {
    return typeof _ == "object"
}

function isObjectLike(_) {
    return isObject(_) && _ !== null
}

function isDefined(_) {
    return _ != null
}

function isBlank(_) {
    return !_.trim().length
}

function getTag(_) {
    return _ == null ? _ === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(_)
}
const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available",
    INCORRECT_INDEX_TYPE = "Incorrect 'index' type",
    LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = _ => `Invalid value for key ${_}`,
    PATTERN_LENGTH_TOO_LARGE = _ => `Pattern length exceeds max of ${_}.`,
    MISSING_KEY_PROPERTY = _ => `Missing ${_} property in key`,
    INVALID_KEY_WEIGHT_VALUE = _ => `Property 'weight' in key '${_}' must be a positive integer`,
    hasOwn = Object.prototype.hasOwnProperty;
class KeyStore {
    constructor(_e) {
        this._keys = [], this._keyMap = {};
        let et = 0;
        _e.forEach(tt => {
            let rt = createKey(tt);
            et += rt.weight, this._keys.push(rt), this._keyMap[rt.id] = rt, et += rt.weight
        }), this._keys.forEach(tt => {
            tt.weight /= et
        })
    }
    get(_e) {
        return this._keyMap[_e]
    }
    keys() {
        return this._keys
    }
    toJSON() {
        return JSON.stringify(this._keys)
    }
}

function createKey(_) {
    let _e = null,
        et = null,
        tt = null,
        rt = 1,
        nt = null;
    if (isString(_) || isArray(_)) tt = _, _e = createKeyPath(_), et = createKeyId(_);
    else {
        if (!hasOwn.call(_, "name")) throw new Error(MISSING_KEY_PROPERTY("name"));
        const at = _.name;
        if (tt = at, hasOwn.call(_, "weight") && (rt = _.weight, rt <= 0)) throw new Error(INVALID_KEY_WEIGHT_VALUE(at));
        _e = createKeyPath(at), et = createKeyId(at), nt = _.getFn
    }
    return {
        path: _e,
        id: et,
        weight: rt,
        src: tt,
        getFn: nt
    }
}

function createKeyPath(_) {
    return isArray(_) ? _ : _.split(".")
}

function createKeyId(_) {
    return isArray(_) ? _.join(".") : _
}

function get$1(_, _e) {
    let et = [],
        tt = !1;
    const rt = (nt, at, st) => {
        if (!!isDefined(nt))
            if (!at[st]) et.push(nt);
            else {
                let it = at[st];
                const ut = nt[it];
                if (!isDefined(ut)) return;
                if (st === at.length - 1 && (isString(ut) || isNumber(ut) || isBoolean(ut))) et.push(toString(ut));
                else if (isArray(ut)) {
                    tt = !0;
                    for (let lt = 0, bt = ut.length; lt < bt; lt += 1) rt(ut[lt], at, st + 1)
                } else at.length && rt(ut, at, st + 1)
            }
    };
    return rt(_, isString(_e) ? _e.split(".") : _e, 0), tt ? et : et[0]
}
const MatchOptions = {
        includeMatches: !1,
        findAllMatches: !1,
        minMatchCharLength: 1
    },
    BasicOptions = {
        isCaseSensitive: !1,
        includeScore: !1,
        keys: [],
        shouldSort: !0,
        sortFn: (_, _e) => _.score === _e.score ? _.idx < _e.idx ? -1 : 1 : _.score < _e.score ? -1 : 1
    },
    FuzzyOptions = {
        location: 0,
        threshold: .6,
        distance: 100
    },
    AdvancedOptions = {
        useExtendedSearch: !1,
        getFn: get$1,
        ignoreLocation: !1,
        ignoreFieldNorm: !1,
        fieldNormWeight: 1
    };
var Config = {
    ...BasicOptions,
    ...MatchOptions,
    ...FuzzyOptions,
    ...AdvancedOptions
};
const SPACE = /[^ ]+/g;

function norm(_ = 1, _e = 3) {
    const et = new Map,
        tt = Math.pow(10, _e);
    return {
        get(rt) {
            const nt = rt.match(SPACE).length;
            if (et.has(nt)) return et.get(nt);
            const at = 1 / Math.pow(nt, .5 * _),
                st = parseFloat(Math.round(at * tt) / tt);
            return et.set(nt, st), st
        },
        clear() {
            et.clear()
        }
    }
}
class FuseIndex {
    constructor({
        getFn: _e = Config.getFn,
        fieldNormWeight: et = Config.fieldNormWeight
    } = {}) {
        this.norm = norm(et, 3), this.getFn = _e, this.isCreated = !1, this.setIndexRecords()
    }
    setSources(_e = []) {
        this.docs = _e
    }
    setIndexRecords(_e = []) {
        this.records = _e
    }
    setKeys(_e = []) {
        this.keys = _e, this._keysMap = {}, _e.forEach((et, tt) => {
            this._keysMap[et.id] = tt
        })
    }
    create() {
        this.isCreated || !this.docs.length || (this.isCreated = !0, isString(this.docs[0]) ? this.docs.forEach((_e, et) => {
            this._addString(_e, et)
        }) : this.docs.forEach((_e, et) => {
            this._addObject(_e, et)
        }), this.norm.clear())
    }
    add(_e) {
        const et = this.size();
        isString(_e) ? this._addString(_e, et) : this._addObject(_e, et)
    }
    removeAt(_e) {
        this.records.splice(_e, 1);
        for (let et = _e, tt = this.size(); et < tt; et += 1) this.records[et].i -= 1
    }
    getValueForItemAtKeyId(_e, et) {
        return _e[this._keysMap[et]]
    }
    size() {
        return this.records.length
    }
    _addString(_e, et) {
        if (!isDefined(_e) || isBlank(_e)) return;
        let tt = {
            v: _e,
            i: et,
            n: this.norm.get(_e)
        };
        this.records.push(tt)
    }
    _addObject(_e, et) {
        let tt = {
            i: et,
            $: {}
        };
        this.keys.forEach((rt, nt) => {
            let at = rt.getFn ? rt.getFn(_e) : this.getFn(_e, rt.path);
            if (!!isDefined(at)) {
                if (isArray(at)) {
                    let st = [];
                    const it = [{
                        nestedArrIndex: -1,
                        value: at
                    }];
                    for (; it.length;) {
                        const {
                            nestedArrIndex: ut,
                            value: lt
                        } = it.pop();
                        if (!!isDefined(lt))
                            if (isString(lt) && !isBlank(lt)) {
                                let bt = {
                                    v: lt,
                                    i: ut,
                                    n: this.norm.get(lt)
                                };
                                st.push(bt)
                            } else isArray(lt) && lt.forEach((bt, pt) => {
                                it.push({
                                    nestedArrIndex: pt,
                                    value: bt
                                })
                            })
                    }
                    tt.$[nt] = st
                } else if (isString(at) && !isBlank(at)) {
                    let st = {
                        v: at,
                        n: this.norm.get(at)
                    };
                    tt.$[nt] = st
                }
            }
        }), this.records.push(tt)
    }
    toJSON() {
        return {
            keys: this.keys,
            records: this.records
        }
    }
}

function createIndex(_, _e, {
    getFn: et = Config.getFn,
    fieldNormWeight: tt = Config.fieldNormWeight
} = {}) {
    const rt = new FuseIndex({
        getFn: et,
        fieldNormWeight: tt
    });
    return rt.setKeys(_.map(createKey)), rt.setSources(_e), rt.create(), rt
}

function parseIndex(_, {
    getFn: _e = Config.getFn,
    fieldNormWeight: et = Config.fieldNormWeight
} = {}) {
    const {
        keys: tt,
        records: rt
    } = _, nt = new FuseIndex({
        getFn: _e,
        fieldNormWeight: et
    });
    return nt.setKeys(tt), nt.setIndexRecords(rt), nt
}

function computeScore$1(_, {
    errors: _e = 0,
    currentLocation: et = 0,
    expectedLocation: tt = 0,
    distance: rt = Config.distance,
    ignoreLocation: nt = Config.ignoreLocation
} = {}) {
    const at = _e / _.length;
    if (nt) return at;
    const st = Math.abs(tt - et);
    return rt ? at + st / rt : st ? 1 : at
}

function convertMaskToIndices(_ = [], _e = Config.minMatchCharLength) {
    let et = [],
        tt = -1,
        rt = -1,
        nt = 0;
    for (let at = _.length; nt < at; nt += 1) {
        let st = _[nt];
        st && tt === -1 ? tt = nt : !st && tt !== -1 && (rt = nt - 1, rt - tt + 1 >= _e && et.push([tt, rt]), tt = -1)
    }
    return _[nt - 1] && nt - tt >= _e && et.push([tt, nt - 1]), et
}
const MAX_BITS = 32;

function search(_, _e, et, {
    location: tt = Config.location,
    distance: rt = Config.distance,
    threshold: nt = Config.threshold,
    findAllMatches: at = Config.findAllMatches,
    minMatchCharLength: st = Config.minMatchCharLength,
    includeMatches: it = Config.includeMatches,
    ignoreLocation: ut = Config.ignoreLocation
} = {}) {
    if (_e.length > MAX_BITS) throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
    const lt = _e.length,
        bt = _.length,
        pt = Math.max(0, Math.min(tt, bt));
    let It = nt,
        At = pt;
    const Ct = st > 1 || it,
        ht = Ct ? Array(bt) : [];
    let ot;
    for (;
        (ot = _.indexOf(_e, At)) > -1;) {
        let ft = computeScore$1(_e, {
            currentLocation: ot,
            expectedLocation: pt,
            distance: rt,
            ignoreLocation: ut
        });
        if (It = Math.min(ft, It), At = ot + lt, Ct) {
            let dt = 0;
            for (; dt < lt;) ht[ot + dt] = 1, dt += 1
        }
    }
    At = -1;
    let ct = [],
        Et = 1,
        Dt = lt + bt;
    const Pt = 1 << lt - 1;
    for (let ft = 0; ft < lt; ft += 1) {
        let dt = 0,
            St = Dt;
        for (; dt < St;) computeScore$1(_e, {
            errors: ft,
            currentLocation: pt + St,
            expectedLocation: pt,
            distance: rt,
            ignoreLocation: ut
        }) <= It ? dt = St : Dt = St, St = Math.floor((Dt - dt) / 2 + dt);
        Dt = St;
        let _t = Math.max(1, pt - St + 1),
            vt = at ? bt : Math.min(pt + St, bt) + lt,
            mt = Array(vt + 2);
        mt[vt + 1] = (1 << ft) - 1;
        for (let yt = vt; yt >= _t; yt -= 1) {
            let Tt = yt - 1,
                Ft = et[_.charAt(Tt)];
            if (Ct && (ht[Tt] = +!!Ft), mt[yt] = (mt[yt + 1] << 1 | 1) & Ft, ft && (mt[yt] |= (ct[yt + 1] | ct[yt]) << 1 | 1 | ct[yt + 1]), mt[yt] & Pt && (Et = computeScore$1(_e, {
                    errors: ft,
                    currentLocation: Tt,
                    expectedLocation: pt,
                    distance: rt,
                    ignoreLocation: ut
                }), Et <= It)) {
                if (It = Et, At = Tt, At <= pt) break;
                _t = Math.max(1, 2 * pt - At)
            }
        }
        if (computeScore$1(_e, {
                errors: ft + 1,
                currentLocation: pt,
                expectedLocation: pt,
                distance: rt,
                ignoreLocation: ut
            }) > It) break;
        ct = mt
    }
    const gt = {
        isMatch: At >= 0,
        score: Math.max(.001, Et)
    };
    if (Ct) {
        const ft = convertMaskToIndices(ht, st);
        ft.length ? it && (gt.indices = ft) : gt.isMatch = !1
    }
    return gt
}

function createPatternAlphabet(_) {
    let _e = {};
    for (let et = 0, tt = _.length; et < tt; et += 1) {
        const rt = _.charAt(et);
        _e[rt] = (_e[rt] || 0) | 1 << tt - et - 1
    }
    return _e
}
class BitapSearch {
    constructor(_e, {
        location: et = Config.location,
        threshold: tt = Config.threshold,
        distance: rt = Config.distance,
        includeMatches: nt = Config.includeMatches,
        findAllMatches: at = Config.findAllMatches,
        minMatchCharLength: st = Config.minMatchCharLength,
        isCaseSensitive: it = Config.isCaseSensitive,
        ignoreLocation: ut = Config.ignoreLocation
    } = {}) {
        if (this.options = {
                location: et,
                threshold: tt,
                distance: rt,
                includeMatches: nt,
                findAllMatches: at,
                minMatchCharLength: st,
                isCaseSensitive: it,
                ignoreLocation: ut
            }, this.pattern = it ? _e : _e.toLowerCase(), this.chunks = [], !this.pattern.length) return;
        const lt = (pt, It) => {
                this.chunks.push({
                    pattern: pt,
                    alphabet: createPatternAlphabet(pt),
                    startIndex: It
                })
            },
            bt = this.pattern.length;
        if (bt > MAX_BITS) {
            let pt = 0;
            const It = bt % MAX_BITS,
                At = bt - It;
            for (; pt < At;) lt(this.pattern.substr(pt, MAX_BITS), pt), pt += MAX_BITS;
            if (It) {
                const Ct = bt - MAX_BITS;
                lt(this.pattern.substr(Ct), Ct)
            }
        } else lt(this.pattern, 0)
    }
    searchIn(_e) {
        const {
            isCaseSensitive: et,
            includeMatches: tt
        } = this.options;
        if (et || (_e = _e.toLowerCase()), this.pattern === _e) {
            let At = {
                isMatch: !0,
                score: 0
            };
            return tt && (At.indices = [
                [0, _e.length - 1]
            ]), At
        }
        const {
            location: rt,
            distance: nt,
            threshold: at,
            findAllMatches: st,
            minMatchCharLength: it,
            ignoreLocation: ut
        } = this.options;
        let lt = [],
            bt = 0,
            pt = !1;
        this.chunks.forEach(({
            pattern: At,
            alphabet: Ct,
            startIndex: ht
        }) => {
            const {
                isMatch: ot,
                score: ct,
                indices: Et
            } = search(_e, At, Ct, {
                location: rt + ht,
                distance: nt,
                threshold: at,
                findAllMatches: st,
                minMatchCharLength: it,
                includeMatches: tt,
                ignoreLocation: ut
            });
            ot && (pt = !0), bt += ct, ot && Et && (lt = [...lt, ...Et])
        });
        let It = {
            isMatch: pt,
            score: pt ? bt / this.chunks.length : 1
        };
        return pt && tt && (It.indices = lt), It
    }
}
class BaseMatch {
    constructor(_e) {
        this.pattern = _e
    }
    static isMultiMatch(_e) {
        return getMatch(_e, this.multiRegex)
    }
    static isSingleMatch(_e) {
        return getMatch(_e, this.singleRegex)
    }
    search() {}
}

function getMatch(_, _e) {
    const et = _.match(_e);
    return et ? et[1] : null
}
class ExactMatch extends BaseMatch {
    constructor(_e) {
        super(_e)
    }
    static get type() {
        return "exact"
    }
    static get multiRegex() {
        return /^="(.*)"$/
    }
    static get singleRegex() {
        return /^=(.*)$/
    }
    search(_e) {
        const et = _e === this.pattern;
        return {
            isMatch: et,
            score: et ? 0 : 1,
            indices: [0, this.pattern.length - 1]
        }
    }
}
class InverseExactMatch extends BaseMatch {
    constructor(_e) {
        super(_e)
    }
    static get type() {
        return "inverse-exact"
    }
    static get multiRegex() {
        return /^!"(.*)"$/
    }
    static get singleRegex() {
        return /^!(.*)$/
    }
    search(_e) {
        const tt = _e.indexOf(this.pattern) === -1;
        return {
            isMatch: tt,
            score: tt ? 0 : 1,
            indices: [0, _e.length - 1]
        }
    }
}
class PrefixExactMatch extends BaseMatch {
    constructor(_e) {
        super(_e)
    }
    static get type() {
        return "prefix-exact"
    }
    static get multiRegex() {
        return /^\^"(.*)"$/
    }
    static get singleRegex() {
        return /^\^(.*)$/
    }
    search(_e) {
        const et = _e.startsWith(this.pattern);
        return {
            isMatch: et,
            score: et ? 0 : 1,
            indices: [0, this.pattern.length - 1]
        }
    }
}
class InversePrefixExactMatch extends BaseMatch {
    constructor(_e) {
        super(_e)
    }
    static get type() {
        return "inverse-prefix-exact"
    }
    static get multiRegex() {
        return /^!\^"(.*)"$/
    }
    static get singleRegex() {
        return /^!\^(.*)$/
    }
    search(_e) {
        const et = !_e.startsWith(this.pattern);
        return {
            isMatch: et,
            score: et ? 0 : 1,
            indices: [0, _e.length - 1]
        }
    }
}
class SuffixExactMatch extends BaseMatch {
    constructor(_e) {
        super(_e)
    }
    static get type() {
        return "suffix-exact"
    }
    static get multiRegex() {
        return /^"(.*)"\$$/
    }
    static get singleRegex() {
        return /^(.*)\$$/
    }
    search(_e) {
        const et = _e.endsWith(this.pattern);
        return {
            isMatch: et,
            score: et ? 0 : 1,
            indices: [_e.length - this.pattern.length, _e.length - 1]
        }
    }
}
class InverseSuffixExactMatch extends BaseMatch {
    constructor(_e) {
        super(_e)
    }
    static get type() {
        return "inverse-suffix-exact"
    }
    static get multiRegex() {
        return /^!"(.*)"\$$/
    }
    static get singleRegex() {
        return /^!(.*)\$$/
    }
    search(_e) {
        const et = !_e.endsWith(this.pattern);
        return {
            isMatch: et,
            score: et ? 0 : 1,
            indices: [0, _e.length - 1]
        }
    }
}
class FuzzyMatch extends BaseMatch {
    constructor(_e, {
        location: et = Config.location,
        threshold: tt = Config.threshold,
        distance: rt = Config.distance,
        includeMatches: nt = Config.includeMatches,
        findAllMatches: at = Config.findAllMatches,
        minMatchCharLength: st = Config.minMatchCharLength,
        isCaseSensitive: it = Config.isCaseSensitive,
        ignoreLocation: ut = Config.ignoreLocation
    } = {}) {
        super(_e), this._bitapSearch = new BitapSearch(_e, {
            location: et,
            threshold: tt,
            distance: rt,
            includeMatches: nt,
            findAllMatches: at,
            minMatchCharLength: st,
            isCaseSensitive: it,
            ignoreLocation: ut
        })
    }
    static get type() {
        return "fuzzy"
    }
    static get multiRegex() {
        return /^"(.*)"$/
    }
    static get singleRegex() {
        return /^(.*)$/
    }
    search(_e) {
        return this._bitapSearch.searchIn(_e)
    }
}
class IncludeMatch extends BaseMatch {
    constructor(_e) {
        super(_e)
    }
    static get type() {
        return "include"
    }
    static get multiRegex() {
        return /^'"(.*)"$/
    }
    static get singleRegex() {
        return /^'(.*)$/
    }
    search(_e) {
        let et = 0,
            tt;
        const rt = [],
            nt = this.pattern.length;
        for (;
            (tt = _e.indexOf(this.pattern, et)) > -1;) et = tt + nt, rt.push([tt, et - 1]);
        const at = !!rt.length;
        return {
            isMatch: at,
            score: at ? 0 : 1,
            indices: rt
        }
    }
}
const searchers = [ExactMatch, IncludeMatch, PrefixExactMatch, InversePrefixExactMatch, InverseSuffixExactMatch, SuffixExactMatch, InverseExactMatch, FuzzyMatch],
    searchersLen = searchers.length,
    SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,
    OR_TOKEN = "|";

function parseQuery(_, _e = {}) {
    return _.split(OR_TOKEN).map(et => {
        let tt = et.trim().split(SPACE_RE).filter(nt => nt && !!nt.trim()),
            rt = [];
        for (let nt = 0, at = tt.length; nt < at; nt += 1) {
            const st = tt[nt];
            let it = !1,
                ut = -1;
            for (; !it && ++ut < searchersLen;) {
                const lt = searchers[ut];
                let bt = lt.isMultiMatch(st);
                bt && (rt.push(new lt(bt, _e)), it = !0)
            }
            if (!it)
                for (ut = -1; ++ut < searchersLen;) {
                    const lt = searchers[ut];
                    let bt = lt.isSingleMatch(st);
                    if (bt) {
                        rt.push(new lt(bt, _e));
                        break
                    }
                }
        }
        return rt
    })
}
const MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);
class ExtendedSearch {
    constructor(_e, {
        isCaseSensitive: et = Config.isCaseSensitive,
        includeMatches: tt = Config.includeMatches,
        minMatchCharLength: rt = Config.minMatchCharLength,
        ignoreLocation: nt = Config.ignoreLocation,
        findAllMatches: at = Config.findAllMatches,
        location: st = Config.location,
        threshold: it = Config.threshold,
        distance: ut = Config.distance
    } = {}) {
        this.query = null, this.options = {
            isCaseSensitive: et,
            includeMatches: tt,
            minMatchCharLength: rt,
            findAllMatches: at,
            ignoreLocation: nt,
            location: st,
            threshold: it,
            distance: ut
        }, this.pattern = et ? _e : _e.toLowerCase(), this.query = parseQuery(this.pattern, this.options)
    }
    static condition(_e, et) {
        return et.useExtendedSearch
    }
    searchIn(_e) {
        const et = this.query;
        if (!et) return {
            isMatch: !1,
            score: 1
        };
        const {
            includeMatches: tt,
            isCaseSensitive: rt
        } = this.options;
        _e = rt ? _e : _e.toLowerCase();
        let nt = 0,
            at = [],
            st = 0;
        for (let it = 0, ut = et.length; it < ut; it += 1) {
            const lt = et[it];
            at.length = 0, nt = 0;
            for (let bt = 0, pt = lt.length; bt < pt; bt += 1) {
                const It = lt[bt],
                    {
                        isMatch: At,
                        indices: Ct,
                        score: ht
                    } = It.search(_e);
                if (At) {
                    if (nt += 1, st += ht, tt) {
                        const ot = It.constructor.type;
                        MultiMatchSet.has(ot) ? at = [...at, ...Ct] : at.push(Ct)
                    }
                } else {
                    st = 0, nt = 0, at.length = 0;
                    break
                }
            }
            if (nt) {
                let bt = {
                    isMatch: !0,
                    score: st / nt
                };
                return tt && (bt.indices = at), bt
            }
        }
        return {
            isMatch: !1,
            score: 1
        }
    }
}
const registeredSearchers = [];

function register(..._) {
    registeredSearchers.push(..._)
}

function createSearcher(_, _e) {
    for (let et = 0, tt = registeredSearchers.length; et < tt; et += 1) {
        let rt = registeredSearchers[et];
        if (rt.condition(_, _e)) return new rt(_, _e)
    }
    return new BitapSearch(_, _e)
}
const LogicalOperator = {
        AND: "$and",
        OR: "$or"
    },
    KeyType = {
        PATH: "$path",
        PATTERN: "$val"
    },
    isExpression = _ => !!(_[LogicalOperator.AND] || _[LogicalOperator.OR]),
    isPath = _ => !!_[KeyType.PATH],
    isLeaf = _ => !isArray(_) && isObject(_) && !isExpression(_),
    convertToExplicit = _ => ({
        [LogicalOperator.AND]: Object.keys(_).map(_e => ({
            [_e]: _[_e]
        }))
    });

function parse(_, _e, {
    auto: et = !0
} = {}) {
    const tt = rt => {
        let nt = Object.keys(rt);
        const at = isPath(rt);
        if (!at && nt.length > 1 && !isExpression(rt)) return tt(convertToExplicit(rt));
        if (isLeaf(rt)) {
            const it = at ? rt[KeyType.PATH] : nt[0],
                ut = at ? rt[KeyType.PATTERN] : rt[it];
            if (!isString(ut)) throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(it));
            const lt = {
                keyId: createKeyId(it),
                pattern: ut
            };
            return et && (lt.searcher = createSearcher(ut, _e)), lt
        }
        let st = {
            children: [],
            operator: nt[0]
        };
        return nt.forEach(it => {
            const ut = rt[it];
            isArray(ut) && ut.forEach(lt => {
                st.children.push(tt(lt))
            })
        }), st
    };
    return isExpression(_) || (_ = convertToExplicit(_)), tt(_)
}

function computeScore(_, {
    ignoreFieldNorm: _e = Config.ignoreFieldNorm
}) {
    _.forEach(et => {
        let tt = 1;
        et.matches.forEach(({
            key: rt,
            norm: nt,
            score: at
        }) => {
            const st = rt ? rt.weight : null;
            tt *= Math.pow(at === 0 && st ? Number.EPSILON : at, (st || 1) * (_e ? 1 : nt))
        }), et.score = tt
    })
}

function transformMatches(_, _e) {
    const et = _.matches;
    _e.matches = [], isDefined(et) && et.forEach(tt => {
        if (!isDefined(tt.indices) || !tt.indices.length) return;
        const {
            indices: rt,
            value: nt
        } = tt;
        let at = {
            indices: rt,
            value: nt
        };
        tt.key && (at.key = tt.key.src), tt.idx > -1 && (at.refIndex = tt.idx), _e.matches.push(at)
    })
}

function transformScore(_, _e) {
    _e.score = _.score
}

function format(_, _e, {
    includeMatches: et = Config.includeMatches,
    includeScore: tt = Config.includeScore
} = {}) {
    const rt = [];
    return et && rt.push(transformMatches), tt && rt.push(transformScore), _.map(nt => {
        const {
            idx: at
        } = nt, st = {
            item: _e[at],
            refIndex: at
        };
        return rt.length && rt.forEach(it => {
            it(nt, st)
        }), st
    })
}
class Fuse {
    constructor(_e, et = {}, tt) {
        this.options = {
            ...Config,
            ...et
        }, this.options.useExtendedSearch, this._keyStore = new KeyStore(this.options.keys), this.setCollection(_e, tt)
    }
    setCollection(_e, et) {
        if (this._docs = _e, et && !(et instanceof FuseIndex)) throw new Error(INCORRECT_INDEX_TYPE);
        this._myIndex = et || createIndex(this.options.keys, this._docs, {
            getFn: this.options.getFn,
            fieldNormWeight: this.options.fieldNormWeight
        })
    }
    add(_e) {
        !isDefined(_e) || (this._docs.push(_e), this._myIndex.add(_e))
    }
    remove(_e = () => !1) {
        const et = [];
        for (let tt = 0, rt = this._docs.length; tt < rt; tt += 1) {
            const nt = this._docs[tt];
            _e(nt, tt) && (this.removeAt(tt), tt -= 1, rt -= 1, et.push(nt))
        }
        return et
    }
    removeAt(_e) {
        this._docs.splice(_e, 1), this._myIndex.removeAt(_e)
    }
    getIndex() {
        return this._myIndex
    }
    search(_e, {
        limit: et = -1
    } = {}) {
        const {
            includeMatches: tt,
            includeScore: rt,
            shouldSort: nt,
            sortFn: at,
            ignoreFieldNorm: st
        } = this.options;
        let it = isString(_e) ? isString(this._docs[0]) ? this._searchStringList(_e) : this._searchObjectList(_e) : this._searchLogical(_e);
        return computeScore(it, {
            ignoreFieldNorm: st
        }), nt && it.sort(at), isNumber(et) && et > -1 && (it = it.slice(0, et)), format(it, this._docs, {
            includeMatches: tt,
            includeScore: rt
        })
    }
    _searchStringList(_e) {
        const et = createSearcher(_e, this.options),
            {
                records: tt
            } = this._myIndex,
            rt = [];
        return tt.forEach(({
            v: nt,
            i: at,
            n: st
        }) => {
            if (!isDefined(nt)) return;
            const {
                isMatch: it,
                score: ut,
                indices: lt
            } = et.searchIn(nt);
            it && rt.push({
                item: nt,
                idx: at,
                matches: [{
                    score: ut,
                    value: nt,
                    norm: st,
                    indices: lt
                }]
            })
        }), rt
    }
    _searchLogical(_e) {
        const et = parse(_e, this.options),
            tt = (st, it, ut) => {
                if (!st.children) {
                    const {
                        keyId: bt,
                        searcher: pt
                    } = st, It = this._findMatches({
                        key: this._keyStore.get(bt),
                        value: this._myIndex.getValueForItemAtKeyId(it, bt),
                        searcher: pt
                    });
                    return It && It.length ? [{
                        idx: ut,
                        item: it,
                        matches: It
                    }] : []
                }
                const lt = [];
                for (let bt = 0, pt = st.children.length; bt < pt; bt += 1) {
                    const It = st.children[bt],
                        At = tt(It, it, ut);
                    if (At.length) lt.push(...At);
                    else if (st.operator === LogicalOperator.AND) return []
                }
                return lt
            },
            rt = this._myIndex.records,
            nt = {},
            at = [];
        return rt.forEach(({
            $: st,
            i: it
        }) => {
            if (isDefined(st)) {
                let ut = tt(et, st, it);
                ut.length && (nt[it] || (nt[it] = {
                    idx: it,
                    item: st,
                    matches: []
                }, at.push(nt[it])), ut.forEach(({
                    matches: lt
                }) => {
                    nt[it].matches.push(...lt)
                }))
            }
        }), at
    }
    _searchObjectList(_e) {
        const et = createSearcher(_e, this.options),
            {
                keys: tt,
                records: rt
            } = this._myIndex,
            nt = [];
        return rt.forEach(({
            $: at,
            i: st
        }) => {
            if (!isDefined(at)) return;
            let it = [];
            tt.forEach((ut, lt) => {
                it.push(...this._findMatches({
                    key: ut,
                    value: at[lt],
                    searcher: et
                }))
            }), it.length && nt.push({
                idx: st,
                item: at,
                matches: it
            })
        }), nt
    }
    _findMatches({
        key: _e,
        value: et,
        searcher: tt
    }) {
        if (!isDefined(et)) return [];
        let rt = [];
        if (isArray(et)) et.forEach(({
            v: nt,
            i: at,
            n: st
        }) => {
            if (!isDefined(nt)) return;
            const {
                isMatch: it,
                score: ut,
                indices: lt
            } = tt.searchIn(nt);
            it && rt.push({
                score: ut,
                key: _e,
                value: nt,
                idx: at,
                norm: st,
                indices: lt
            })
        });
        else {
            const {
                v: nt,
                n: at
            } = et, {
                isMatch: st,
                score: it,
                indices: ut
            } = tt.searchIn(nt);
            st && rt.push({
                score: it,
                key: _e,
                value: nt,
                norm: at,
                indices: ut
            })
        }
        return rt
    }
}
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
Fuse.parseQuery = parse;
register(ExtendedSearch);
const resultCache = new SimpleCache;
resultCache.setCompare((_, _e) => _.searchQuery === _e.searchQuery && _.type === _e.type);
resultCache.initialize();
async function callProviders(_) {
    const _e = GetProvidersForType(_.type).map(async nt => {
            try {
                return {
                    media: await nt.searchForMedia(_),
                    success: !0,
                    id: nt.id
                }
            } catch (at) {
                return console.error(`Failed running provider ${nt.id}`, at, _), {
                    media: [],
                    success: !1,
                    id: nt.id
                }
            }
        }),
        et = await Promise.all(_e),
        tt = et.map(nt => ({
            success: nt.success,
            id: nt.id
        })),
        rt = {
            results: et.flatMap(nt => nt.media),
            providers: tt,
            stats: {
                total: tt.length,
                failed: tt.filter(nt => !nt.success).length,
                succeeded: tt.filter(nt => nt.success).length
            }
        };
    return rt.stats.failed === 0 && resultCache.set(_, rt, 60 * 60), rt.results.forEach(nt => {
        contentCache.set(convertMediaToPortable(nt), nt, 60 * 60)
    }), rt
}

function sortResults(_, _e) {
    const et = {
            ..._e
        },
        tt = new Fuse(et.results, {
            threshold: .3,
            keys: ["title"],
            fieldNormWeight: .5
        });
    return et.results = tt.search(_.searchQuery).map(rt => rt.item), et
}
async function SearchProviders(_) {
    const _e = {
        ..._
    };
    _e.searchQuery = _e.searchQuery.toLowerCase().trim();
    let et = resultCache.get(_e);
    if (et || (et = await callProviders(_e)), et = sortResults(_e, et), et.stats.total === et.stats.failed) throw new Error("All Scrapers failed");
    return et
}

function convertMediaToPortable(_) {
    return {
        mediaId: _.mediaId,
        providerId: _.providerId,
        mediaType: _.mediaType,
        episodeId: _.episodeId,
        seasonId: _.seasonId
    }
}
async function convertPortableToMedia(_) {
    const _e = getProviderFromId(_.providerId);
    return _e == null ? void 0 : _e.getMediaFromPortable(_)
}
async function getStream(_) {
    const _e = getProviderFromId(_.providerId);
    if (!!_e) return _e.getStream(_)
}

function buildStoreObject(_) {
    const _e = {
        versions: _.versions,
        currentVersion: _.maxVersion,
        id: _.storageString
    };

    function et(rt) {
        let nt = rt;
        if (!nt) throw new Error("object to update is not an object");
        for (nt["--version"] === void 0 && (nt["--version"] = 0); nt["--version"] !== this.currentVersion;) {
            let at = nt["--version"] || 0;
            if (at.constructor !== Number || at < 0 ? at = -42 : at = (at + 1).toString(), !this.versions[at]) {
                console.error(`Version not found for storage item in store ${this.id}, resetting`), nt = null;
                break
            }
            nt = this.versions[at].update(nt)
        }
        return nt === null ? (console.error(`Storage item for store ${this.id} has been reset due to faulty updates`), this.versions[this.currentVersion.toString()].init()) : nt
    }

    function tt() {
        const rt = this;
        let nt = localStorage.getItem(this.id);
        if (nt) try {
            if (nt = JSON.parse(nt), !nt.constructor) throw console.error(`Storage item for store ${this.id} has not constructor`), new Error("storage item has no constructor");
            if (nt.constructor !== Object) throw console.error(`Storage item for store ${this.id} is not an object`), new Error("storage item is not an object")
        } catch {
            console.error(`Failed to parse storage item for store ${this.id}`), nt = null
        }
        return nt || (nt = this.versions[this.currentVersion.toString()].init()), nt = this.update(nt), nt.save = function(st) {
            const it = st || nt;
            localStorage.setItem(rt.id, JSON.stringify(it))
        }, Object.entries(_.instanceHelpers).forEach(([at, st]) => {
            if (nt[at] !== void 0) throw new Error(`helper name: ${at} on instance of store ${this.id} is reserved`);
            nt[at] = st.bind(nt)
        }), nt
    }
    return _e.get = tt.bind(_e), _e.update = et.bind(_e), Object.entries(_.staticHelpers).forEach(([rt, nt]) => {
        if (_e[rt] !== void 0) throw new Error(`helper name: ${rt} on store ${_e.id} is reserved`);
        _e[rt] = nt.bind({})
    }), _e
}

function versionedStoreBuilder() {
    return {
        _data: {
            versionList: [],
            maxVersion: 0,
            versions: {},
            storageString: void 0,
            instanceHelpers: {},
            staticHelpers: {}
        },
        setKey(_) {
            return this._data.storageString = _, this
        },
        addVersion({
            version: _,
            migrate: _e,
            create: et
        }) {
            if (_ < 0) throw new Error("Cannot add version below 0 in store");
            if (_ > 0 && !_e) throw new Error(`Missing migration on version ${_} (needed for any version above 0)`);
            return _ > this._data.maxVersion && (this._data.maxVersion = _), this._data.versionList.push(_), this._data.versions[_.toString()] = {
                version: _,
                update: _e ? tt => {
                    const rt = _e(tt);
                    return rt["--version"] = _, rt
                } : void 0,
                init: et ? () => {
                    const tt = et();
                    return tt["--version"] = _, tt
                } : void 0
            }, this
        },
        registerHelper({
            name: _,
            helper: _e,
            type: et
        }) {
            let tt = et;
            if (tt || (tt = "instance"), !_ || _.constructor !== String) throw new Error("helper name is not a string");
            if (!_e || _e.constructor !== Function) throw new Error("helper function is not a function");
            if (!["instance", "static"].includes(tt)) throw new Error("helper type must be either 'instance' or 'static'");
            return tt === "instance" ? this._data.instanceHelpers[_] = _e : tt === "static" && (this._data.staticHelpers[_] = _e), this
        },
        build() {
            const _ = this._data.versionList.sort((_e, et) => _e - et);
            if (_.forEach((_e, et, tt) => {
                    if (et !== 0 && _e !== tt[et - 1] + 1) throw new Error("Version list of store is not incremental")
                }), _[0] !== 0) throw new Error("Version 0 doesn't exist in version list of store");
            if (!this._data.versions[this._data.maxVersion.toString()].init) throw new Error(`Missing create function on version ${this._data.maxVersion} (needed for latest version of store)`);
            if (!this._data.storageString) throw new Error("storage key not set in store");
            return buildStoreObject(this._data)
        }
    }
}
const BookmarkStore = versionedStoreBuilder().setKey("mw-bookmarks").addVersion({
        version: 0,
        create() {
            return {
                bookmarks: []
            }
        }
    }).build(),
    BookmarkedContext = react.exports.createContext({
        setItemBookmark: () => {},
        getFilteredBookmarks: () => [],
        bookmarkStore: {
            bookmarks: []
        }
    });

function getBookmarkIndexFromMedia(_, _e) {
    return _.findIndex(tt => tt.mediaId === _e.mediaId && tt.providerId === _e.providerId && tt.episodeId === _e.episodeId && tt.seasonId === _e.seasonId)
}

function BookmarkContextProvider(_) {
    const _e = BookmarkStore.get(),
        [et, tt] = react.exports.useState(_e),
        rt = react.exports.useCallback(at => {
            tt(st => {
                const it = JSON.parse(JSON.stringify(st));
                let ut = at;
                return at.constructor === Function && (ut = at(it)), _e.save(ut), ut
            })
        }, [_e, tt]),
        nt = react.exports.useMemo(() => ({
            setItemBookmark(at, st) {
                rt(it => {
                    if (st) {
                        if (getBookmarkIndexFromMedia(it.bookmarks, at) === -1) {
                            const lt = {
                                mediaId: at.mediaId,
                                mediaType: at.mediaType,
                                providerId: at.providerId,
                                title: at.title,
                                year: at.year,
                                episodeId: at.episodeId,
                                seasonId: at.seasonId
                            };
                            it.bookmarks.push(lt)
                        }
                    } else {
                        const ut = getBookmarkIndexFromMedia(it.bookmarks, at);
                        ut !== -1 && it.bookmarks.splice(ut)
                    }
                    return it
                })
            },
            getFilteredBookmarks() {
                return et.bookmarks.filter(at => {
                    var st;
                    return (st = getProviderMetadata(at.providerId)) == null ? void 0 : st.enabled
                })
            },
            bookmarkStore: et
        }), [et, rt]);
    return jsxRuntime.exports.jsx(BookmarkedContext.Provider, {
        value: nt,
        children: _.children
    })
}

function useBookmarkContext() {
    return react.exports.useContext(BookmarkedContext)
}

function getIfBookmarkedFromPortable(_, _e) {
    return getBookmarkIndexFromMedia(_, _e) !== -1
}
const VideoProgressStore = versionedStoreBuilder().setKey("video-progress").addVersion({
    version: 0
}).addVersion({
    version: 1,
    migrate(_) {
        const _e = {
            items: []
        };
        return !_ || _.constructor !== Object || Object.keys(_).forEach(et => {
            et !== "--version" && et !== "save" && (_[et].movie && _[et].movie.constructor === Object && Object.keys(_[et].movie).forEach(tt => {
                try {
                    _e.items.push({
                        mediaId: tt.includes("player.php") ? tt.split("player.php%3Fimdb%3D")[1] : tt,
                        mediaType: MWMediaType.MOVIE,
                        providerId: et,
                        title: _[et].movie[tt].full.meta.title,
                        year: _[et].movie[tt].full.meta.year,
                        progress: _[et].movie[tt].full.currentlyAt,
                        percentage: Math.round(_[et].movie[tt].full.currentlyAt / _[et].movie[tt].full.totalDuration * 100)
                    })
                } catch {
                    console.error(`Failed to migrate movie: ${et}/${tt}`, _[et].movie[tt])
                }
            }), _[et].show && _[et].show.constructor === Object && Object.keys(_[et].show).forEach(tt => {
                _[et].show[tt].constructor === Object && Object.keys(_[et].show[tt]).forEach(rt => {
                    try {
                        _e.items.push({
                            mediaId: tt,
                            mediaType: MWMediaType.SERIES,
                            providerId: et,
                            title: _[et].show[tt][rt].meta.title,
                            year: _[et].show[tt][rt].meta.year,
                            percentage: Math.round(_[et].show[tt][rt].currentlyAt / _[et].show[tt][rt].totalDuration * 100),
                            progress: _[et].show[tt][rt].currentlyAt,
                            episodeId: _[et].show[tt][rt].show.episode,
                            seasonId: _[et].show[tt][rt].show.season
                        })
                    } catch {
                        console.error(`Failed to migrate series: ${et}/${tt}/${rt}`, _[et].show[tt][rt])
                    }
                })
            }))
        }), _e
    },
    create() {
        return {
            items: []
        }
    }
}).build();

function getWatchedFromPortable(_, _e) {
    return _.find(et => et.mediaId === _e.mediaId && et.providerId === _e.providerId && et.episodeId === _e.episodeId && et.seasonId === _e.seasonId)
}
const WatchedContext = react.exports.createContext({
    updateProgress: () => {},
    getFilteredWatched: () => [],
    watched: {
        items: []
    }
});
WatchedContext.displayName = "WatchedContext";

function WatchedContextProvider(_) {
    const _e = VideoProgressStore.get(),
        [et, tt] = react.exports.useState(_e),
        rt = react.exports.useCallback(at => {
            tt(st => {
                let it = at;
                return at.constructor === Function && (it = at(st)), _e.save(it), it
            })
        }, [tt, _e]),
        nt = react.exports.useMemo(() => ({
            updateProgress(at, st, it) {
                rt(ut => {
                    let lt = getWatchedFromPortable(ut.items, at);
                    return lt || (lt = {
                        mediaId: at.mediaId,
                        mediaType: at.mediaType,
                        providerId: at.providerId,
                        title: at.title,
                        year: at.year,
                        percentage: 0,
                        progress: 0,
                        episodeId: at.episodeId,
                        seasonId: at.seasonId
                    }, ut.items.push(lt)), lt.progress = st, lt.percentage = Math.round(st / it * 100), ut
                })
            },
            getFilteredWatched() {
                let at = et.items.filter(ut => {
                    var lt;
                    return (lt = getProviderMetadata(ut.providerId)) == null ? void 0 : lt.enabled
                });
                const st = {},
                    it = {};
                return at = at.filter(ut => {
                    if ([MWMediaType.ANIME, MWMediaType.SERIES].includes(ut.mediaType)) {
                        const lt = `${ut.mediaType}-${ut.mediaId}`,
                            bt = [ut.episodeId ? parseInt(ut.episodeId, 10) : -1, ut.seasonId ? parseInt(ut.seasonId, 10) : -1];
                        let pt = st[lt];
                        return pt || (pt = bt, st[lt] = bt, it[lt] = ut), (bt[0] > pt[0] || bt[0] === pt[0] && bt[1] > pt[1]) && (st[lt] = bt, it[lt] = ut), !1
                    }
                    return !0
                }), [...at, ...Object.values(it)]
            },
            watched: et
        }), [et, rt]);
    return jsxRuntime.exports.jsx(WatchedContext.Provider, {
        value: nt,
        children: _.children
    })
}

function useWatchedContext() {
    return react.exports.useContext(WatchedContext)
}

function _typeof$3(_) {
    return _typeof$3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(_e) {
        return typeof _e
    } : function(_e) {
        return _e && typeof Symbol == "function" && _e.constructor === Symbol && _e !== Symbol.prototype ? "symbol" : typeof _e
    }, _typeof$3(_)
}

function _toPrimitive$1(_, _e) {
    if (_typeof$3(_) !== "object" || _ === null) return _;
    var et = _[Symbol.toPrimitive];
    if (et !== void 0) {
        var tt = et.call(_, _e || "default");
        if (_typeof$3(tt) !== "object") return tt;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (_e === "string" ? String : Number)(_)
}

function _toPropertyKey$1(_) {
    var _e = _toPrimitive$1(_, "string");
    return _typeof$3(_e) === "symbol" ? _e : String(_e)
}

function _defineProperty$1(_, _e, et) {
    return _e = _toPropertyKey$1(_e), _e in _ ? Object.defineProperty(_, _e, {
        value: et,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : _[_e] = et, _
}

function warn() {
    if (console && console.warn) {
        for (var _, _e = arguments.length, et = new Array(_e), tt = 0; tt < _e; tt++) et[tt] = arguments[tt];
        typeof et[0] == "string" && (et[0] = "react-i18next:: ".concat(et[0])), (_ = console).warn.apply(_, et)
    }
}
var alreadyWarned = {};

function warnOnce() {
    for (var _ = arguments.length, _e = new Array(_), et = 0; et < _; et++) _e[et] = arguments[et];
    typeof _e[0] == "string" && alreadyWarned[_e[0]] || (typeof _e[0] == "string" && (alreadyWarned[_e[0]] = new Date), warn.apply(void 0, _e))
}

function loadNamespaces(_, _e, et) {
    _.loadNamespaces(_e, function() {
        if (_.isInitialized) et();
        else {
            var tt = function rt() {
                setTimeout(function() {
                    _.off("initialized", rt)
                }, 0), et()
            };
            _.on("initialized", tt)
        }
    })
}

function oldI18nextHasLoadedNamespace(_, _e) {
    var et = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        tt = _e.languages[0],
        rt = _e.options ? _e.options.fallbackLng : !1,
        nt = _e.languages[_e.languages.length - 1];
    if (tt.toLowerCase() === "cimode") return !0;
    var at = function(it, ut) {
        var lt = _e.services.backendConnector.state["".concat(it, "|").concat(ut)];
        return lt === -1 || lt === 2
    };
    return et.bindI18n && et.bindI18n.indexOf("languageChanging") > -1 && _e.services.backendConnector.backend && _e.isLanguageChangingTo && !at(_e.isLanguageChangingTo, _) ? !1 : !!(_e.hasResourceBundle(tt, _) || !_e.services.backendConnector.backend || _e.options.resources && !_e.options.partialBundledLanguages || at(tt, _) && (!rt || at(nt, _)))
}

function hasLoadedNamespace(_, _e) {
    var et = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!_e.languages || !_e.languages.length) return warnOnce("i18n.languages were undefined or empty", _e.languages), !0;
    var tt = _e.options.ignoreJSONStructure !== void 0;
    return tt ? _e.hasLoadedNamespace(_, {
        precheck: function(nt, at) {
            if (et.bindI18n && et.bindI18n.indexOf("languageChanging") > -1 && nt.services.backendConnector.backend && nt.isLanguageChangingTo && !at(nt.isLanguageChangingTo, _)) return !1
        }
    }) : oldI18nextHasLoadedNamespace(_, _e, et)
}
var matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,
    htmlEntities = {
        "&amp;": "&",
        "&#38;": "&",
        "&lt;": "<",
        "&#60;": "<",
        "&gt;": ">",
        "&#62;": ">",
        "&apos;": "'",
        "&#39;": "'",
        "&quot;": '"',
        "&#34;": '"',
        "&nbsp;": " ",
        "&#160;": " ",
        "&copy;": "",
        "&#169;": "",
        "&reg;": "",
        "&#174;": "",
        "&hellip;": "",
        "&#8230;": "",
        "&#x2F;": "/",
        "&#47;": "/"
    },
    unescapeHtmlEntity = function _(_e) {
        return htmlEntities[_e]
    },
    unescape$1 = function _(_e) {
        return _e.replace(matchHtmlEntity, unescapeHtmlEntity)
    };

function ownKeys$8(_, _e) {
    var et = Object.keys(_);
    if (Object.getOwnPropertySymbols) {
        var tt = Object.getOwnPropertySymbols(_);
        _e && (tt = tt.filter(function(rt) {
            return Object.getOwnPropertyDescriptor(_, rt).enumerable
        })), et.push.apply(et, tt)
    }
    return et
}

function _objectSpread$8(_) {
    for (var _e = 1; _e < arguments.length; _e++) {
        var et = arguments[_e] != null ? arguments[_e] : {};
        _e % 2 ? ownKeys$8(Object(et), !0).forEach(function(tt) {
            _defineProperty$1(_, tt, et[tt])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(et)) : ownKeys$8(Object(et)).forEach(function(tt) {
            Object.defineProperty(_, tt, Object.getOwnPropertyDescriptor(et, tt))
        })
    }
    return _
}
var defaultOptions = {
    bindI18n: "languageChanged",
    bindI18nStore: "",
    transEmptyNodeValue: "",
    transSupportBasicHtmlNodes: !0,
    transWrapTextNodes: "",
    transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
    useSuspense: !0,
    unescape: unescape$1
};

function setDefaults() {
    var _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    defaultOptions = _objectSpread$8(_objectSpread$8({}, defaultOptions), _)
}

function getDefaults$2() {
    return defaultOptions
}
var i18nInstance;

function setI18n(_) {
    i18nInstance = _
}

function getI18n() {
    return i18nInstance
}

function _classCallCheck$1(_, _e) {
    if (!(_ instanceof _e)) throw new TypeError("Cannot call a class as a function")
}

function _defineProperties$1(_, _e) {
    for (var et = 0; et < _e.length; et++) {
        var tt = _e[et];
        tt.enumerable = tt.enumerable || !1, tt.configurable = !0, "value" in tt && (tt.writable = !0), Object.defineProperty(_, _toPropertyKey$1(tt.key), tt)
    }
}

function _createClass$1(_, _e, et) {
    return _e && _defineProperties$1(_.prototype, _e), et && _defineProperties$1(_, et), Object.defineProperty(_, "prototype", {
        writable: !1
    }), _
}
var initReactI18next = {
        type: "3rdParty",
        init: function _(_e) {
            setDefaults(_e.options.react), setI18n(_e)
        }
    },
    I18nContext = react.exports.createContext(),
    ReportNamespaces = function() {
        function _() {
            _classCallCheck$1(this, _), this.usedNamespaces = {}
        }
        return _createClass$1(_, [{
            key: "addUsedNamespaces",
            value: function(et) {
                var tt = this;
                et.forEach(function(rt) {
                    tt.usedNamespaces[rt] || (tt.usedNamespaces[rt] = !0)
                })
            }
        }, {
            key: "getUsedNamespaces",
            value: function() {
                return Object.keys(this.usedNamespaces)
            }
        }]), _
    }();

function _arrayWithHoles(_) {
    if (Array.isArray(_)) return _
}

function _iterableToArrayLimit(_, _e) {
    var et = _ == null ? null : typeof Symbol < "u" && _[Symbol.iterator] || _["@@iterator"];
    if (et != null) {
        var tt, rt, nt, at, st = [],
            it = !0,
            ut = !1;
        try {
            if (nt = (et = et.call(_)).next, _e === 0) {
                if (Object(et) !== et) return;
                it = !1
            } else
                for (; !(it = (tt = nt.call(et)).done) && (st.push(tt.value), st.length !== _e); it = !0);
        } catch (lt) {
            ut = !0, rt = lt
        } finally {
            try {
                if (!it && et.return != null && (at = et.return(), Object(at) !== at)) return
            } finally {
                if (ut) throw rt
            }
        }
        return st
    }
}

function _arrayLikeToArray(_, _e) {
    (_e == null || _e > _.length) && (_e = _.length);
    for (var et = 0, tt = new Array(_e); et < _e; et++) tt[et] = _[et];
    return tt
}

function _unsupportedIterableToArray(_, _e) {
    if (!!_) {
        if (typeof _ == "string") return _arrayLikeToArray(_, _e);
        var et = Object.prototype.toString.call(_).slice(8, -1);
        if (et === "Object" && _.constructor && (et = _.constructor.name), et === "Map" || et === "Set") return Array.from(_);
        if (et === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(et)) return _arrayLikeToArray(_, _e)
    }
}

function _nonIterableRest() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function _slicedToArray(_, _e) {
    return _arrayWithHoles(_) || _iterableToArrayLimit(_, _e) || _unsupportedIterableToArray(_, _e) || _nonIterableRest()
}

function ownKeys$7(_, _e) {
    var et = Object.keys(_);
    if (Object.getOwnPropertySymbols) {
        var tt = Object.getOwnPropertySymbols(_);
        _e && (tt = tt.filter(function(rt) {
            return Object.getOwnPropertyDescriptor(_, rt).enumerable
        })), et.push.apply(et, tt)
    }
    return et
}

function _objectSpread$7(_) {
    for (var _e = 1; _e < arguments.length; _e++) {
        var et = arguments[_e] != null ? arguments[_e] : {};
        _e % 2 ? ownKeys$7(Object(et), !0).forEach(function(tt) {
            _defineProperty$1(_, tt, et[tt])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(et)) : ownKeys$7(Object(et)).forEach(function(tt) {
            Object.defineProperty(_, tt, Object.getOwnPropertyDescriptor(et, tt))
        })
    }
    return _
}
var usePrevious = function _(_e, et) {
    var tt = react.exports.useRef();
    return react.exports.useEffect(function() {
        tt.current = et ? tt.current : _e
    }, [_e, et]), tt.current
};

function useTranslation(_) {
    var _e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        et = _e.i18n,
        tt = react.exports.useContext(I18nContext) || {},
        rt = tt.i18n,
        nt = tt.defaultNS,
        at = et || rt || getI18n();
    if (at && !at.reportNamespaces && (at.reportNamespaces = new ReportNamespaces), !at) {
        warnOnce("You will need to pass in an i18next instance by using initReactI18next");
        var st = function(St) {
                return Array.isArray(St) ? St[St.length - 1] : St
            },
            it = [st, {}, !1];
        return it.t = st, it.i18n = {}, it.ready = !1, it
    }
    at.options.react && at.options.react.wait !== void 0 && warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
    var ut = _objectSpread$7(_objectSpread$7(_objectSpread$7({}, getDefaults$2()), at.options.react), _e),
        lt = ut.useSuspense,
        bt = ut.keyPrefix,
        pt = _ || nt || at.options && at.options.defaultNS;
    pt = typeof pt == "string" ? [pt] : pt || ["translation"], at.reportNamespaces.addUsedNamespaces && at.reportNamespaces.addUsedNamespaces(pt);
    var It = (at.isInitialized || at.initializedStoreOnce) && pt.every(function(dt) {
        return hasLoadedNamespace(dt, at, ut)
    });

    function At() {
        return at.getFixedT(null, ut.nsMode === "fallback" ? pt : pt[0], bt)
    }
    var Ct = react.exports.useState(At),
        ht = _slicedToArray(Ct, 2),
        ot = ht[0],
        ct = ht[1],
        Et = pt.join(),
        Dt = usePrevious(Et),
        Pt = react.exports.useRef(!0);
    react.exports.useEffect(function() {
        var dt = ut.bindI18n,
            St = ut.bindI18nStore;
        Pt.current = !0, !It && !lt && loadNamespaces(at, pt, function() {
            Pt.current && ct(At)
        }), It && Dt && Dt !== Et && Pt.current && ct(At);

        function _t() {
            Pt.current && ct(At)
        }
        return dt && at && at.on(dt, _t), St && at && at.store.on(St, _t),
            function() {
                Pt.current = !1, dt && at && dt.split(" ").forEach(function(vt) {
                    return at.off(vt, _t)
                }), St && at && St.split(" ").forEach(function(vt) {
                    return at.store.off(vt, _t)
                })
            }
    }, [at, Et]);
    var gt = react.exports.useRef(!0);
    react.exports.useEffect(function() {
        Pt.current && !gt.current && ct(At), gt.current = !1
    }, [at, bt]);
    var ft = [ot, at, It];
    if (ft.t = ot, ft.i18n = at, ft.ready = It, It || !It && !lt) return ft;
    throw new Promise(function(dt) {
        loadNamespaces(at, pt, function() {
            dt()
        })
    })
}

function BrandPill(_) {
    const {
        t: _e
    } = useTranslation();
    return jsxRuntime.exports.jsxs("div", {
        className: `flex items-center space-x-2 rounded-full bg-bink-100 bg-opacity-50 px-4 py-2 text-bink-600 ${_.clickable?"transition-[transform,background-color] hover:scale-105 hover:bg-bink-200 hover:text-bink-700 active:scale-95":""}`,
        children: [jsxRuntime.exports.jsx(Icon, {
            className: "text-xl",
            icon: Icons.MOVIE_WEB
        }), jsxRuntime.exports.jsx("span", {
            className: "font-semibold text-white",
            children: _e("global.name")
        })]
    })
}

function Navigation(_) {
    return jsxRuntime.exports.jsxs("div", {
        className: "absolute left-0 right-0 top-0 flex min-h-[88px] items-center justify-between py-5 px-7",
        children: [jsxRuntime.exports.jsxs("div", {
            className: "flex w-full items-center justify-center sm:w-fit",
            children: [jsxRuntime.exports.jsx("div", {
                className: "mr-auto sm:mr-6",
                children: jsxRuntime.exports.jsx(Link$1, {
                    to: "/",
                    children: jsxRuntime.exports.jsx(BrandPill, {
                        clickable: !0
                    })
                })
            }), _.children]
        }), jsxRuntime.exports.jsxs("div", {
            className: `${_.children?"hidden sm:flex":"flex"} flex-row	gap-4`,
            children: [jsxRuntime.exports.jsx("a", {
                href: conf().DISCORD_LINK,
                target: "_blank",
                rel: "noreferrer",
                className: "text-2xl text-white",
                children: jsxRuntime.exports.jsx(IconPatch, {
                    icon: Icons.DISCORD,
                    clickable: !0
                })
            }), jsxRuntime.exports.jsx("a", {
                href: conf().GITHUB_LINK,
                target: "_blank",
                rel: "noreferrer",
                className: "text-2xl text-white",
                children: jsxRuntime.exports.jsx(IconPatch, {
                    icon: Icons.GITHUB,
                    clickable: !0
                })
            })]
        })]
    })
}

function ArrowLink(_) {
    const _e = _.direction || "right",
        et = !!_.url,
        tt = !!_.to,
        rt = jsxRuntime.exports.jsxs("span", {
            className: "group mt-1 inline-flex cursor-pointer items-center space-x-1 pr-1 font-bold text-bink-600 hover:text-bink-700 active:scale-95",
            children: [_e === "left" ? jsxRuntime.exports.jsx("span", {
                className: "text-xl transition-transform group-hover:-translate-x-1",
                children: jsxRuntime.exports.jsx(Icon, {
                    icon: Icons.ARROW_LEFT
                })
            }) : null, jsxRuntime.exports.jsx("span", {
                className: "flex-1",
                children: _.linkText
            }), _e === "right" ? jsxRuntime.exports.jsx("span", {
                className: "text-xl transition-transform group-hover:translate-x-1",
                children: jsxRuntime.exports.jsx(Icon, {
                    icon: Icons.ARROW_RIGHT
                })
            }) : null]
        });
    return et ? jsxRuntime.exports.jsx("a", {
        href: _.url,
        children: rt
    }) : tt ? jsxRuntime.exports.jsx(Link$1, {
        to: _.to,
        children: rt
    }) : jsxRuntime.exports.jsx("span", {
        onClick: () => _.onClick && _.onClick(),
        children: rt
    })
}

function NotFoundWrapper(_) {
    return jsxRuntime.exports.jsxs("div", {
        className: "h-screen flex-1",
        children: [jsxRuntime.exports.jsx(Navigation, {}), jsxRuntime.exports.jsx("div", {
            className: "flex h-full flex-col items-center justify-center p-5 text-center",
            children: _.children
        })]
    })
}

function NotFoundMedia() {
    const {
        t: _
    } = useTranslation();
    return jsxRuntime.exports.jsxs("div", {
        className: "flex flex-1 flex-col items-center justify-center p-5 text-center",
        children: [jsxRuntime.exports.jsx(IconPatch, {
            icon: Icons.EYE_SLASH,
            className: "mb-6 text-xl text-bink-600"
        }), jsxRuntime.exports.jsx(Title, {
            children: _("notFound.media.title")
        }), jsxRuntime.exports.jsx("p", {
            className: "mt-5 mb-12 max-w-sm",
            children: _("notFound.media.description")
        }), jsxRuntime.exports.jsx(ArrowLink, {
            to: "/",
            linkText: _("notFound.backArrow")
        })]
    })
}

function NotFoundProvider() {
    const {
        t: _
    } = useTranslation();
    return jsxRuntime.exports.jsxs("div", {
        className: "flex flex-1 flex-col items-center justify-center p-5 text-center",
        children: [jsxRuntime.exports.jsx(IconPatch, {
            icon: Icons.EYE_SLASH,
            className: "mb-6 text-xl text-bink-600"
        }), jsxRuntime.exports.jsx(Title, {
            children: _("notFound.provider.title")
        }), jsxRuntime.exports.jsx("p", {
            className: "mt-5 mb-12 max-w-sm",
            children: _("notFound.provider.description")
        }), jsxRuntime.exports.jsx(ArrowLink, {
            to: "/",
            linkText: _("notFound.backArrow")
        })]
    })
}

function NotFoundPage() {
    const {
        t: _
    } = useTranslation();
    return jsxRuntime.exports.jsxs(NotFoundWrapper, {
        children: [jsxRuntime.exports.jsx(IconPatch, {
            icon: Icons.EYE_SLASH,
            className: "mb-6 text-xl text-bink-600"
        }), jsxRuntime.exports.jsx(Title, {
            children: _("notFound.page.title")
        }), jsxRuntime.exports.jsx("p", {
            className: "mt-5 mb-12 max-w-sm",
            children: _("notFound.page.description")
        }), jsxRuntime.exports.jsx(ArrowLink, {
            to: "/",
            linkText: _("notFound.backArrow")
        })]
    })
}

function Paper(_) {
    return jsxRuntime.exports.jsx("div", {
        className: `bg-denim-200 lg:rounded-xl px-4 sm:px-8 md:px-12 py-6 sm:py-8 md:py-12 ${_.className}`,
        children: _.children
    })
}
const e$3 = typeof window > "u" || typeof document > "u";
let s$5 = e$3 ? react.exports.useEffect : react.exports.useLayoutEffect;

function s$4(_) {
    let _e = react.exports.useRef(_);
    return s$5(() => {
        _e.current = _
    }, [_]), _e
}

function i$2(_, _e) {
    let [et, tt] = react.exports.useState(_), rt = s$4(_);
    return s$5(() => tt(rt.current), [rt, tt, ..._e]), et
}

function t$1(_) {
    typeof queueMicrotask == "function" ? queueMicrotask(_) : Promise.resolve().then(_).catch(_e => setTimeout(() => {
        throw _e
    }))
}

function m$2() {
    let _ = [],
        _e = [],
        et = {
            enqueue(tt) {
                _e.push(tt)
            },
            addEventListener(tt, rt, nt, at) {
                return tt.addEventListener(rt, nt, at), et.add(() => tt.removeEventListener(rt, nt, at))
            },
            requestAnimationFrame(...tt) {
                let rt = requestAnimationFrame(...tt);
                return et.add(() => cancelAnimationFrame(rt))
            },
            nextFrame(...tt) {
                return et.requestAnimationFrame(() => et.requestAnimationFrame(...tt))
            },
            setTimeout(...tt) {
                let rt = setTimeout(...tt);
                return et.add(() => clearTimeout(rt))
            },
            microTask(...tt) {
                let rt = {
                    current: !0
                };
                return t$1(() => {
                    rt.current && tt[0]()
                }), et.add(() => {
                    rt.current = !1
                })
            },
            add(tt) {
                return _.push(tt), () => {
                    let rt = _.indexOf(tt);
                    if (rt >= 0) {
                        let [nt] = _.splice(rt, 1);
                        nt()
                    }
                }
            },
            dispose() {
                for (let tt of _.splice(0)) tt()
            },
            async workQueue() {
                for (let tt of _e.splice(0)) await tt()
            }
        };
    return et
}

function p$2() {
    let [_] = react.exports.useState(m$2);
    return react.exports.useEffect(() => () => _.dispose(), [_]), _
}
let o$2 = function(_) {
        let _e = s$4(_);
        return React.useCallback((...et) => _e.current(...et), [_e])
    },
    r$2 = {
        serverHandoffComplete: !1
    };

function a$2() {
    let [_, _e] = react.exports.useState(r$2.serverHandoffComplete);
    return react.exports.useEffect(() => {
        _ !== !0 && _e(!0)
    }, [_]), react.exports.useEffect(() => {
        r$2.serverHandoffComplete === !1 && (r$2.serverHandoffComplete = !0)
    }, []), _
}
var u$3;
let l$1 = 0;

function r$1() {
    return ++l$1
}
let I$1 = (u$3 = React.useId) != null ? u$3 : function() {
    let _ = a$2(),
        [_e, et] = React.useState(_ ? r$1 : null);
    return s$5(() => {
        _e === null && et(r$1())
    }, [_e]), _e != null ? "" + _e : void 0
};

function u$2(_, _e, ...et) {
    if (_ in _e) {
        let rt = _e[_];
        return typeof rt == "function" ? rt(...et) : rt
    }
    let tt = new Error(`Tried to handle "${_}" but there is no handler defined. Only defined handlers are: ${Object.keys(_e).map(rt=>`"${rt}"`).join(", ")}.`);
    throw Error.captureStackTrace && Error.captureStackTrace(tt, u$2), tt
}

function e$2(_) {
    return e$3 ? null : _ instanceof Node ? _.ownerDocument : _ != null && _.hasOwnProperty("current") && _.current instanceof Node ? _.current.ownerDocument : document
}
let m$1 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map(_ => `${_}:not([tabindex='-1'])`).join(",");
var T$2 = (_ => (_[_.First = 1] = "First", _[_.Previous = 2] = "Previous", _[_.Next = 4] = "Next", _[_.Last = 8] = "Last", _[_.WrapAround = 16] = "WrapAround", _[_.NoScroll = 32] = "NoScroll", _))(T$2 || {}),
    M$2 = (_ => (_[_.Error = 0] = "Error", _[_.Overflow = 1] = "Overflow", _[_.Success = 2] = "Success", _[_.Underflow = 3] = "Underflow", _))(M$2 || {}),
    b = (_ => (_[_.Previous = -1] = "Previous", _[_.Next = 1] = "Next", _))(b || {}),
    N = (_ => (_[_.Strict = 0] = "Strict", _[_.Loose = 1] = "Loose", _))(N || {});

function F$2(_, _e = 0) {
    var et;
    return _ === ((et = e$2(_)) == null ? void 0 : et.body) ? !1 : u$2(_e, {
        [0]() {
            return _.matches(m$1)
        },
        [1]() {
            let tt = _;
            for (; tt !== null;) {
                if (tt.matches(m$1)) return !0;
                tt = tt.parentElement
            }
            return !1
        }
    })
}

function S$1(_, _e = et => et) {
    return _.slice().sort((et, tt) => {
        let rt = _e(et),
            nt = _e(tt);
        if (rt === null || nt === null) return 0;
        let at = rt.compareDocumentPosition(nt);
        return at & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : at & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0
    })
}

function d(_, _e, et) {
    let tt = s$4(_e);
    react.exports.useEffect(() => {
        function rt(nt) {
            tt.current(nt)
        }
        return document.addEventListener(_, rt, et), () => document.removeEventListener(_, rt, et)
    }, [_, et])
}

function L(_, _e, et = !0) {
    let tt = react.exports.useRef(!1);
    react.exports.useEffect(() => {
        requestAnimationFrame(() => {
            tt.current = et
        })
    }, [et]);

    function rt(at, st) {
        if (!tt.current || at.defaultPrevented) return;
        let it = function lt(bt) {
                return typeof bt == "function" ? lt(bt()) : Array.isArray(bt) || bt instanceof Set ? bt : [bt]
            }(_),
            ut = st(at);
        if (ut !== null && ut.getRootNode().contains(ut)) {
            for (let lt of it) {
                if (lt === null) continue;
                let bt = lt instanceof HTMLElement ? lt : lt.current;
                if (bt != null && bt.contains(ut) || at.composed && at.composedPath().includes(bt)) return
            }
            return !F$2(ut, N.Loose) && ut.tabIndex !== -1 && at.preventDefault(), _e(at, ut)
        }
    }
    let nt = react.exports.useRef(null);
    d("mousedown", at => {
        var st, it;
        tt.current && (nt.current = ((it = (st = at.composedPath) == null ? void 0 : st.call(at)) == null ? void 0 : it[0]) || at.target)
    }, !0), d("click", at => {
        !nt.current || (rt(at, () => nt.current), nt.current = null)
    }, !0), d("blur", at => rt(at, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0)
}

function i$1(_) {
    var _e;
    if (_.type) return _.type;
    let et = (_e = _.as) != null ? _e : "button";
    if (typeof et == "string" && et.toLowerCase() === "button") return "button"
}

function s$3(_, _e) {
    let [et, tt] = react.exports.useState(() => i$1(_));
    return s$5(() => {
        tt(i$1(_))
    }, [_.type, _.as]), s$5(() => {
        et || !_e.current || _e.current instanceof HTMLButtonElement && !_e.current.hasAttribute("type") && tt("button")
    }, [et, _e]), et
}
let u$1 = Symbol();

function y(..._) {
    let _e = react.exports.useRef(_);
    react.exports.useEffect(() => {
        _e.current = _
    }, [_]);
    let et = o$2(tt => {
        for (let rt of _e.current) rt != null && (typeof rt == "function" ? rt(tt) : rt.current = tt)
    });
    return _.every(tt => tt == null || (tt == null ? void 0 : tt[u$1])) ? void 0 : et
}

function f$3(_) {
    throw new Error("Unexpected object: " + _)
}
var a$1 = (_ => (_[_.First = 0] = "First", _[_.Previous = 1] = "Previous", _[_.Next = 2] = "Next", _[_.Last = 3] = "Last", _[_.Specific = 4] = "Specific", _[_.Nothing = 5] = "Nothing", _))(a$1 || {});

function x(_, _e) {
    let et = _e.resolveItems();
    if (et.length <= 0) return null;
    let tt = _e.resolveActiveIndex(),
        rt = tt ?? -1,
        nt = (() => {
            switch (_.focus) {
                case 0:
                    return et.findIndex(at => !_e.resolveDisabled(at));
                case 1: {
                    let at = et.slice().reverse().findIndex((st, it, ut) => rt !== -1 && ut.length - it - 1 >= rt ? !1 : !_e.resolveDisabled(st));
                    return at === -1 ? at : et.length - 1 - at
                }
                case 2:
                    return et.findIndex((at, st) => st <= rt ? !1 : !_e.resolveDisabled(at));
                case 3: {
                    let at = et.slice().reverse().findIndex(st => !_e.resolveDisabled(st));
                    return at === -1 ? at : et.length - 1 - at
                }
                case 4:
                    return et.findIndex(at => _e.resolveId(at) === _.id);
                case 5:
                    return null;
                default:
                    f$3(_)
            }
        })();
    return nt === -1 ? tt : nt
}
var S = (_ => (_[_.None = 0] = "None", _[_.RenderStrategy = 1] = "RenderStrategy", _[_.Static = 2] = "Static", _))(S || {}),
    j = (_ => (_[_.Unmount = 0] = "Unmount", _[_.Hidden = 1] = "Hidden", _))(j || {});

function $({
    ourProps: _,
    theirProps: _e,
    slot: et,
    defaultTag: tt,
    features: rt,
    visible: nt = !0,
    name: at
}) {
    let st = T$1(_e, _);
    if (nt) return p$1(st, et, tt, at);
    let it = rt ?? 0;
    if (it & 2) {
        let {
            static: ut = !1,
            ...lt
        } = st;
        if (ut) return p$1(lt, et, tt, at)
    }
    if (it & 1) {
        let {
            unmount: ut = !0,
            ...lt
        } = st;
        return u$2(ut ? 0 : 1, {
            [0]() {
                return null
            },
            [1]() {
                return p$1({
                    ...lt,
                    hidden: !0,
                    style: {
                        display: "none"
                    }
                }, et, tt, at)
            }
        })
    }
    return p$1(st, et, tt, at)
}

function p$1(_, _e = {}, et, tt) {
    let {
        as: rt = et,
        children: nt,
        refName: at = "ref",
        ...st
    } = m(_, ["unmount", "static"]), it = _.ref !== void 0 ? {
        [at]: _.ref
    } : {}, ut = typeof nt == "function" ? nt(_e) : nt;
    st.className && typeof st.className == "function" && (st.className = st.className(_e));
    let lt = {};
    if (_e) {
        let bt = !1,
            pt = [];
        for (let [It, At] of Object.entries(_e)) typeof At == "boolean" && (bt = !0), At === !0 && pt.push(It);
        bt && (lt["data-headlessui-state"] = pt.join(" "))
    }
    if (rt === react.exports.Fragment && Object.keys(F$1(st)).length > 0) {
        if (!react.exports.isValidElement(ut) || Array.isArray(ut) && ut.length > 1) throw new Error(['Passing props on "Fragment"!', "", `The current component <${tt} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(st).map(bt => `  - ${bt}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map(bt => `  - ${bt}`).join(`
`)].join(`
`));
        return react.exports.cloneElement(ut, Object.assign({}, T$1(ut.props, F$1(m(st, ["ref"]))), lt, it, w(ut.ref, it.ref)))
    }
    return react.exports.createElement(rt, Object.assign({}, m(st, ["ref"]), rt !== react.exports.Fragment && it, rt !== react.exports.Fragment && lt), ut)
}

function w(..._) {
    return {
        ref: _.every(_e => _e == null) ? void 0 : _e => {
            for (let et of _) et != null && (typeof et == "function" ? et(_e) : et.current = _e)
        }
    }
}

function T$1(..._) {
    if (_.length === 0) return {};
    if (_.length === 1) return _[0];
    let _e = {},
        et = {};
    for (let tt of _)
        for (let rt in tt) rt.startsWith("on") && typeof tt[rt] == "function" ? (et[rt] != null || (et[rt] = []), et[rt].push(tt[rt])) : _e[rt] = tt[rt];
    if (_e.disabled || _e["aria-disabled"]) return Object.assign(_e, Object.fromEntries(Object.keys(et).map(tt => [tt, void 0])));
    for (let tt in et) Object.assign(_e, {
        [tt](rt, ...nt) {
            let at = et[tt];
            for (let st of at) {
                if ((rt instanceof Event || (rt == null ? void 0 : rt.nativeEvent) instanceof Event) && rt.defaultPrevented) return;
                st(rt, ...nt)
            }
        }
    });
    return _e
}

function C$1(_) {
    var _e;
    return Object.assign(react.exports.forwardRef(_), {
        displayName: (_e = _.displayName) != null ? _e : _.name
    })
}

function F$1(_) {
    let _e = Object.assign({}, _);
    for (let et in _e) _e[et] === void 0 && delete _e[et];
    return _e
}

function m(_, _e = []) {
    let et = Object.assign({}, _);
    for (let tt of _e) tt in et && delete et[tt];
    return et
}

function r(_) {
    let _e = _.parentElement,
        et = null;
    for (; _e && !(_e instanceof HTMLFieldSetElement);) _e instanceof HTMLLegendElement && (et = _e), _e = _e.parentElement;
    let tt = (_e == null ? void 0 : _e.getAttribute("disabled")) === "";
    return tt && i(et) ? !1 : tt
}

function i(_) {
    if (!_) return !1;
    let _e = _.previousElementSibling;
    for (; _e !== null;) {
        if (_e instanceof HTMLLegendElement) return !1;
        _e = _e.previousElementSibling
    }
    return !0
}

function e$1(_ = {}, _e = null, et = []) {
    for (let [tt, rt] of Object.entries(_)) f$2(et, s$2(_e, tt), rt);
    return et
}

function s$2(_, _e) {
    return _ ? _ + "[" + _e + "]" : _e
}

function f$2(_, _e, et) {
    if (Array.isArray(et))
        for (let [tt, rt] of et.entries()) f$2(_, s$2(_e, tt.toString()), rt);
    else et instanceof Date ? _.push([_e, et.toISOString()]) : typeof et == "boolean" ? _.push([_e, et ? "1" : "0"]) : typeof et == "string" ? _.push([_e, et]) : typeof et == "number" ? _.push([_e, `${et}`]) : et == null ? _.push([_e, ""]) : e$1(et, _e, _)
}
let a = "div";
var s$1 = (_ => (_[_.None = 1] = "None", _[_.Focusable = 2] = "Focusable", _[_.Hidden = 4] = "Hidden", _))(s$1 || {});
let h = C$1(function(_, _e) {
        let {
            features: et = 1,
            ...tt
        } = _, rt = {
            ref: _e,
            "aria-hidden": (et & 2) === 2 ? !0 : void 0,
            style: {
                position: "fixed",
                top: 1,
                left: 1,
                width: 1,
                height: 0,
                padding: 0,
                margin: -1,
                overflow: "hidden",
                clip: "rect(0, 0, 0, 0)",
                whiteSpace: "nowrap",
                borderWidth: "0",
                ...(et & 4) === 4 && (et & 2) !== 2 && {
                    display: "none"
                }
            }
        };
        return $({
            ourProps: rt,
            theirProps: tt,
            slot: {},
            defaultTag: a,
            name: "Hidden"
        })
    }),
    o$1 = react.exports.createContext(null);
o$1.displayName = "OpenClosedContext";
var p = (_ => (_[_.Open = 0] = "Open", _[_.Closed = 1] = "Closed", _))(p || {});

function s() {
    return react.exports.useContext(o$1)
}

function C({
    value: _,
    children: _e
}) {
    return React.createElement(o$1.Provider, {
        value: _
    }, _e)
}
var o = (_ => (_.Space = " ", _.Enter = "Enter", _.Escape = "Escape", _.Backspace = "Backspace", _.Delete = "Delete", _.ArrowLeft = "ArrowLeft", _.ArrowUp = "ArrowUp", _.ArrowRight = "ArrowRight", _.ArrowDown = "ArrowDown", _.Home = "Home", _.End = "End", _.PageUp = "PageUp", _.PageDown = "PageDown", _.Tab = "Tab", _))(o || {});

function T(_, _e, et) {
    let [tt, rt] = react.exports.useState(et), nt = _ !== void 0, at = react.exports.useRef(nt), st = react.exports.useRef(!1), it = react.exports.useRef(!1);
    return nt && !at.current && !st.current ? (st.current = !0, at.current = nt, console.error("A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.")) : !nt && at.current && !it.current && (it.current = !0, at.current = nt, console.error("A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.")), [nt ? _ : tt, o$2(ut => (nt || rt(ut), _e == null ? void 0 : _e(ut)))]
}

function t(_) {
    return [_.screenX, _.screenY]
}

function u() {
    let _ = react.exports.useRef([-1, -1]);
    return {
        wasMoved(_e) {
            let et = t(_e);
            return _.current[0] === et[0] && _.current[1] === et[1] ? !1 : (_.current = et, !0)
        },
        update(_e) {
            _.current = t(_e)
        }
    }
}

function f$1() {
    let _ = react.exports.useRef(!1);
    return s$5(() => (_.current = !0, () => {
        _.current = !1
    }), []), _
}
var Ue = (_ => (_[_.Open = 0] = "Open", _[_.Closed = 1] = "Closed", _))(Ue || {}),
    Be = (_ => (_[_.Single = 0] = "Single", _[_.Multi = 1] = "Multi", _))(Be || {}),
    He = (_ => (_[_.Pointer = 0] = "Pointer", _[_.Other = 1] = "Other", _))(He || {}),
    Ge = (_ => (_[_.OpenListbox = 0] = "OpenListbox", _[_.CloseListbox = 1] = "CloseListbox", _[_.GoToOption = 2] = "GoToOption", _[_.Search = 3] = "Search", _[_.ClearSearch = 4] = "ClearSearch", _[_.RegisterOption = 5] = "RegisterOption", _[_.UnregisterOption = 6] = "UnregisterOption", _[_.RegisterLabel = 7] = "RegisterLabel", _))(Ge || {});

function q(_, _e = et => et) {
    let et = _.activeOptionIndex !== null ? _.options[_.activeOptionIndex] : null,
        tt = S$1(_e(_.options.slice()), nt => nt.dataRef.current.domRef.current),
        rt = et ? tt.indexOf(et) : null;
    return rt === -1 && (rt = null), {
        options: tt,
        activeOptionIndex: rt
    }
}
let je = {
        [1](_) {
            return _.dataRef.current.disabled || _.listboxState === 1 ? _ : {
                ..._,
                activeOptionIndex: null,
                listboxState: 1
            }
        },
        [0](_) {
            if (_.dataRef.current.disabled || _.listboxState === 0) return _;
            let _e = _.activeOptionIndex,
                {
                    isSelected: et
                } = _.dataRef.current,
                tt = _.options.findIndex(rt => et(rt.dataRef.current.value));
            return tt !== -1 && (_e = tt), {
                ..._,
                listboxState: 0,
                activeOptionIndex: _e
            }
        },
        [2](_, _e) {
            var et;
            if (_.dataRef.current.disabled || _.listboxState === 1) return _;
            let tt = q(_),
                rt = x(_e, {
                    resolveItems: () => tt.options,
                    resolveActiveIndex: () => tt.activeOptionIndex,
                    resolveId: nt => nt.id,
                    resolveDisabled: nt => nt.dataRef.current.disabled
                });
            return {
                ..._,
                ...tt,
                searchQuery: "",
                activeOptionIndex: rt,
                activationTrigger: (et = _e.trigger) != null ? et : 1
            }
        },
        [3]: (_, _e) => {
            if (_.dataRef.current.disabled || _.listboxState === 1) return _;
            let et = _.searchQuery !== "" ? 0 : 1,
                tt = _.searchQuery + _e.value.toLowerCase(),
                rt = (_.activeOptionIndex !== null ? _.options.slice(_.activeOptionIndex + et).concat(_.options.slice(0, _.activeOptionIndex + et)) : _.options).find(at => {
                    var st;
                    return !at.dataRef.current.disabled && ((st = at.dataRef.current.textValue) == null ? void 0 : st.startsWith(tt))
                }),
                nt = rt ? _.options.indexOf(rt) : -1;
            return nt === -1 || nt === _.activeOptionIndex ? {
                ..._,
                searchQuery: tt
            } : {
                ..._,
                searchQuery: tt,
                activeOptionIndex: nt,
                activationTrigger: 1
            }
        },
        [4](_) {
            return _.dataRef.current.disabled || _.listboxState === 1 || _.searchQuery === "" ? _ : {
                ..._,
                searchQuery: ""
            }
        },
        [5]: (_, _e) => {
            let et = {
                    id: _e.id,
                    dataRef: _e.dataRef
                },
                tt = q(_, rt => [...rt, et]);
            return _.activeOptionIndex === null && _.dataRef.current.isSelected(_e.dataRef.current.value) && (tt.activeOptionIndex = tt.options.indexOf(et)), {
                ..._,
                ...tt
            }
        },
        [6]: (_, _e) => {
            let et = q(_, tt => {
                let rt = tt.findIndex(nt => nt.id === _e.id);
                return rt !== -1 && tt.splice(rt, 1), tt
            });
            return {
                ..._,
                ...et,
                activationTrigger: 1
            }
        },
        [7]: (_, _e) => ({
            ..._,
            labelId: _e.id
        })
    },
    X = react.exports.createContext(null);
X.displayName = "ListboxActionsContext";

function B(_) {
    let _e = react.exports.useContext(X);
    if (_e === null) {
        let et = new Error(`<${_} /> is missing a parent <Listbox /> component.`);
        throw Error.captureStackTrace && Error.captureStackTrace(et, B), et
    }
    return _e
}
let J$1 = react.exports.createContext(null);
J$1.displayName = "ListboxDataContext";

function H(_) {
    let _e = react.exports.useContext(J$1);
    if (_e === null) {
        let et = new Error(`<${_} /> is missing a parent <Listbox /> component.`);
        throw Error.captureStackTrace && Error.captureStackTrace(et, H), et
    }
    return _e
}

function Ke(_, _e) {
    return u$2(_e.type, je, _, _e)
}
let Ve = react.exports.Fragment,
    Ne = C$1(function(_, _e) {
        let {
            value: et,
            defaultValue: tt,
            name: rt,
            onChange: nt,
            by: at = (Nt, $t) => Nt === $t,
            disabled: st = !1,
            horizontal: it = !1,
            multiple: ut = !1,
            ...lt
        } = _;
        const bt = it ? "horizontal" : "vertical";
        let pt = y(_e),
            [It = ut ? [] : void 0, At] = T(et, nt, tt),
            [Ct, ht] = react.exports.useReducer(Ke, {
                dataRef: react.exports.createRef(),
                listboxState: 1,
                options: [],
                searchQuery: "",
                labelId: null,
                activeOptionIndex: null,
                activationTrigger: 1
            }),
            ot = react.exports.useRef({
                static: !1,
                hold: !1
            }),
            ct = react.exports.useRef(null),
            Et = react.exports.useRef(null),
            Dt = react.exports.useRef(null),
            Pt = o$2(typeof at == "string" ? (Nt, $t) => {
                let jt = at;
                return (Nt == null ? void 0 : Nt[jt]) === ($t == null ? void 0 : $t[jt])
            } : at),
            gt = react.exports.useCallback(Nt => u$2(ft.mode, {
                [1]: () => It.some($t => Pt($t, Nt)),
                [0]: () => Pt(It, Nt)
            }), [It]),
            ft = react.exports.useMemo(() => ({
                ...Ct,
                value: It,
                disabled: st,
                mode: ut ? 1 : 0,
                orientation: bt,
                compare: Pt,
                isSelected: gt,
                optionsPropsRef: ot,
                labelRef: ct,
                buttonRef: Et,
                optionsRef: Dt
            }), [It, st, ut, Ct]);
        s$5(() => {
            Ct.dataRef.current = ft
        }, [ft]), L([ft.buttonRef, ft.optionsRef], (Nt, $t) => {
            var jt;
            ht({
                type: 1
            }), F$2($t, N.Loose) || (Nt.preventDefault(), (jt = ft.buttonRef.current) == null || jt.focus())
        }, ft.listboxState === 0);
        let dt = react.exports.useMemo(() => ({
                open: ft.listboxState === 0,
                disabled: st,
                value: It
            }), [ft, st, It]),
            St = o$2(Nt => {
                let $t = ft.options.find(jt => jt.id === Nt);
                !$t || Ft($t.dataRef.current.value)
            }),
            _t = o$2(() => {
                if (ft.activeOptionIndex !== null) {
                    let {
                        dataRef: Nt,
                        id: $t
                    } = ft.options[ft.activeOptionIndex];
                    Ft(Nt.current.value), ht({
                        type: 2,
                        focus: a$1.Specific,
                        id: $t
                    })
                }
            }),
            vt = o$2(() => ht({
                type: 0
            })),
            mt = o$2(() => ht({
                type: 1
            })),
            xt = o$2((Nt, $t, jt) => Nt === a$1.Specific ? ht({
                type: 2,
                focus: a$1.Specific,
                id: $t,
                trigger: jt
            }) : ht({
                type: 2,
                focus: Nt,
                trigger: jt
            })),
            yt = o$2((Nt, $t) => (ht({
                type: 5,
                id: Nt,
                dataRef: $t
            }), () => ht({
                type: 6,
                id: Nt
            }))),
            Tt = o$2(Nt => (ht({
                type: 7,
                id: Nt
            }), () => ht({
                type: 7,
                id: null
            }))),
            Ft = o$2(Nt => u$2(ft.mode, {
                [0]() {
                    return At == null ? void 0 : At(Nt)
                },
                [1]() {
                    let $t = ft.value.slice(),
                        jt = $t.findIndex(Ut => Pt(Ut, Nt));
                    return jt === -1 ? $t.push(Nt) : $t.splice(jt, 1), At == null ? void 0 : At($t)
                }
            })),
            wt = o$2(Nt => ht({
                type: 3,
                value: Nt
            })),
            kt = o$2(() => ht({
                type: 4
            })),
            Ot = react.exports.useMemo(() => ({
                onChange: Ft,
                registerOption: yt,
                registerLabel: Tt,
                goToOption: xt,
                closeListbox: mt,
                openListbox: vt,
                selectActiveOption: _t,
                selectOption: St,
                search: wt,
                clearSearch: kt
            }), []),
            Rt = {
                ref: pt
            },
            Lt = react.exports.useRef(null),
            Bt = p$2();
        return react.exports.useEffect(() => {
            !Lt.current || tt !== void 0 && Bt.addEventListener(Lt.current, "reset", () => {
                Ft(tt)
            })
        }, [Lt, Ft]), React.createElement(X.Provider, {
            value: Ot
        }, React.createElement(J$1.Provider, {
            value: ft
        }, React.createElement(C, {
            value: u$2(ft.listboxState, {
                [0]: p.Open,
                [1]: p.Closed
            })
        }, rt != null && It != null && e$1({
            [rt]: It
        }).map(([Nt, $t], jt) => React.createElement(h, {
            features: s$1.Hidden,
            ref: jt === 0 ? Ut => {
                var Ht;
                Lt.current = (Ht = Ut == null ? void 0 : Ut.closest("form")) != null ? Ht : null
            } : void 0,
            ...F$1({
                key: Nt,
                as: "input",
                type: "hidden",
                hidden: !0,
                readOnly: !0,
                name: Nt,
                value: $t
            })
        })), $({
            ourProps: Rt,
            theirProps: lt,
            slot: dt,
            defaultTag: Ve,
            name: "Listbox"
        }))))
    }),
    We = "button",
    Qe = C$1(function(_, _e) {
        var et;
        let tt = I$1(),
            {
                id: rt = `headlessui-listbox-button-${tt}`,
                ...nt
            } = _,
            at = H("Listbox.Button"),
            st = B("Listbox.Button"),
            it = y(at.buttonRef, _e),
            ut = p$2(),
            lt = o$2(ht => {
                switch (ht.key) {
                    case o.Space:
                    case o.Enter:
                    case o.ArrowDown:
                        ht.preventDefault(), st.openListbox(), ut.nextFrame(() => {
                            at.value || st.goToOption(a$1.First)
                        });
                        break;
                    case o.ArrowUp:
                        ht.preventDefault(), st.openListbox(), ut.nextFrame(() => {
                            at.value || st.goToOption(a$1.Last)
                        });
                        break
                }
            }),
            bt = o$2(ht => {
                switch (ht.key) {
                    case o.Space:
                        ht.preventDefault();
                        break
                }
            }),
            pt = o$2(ht => {
                if (r(ht.currentTarget)) return ht.preventDefault();
                at.listboxState === 0 ? (st.closeListbox(), ut.nextFrame(() => {
                    var ot;
                    return (ot = at.buttonRef.current) == null ? void 0 : ot.focus({
                        preventScroll: !0
                    })
                })) : (ht.preventDefault(), st.openListbox())
            }),
            It = i$2(() => {
                if (at.labelId) return [at.labelId, rt].join(" ")
            }, [at.labelId, rt]),
            At = react.exports.useMemo(() => ({
                open: at.listboxState === 0,
                disabled: at.disabled,
                value: at.value
            }), [at]),
            Ct = {
                ref: it,
                id: rt,
                type: s$3(_, at.buttonRef),
                "aria-haspopup": !0,
                "aria-controls": (et = at.optionsRef.current) == null ? void 0 : et.id,
                "aria-expanded": at.disabled ? void 0 : at.listboxState === 0,
                "aria-labelledby": It,
                disabled: at.disabled,
                onKeyDown: lt,
                onKeyUp: bt,
                onClick: pt
            };
        return $({
            ourProps: Ct,
            theirProps: nt,
            slot: At,
            defaultTag: We,
            name: "Listbox.Button"
        })
    }),
    $e = "label",
    ze = C$1(function(_, _e) {
        let et = I$1(),
            {
                id: tt = `headlessui-listbox-label-${et}`,
                ...rt
            } = _,
            nt = H("Listbox.Label"),
            at = B("Listbox.Label"),
            st = y(nt.labelRef, _e);
        s$5(() => at.registerLabel(tt), [tt]);
        let it = o$2(() => {
                var lt;
                return (lt = nt.buttonRef.current) == null ? void 0 : lt.focus({
                    preventScroll: !0
                })
            }),
            ut = react.exports.useMemo(() => ({
                open: nt.listboxState === 0,
                disabled: nt.disabled
            }), [nt]);
        return $({
            ourProps: {
                ref: st,
                id: tt,
                onClick: it
            },
            theirProps: rt,
            slot: ut,
            defaultTag: $e,
            name: "Listbox.Label"
        })
    }),
    qe = "ul",
    Xe = S.RenderStrategy | S.Static,
    Je$1 = C$1(function(_, _e) {
        var et;
        let tt = I$1(),
            {
                id: rt = `headlessui-listbox-options-${tt}`,
                ...nt
            } = _,
            at = H("Listbox.Options"),
            st = B("Listbox.Options"),
            it = y(at.optionsRef, _e),
            ut = p$2(),
            lt = p$2(),
            bt = s(),
            pt = (() => bt !== null ? bt === p.Open : at.listboxState === 0)();
        react.exports.useEffect(() => {
            var ot;
            let ct = at.optionsRef.current;
            !ct || at.listboxState === 0 && ct !== ((ot = e$2(ct)) == null ? void 0 : ot.activeElement) && ct.focus({
                preventScroll: !0
            })
        }, [at.listboxState, at.optionsRef]);
        let It = o$2(ot => {
                switch (lt.dispose(), ot.key) {
                    case o.Space:
                        if (at.searchQuery !== "") return ot.preventDefault(), ot.stopPropagation(), st.search(ot.key);
                    case o.Enter:
                        if (ot.preventDefault(), ot.stopPropagation(), at.activeOptionIndex !== null) {
                            let {
                                dataRef: ct
                            } = at.options[at.activeOptionIndex];
                            st.onChange(ct.current.value)
                        }
                        at.mode === 0 && (st.closeListbox(), m$2().nextFrame(() => {
                            var ct;
                            return (ct = at.buttonRef.current) == null ? void 0 : ct.focus({
                                preventScroll: !0
                            })
                        }));
                        break;
                    case u$2(at.orientation, {
                        vertical: o.ArrowDown,
                        horizontal: o.ArrowRight
                    }):
                        return ot.preventDefault(), ot.stopPropagation(), st.goToOption(a$1.Next);
                    case u$2(at.orientation, {
                        vertical: o.ArrowUp,
                        horizontal: o.ArrowLeft
                    }):
                        return ot.preventDefault(), ot.stopPropagation(), st.goToOption(a$1.Previous);
                    case o.Home:
                    case o.PageUp:
                        return ot.preventDefault(), ot.stopPropagation(), st.goToOption(a$1.First);
                    case o.End:
                    case o.PageDown:
                        return ot.preventDefault(), ot.stopPropagation(), st.goToOption(a$1.Last);
                    case o.Escape:
                        return ot.preventDefault(), ot.stopPropagation(), st.closeListbox(), ut.nextFrame(() => {
                            var ct;
                            return (ct = at.buttonRef.current) == null ? void 0 : ct.focus({
                                preventScroll: !0
                            })
                        });
                    case o.Tab:
                        ot.preventDefault(), ot.stopPropagation();
                        break;
                    default:
                        ot.key.length === 1 && (st.search(ot.key), lt.setTimeout(() => st.clearSearch(), 350));
                        break
                }
            }),
            At = i$2(() => {
                var ot, ct, Et;
                return (Et = (ot = at.labelRef.current) == null ? void 0 : ot.id) != null ? Et : (ct = at.buttonRef.current) == null ? void 0 : ct.id
            }, [at.labelRef.current, at.buttonRef.current]),
            Ct = react.exports.useMemo(() => ({
                open: at.listboxState === 0
            }), [at]),
            ht = {
                "aria-activedescendant": at.activeOptionIndex === null || (et = at.options[at.activeOptionIndex]) == null ? void 0 : et.id,
                "aria-multiselectable": at.mode === 1 ? !0 : void 0,
                "aria-labelledby": At,
                "aria-orientation": at.orientation,
                id: rt,
                onKeyDown: It,
                role: "listbox",
                tabIndex: 0,
                ref: it
            };
        return $({
            ourProps: ht,
            theirProps: nt,
            slot: Ct,
            defaultTag: qe,
            features: Xe,
            visible: pt,
            name: "Listbox.Options"
        })
    }),
    Ye = "li",
    Ze = C$1(function(_, _e) {
        let et = I$1(),
            {
                id: tt = `headlessui-listbox-option-${et}`,
                disabled: rt = !1,
                value: nt,
                ...at
            } = _,
            st = H("Listbox.Option"),
            it = B("Listbox.Option"),
            ut = st.activeOptionIndex !== null ? st.options[st.activeOptionIndex].id === tt : !1,
            lt = st.isSelected(nt),
            bt = react.exports.useRef(null),
            pt = s$4({
                disabled: rt,
                value: nt,
                domRef: bt,
                get textValue() {
                    var Pt, gt;
                    return (gt = (Pt = bt.current) == null ? void 0 : Pt.textContent) == null ? void 0 : gt.toLowerCase()
                }
            }),
            It = y(_e, bt);
        s$5(() => {
            if (st.listboxState !== 0 || !ut || st.activationTrigger === 0) return;
            let Pt = m$2();
            return Pt.requestAnimationFrame(() => {
                var gt, ft;
                (ft = (gt = bt.current) == null ? void 0 : gt.scrollIntoView) == null || ft.call(gt, {
                    block: "nearest"
                })
            }), Pt.dispose
        }, [bt, ut, st.listboxState, st.activationTrigger, st.activeOptionIndex]), s$5(() => it.registerOption(tt, pt), [pt, tt]);
        let At = o$2(Pt => {
                if (rt) return Pt.preventDefault();
                it.onChange(nt), st.mode === 0 && (it.closeListbox(), m$2().nextFrame(() => {
                    var gt;
                    return (gt = st.buttonRef.current) == null ? void 0 : gt.focus({
                        preventScroll: !0
                    })
                }))
            }),
            Ct = o$2(() => {
                if (rt) return it.goToOption(a$1.Nothing);
                it.goToOption(a$1.Specific, tt)
            }),
            ht = u(),
            ot = o$2(Pt => ht.update(Pt)),
            ct = o$2(Pt => {
                !ht.wasMoved(Pt) || rt || ut || it.goToOption(a$1.Specific, tt, 0)
            }),
            Et = o$2(Pt => {
                !ht.wasMoved(Pt) || rt || !ut || it.goToOption(a$1.Nothing)
            }),
            Dt = react.exports.useMemo(() => ({
                active: ut,
                selected: lt,
                disabled: rt
            }), [ut, lt, rt]);
        return $({
            ourProps: {
                id: tt,
                ref: It,
                role: "option",
                tabIndex: rt === !0 ? void 0 : -1,
                "aria-disabled": rt === !0 ? !0 : void 0,
                "aria-selected": lt,
                disabled: void 0,
                onClick: At,
                onFocus: Ct,
                onPointerEnter: ot,
                onMouseEnter: ot,
                onPointerMove: ct,
                onMouseMove: ct,
                onPointerLeave: Et,
                onMouseLeave: Et
            },
            theirProps: at,
            slot: Dt,
            defaultTag: Ye,
            name: "Listbox.Option"
        })
    }),
    Mt = Object.assign(Ne, {
        Button: Qe,
        Label: ze,
        Options: Je$1,
        Option: Ze
    });

function l(_) {
    let _e = {
        called: !1
    };
    return (...et) => {
        if (!_e.called) return _e.called = !0, _(...et)
    }
}

function v(_, ..._e) {
    _ && _e.length > 0 && _.classList.add(..._e)
}

function f(_, ..._e) {
    _ && _e.length > 0 && _.classList.remove(..._e)
}

function F(_, _e) {
    let et = m$2();
    if (!_) return et.dispose;
    let {
        transitionDuration: tt,
        transitionDelay: rt
    } = getComputedStyle(_), [nt, at] = [tt, rt].map(st => {
        let [it = 0] = st.split(",").filter(Boolean).map(ut => ut.includes("ms") ? parseFloat(ut) : parseFloat(ut) * 1e3).sort((ut, lt) => lt - ut);
        return it
    });
    if (nt + at !== 0) {
        let st = et.addEventListener(_, "transitionend", it => {
            it.target === it.currentTarget && (_e(), st())
        })
    } else _e();
    return et.add(() => _e()), et.dispose
}

function M$1(_, _e, et, tt) {
    let rt = et ? "enter" : "leave",
        nt = m$2(),
        at = tt !== void 0 ? l(tt) : () => {};
    rt === "enter" && (_.removeAttribute("hidden"), _.style.display = "");
    let st = u$2(rt, {
            enter: () => _e.enter,
            leave: () => _e.leave
        }),
        it = u$2(rt, {
            enter: () => _e.enterTo,
            leave: () => _e.leaveTo
        }),
        ut = u$2(rt, {
            enter: () => _e.enterFrom,
            leave: () => _e.leaveFrom
        });
    return f(_, ..._e.enter, ..._e.enterTo, ..._e.enterFrom, ..._e.leave, ..._e.leaveFrom, ..._e.leaveTo, ..._e.entered), v(_, ...st, ...ut), nt.nextFrame(() => {
        f(_, ...ut), v(_, ...it), F(_, () => (f(_, ...st), v(_, ..._e.entered), at()))
    }), nt.dispose
}

function D({
    container: _,
    direction: _e,
    classes: et,
    onStart: tt,
    onStop: rt
}) {
    let nt = f$1(),
        at = p$2(),
        st = s$4(_e);
    s$5(() => {
        let it = m$2();
        at.add(it.dispose);
        let ut = _.current;
        if (ut && st.current !== "idle" && nt.current) return it.dispose(), tt.current(st.current), it.add(M$1(ut, et.current, st.current === "enter", () => {
            it.dispose(), rt.current(st.current)
        })), it.dispose
    }, [_e])
}

function e(..._) {
    return _.filter(Boolean).join(" ")
}

function P(_ = "") {
    return _.split(" ").filter(_e => _e.trim().length > 1)
}
let A = react.exports.createContext(null);
A.displayName = "TransitionContext";
var Ce = (_ => (_.Visible = "visible", _.Hidden = "hidden", _))(Ce || {});

function ge() {
    let _ = react.exports.useContext(A);
    if (_ === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
    return _
}

function be() {
    let _ = react.exports.useContext(M);
    if (_ === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
    return _
}
let M = react.exports.createContext(null);
M.displayName = "NestingContext";

function I(_) {
    return "children" in _ ? I(_.children) : _.current.filter(({
        el: _e
    }) => _e.current !== null).filter(({
        state: _e
    }) => _e === "visible").length > 0
}

function ne(_, _e) {
    let et = s$4(_),
        tt = react.exports.useRef([]),
        rt = f$1(),
        nt = p$2(),
        at = o$2((It, At = j.Hidden) => {
            let Ct = tt.current.findIndex(({
                el: ht
            }) => ht === It);
            Ct !== -1 && (u$2(At, {
                [j.Unmount]() {
                    tt.current.splice(Ct, 1)
                },
                [j.Hidden]() {
                    tt.current[Ct].state = "hidden"
                }
            }), nt.microTask(() => {
                var ht;
                !I(tt) && rt.current && ((ht = et.current) == null || ht.call(et))
            }))
        }),
        st = o$2(It => {
            let At = tt.current.find(({
                el: Ct
            }) => Ct === It);
            return At ? At.state !== "visible" && (At.state = "visible") : tt.current.push({
                el: It,
                state: "visible"
            }), () => at(It, j.Unmount)
        }),
        it = react.exports.useRef([]),
        ut = react.exports.useRef(Promise.resolve()),
        lt = react.exports.useRef({
            enter: [],
            leave: [],
            idle: []
        }),
        bt = o$2((It, At, Ct) => {
            it.current.splice(0), _e && (_e.chains.current[At] = _e.chains.current[At].filter(([ht]) => ht !== It)), _e == null || _e.chains.current[At].push([It, new Promise(ht => {
                it.current.push(ht)
            })]), _e == null || _e.chains.current[At].push([It, new Promise(ht => {
                Promise.all(lt.current[At].map(([ot, ct]) => ct)).then(() => ht())
            })]), At === "enter" ? ut.current = ut.current.then(() => _e == null ? void 0 : _e.wait.current).then(() => Ct(At)) : Ct(At)
        }),
        pt = o$2((It, At, Ct) => {
            Promise.all(lt.current[At].splice(0).map(([ht, ot]) => ot)).then(() => {
                var ht;
                (ht = it.current.shift()) == null || ht()
            }).then(() => Ct(At))
        });
    return react.exports.useMemo(() => ({
        children: tt,
        register: st,
        unregister: at,
        onStart: bt,
        onStop: pt,
        wait: ut,
        chains: lt
    }), [st, at, tt, bt, pt, lt, ut])
}

function Ee() {}
let Se = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];

function re(_) {
    var _e;
    let et = {};
    for (let tt of Se) et[tt] = (_e = _[tt]) != null ? _e : Ee;
    return et
}

function xe(_) {
    let _e = react.exports.useRef(re(_));
    return react.exports.useEffect(() => {
        _e.current = re(_)
    }, [_]), _e
}
let Pe = "div",
    ie = S.RenderStrategy,
    oe = C$1(function(_, _e) {
        let {
            beforeEnter: et,
            afterEnter: tt,
            beforeLeave: rt,
            afterLeave: nt,
            enter: at,
            enterFrom: st,
            enterTo: it,
            entered: ut,
            leave: lt,
            leaveFrom: bt,
            leaveTo: pt,
            ...It
        } = _, At = react.exports.useRef(null), Ct = y(At, _e), ht = It.unmount ? j.Unmount : j.Hidden, {
            show: ot,
            appear: ct,
            initial: Et
        } = ge(), [Dt, Pt] = react.exports.useState(ot ? "visible" : "hidden"), gt = be(), {
            register: ft,
            unregister: dt
        } = gt, St = react.exports.useRef(null);
        react.exports.useEffect(() => ft(At), [ft, At]), react.exports.useEffect(() => {
            if (ht === j.Hidden && At.current) {
                if (ot && Dt !== "visible") {
                    Pt("visible");
                    return
                }
                return u$2(Dt, {
                    hidden: () => dt(At),
                    visible: () => ft(At)
                })
            }
        }, [Dt, At, ft, dt, ot, ht]);
        let _t = s$4({
                enter: P(at),
                enterFrom: P(st),
                enterTo: P(it),
                entered: P(ut),
                leave: P(lt),
                leaveFrom: P(bt),
                leaveTo: P(pt)
            }),
            vt = xe({
                beforeEnter: et,
                afterEnter: tt,
                beforeLeave: rt,
                afterLeave: nt
            }),
            mt = a$2();
        react.exports.useEffect(() => {
            if (mt && Dt === "visible" && At.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?")
        }, [At, Dt, mt]);
        let xt = Et && !ct,
            yt = (() => !mt || xt || St.current === ot ? "idle" : ot ? "enter" : "leave")(),
            Tt = o$2(Rt => u$2(Rt, {
                enter: () => vt.current.beforeEnter(),
                leave: () => vt.current.beforeLeave(),
                idle: () => {}
            })),
            Ft = o$2(Rt => u$2(Rt, {
                enter: () => vt.current.afterEnter(),
                leave: () => vt.current.afterLeave(),
                idle: () => {}
            })),
            wt = ne(() => {
                Pt("hidden"), dt(At)
            }, gt);
        D({
            container: At,
            classes: _t,
            direction: yt,
            onStart: s$4(Rt => {
                wt.onStart(At, Rt, Tt)
            }),
            onStop: s$4(Rt => {
                wt.onStop(At, Rt, Ft), Rt === "leave" && !I(wt) && (Pt("hidden"), dt(At))
            })
        }), react.exports.useEffect(() => {
            !xt || (ht === j.Hidden ? St.current = null : St.current = ot)
        }, [ot, xt, Dt]);
        let kt = It,
            Ot = {
                ref: Ct
            };
        return ct && ot && (typeof window > "u" || typeof document > "u") && (kt = {
            ...kt,
            className: e(It.className, ..._t.current.enter, ..._t.current.enterFrom)
        }), React.createElement(M.Provider, {
            value: wt
        }, React.createElement(C, {
            value: u$2(Dt, {
                visible: p.Open,
                hidden: p.Closed
            })
        }, $({
            ourProps: Ot,
            theirProps: kt,
            defaultTag: Pe,
            features: ie,
            visible: Dt === "visible",
            name: "Transition.Child"
        })))
    }),
    J = C$1(function(_, _e) {
        let {
            show: et,
            appear: tt = !1,
            unmount: rt,
            ...nt
        } = _, at = react.exports.useRef(null), st = y(at, _e);
        a$2();
        let it = s();
        if (et === void 0 && it !== null && (et = u$2(it, {
                [p.Open]: !0,
                [p.Closed]: !1
            })), ![!0, !1].includes(et)) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
        let [ut, lt] = react.exports.useState(et ? "visible" : "hidden"), bt = ne(() => {
            lt("hidden")
        }), [pt, It] = react.exports.useState(!0), At = react.exports.useRef([et]);
        s$5(() => {
            pt !== !1 && At.current[At.current.length - 1] !== et && (At.current.push(et), It(!1))
        }, [At, et]);
        let Ct = react.exports.useMemo(() => ({
            show: et,
            appear: tt,
            initial: pt
        }), [et, tt, pt]);
        react.exports.useEffect(() => {
            if (et) lt("visible");
            else if (!I(bt)) lt("hidden");
            else {
                let ot = at.current;
                if (!ot) return;
                let ct = ot.getBoundingClientRect();
                ct.x === 0 && ct.y === 0 && ct.width === 0 && ct.height === 0 && lt("hidden")
            }
        }, [et, bt]);
        let ht = {
            unmount: rt
        };
        return React.createElement(M.Provider, {
            value: bt
        }, React.createElement(A.Provider, {
            value: Ct
        }, $({
            ourProps: {
                ...ht,
                as: react.exports.Fragment,
                children: React.createElement(oe, {
                    ref: st,
                    ...ht,
                    ...nt
                })
            },
            theirProps: {},
            defaultTag: react.exports.Fragment,
            features: ie,
            visible: ut === "visible",
            name: "Transition"
        })))
    }),
    ye = C$1(function(_, _e) {
        let et = react.exports.useContext(A) !== null,
            tt = s() !== null;
        return React.createElement(React.Fragment, null, !et && tt ? React.createElement(J, {
            ref: _e,
            ..._
        }) : React.createElement(oe, {
            ref: _e,
            ..._
        }))
    }),
    Je = Object.assign(J, {
        Child: ye,
        Root: J
    });

function Dropdown(_) {
    return jsxRuntime.exports.jsx("div", {
        className: "relative my-4 max-w-[18rem]",
        children: jsxRuntime.exports.jsx(Mt, {
            value: _.selectedItem,
            onChange: _.setSelectedItem,
            children: ({
                open: _e
            }) => jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, {
                children: [jsxRuntime.exports.jsxs(Mt.Button, {
                    className: "relative w-full cursor-default rounded-lg bg-denim-500 py-2 pl-3 pr-10 text-left text-white shadow-md focus:outline-none focus-visible:border-indigo-500 focus-visible:ring-2 focus-visible:ring-bink-500  focus-visible:ring-opacity-75 focus-visible:ring-offset-2 focus-visible:ring-offset-bink-300 sm:text-sm",
                    children: [jsxRuntime.exports.jsx("span", {
                        className: "block truncate",
                        children: _.selectedItem.name
                    }), jsxRuntime.exports.jsx("span", {
                        className: "pointer-events-none absolute inset-y-0 right-0 flex items-center pr-2",
                        children: jsxRuntime.exports.jsx(Icon, {
                            icon: Icons.CHEVRON_DOWN,
                            className: `transform transition-transform ${_e?"rotate-180":""}`
                        })
                    })]
                }), jsxRuntime.exports.jsx(Je, {
                    as: react.exports.Fragment,
                    leave: "transition ease-in duration-100",
                    leaveFrom: "opacity-100",
                    leaveTo: "opacity-0",
                    children: jsxRuntime.exports.jsx(Mt.Options, {
                        className: "absolute bottom-11 left-0 right-0 z-10 mt-1 max-h-60 overflow-auto rounded-md bg-denim-500 py-1 text-white shadow-lg ring-1 ring-black ring-opacity-5 scrollbar-thin scrollbar-track-denim-400 scrollbar-thumb-denim-200 focus:outline-none sm:bottom-10 sm:text-sm",
                        children: _.options.map(et => jsxRuntime.exports.jsx(Mt.Option, {
                            className: ({
                                active: tt
                            }) => `relative cursor-default select-none py-2 pl-10 pr-4 ${tt?"bg-denim-400 text-bink-700":"text-white"}`,
                            value: et,
                            children: et.name
                        }, et.id))
                    })
                })]
            })
        })
    })
}

function Episode(_) {
    return jsxRuntime.exports.jsxs("div", {
        onClick: _.onClick,
        className: `bg-denim-500 hover:bg-denim-400 transition-[background-color, transform, box-shadow] relative mr-3 mb-3 inline-flex h-10 w-10 cursor-pointer select-none items-center justify-center overflow-hidden rounded font-bold text-white active:scale-110 ${_.active?"shadow-bink-500 shadow-[inset_0_0_0_2px]":""}`,
        children: [jsxRuntime.exports.jsx("div", {
            className: "bg-bink-500 absolute bottom-0 top-0 left-0 bg-opacity-50",
            style: {
                width: `${_.progress||0}%`
            }
        }), jsxRuntime.exports.jsx("span", {
            className: "relative",
            children: _.episodeNumber
        })]
    })
}

function WatchedEpisode(_) {
    var nt;
    const {
        watched: _e
    } = useWatchedContext(), et = getWatchedFromPortable(_e.items, _.media), tt = getEpisodeFromMedia(_.media), rt = et && et.percentage || 0;
    return jsxRuntime.exports.jsx(Episode, {
        progress: rt,
        episodeNumber: ((nt = tt == null ? void 0 : tt.episode) == null ? void 0 : nt.sort) ?? 1,
        active: _.active,
        onClick: _.onClick
    })
}

function useLoading(_) {
    const [_e, et] = react.exports.useState(!1), [tt, rt] = react.exports.useState(!1), [nt, at] = react.exports.useState(void 0), st = react.exports.useRef(!0), it = react.exports.useMemo(() => _, []);
    return React.useEffect(() => (st.current = !0, () => {
        st.current = !1
    }), []), [react.exports.useMemo(() => async (...lt) => (et(!0), rt(!1), at(void 0), new Promise(bt => {
        it(...lt).then(pt => st.current ? (rt(!0), bt(pt), null) : bt(void 0)).catch(pt => {
            st && (at(pt), rt(!1)), bt(void 0)
        })
    }).finally(() => st.current && et(!1))), [it]), _e, nt, tt]
}

function deserializePortableMedia(_) {
    return JSON.parse(atob(decodeURIComponent(_)))
}

function serializePortableMedia(_) {
    return encodeURIComponent(btoa(JSON.stringify(_)))
}

function usePortableMedia() {
    const {
        media: _
    } = useParams(), [_e, et] = react.exports.useState(void 0);
    return react.exports.useEffect(() => {
        try {
            et(deserializePortableMedia(_))
        } catch (tt) {
            console.error("Failed to deserialize portable media", tt), et(void 0)
        }
    }, [_, et]), _e
}
const seasonCache = new SimpleCache;
seasonCache.setCompare((_, _e) => _.mediaId === _e.mediaId && _.providerId === _e.providerId);
seasonCache.initialize();
async function getSeasonDataFromMedia(_) {
    const _e = getProviderFromId(_.providerId);
    if (!_e) return {
        seasons: []
    };
    if (!_e.type.includes(MWMediaType.SERIES) && !_e.type.includes(MWMediaType.ANIME)) return {
        seasons: []
    };
    if (seasonCache.has(_)) return seasonCache.get(_);
    const et = await _e.getSeasonDataFromMedia(_);
    return et.seasons.sort((tt, rt) => tt.sort - rt.sort), et.seasons.forEach(tt => tt.episodes.sort((rt, nt) => rt.sort - nt.sort)), seasonCache.set(_, et, 60 * 60), et
}

function LoadingSeasons(_) {
    const {
        t: _e
    } = useTranslation();
    return jsxRuntime.exports.jsxs("div", {
        children: [jsxRuntime.exports.jsx("div", {
            children: jsxRuntime.exports.jsx("div", {
                className: "mb-3 mt-5 h-10  w-56 rounded bg-denim-400 opacity-50"
            })
        }), _.error ? jsxRuntime.exports.jsxs("div", {
            className: "flex items-center space-x-3",
            children: [jsxRuntime.exports.jsx(IconPatch, {
                icon: Icons.WARNING,
                className: "text-red-400"
            }), jsxRuntime.exports.jsx("p", {
                children: _e("seasons.failed")
            })]
        }) : jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, {
            children: [jsxRuntime.exports.jsx("div", {
                className: "mr-3 mb-3 inline-block h-10 w-10 rounded bg-denim-400 opacity-50"
            }), jsxRuntime.exports.jsx("div", {
                className: "mr-3 mb-3 inline-block h-10 w-10 rounded bg-denim-400 opacity-50"
            }), jsxRuntime.exports.jsx("div", {
                className: "mr-3 mb-3 inline-block h-10 w-10 rounded bg-denim-400 opacity-50"
            })]
        })]
    })
}

function Seasons(_) {
    var ht;
    const {
        t: _e
    } = useTranslation(), [et, tt, rt, nt] = useLoading(ot => getSeasonDataFromMedia(ot)), at = useHistory(), [st, it] = react.exports.useState({
        seasons: []
    }), ut = _.media.seasonId, lt = _.media.episodeId;
    react.exports.useEffect(() => {
        (async () => {
            const ot = await et(_.media);
            it(ot)
        })()
    }, [et, _.media]);

    function bt(ot, ct) {
        const Et = {
            ..._.media
        };
        Et.episodeId = ct, Et.seasonId = ot, at.replace(`/media/${Et.mediaType}/${serializePortableMedia(convertMediaToPortable(Et))}`)
    }
    const pt = ot => ({
            id: ot.id,
            name: ot.title || `${_e("seasons.season",{season:ot.sort})}`
        }),
        It = st.seasons.map(pt),
        At = st.seasons.find(ot => ot.id === ut),
        Ct = At ? pt(At) : null;
    return jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, {
        children: [tt ? jsxRuntime.exports.jsx(LoadingSeasons, {}) : null, rt ? jsxRuntime.exports.jsx(LoadingSeasons, {
            error: !0
        }) : null, nt && st.seasons.length ? jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, {
            children: [jsxRuntime.exports.jsx(Dropdown, {
                selectedItem: Ct,
                options: It,
                setSelectedItem: ot => {
                    var ct;
                    return bt(ot.id, (ct = st.seasons.find(Et => Et.id === ot.id)) == null ? void 0 : ct.episodes[0].id)
                }
            }), (ht = st.seasons.find(ot => ot.id === ut)) == null ? void 0 : ht.episodes.map(ot => jsxRuntime.exports.jsx(WatchedEpisode, {
                media: {
                    ..._.media,
                    seriesData: st,
                    episodeId: ot.id,
                    seasonId: ut
                },
                active: ot.id === lt,
                onClick: () => bt(ut, ot.id)
            }, ot.id))]
        }) : null]
    })
}
var hls = {
    exports: {}
};
(function(_, _e) {
    typeof window < "u" && function(tt, rt) {
        _.exports = rt()
    }(commonjsGlobal$1, () => (() => {
        var et = {
                "./src/config.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        enableStreamingMode: () => Ft,
                        hlsDefaultConfig: () => xt,
                        mergeConfig: () => Tt
                    });
                    var ut = it("./src/controller/abr-controller.ts"),
                        lt = it("./src/controller/audio-stream-controller.ts"),
                        bt = it("./src/controller/audio-track-controller.ts"),
                        pt = it("./src/controller/subtitle-stream-controller.ts"),
                        It = it("./src/controller/subtitle-track-controller.ts"),
                        At = it("./src/controller/buffer-controller.ts"),
                        Ct = it("./src/controller/timeline-controller.ts"),
                        ht = it("./src/controller/cap-level-controller.ts"),
                        ot = it("./src/controller/fps-controller.ts"),
                        ct = it("./src/controller/eme-controller.ts"),
                        Et = it("./src/controller/cmcd-controller.ts"),
                        Dt = it("./src/utils/xhr-loader.ts"),
                        Pt = it("./src/utils/fetch-loader.ts"),
                        gt = it("./src/utils/cues.ts"),
                        ft = it("./src/utils/mediakeys-helper.ts"),
                        dt = it("./src/utils/logger.ts");

                    function St() {
                        return St = Object.assign ? Object.assign.bind() : function(wt) {
                            for (var kt = 1; kt < arguments.length; kt++) {
                                var Ot = arguments[kt];
                                for (var Rt in Ot) Object.prototype.hasOwnProperty.call(Ot, Rt) && (wt[Rt] = Ot[Rt])
                            }
                            return wt
                        }, St.apply(this, arguments)
                    }

                    function _t(wt, kt) {
                        var Ot = Object.keys(wt);
                        if (Object.getOwnPropertySymbols) {
                            var Rt = Object.getOwnPropertySymbols(wt);
                            kt && (Rt = Rt.filter(function(Lt) {
                                return Object.getOwnPropertyDescriptor(wt, Lt).enumerable
                            })), Ot.push.apply(Ot, Rt)
                        }
                        return Ot
                    }

                    function vt(wt) {
                        for (var kt = 1; kt < arguments.length; kt++) {
                            var Ot = arguments[kt] != null ? arguments[kt] : {};
                            kt % 2 ? _t(Object(Ot), !0).forEach(function(Rt) {
                                mt(wt, Rt, Ot[Rt])
                            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(wt, Object.getOwnPropertyDescriptors(Ot)) : _t(Object(Ot)).forEach(function(Rt) {
                                Object.defineProperty(wt, Rt, Object.getOwnPropertyDescriptor(Ot, Rt))
                            })
                        }
                        return wt
                    }

                    function mt(wt, kt, Ot) {
                        return kt in wt ? Object.defineProperty(wt, kt, {
                            value: Ot,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : wt[kt] = Ot, wt
                    }
                    var xt = vt(vt({
                        autoStartLoad: !0,
                        startPosition: -1,
                        defaultAudioCodec: void 0,
                        debug: !1,
                        capLevelOnFPSDrop: !1,
                        capLevelToPlayerSize: !1,
                        ignoreDevicePixelRatio: !1,
                        initialLiveManifestSize: 1,
                        maxBufferLength: 30,
                        backBufferLength: 1 / 0,
                        maxBufferSize: 60 * 1e3 * 1e3,
                        maxBufferHole: .1,
                        highBufferWatchdogPeriod: 2,
                        nudgeOffset: .1,
                        nudgeMaxRetry: 3,
                        maxFragLookUpTolerance: .25,
                        liveSyncDurationCount: 3,
                        liveMaxLatencyDurationCount: 1 / 0,
                        liveSyncDuration: void 0,
                        liveMaxLatencyDuration: void 0,
                        maxLiveSyncPlaybackRate: 1,
                        liveDurationInfinity: !1,
                        liveBackBufferLength: null,
                        maxMaxBufferLength: 600,
                        enableWorker: !0,
                        enableSoftwareAES: !0,
                        manifestLoadingTimeOut: 1e4,
                        manifestLoadingMaxRetry: 1,
                        manifestLoadingRetryDelay: 1e3,
                        manifestLoadingMaxRetryTimeout: 64e3,
                        startLevel: void 0,
                        levelLoadingTimeOut: 1e4,
                        levelLoadingMaxRetry: 4,
                        levelLoadingRetryDelay: 1e3,
                        levelLoadingMaxRetryTimeout: 64e3,
                        fragLoadingTimeOut: 2e4,
                        fragLoadingMaxRetry: 6,
                        fragLoadingRetryDelay: 1e3,
                        fragLoadingMaxRetryTimeout: 64e3,
                        startFragPrefetch: !1,
                        fpsDroppedMonitoringPeriod: 5e3,
                        fpsDroppedMonitoringThreshold: .2,
                        appendErrorMaxRetry: 3,
                        loader: Dt.default,
                        fLoader: void 0,
                        pLoader: void 0,
                        xhrSetup: void 0,
                        licenseXhrSetup: void 0,
                        licenseResponseCallback: void 0,
                        abrController: ut.default,
                        bufferController: At.default,
                        capLevelController: ht.default,
                        fpsController: ot.default,
                        stretchShortVideoTrack: !1,
                        maxAudioFramesDrift: 1,
                        forceKeyFrameOnDiscontinuity: !0,
                        abrEwmaFastLive: 3,
                        abrEwmaSlowLive: 9,
                        abrEwmaFastVoD: 3,
                        abrEwmaSlowVoD: 9,
                        abrEwmaDefaultEstimate: 5e5,
                        abrBandWidthFactor: .95,
                        abrBandWidthUpFactor: .7,
                        abrMaxWithRealBitrate: !1,
                        maxStarvationDelay: 4,
                        maxLoadingDelay: 4,
                        minAutoBitrate: 0,
                        emeEnabled: !1,
                        widevineLicenseUrl: void 0,
                        drmSystemOptions: {},
                        requestMediaKeySystemAccessFunc: ft.requestMediaKeySystemAccess,
                        testBandwidth: !0,
                        progressive: !1,
                        lowLatencyMode: !0,
                        cmcd: void 0,
                        enableDateRangeMetadataCues: !0,
                        enableEmsgMetadataCues: !0,
                        enableID3MetadataCues: !0
                    }, yt()), {}, {
                        subtitleStreamController: pt.SubtitleStreamController,
                        subtitleTrackController: It.default,
                        timelineController: Ct.TimelineController,
                        audioStreamController: lt.default,
                        audioTrackController: bt.default,
                        emeController: ct.default,
                        cmcdController: Et.default
                    });

                    function yt() {
                        return {
                            cueHandler: gt.default,
                            enableWebVTT: !0,
                            enableIMSC1: !0,
                            enableCEA708Captions: !0,
                            captionsTextTrack1Label: "English",
                            captionsTextTrack1LanguageCode: "en",
                            captionsTextTrack2Label: "Spanish",
                            captionsTextTrack2LanguageCode: "es",
                            captionsTextTrack3Label: "Unknown CC",
                            captionsTextTrack3LanguageCode: "",
                            captionsTextTrack4Label: "Unknown CC",
                            captionsTextTrack4LanguageCode: "",
                            renderTextTracksNatively: !0
                        }
                    }

                    function Tt(wt, kt) {
                        if ((kt.liveSyncDurationCount || kt.liveMaxLatencyDurationCount) && (kt.liveSyncDuration || kt.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
                        if (kt.liveMaxLatencyDurationCount !== void 0 && (kt.liveSyncDurationCount === void 0 || kt.liveMaxLatencyDurationCount <= kt.liveSyncDurationCount)) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
                        if (kt.liveMaxLatencyDuration !== void 0 && (kt.liveSyncDuration === void 0 || kt.liveMaxLatencyDuration <= kt.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
                        return St({}, wt, kt)
                    }

                    function Ft(wt) {
                        var kt = wt.loader;
                        if (kt !== Pt.default && kt !== Dt.default) dt.logger.log("[config]: Custom loader detected, cannot enable progressive streaming"), wt.progressive = !1;
                        else {
                            var Ot = (0, Pt.fetchSupported)();
                            Ot && (wt.loader = Pt.default, wt.progressive = !0, wt.enableSoftwareAES = !0, dt.logger.log("[config]: Progressive streaming enabled, using FetchLoader"))
                        }
                    }
                },
                "./src/controller/abr-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => ct
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/utils/ewma-bandwidth-estimator.ts"),
                        bt = it("./src/events.ts"),
                        pt = it("./src/errors.ts"),
                        It = it("./src/types/loader.ts"),
                        At = it("./src/utils/logger.ts");

                    function Ct(Et, Dt) {
                        for (var Pt = 0; Pt < Dt.length; Pt++) {
                            var gt = Dt[Pt];
                            gt.enumerable = gt.enumerable || !1, gt.configurable = !0, "value" in gt && (gt.writable = !0), Object.defineProperty(Et, gt.key, gt)
                        }
                    }

                    function ht(Et, Dt, Pt) {
                        return Dt && Ct(Et.prototype, Dt), Pt && Ct(Et, Pt), Object.defineProperty(Et, "prototype", {
                            writable: !1
                        }), Et
                    }
                    var ot = function() {
                        function Et(Pt) {
                            this.hls = void 0, this.lastLoadedFragLevel = 0, this._nextAutoLevel = -1, this.timer = void 0, this.onCheck = this._abandonRulesCheck.bind(this), this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0, this.hls = Pt;
                            var gt = Pt.config;
                            this.bwEstimator = new lt.default(gt.abrEwmaSlowVoD, gt.abrEwmaFastVoD, gt.abrEwmaDefaultEstimate), this.registerListeners()
                        }
                        var Dt = Et.prototype;
                        return Dt.registerListeners = function() {
                            var gt = this.hls;
                            gt.on(bt.Events.FRAG_LOADING, this.onFragLoading, this), gt.on(bt.Events.FRAG_LOADED, this.onFragLoaded, this), gt.on(bt.Events.FRAG_BUFFERED, this.onFragBuffered, this), gt.on(bt.Events.LEVEL_LOADED, this.onLevelLoaded, this), gt.on(bt.Events.ERROR, this.onError, this)
                        }, Dt.unregisterListeners = function() {
                            var gt = this.hls;
                            gt.off(bt.Events.FRAG_LOADING, this.onFragLoading, this), gt.off(bt.Events.FRAG_LOADED, this.onFragLoaded, this), gt.off(bt.Events.FRAG_BUFFERED, this.onFragBuffered, this), gt.off(bt.Events.LEVEL_LOADED, this.onLevelLoaded, this), gt.off(bt.Events.ERROR, this.onError, this)
                        }, Dt.destroy = function() {
                            this.unregisterListeners(), this.clearTimer(), this.hls = this.onCheck = null, this.fragCurrent = this.partCurrent = null
                        }, Dt.onFragLoading = function(gt, ft) {
                            var dt = ft.frag;
                            if (dt.type === It.PlaylistLevelType.MAIN && !this.timer) {
                                var St;
                                this.fragCurrent = dt, this.partCurrent = (St = ft.part) != null ? St : null, this.timer = self.setInterval(this.onCheck, 100)
                            }
                        }, Dt.onLevelLoaded = function(gt, ft) {
                            var dt = this.hls.config;
                            ft.details.live ? this.bwEstimator.update(dt.abrEwmaSlowLive, dt.abrEwmaFastLive) : this.bwEstimator.update(dt.abrEwmaSlowVoD, dt.abrEwmaFastVoD)
                        }, Dt._abandonRulesCheck = function() {
                            var gt = this.fragCurrent,
                                ft = this.partCurrent,
                                dt = this.hls,
                                St = dt.autoLevelEnabled;
                            dt.config;
                            var _t = dt.media;
                            if (!(!gt || !_t)) {
                                var vt = ft ? ft.stats : gt.stats,
                                    mt = ft ? ft.duration : gt.duration;
                                if (vt.aborted || vt.loaded && vt.loaded === vt.total || gt.level === 0) {
                                    this.clearTimer(), this._nextAutoLevel = -1;
                                    return
                                }
                                if (!(!St || _t.paused || !_t.playbackRate || !_t.readyState)) {
                                    var xt = dt.mainForwardBufferInfo;
                                    if (xt !== null) {
                                        var yt = performance.now() - vt.loading.start,
                                            Tt = Math.abs(_t.playbackRate);
                                        if (!(yt <= 500 * mt / Tt)) {
                                            var Ft = vt.loaded && vt.loading.first,
                                                wt = this.bwEstimator.getEstimate(),
                                                kt = dt.levels,
                                                Ot = dt.minAutoLevel,
                                                Rt = kt[gt.level],
                                                Lt = vt.total || Math.max(vt.loaded, Math.round(mt * Rt.maxBitrate / 8)),
                                                Bt = Ft ? vt.loaded * 1e3 / yt : 0,
                                                Nt = Bt ? (Lt - vt.loaded) / Bt : Lt * 8 / wt,
                                                $t = xt.len / Tt;
                                            if (!(Nt <= $t)) {
                                                var jt = Number.POSITIVE_INFINITY,
                                                    Ut;
                                                for (Ut = gt.level - 1; Ut > Ot; Ut--) {
                                                    var Ht = kt[Ut].maxBitrate;
                                                    if (jt = Bt ? mt * Ht / (8 * .8 * Bt) : mt * Ht / wt, jt < $t) break
                                                }
                                                jt >= Nt || (At.logger.warn("Fragment " + gt.sn + (ft ? " part " + ft.index : "") + " of level " + gt.level + " is loading too slowly and will cause an underbuffer; aborting and switching to level " + Ut + `
      Current BW estimate: ` + ((0, ut.isFiniteNumber)(wt) ? (wt / 1024).toFixed(3) : "Unknown") + ` Kb/s
      Estimated load time for current fragment: ` + Nt.toFixed(3) + ` s
      Estimated load time for the next fragment: ` + jt.toFixed(3) + ` s
      Time to underbuffer: ` + $t.toFixed(3) + " s"), dt.nextLoadLevel = Ut, Ft && this.bwEstimator.sample(yt, vt.loaded), this.clearTimer(), gt.loader && (this.fragCurrent = this.partCurrent = null, gt.loader.abort()), dt.trigger(bt.Events.FRAG_LOAD_EMERGENCY_ABORTED, {
                                                    frag: gt,
                                                    part: ft,
                                                    stats: vt
                                                }))
                                            }
                                        }
                                    }
                                }
                            }
                        }, Dt.onFragLoaded = function(gt, ft) {
                            var dt = ft.frag,
                                St = ft.part;
                            if (dt.type === It.PlaylistLevelType.MAIN && (0, ut.isFiniteNumber)(dt.sn)) {
                                var _t = St ? St.stats : dt.stats,
                                    vt = St ? St.duration : dt.duration;
                                if (this.clearTimer(), this.lastLoadedFragLevel = dt.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate) {
                                    var mt = this.hls.levels[dt.level],
                                        xt = (mt.loaded ? mt.loaded.bytes : 0) + _t.loaded,
                                        yt = (mt.loaded ? mt.loaded.duration : 0) + vt;
                                    mt.loaded = {
                                        bytes: xt,
                                        duration: yt
                                    }, mt.realBitrate = Math.round(8 * xt / yt)
                                }
                                if (dt.bitrateTest) {
                                    var Tt = {
                                        stats: _t,
                                        frag: dt,
                                        part: St,
                                        id: dt.type
                                    };
                                    this.onFragBuffered(bt.Events.FRAG_BUFFERED, Tt)
                                }
                            }
                        }, Dt.onFragBuffered = function(gt, ft) {
                            var dt = ft.frag,
                                St = ft.part,
                                _t = St ? St.stats : dt.stats;
                            if (!_t.aborted && !(dt.type !== It.PlaylistLevelType.MAIN || dt.sn === "initSegment")) {
                                var vt = _t.parsing.end - _t.loading.start;
                                this.bwEstimator.sample(vt, _t.loaded), _t.bwEstimate = this.bwEstimator.getEstimate(), dt.bitrateTest ? this.bitrateTestDelay = vt / 1e3 : this.bitrateTestDelay = 0
                            }
                        }, Dt.onError = function(gt, ft) {
                            switch (ft.details) {
                                case pt.ErrorDetails.FRAG_LOAD_ERROR:
                                case pt.ErrorDetails.FRAG_LOAD_TIMEOUT:
                                    this.clearTimer();
                                    break
                            }
                        }, Dt.clearTimer = function() {
                            self.clearInterval(this.timer), this.timer = void 0
                        }, Dt.getNextABRAutoLevel = function() {
                            var gt = this.fragCurrent,
                                ft = this.partCurrent,
                                dt = this.hls,
                                St = dt.maxAutoLevel,
                                _t = dt.config,
                                vt = dt.minAutoLevel,
                                mt = dt.media,
                                xt = ft ? ft.duration : gt ? gt.duration : 0;
                            mt && mt.currentTime;
                            var yt = mt && mt.playbackRate !== 0 ? Math.abs(mt.playbackRate) : 1,
                                Tt = this.bwEstimator ? this.bwEstimator.getEstimate() : _t.abrEwmaDefaultEstimate,
                                Ft = dt.mainForwardBufferInfo,
                                wt = (Ft ? Ft.len : 0) / yt,
                                kt = this.findBestLevel(Tt, vt, St, wt, _t.abrBandWidthFactor, _t.abrBandWidthUpFactor);
                            if (kt >= 0) return kt;
                            At.logger.trace((wt ? "rebuffering expected" : "buffer is empty") + ", finding optimal quality level");
                            var Ot = xt ? Math.min(xt, _t.maxStarvationDelay) : _t.maxStarvationDelay,
                                Rt = _t.abrBandWidthFactor,
                                Lt = _t.abrBandWidthUpFactor;
                            if (!wt) {
                                var Bt = this.bitrateTestDelay;
                                if (Bt) {
                                    var Nt = xt ? Math.min(xt, _t.maxLoadingDelay) : _t.maxLoadingDelay;
                                    Ot = Nt - Bt, At.logger.trace("bitrate test took " + Math.round(1e3 * Bt) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * Ot) + " ms"), Rt = Lt = 1
                                }
                            }
                            return kt = this.findBestLevel(Tt, vt, St, wt + Ot, Rt, Lt), Math.max(kt, 0)
                        }, Dt.findBestLevel = function(gt, ft, dt, St, _t, vt) {
                            for (var mt, xt = this.fragCurrent, yt = this.partCurrent, Tt = this.lastLoadedFragLevel, Ft = this.hls.levels, wt = Ft[Tt], kt = !!(wt != null && (mt = wt.details) !== null && mt !== void 0 && mt.live), Ot = wt == null ? void 0 : wt.codecSet, Rt = yt ? yt.duration : xt ? xt.duration : 0, Lt = dt; Lt >= ft; Lt--) {
                                var Bt = Ft[Lt];
                                if (!(!Bt || Ot && Bt.codecSet !== Ot)) {
                                    var Nt = Bt.details,
                                        $t = (yt ? Nt == null ? void 0 : Nt.partTarget : Nt == null ? void 0 : Nt.averagetargetduration) || Rt,
                                        jt = void 0;
                                    Lt <= Tt ? jt = _t * gt : jt = vt * gt;
                                    var Ut = Ft[Lt].maxBitrate,
                                        Ht = Ut * $t / jt;
                                    if (At.logger.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + Lt + "/" + Math.round(jt) + "/" + Ut + "/" + $t + "/" + St + "/" + Ht), jt > Ut && (Ht === 0 || !(0, ut.isFiniteNumber)(Ht) || kt && !this.bitrateTestDelay || Ht < St)) return Lt
                                }
                            }
                            return -1
                        }, ht(Et, [{
                            key: "nextAutoLevel",
                            get: function() {
                                var gt = this._nextAutoLevel,
                                    ft = this.bwEstimator;
                                if (gt !== -1 && !ft.canEstimate()) return gt;
                                var dt = this.getNextABRAutoLevel();
                                return gt !== -1 && this.hls.levels[dt].loadError ? gt : (gt !== -1 && (dt = Math.min(gt, dt)), dt)
                            },
                            set: function(gt) {
                                this._nextAutoLevel = gt
                            }
                        }]), Et
                    }();
                    const ct = ot
                },
                "./src/controller/audio-stream-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => mt
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/controller/base-stream-controller.ts"),
                        bt = it("./src/events.ts"),
                        pt = it("./src/utils/buffer-helper.ts"),
                        It = it("./src/controller/fragment-tracker.ts"),
                        At = it("./src/types/level.ts"),
                        Ct = it("./src/types/loader.ts"),
                        ht = it("./src/loader/fragment.ts"),
                        ot = it("./src/demux/chunk-cache.ts"),
                        ct = it("./src/demux/transmuxer-interface.ts"),
                        Et = it("./src/types/transmuxer.ts"),
                        Dt = it("./src/controller/fragment-finders.ts"),
                        Pt = it("./src/utils/discontinuities.ts"),
                        gt = it("./src/errors.ts");

                    function ft() {
                        return ft = Object.assign ? Object.assign.bind() : function(xt) {
                            for (var yt = 1; yt < arguments.length; yt++) {
                                var Tt = arguments[yt];
                                for (var Ft in Tt) Object.prototype.hasOwnProperty.call(Tt, Ft) && (xt[Ft] = Tt[Ft])
                            }
                            return xt
                        }, ft.apply(this, arguments)
                    }

                    function dt(xt, yt) {
                        xt.prototype = Object.create(yt.prototype), xt.prototype.constructor = xt, St(xt, yt)
                    }

                    function St(xt, yt) {
                        return St = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(Ft, wt) {
                            return Ft.__proto__ = wt, Ft
                        }, St(xt, yt)
                    }
                    var _t = 100,
                        vt = function(xt) {
                            dt(yt, xt);

                            function yt(Ft, wt) {
                                var kt;
                                return kt = xt.call(this, Ft, wt, "[audio-stream-controller]") || this, kt.videoBuffer = null, kt.videoTrackCC = -1, kt.waitingVideoCC = -1, kt.audioSwitch = !1, kt.trackId = -1, kt.waitingData = null, kt.mainDetails = null, kt.bufferFlushed = !1, kt.cachedTrackLoadedData = null, kt._registerListeners(), kt
                            }
                            var Tt = yt.prototype;
                            return Tt.onHandlerDestroying = function() {
                                this._unregisterListeners(), this.mainDetails = null
                            }, Tt._registerListeners = function() {
                                var wt = this.hls;
                                wt.on(bt.Events.MEDIA_ATTACHED, this.onMediaAttached, this), wt.on(bt.Events.MEDIA_DETACHING, this.onMediaDetaching, this), wt.on(bt.Events.MANIFEST_LOADING, this.onManifestLoading, this), wt.on(bt.Events.LEVEL_LOADED, this.onLevelLoaded, this), wt.on(bt.Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), wt.on(bt.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), wt.on(bt.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), wt.on(bt.Events.ERROR, this.onError, this), wt.on(bt.Events.BUFFER_RESET, this.onBufferReset, this), wt.on(bt.Events.BUFFER_CREATED, this.onBufferCreated, this), wt.on(bt.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), wt.on(bt.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), wt.on(bt.Events.FRAG_BUFFERED, this.onFragBuffered, this)
                            }, Tt._unregisterListeners = function() {
                                var wt = this.hls;
                                wt.off(bt.Events.MEDIA_ATTACHED, this.onMediaAttached, this), wt.off(bt.Events.MEDIA_DETACHING, this.onMediaDetaching, this), wt.off(bt.Events.MANIFEST_LOADING, this.onManifestLoading, this), wt.off(bt.Events.LEVEL_LOADED, this.onLevelLoaded, this), wt.off(bt.Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), wt.off(bt.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), wt.off(bt.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), wt.off(bt.Events.ERROR, this.onError, this), wt.off(bt.Events.BUFFER_RESET, this.onBufferReset, this), wt.off(bt.Events.BUFFER_CREATED, this.onBufferCreated, this), wt.off(bt.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), wt.off(bt.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), wt.off(bt.Events.FRAG_BUFFERED, this.onFragBuffered, this)
                            }, Tt.onInitPtsFound = function(wt, kt) {
                                var Ot = kt.frag,
                                    Rt = kt.id,
                                    Lt = kt.initPTS;
                                if (Rt === "main") {
                                    var Bt = Ot.cc;
                                    this.initPTS[Ot.cc] = Lt, this.log("InitPTS for cc: " + Bt + " found from main: " + Lt), this.videoTrackCC = Bt, this.state === lt.State.WAITING_INIT_PTS && this.tick()
                                }
                            }, Tt.startLoad = function(wt) {
                                if (!this.levels) {
                                    this.startPosition = wt, this.state = lt.State.STOPPED;
                                    return
                                }
                                var kt = this.lastCurrentTime;
                                this.stopLoad(), this.setInterval(_t), this.fragLoadError = 0, kt > 0 && wt === -1 ? (this.log("Override startPosition with lastCurrentTime @" + kt.toFixed(3)), wt = kt, this.state = lt.State.IDLE) : (this.loadedmetadata = !1, this.state = lt.State.WAITING_TRACK), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = wt, this.tick()
                            }, Tt.doTick = function() {
                                switch (this.state) {
                                    case lt.State.IDLE:
                                        this.doTickIdle();
                                        break;
                                    case lt.State.WAITING_TRACK: {
                                        var wt, kt = this.levels,
                                            Ot = this.trackId,
                                            Rt = kt == null || (wt = kt[Ot]) === null || wt === void 0 ? void 0 : wt.details;
                                        if (Rt) {
                                            if (this.waitForCdnTuneIn(Rt)) break;
                                            this.state = lt.State.WAITING_INIT_PTS
                                        }
                                        break
                                    }
                                    case lt.State.FRAG_LOADING_WAITING_RETRY: {
                                        var Lt, Bt = performance.now(),
                                            Nt = this.retryDate;
                                        (!Nt || Bt >= Nt || (Lt = this.media) !== null && Lt !== void 0 && Lt.seeking) && (this.log("RetryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded(this.trackId), this.state = lt.State.IDLE);
                                        break
                                    }
                                    case lt.State.WAITING_INIT_PTS: {
                                        var $t = this.waitingData;
                                        if ($t) {
                                            var jt = $t.frag,
                                                Ut = $t.part,
                                                Ht = $t.cache,
                                                Wt = $t.complete;
                                            if (this.initPTS[jt.cc] !== void 0) {
                                                this.waitingData = null, this.waitingVideoCC = -1, this.state = lt.State.FRAG_LOADING;
                                                var Kt = Ht.flush(),
                                                    Gt = {
                                                        frag: jt,
                                                        part: Ut,
                                                        payload: Kt,
                                                        networkDetails: null
                                                    };
                                                this._handleFragmentLoadProgress(Gt), Wt && xt.prototype._handleFragmentLoadComplete.call(this, Gt)
                                            } else if (this.videoTrackCC !== this.waitingVideoCC) this.log("Waiting fragment cc (" + jt.cc + ") cancelled because video is at cc " + this.videoTrackCC), this.clearWaitingFragment();
                                            else {
                                                var Vt = this.getLoadPosition(),
                                                    zt = pt.BufferHelper.bufferInfo(this.mediaBuffer, Vt, this.config.maxBufferHole),
                                                    Xt = (0, Dt.fragmentWithinToleranceTest)(zt.end, this.config.maxFragLookUpTolerance, jt);
                                                Xt < 0 && (this.log("Waiting fragment cc (" + jt.cc + ") @ " + jt.start + " cancelled because another fragment at " + zt.end + " is needed"), this.clearWaitingFragment())
                                            }
                                        } else this.state = lt.State.IDLE
                                    }
                                }
                                this.onTickEnd()
                            }, Tt.clearWaitingFragment = function() {
                                var wt = this.waitingData;
                                wt && (this.fragmentTracker.removeFragment(wt.frag), this.waitingData = null, this.waitingVideoCC = -1, this.state = lt.State.IDLE)
                            }, Tt.resetLoadingState = function() {
                                this.clearWaitingFragment(), xt.prototype.resetLoadingState.call(this)
                            }, Tt.onTickEnd = function() {
                                var wt = this.media;
                                !wt || !wt.readyState || (this.lastCurrentTime = wt.currentTime)
                            }, Tt.doTickIdle = function() {
                                var wt, kt, Ot = this.hls,
                                    Rt = this.levels,
                                    Lt = this.media,
                                    Bt = this.trackId,
                                    Nt = Ot.config;
                                if (!(!Rt || !Rt[Bt]) && !(!Lt && (this.startFragRequested || !Nt.startFragPrefetch))) {
                                    var $t = Rt[Bt],
                                        jt = $t.details;
                                    if (!jt || jt.live && this.levelLastLoaded !== Bt || this.waitForCdnTuneIn(jt)) {
                                        this.state = lt.State.WAITING_TRACK;
                                        return
                                    }
                                    var Ut = this.mediaBuffer ? this.mediaBuffer : this.media;
                                    this.bufferFlushed && Ut && (this.bufferFlushed = !1, this.afterBufferFlushed(Ut, ht.ElementaryStreamTypes.AUDIO, Ct.PlaylistLevelType.AUDIO));
                                    var Ht = this.getFwdBufferInfo(Ut, Ct.PlaylistLevelType.AUDIO);
                                    if (Ht !== null) {
                                        var Wt = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, Ct.PlaylistLevelType.MAIN),
                                            Kt = Ht.len,
                                            Gt = this.getMaxBufferLength(Wt == null ? void 0 : Wt.len),
                                            Vt = this.audioSwitch;
                                        if (!(Kt >= Gt && !Vt)) {
                                            if (!Vt && this._streamEnded(Ht, jt)) {
                                                Ot.trigger(bt.Events.BUFFER_EOS, {
                                                    type: "audio"
                                                }), this.state = lt.State.ENDED;
                                                return
                                            }
                                            var zt = jt.fragments,
                                                Xt = zt[0].start,
                                                Yt = Ht.end;
                                            if (Vt && Lt) {
                                                var Zt = this.getLoadPosition();
                                                Yt = Zt, jt.PTSKnown && Zt < Xt && (Ht.end > Xt || Ht.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), Lt.currentTime = Xt + .05)
                                            }
                                            if (!(Wt && Yt > Wt.end + jt.targetduration) && !((!Wt || !Wt.len) && Ht.len)) {
                                                var qt = this.getNextFragment(Yt, jt);
                                                if (!qt) {
                                                    this.bufferFlushed = !0;
                                                    return
                                                }((wt = qt.decryptdata) === null || wt === void 0 ? void 0 : wt.keyFormat) === "identity" && !((kt = qt.decryptdata) !== null && kt !== void 0 && kt.key) ? this.loadKey(qt, jt): this.loadFragment(qt, jt, Yt)
                                            }
                                        }
                                    }
                                }
                            }, Tt.getMaxBufferLength = function(wt) {
                                var kt = xt.prototype.getMaxBufferLength.call(this);
                                return wt ? Math.max(kt, wt) : kt
                            }, Tt.onMediaDetaching = function() {
                                this.videoBuffer = null, xt.prototype.onMediaDetaching.call(this)
                            }, Tt.onAudioTracksUpdated = function(wt, kt) {
                                var Ot = kt.audioTracks;
                                this.resetTransmuxer(), this.levels = Ot.map(function(Rt) {
                                    return new At.Level(Rt)
                                })
                            }, Tt.onAudioTrackSwitching = function(wt, kt) {
                                var Ot = !!kt.url;
                                this.trackId = kt.id;
                                var Rt = this.fragCurrent;
                                Rt != null && Rt.loader && Rt.loader.abort(), this.fragCurrent = null, this.clearWaitingFragment(), Ot ? this.setInterval(_t) : this.resetTransmuxer(), Ot ? (this.audioSwitch = !0, this.state = lt.State.IDLE) : this.state = lt.State.STOPPED, this.tick()
                            }, Tt.onManifestLoading = function() {
                                this.mainDetails = null, this.fragmentTracker.removeAllFragments(), this.startPosition = this.lastCurrentTime = 0, this.bufferFlushed = !1
                            }, Tt.onLevelLoaded = function(wt, kt) {
                                this.mainDetails = kt.details, this.cachedTrackLoadedData !== null && (this.hls.trigger(bt.Events.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData), this.cachedTrackLoadedData = null)
                            }, Tt.onAudioTrackLoaded = function(wt, kt) {
                                var Ot;
                                if (this.mainDetails == null) {
                                    this.cachedTrackLoadedData = kt;
                                    return
                                }
                                var Rt = this.levels,
                                    Lt = kt.details,
                                    Bt = kt.id;
                                if (!Rt) {
                                    this.warn("Audio tracks were reset while loading level " + Bt);
                                    return
                                }
                                this.log("Track " + Bt + " loaded [" + Lt.startSN + "," + Lt.endSN + "],duration:" + Lt.totalduration);
                                var Nt = Rt[Bt],
                                    $t = 0;
                                if (Lt.live || (Ot = Nt.details) !== null && Ot !== void 0 && Ot.live) {
                                    var jt = this.mainDetails;
                                    if (Lt.fragments[0] || (Lt.deltaUpdateFailed = !0), Lt.deltaUpdateFailed || !jt) return;
                                    !Nt.details && Lt.hasProgramDateTime && jt.hasProgramDateTime ? ((0, Pt.alignMediaPlaylistByPDT)(Lt, jt), $t = Lt.fragments[0].start) : $t = this.alignPlaylists(Lt, Nt.details)
                                }
                                Nt.details = Lt, this.levelLastLoaded = Bt, !this.startFragRequested && (this.mainDetails || !Lt.live) && this.setStartPosition(Nt.details, $t), this.state === lt.State.WAITING_TRACK && !this.waitForCdnTuneIn(Lt) && (this.state = lt.State.IDLE), this.tick()
                            }, Tt._handleFragmentLoadProgress = function(wt) {
                                var kt, Ot = wt.frag,
                                    Rt = wt.part,
                                    Lt = wt.payload,
                                    Bt = this.config,
                                    Nt = this.trackId,
                                    $t = this.levels;
                                if (!$t) {
                                    this.warn("Audio tracks were reset while fragment load was in progress. Fragment " + Ot.sn + " of level " + Ot.level + " will not be buffered");
                                    return
                                }
                                var jt = $t[Nt];
                                console.assert(jt, "Audio track is defined on fragment load progress");
                                var Ut = jt.details;
                                console.assert(Ut, "Audio track details are defined on fragment load progress");
                                var Ht = Bt.defaultAudioCodec || jt.audioCodec || "mp4a.40.2",
                                    Wt = this.transmuxer;
                                Wt || (Wt = this.transmuxer = new ct.default(this.hls, Ct.PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)));
                                var Kt = this.initPTS[Ot.cc],
                                    Gt = (kt = Ot.initSegment) === null || kt === void 0 ? void 0 : kt.data;
                                if (Kt !== void 0) {
                                    var Vt = !1,
                                        zt = Rt ? Rt.index : -1,
                                        Xt = zt !== -1,
                                        Yt = new Et.ChunkMetadata(Ot.level, Ot.sn, Ot.stats.chunkCount, Lt.byteLength, zt, Xt);
                                    Wt.push(Lt, Gt, Ht, "", Ot, Rt, Ut.totalduration, Vt, Yt, Kt)
                                } else {
                                    this.log("Unknown video PTS for cc " + Ot.cc + ", waiting for video PTS before demuxing audio frag " + Ot.sn + " of [" + Ut.startSN + " ," + Ut.endSN + "],track " + Nt);
                                    var Zt = this.waitingData = this.waitingData || {
                                            frag: Ot,
                                            part: Rt,
                                            cache: new ot.default,
                                            complete: !1
                                        },
                                        qt = Zt.cache;
                                    qt.push(new Uint8Array(Lt)), this.waitingVideoCC = this.videoTrackCC, this.state = lt.State.WAITING_INIT_PTS
                                }
                            }, Tt._handleFragmentLoadComplete = function(wt) {
                                if (this.waitingData) {
                                    this.waitingData.complete = !0;
                                    return
                                }
                                xt.prototype._handleFragmentLoadComplete.call(this, wt)
                            }, Tt.onBufferReset = function() {
                                this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1
                            }, Tt.onBufferCreated = function(wt, kt) {
                                var Ot = kt.tracks.audio;
                                Ot && (this.mediaBuffer = Ot.buffer || null), kt.tracks.video && (this.videoBuffer = kt.tracks.video.buffer || null)
                            }, Tt.onFragBuffered = function(wt, kt) {
                                var Ot = kt.frag,
                                    Rt = kt.part;
                                if (Ot.type !== Ct.PlaylistLevelType.AUDIO) {
                                    if (!this.loadedmetadata && Ot.type === Ct.PlaylistLevelType.MAIN) {
                                        var Lt;
                                        (Lt = this.videoBuffer || this.media) !== null && Lt !== void 0 && Lt.buffered.length && (this.loadedmetadata = !0)
                                    }
                                    return
                                }
                                if (this.fragContextChanged(Ot)) {
                                    this.warn("Fragment " + Ot.sn + (Rt ? " p: " + Rt.index : "") + " of level " + Ot.level + " finished buffering, but was aborted. state: " + this.state + ", audioSwitch: " + this.audioSwitch);
                                    return
                                }
                                Ot.sn !== "initSegment" && (this.fragPrevious = Ot, this.audioSwitch && (this.audioSwitch = !1, this.hls.trigger(bt.Events.AUDIO_TRACK_SWITCHED, {
                                    id: this.trackId
                                }))), this.fragBufferedComplete(Ot, Rt)
                            }, Tt.onError = function(wt, kt) {
                                switch (kt.details) {
                                    case gt.ErrorDetails.FRAG_LOAD_ERROR:
                                    case gt.ErrorDetails.FRAG_LOAD_TIMEOUT:
                                    case gt.ErrorDetails.KEY_LOAD_ERROR:
                                    case gt.ErrorDetails.KEY_LOAD_TIMEOUT:
                                        this.onFragmentOrKeyLoadError(Ct.PlaylistLevelType.AUDIO, kt);
                                        break;
                                    case gt.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
                                    case gt.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
                                        this.state !== lt.State.ERROR && this.state !== lt.State.STOPPED && (this.state = kt.fatal ? lt.State.ERROR : lt.State.IDLE, this.warn(kt.details + " while loading frag, switching to " + this.state + " state"));
                                        break;
                                    case gt.ErrorDetails.BUFFER_FULL_ERROR:
                                        if (kt.parent === "audio" && (this.state === lt.State.PARSING || this.state === lt.State.PARSED)) {
                                            var Ot = !0,
                                                Rt = this.getFwdBufferInfo(this.mediaBuffer, Ct.PlaylistLevelType.AUDIO);
                                            Rt && Rt.len > .5 && (Ot = !this.reduceMaxBufferLength(Rt.len)), Ot && (this.warn("Buffer full error also media.currentTime is not buffered, flush audio buffer"), this.fragCurrent = null, xt.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio")), this.resetLoadingState()
                                        }
                                        break
                                }
                            }, Tt.onBufferFlushed = function(wt, kt) {
                                var Ot = kt.type;
                                Ot === ht.ElementaryStreamTypes.AUDIO && (this.bufferFlushed = !0)
                            }, Tt._handleTransmuxComplete = function(wt) {
                                var kt, Ot = "audio",
                                    Rt = this.hls,
                                    Lt = wt.remuxResult,
                                    Bt = wt.chunkMeta,
                                    Nt = this.getCurrentContext(Bt);
                                if (!Nt) {
                                    this.warn("The loading context changed while buffering fragment " + Bt.sn + " of level " + Bt.level + ". This chunk will not be buffered."), this.resetStartWhenNotLoaded(Bt.level);
                                    return
                                }
                                var $t = Nt.frag,
                                    jt = Nt.part,
                                    Ut = Nt.level.details,
                                    Ht = Lt.audio,
                                    Wt = Lt.text,
                                    Kt = Lt.id3,
                                    Gt = Lt.initSegment;
                                if (!(this.fragContextChanged($t) || !Ut)) {
                                    if (this.state = lt.State.PARSING, this.audioSwitch && Ht && this.completeAudioSwitch(), Gt != null && Gt.tracks && (this._bufferInitSegment(Gt.tracks, $t, Bt), Rt.trigger(bt.Events.FRAG_PARSING_INIT_SEGMENT, {
                                            frag: $t,
                                            id: Ot,
                                            tracks: Gt.tracks
                                        })), Ht) {
                                        var Vt = Ht.startPTS,
                                            zt = Ht.endPTS,
                                            Xt = Ht.startDTS,
                                            Yt = Ht.endDTS;
                                        jt && (jt.elementaryStreams[ht.ElementaryStreamTypes.AUDIO] = {
                                            startPTS: Vt,
                                            endPTS: zt,
                                            startDTS: Xt,
                                            endDTS: Yt
                                        }), $t.setElementaryStreamInfo(ht.ElementaryStreamTypes.AUDIO, Vt, zt, Xt, Yt), this.bufferFragmentData(Ht, $t, jt, Bt)
                                    }
                                    if (Kt != null && (kt = Kt.samples) !== null && kt !== void 0 && kt.length) {
                                        var Zt = ft({
                                            id: Ot,
                                            frag: $t,
                                            details: Ut
                                        }, Kt);
                                        Rt.trigger(bt.Events.FRAG_PARSING_METADATA, Zt)
                                    }
                                    if (Wt) {
                                        var qt = ft({
                                            id: Ot,
                                            frag: $t,
                                            details: Ut
                                        }, Wt);
                                        Rt.trigger(bt.Events.FRAG_PARSING_USERDATA, qt)
                                    }
                                }
                            }, Tt._bufferInitSegment = function(wt, kt, Ot) {
                                if (this.state === lt.State.PARSING) {
                                    wt.video && delete wt.video;
                                    var Rt = wt.audio;
                                    if (!!Rt) {
                                        Rt.levelCodec = Rt.codec, Rt.id = "audio", this.log("Init audio buffer, container:" + Rt.container + ", codecs[parsed]=[" + Rt.codec + "]"), this.hls.trigger(bt.Events.BUFFER_CODECS, wt);
                                        var Lt = Rt.initSegment;
                                        if (Lt != null && Lt.byteLength) {
                                            var Bt = {
                                                type: "audio",
                                                frag: kt,
                                                part: null,
                                                chunkMeta: Ot,
                                                parent: kt.type,
                                                data: Lt
                                            };
                                            this.hls.trigger(bt.Events.BUFFER_APPENDING, Bt)
                                        }
                                        this.tick()
                                    }
                                }
                            }, Tt.loadFragment = function(wt, kt, Ot) {
                                var Rt = this.fragmentTracker.getState(wt);
                                this.fragCurrent = wt, (this.audioSwitch || Rt === It.FragmentState.NOT_LOADED || Rt === It.FragmentState.PARTIAL) && (wt.sn === "initSegment" ? this._loadInitSegment(wt) : kt.live && !(0, ut.isFiniteNumber)(this.initPTS[wt.cc]) ? (this.log("Waiting for video PTS in continuity counter " + wt.cc + " of live stream before loading audio fragment " + wt.sn + " of level " + this.trackId), this.state = lt.State.WAITING_INIT_PTS) : (this.startFragRequested = !0, xt.prototype.loadFragment.call(this, wt, kt, Ot)))
                            }, Tt.completeAudioSwitch = function() {
                                var wt = this.hls,
                                    kt = this.media,
                                    Ot = this.trackId;
                                kt && (this.log("Switching audio track : flushing all audio"), xt.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio")), this.audioSwitch = !1, wt.trigger(bt.Events.AUDIO_TRACK_SWITCHED, {
                                    id: Ot
                                })
                            }, yt
                        }(lt.default);
                    const mt = vt
                },
                "./src/controller/audio-track-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => ct
                    });
                    var ut = it("./src/events.ts"),
                        lt = it("./src/errors.ts"),
                        bt = it("./src/controller/base-playlist-controller.ts"),
                        pt = it("./src/types/loader.ts");

                    function It(Et, Dt) {
                        for (var Pt = 0; Pt < Dt.length; Pt++) {
                            var gt = Dt[Pt];
                            gt.enumerable = gt.enumerable || !1, gt.configurable = !0, "value" in gt && (gt.writable = !0), Object.defineProperty(Et, gt.key, gt)
                        }
                    }

                    function At(Et, Dt, Pt) {
                        return Dt && It(Et.prototype, Dt), Pt && It(Et, Pt), Object.defineProperty(Et, "prototype", {
                            writable: !1
                        }), Et
                    }

                    function Ct(Et, Dt) {
                        Et.prototype = Object.create(Dt.prototype), Et.prototype.constructor = Et, ht(Et, Dt)
                    }

                    function ht(Et, Dt) {
                        return ht = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(gt, ft) {
                            return gt.__proto__ = ft, gt
                        }, ht(Et, Dt)
                    }
                    var ot = function(Et) {
                        Ct(Dt, Et);

                        function Dt(gt) {
                            var ft;
                            return ft = Et.call(this, gt, "[audio-track-controller]") || this, ft.tracks = [], ft.groupId = null, ft.tracksInGroup = [], ft.trackId = -1, ft.trackName = "", ft.selectDefaultTrack = !0, ft.registerListeners(), ft
                        }
                        var Pt = Dt.prototype;
                        return Pt.registerListeners = function() {
                            var ft = this.hls;
                            ft.on(ut.Events.MANIFEST_LOADING, this.onManifestLoading, this), ft.on(ut.Events.MANIFEST_PARSED, this.onManifestParsed, this), ft.on(ut.Events.LEVEL_LOADING, this.onLevelLoading, this), ft.on(ut.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), ft.on(ut.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), ft.on(ut.Events.ERROR, this.onError, this)
                        }, Pt.unregisterListeners = function() {
                            var ft = this.hls;
                            ft.off(ut.Events.MANIFEST_LOADING, this.onManifestLoading, this), ft.off(ut.Events.MANIFEST_PARSED, this.onManifestParsed, this), ft.off(ut.Events.LEVEL_LOADING, this.onLevelLoading, this), ft.off(ut.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), ft.off(ut.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), ft.off(ut.Events.ERROR, this.onError, this)
                        }, Pt.destroy = function() {
                            this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, Et.prototype.destroy.call(this)
                        }, Pt.onManifestLoading = function() {
                            this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.trackName = "", this.selectDefaultTrack = !0
                        }, Pt.onManifestParsed = function(ft, dt) {
                            this.tracks = dt.audioTracks || []
                        }, Pt.onAudioTrackLoaded = function(ft, dt) {
                            var St = dt.id,
                                _t = dt.details,
                                vt = this.tracksInGroup[St];
                            if (!vt) {
                                this.warn("Invalid audio track id " + St);
                                return
                            }
                            var mt = vt.details;
                            vt.details = dt.details, this.log("audioTrack " + St + " loaded [" + _t.startSN + "-" + _t.endSN + "]"), St === this.trackId && (this.retryCount = 0, this.playlistLoaded(St, dt, mt))
                        }, Pt.onLevelLoading = function(ft, dt) {
                            this.switchLevel(dt.level)
                        }, Pt.onLevelSwitching = function(ft, dt) {
                            this.switchLevel(dt.level)
                        }, Pt.switchLevel = function(ft) {
                            var dt = this.hls.levels[ft];
                            if (!!(dt != null && dt.audioGroupIds)) {
                                var St = dt.audioGroupIds[dt.urlId];
                                if (this.groupId !== St) {
                                    this.groupId = St;
                                    var _t = this.tracks.filter(function(mt) {
                                        return !St || mt.groupId === St
                                    });
                                    this.selectDefaultTrack && !_t.some(function(mt) {
                                        return mt.default
                                    }) && (this.selectDefaultTrack = !1), this.tracksInGroup = _t;
                                    var vt = {
                                        audioTracks: _t
                                    };
                                    this.log("Updating audio tracks, " + _t.length + ' track(s) found in "' + St + '" group-id'), this.hls.trigger(ut.Events.AUDIO_TRACKS_UPDATED, vt), this.selectInitialTrack()
                                }
                            }
                        }, Pt.onError = function(ft, dt) {
                            Et.prototype.onError.call(this, ft, dt), !(dt.fatal || !dt.context) && dt.context.type === pt.PlaylistContextType.AUDIO_TRACK && dt.context.id === this.trackId && dt.context.groupId === this.groupId && this.retryLoadingOrFail(dt)
                        }, Pt.setAudioTrack = function(ft) {
                            var dt = this.tracksInGroup;
                            if (ft < 0 || ft >= dt.length) {
                                this.warn("Invalid id passed to audio-track controller");
                                return
                            }
                            this.clearTimer();
                            var St = dt[this.trackId];
                            this.log("Now switching to audio-track index " + ft);
                            var _t = dt[ft],
                                vt = _t.id,
                                mt = _t.groupId,
                                xt = mt === void 0 ? "" : mt,
                                yt = _t.name,
                                Tt = _t.type,
                                Ft = _t.url;
                            if (this.trackId = ft, this.trackName = yt, this.selectDefaultTrack = !1, this.hls.trigger(ut.Events.AUDIO_TRACK_SWITCHING, {
                                    id: vt,
                                    groupId: xt,
                                    name: yt,
                                    type: Tt,
                                    url: Ft
                                }), !(_t.details && !_t.details.live)) {
                                var wt = this.switchParams(_t.url, St == null ? void 0 : St.details);
                                this.loadPlaylist(wt)
                            }
                        }, Pt.selectInitialTrack = function() {
                            var ft = this.tracksInGroup;
                            console.assert(ft.length, "Initial audio track should be selected when tracks are known");
                            var dt = this.trackName,
                                St = this.findTrackId(dt) || this.findTrackId();
                            St !== -1 ? this.setAudioTrack(St) : (this.warn("No track found for running audio group-ID: " + this.groupId), this.hls.trigger(ut.Events.ERROR, {
                                type: lt.ErrorTypes.MEDIA_ERROR,
                                details: lt.ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
                                fatal: !0
                            }))
                        }, Pt.findTrackId = function(ft) {
                            for (var dt = this.tracksInGroup, St = 0; St < dt.length; St++) {
                                var _t = dt[St];
                                if ((!this.selectDefaultTrack || _t.default) && (!ft || ft === _t.name)) return _t.id
                            }
                            return -1
                        }, Pt.loadPlaylist = function(ft) {
                            var dt = this.tracksInGroup[this.trackId];
                            if (this.shouldLoadTrack(dt)) {
                                var St = dt.id,
                                    _t = dt.groupId,
                                    vt = dt.url;
                                if (ft) try {
                                    vt = ft.addDirectives(vt)
                                } catch (mt) {
                                    this.warn("Could not construct new URL with HLS Delivery Directives: " + mt)
                                }
                                this.log("loading audio-track playlist for id: " + St), this.clearTimer(), this.hls.trigger(ut.Events.AUDIO_TRACK_LOADING, {
                                    url: vt,
                                    id: St,
                                    groupId: _t,
                                    deliveryDirectives: ft || null
                                })
                            }
                        }, At(Dt, [{
                            key: "audioTracks",
                            get: function() {
                                return this.tracksInGroup
                            }
                        }, {
                            key: "audioTrack",
                            get: function() {
                                return this.trackId
                            },
                            set: function(ft) {
                                this.selectDefaultTrack = !1, this.setAudioTrack(ft)
                            }
                        }]), Dt
                    }(bt.default);
                    const ct = ot
                },
                "./src/controller/base-playlist-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => At
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/types/level.ts"),
                        bt = it("./src/controller/level-helper.ts"),
                        pt = it("./src/utils/logger.ts"),
                        It = it("./src/errors.ts"),
                        At = function() {
                            function Ct(ot, ct) {
                                this.hls = void 0, this.timer = -1, this.canLoad = !1, this.retryCount = 0, this.log = void 0, this.warn = void 0, this.log = pt.logger.log.bind(pt.logger, ct + ":"), this.warn = pt.logger.warn.bind(pt.logger, ct + ":"), this.hls = ot
                            }
                            var ht = Ct.prototype;
                            return ht.destroy = function() {
                                this.clearTimer(), this.hls = this.log = this.warn = null
                            }, ht.onError = function(ct, Et) {
                                Et.fatal && Et.type === It.ErrorTypes.NETWORK_ERROR && this.clearTimer()
                            }, ht.clearTimer = function() {
                                clearTimeout(this.timer), this.timer = -1
                            }, ht.startLoad = function() {
                                this.canLoad = !0, this.retryCount = 0, this.loadPlaylist()
                            }, ht.stopLoad = function() {
                                this.canLoad = !1, this.clearTimer()
                            }, ht.switchParams = function(ct, Et) {
                                var Dt = Et == null ? void 0 : Et.renditionReports;
                                if (Dt)
                                    for (var Pt = 0; Pt < Dt.length; Pt++) {
                                        var gt = Dt[Pt],
                                            ft = "" + gt.URI;
                                        if (ft === ct.slice(-ft.length)) {
                                            var dt = parseInt(gt["LAST-MSN"]),
                                                St = parseInt(gt["LAST-PART"]);
                                            if (Et && this.hls.config.lowLatencyMode) {
                                                var _t = Math.min(Et.age - Et.partTarget, Et.targetduration);
                                                St !== void 0 && _t > Et.partTarget && (St += 1)
                                            }
                                            if ((0, ut.isFiniteNumber)(dt)) return new lt.HlsUrlParameters(dt, (0, ut.isFiniteNumber)(St) ? St : void 0, lt.HlsSkip.No)
                                        }
                                    }
                            }, ht.loadPlaylist = function(ct) {}, ht.shouldLoadTrack = function(ct) {
                                return this.canLoad && ct && !!ct.url && (!ct.details || ct.details.live)
                            }, ht.playlistLoaded = function(ct, Et, Dt) {
                                var Pt = this,
                                    gt = Et.details,
                                    ft = Et.stats,
                                    dt = ft.loading.end ? Math.max(0, self.performance.now() - ft.loading.end) : 0;
                                if (gt.advancedDateTime = Date.now() - dt, gt.live || Dt != null && Dt.live) {
                                    if (gt.reloaded(Dt), Dt && this.log("live playlist " + ct + " " + (gt.advanced ? "REFRESHED " + gt.lastPartSn + "-" + gt.lastPartIndex : "MISSED")), Dt && gt.fragments.length > 0 && (0, bt.mergeDetails)(Dt, gt), !this.canLoad || !gt.live) return;
                                    var St, _t = void 0,
                                        vt = void 0;
                                    if (gt.canBlockReload && gt.endSN && gt.advanced) {
                                        var mt = this.hls.config.lowLatencyMode,
                                            xt = gt.lastPartSn,
                                            yt = gt.endSN,
                                            Tt = gt.lastPartIndex,
                                            Ft = Tt !== -1,
                                            wt = xt === yt,
                                            kt = mt ? 0 : Tt;
                                        Ft ? (_t = wt ? yt + 1 : xt, vt = wt ? kt : Tt + 1) : _t = yt + 1;
                                        var Ot = gt.age,
                                            Rt = Ot + gt.ageHeader,
                                            Lt = Math.min(Rt - gt.partTarget, gt.targetduration * 1.5);
                                        if (Lt > 0) {
                                            if (Dt && Lt > Dt.tuneInGoal) this.warn("CDN Tune-in goal increased from: " + Dt.tuneInGoal + " to: " + Lt + " with playlist age: " + gt.age), Lt = 0;
                                            else {
                                                var Bt = Math.floor(Lt / gt.targetduration);
                                                if (_t += Bt, vt !== void 0) {
                                                    var Nt = Math.round(Lt % gt.targetduration / gt.partTarget);
                                                    vt += Nt
                                                }
                                                this.log("CDN Tune-in age: " + gt.ageHeader + "s last advanced " + Ot.toFixed(2) + "s goal: " + Lt + " skip sn " + Bt + " to part " + vt)
                                            }
                                            gt.tuneInGoal = Lt
                                        }
                                        if (St = this.getDeliveryDirectives(gt, Et.deliveryDirectives, _t, vt), mt || !wt) {
                                            this.loadPlaylist(St);
                                            return
                                        }
                                    } else St = this.getDeliveryDirectives(gt, Et.deliveryDirectives, _t, vt);
                                    var $t = (0, bt.computeReloadInterval)(gt, ft);
                                    _t !== void 0 && gt.canBlockReload && ($t -= gt.partTarget || 1), this.log("reload live playlist " + ct + " in " + Math.round($t) + " ms"), this.timer = self.setTimeout(function() {
                                        return Pt.loadPlaylist(St)
                                    }, $t)
                                } else this.clearTimer()
                            }, ht.getDeliveryDirectives = function(ct, Et, Dt, Pt) {
                                var gt = (0, lt.getSkipValue)(ct, Dt);
                                return Et != null && Et.skip && ct.deltaUpdateFailed && (Dt = Et.msn, Pt = Et.part, gt = lt.HlsSkip.No), new lt.HlsUrlParameters(Dt, Pt, gt)
                            }, ht.retryLoadingOrFail = function(ct) {
                                var Et = this,
                                    Dt = this.hls.config,
                                    Pt = this.retryCount < Dt.levelLoadingMaxRetry;
                                if (Pt) {
                                    var gt;
                                    if (this.retryCount++, ct.details.indexOf("LoadTimeOut") > -1 && (gt = ct.context) !== null && gt !== void 0 && gt.deliveryDirectives) this.warn("retry playlist loading #" + this.retryCount + ' after "' + ct.details + '"'), this.loadPlaylist();
                                    else {
                                        var ft = Math.min(Math.pow(2, this.retryCount) * Dt.levelLoadingRetryDelay, Dt.levelLoadingMaxRetryTimeout);
                                        this.timer = self.setTimeout(function() {
                                            return Et.loadPlaylist()
                                        }, ft), this.warn("retry playlist loading #" + this.retryCount + " in " + ft + ' ms after "' + ct.details + '"')
                                    }
                                } else this.warn('cannot recover from error "' + ct.details + '"'), this.clearTimer(), ct.fatal = !0;
                                return Pt
                            }, Ct
                        }()
                },
                "./src/controller/base-stream-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        State: () => yt,
                        default: () => Tt
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/task-loop.ts"),
                        bt = it("./src/controller/fragment-tracker.ts"),
                        pt = it("./src/utils/buffer-helper.ts"),
                        It = it("./src/utils/logger.ts"),
                        At = it("./src/events.ts"),
                        Ct = it("./src/errors.ts"),
                        ht = it("./src/types/transmuxer.ts"),
                        ot = it("./src/utils/mp4-tools.ts"),
                        ct = it("./src/utils/discontinuities.ts"),
                        Et = it("./src/controller/fragment-finders.ts"),
                        Dt = it("./src/controller/level-helper.ts"),
                        Pt = it("./src/loader/fragment-loader.ts"),
                        gt = it("./src/crypt/decrypter.ts"),
                        ft = it("./src/utils/time-ranges.ts"),
                        dt = it("./src/types/loader.ts");

                    function St(Ft, wt) {
                        for (var kt = 0; kt < wt.length; kt++) {
                            var Ot = wt[kt];
                            Ot.enumerable = Ot.enumerable || !1, Ot.configurable = !0, "value" in Ot && (Ot.writable = !0), Object.defineProperty(Ft, Ot.key, Ot)
                        }
                    }

                    function _t(Ft, wt, kt) {
                        return wt && St(Ft.prototype, wt), kt && St(Ft, kt), Object.defineProperty(Ft, "prototype", {
                            writable: !1
                        }), Ft
                    }

                    function vt(Ft) {
                        if (Ft === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return Ft
                    }

                    function mt(Ft, wt) {
                        Ft.prototype = Object.create(wt.prototype), Ft.prototype.constructor = Ft, xt(Ft, wt)
                    }

                    function xt(Ft, wt) {
                        return xt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(Ot, Rt) {
                            return Ot.__proto__ = Rt, Ot
                        }, xt(Ft, wt)
                    }
                    var yt = {
                            STOPPED: "STOPPED",
                            IDLE: "IDLE",
                            KEY_LOADING: "KEY_LOADING",
                            FRAG_LOADING: "FRAG_LOADING",
                            FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
                            WAITING_TRACK: "WAITING_TRACK",
                            PARSING: "PARSING",
                            PARSED: "PARSED",
                            ENDED: "ENDED",
                            ERROR: "ERROR",
                            WAITING_INIT_PTS: "WAITING_INIT_PTS",
                            WAITING_LEVEL: "WAITING_LEVEL"
                        },
                        Tt = function(Ft) {
                            mt(wt, Ft);

                            function wt(Ot, Rt, Lt) {
                                var Bt;
                                return Bt = Ft.call(this) || this, Bt.hls = void 0, Bt.fragPrevious = null, Bt.fragCurrent = null, Bt.fragmentTracker = void 0, Bt.transmuxer = null, Bt._state = yt.STOPPED, Bt.media = null, Bt.mediaBuffer = null, Bt.config = void 0, Bt.bitrateTest = !1, Bt.lastCurrentTime = 0, Bt.nextLoadPosition = 0, Bt.startPosition = 0, Bt.loadedmetadata = !1, Bt.fragLoadError = 0, Bt.retryDate = 0, Bt.levels = null, Bt.fragmentLoader = void 0, Bt.levelLastLoaded = null, Bt.startFragRequested = !1, Bt.decrypter = void 0, Bt.initPTS = [], Bt.onvseeking = null, Bt.onvended = null, Bt.logPrefix = "", Bt.log = void 0, Bt.warn = void 0, Bt.logPrefix = Lt, Bt.log = It.logger.log.bind(It.logger, Lt + ":"), Bt.warn = It.logger.warn.bind(It.logger, Lt + ":"), Bt.hls = Ot, Bt.fragmentLoader = new Pt.default(Ot.config), Bt.fragmentTracker = Rt, Bt.config = Ot.config, Bt.decrypter = new gt.default(Ot, Ot.config), Ot.on(At.Events.KEY_LOADED, Bt.onKeyLoaded, vt(Bt)), Ot.on(At.Events.LEVEL_SWITCHING, Bt.onLevelSwitching, vt(Bt)), Bt
                            }
                            var kt = wt.prototype;
                            return kt.doTick = function() {
                                this.onTickEnd()
                            }, kt.onTickEnd = function() {}, kt.startLoad = function(Rt) {}, kt.stopLoad = function() {
                                this.fragmentLoader.abort();
                                var Rt = this.fragCurrent;
                                Rt && this.fragmentTracker.removeFragment(Rt), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = yt.STOPPED
                            }, kt._streamEnded = function(Rt, Lt) {
                                var Bt = this.fragCurrent,
                                    Nt = this.fragmentTracker;
                                if (!Lt.live && Bt && this.media && Bt.sn >= Lt.endSN && !Rt.nextStart) {
                                    var $t = Lt.partList;
                                    if ($t != null && $t.length) {
                                        var jt = $t[$t.length - 1],
                                            Ut = pt.BufferHelper.isBuffered(this.media, jt.start + jt.duration / 2);
                                        return Ut
                                    }
                                    var Ht = Nt.getState(Bt);
                                    return Ht === bt.FragmentState.PARTIAL || Ht === bt.FragmentState.OK
                                }
                                return !1
                            }, kt.onMediaAttached = function(Rt, Lt) {
                                var Bt = this.media = this.mediaBuffer = Lt.media;
                                this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), Bt.addEventListener("seeking", this.onvseeking), Bt.addEventListener("ended", this.onvended);
                                var Nt = this.config;
                                this.levels && Nt.autoStartLoad && this.state === yt.STOPPED && this.startLoad(Nt.startPosition)
                            }, kt.onMediaDetaching = function() {
                                var Rt = this.media;
                                Rt != null && Rt.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), Rt && this.onvseeking && this.onvended && (Rt.removeEventListener("seeking", this.onvseeking), Rt.removeEventListener("ended", this.onvended), this.onvseeking = this.onvended = null), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad()
                            }, kt.onMediaSeeking = function() {
                                var Rt = this.config,
                                    Lt = this.fragCurrent,
                                    Bt = this.media,
                                    Nt = this.mediaBuffer,
                                    $t = this.state,
                                    jt = Bt ? Bt.currentTime : 0,
                                    Ut = pt.BufferHelper.bufferInfo(Nt || Bt, jt, Rt.maxBufferHole);
                                if (this.log("media seeking to " + ((0, ut.isFiniteNumber)(jt) ? jt.toFixed(3) : jt) + ", state: " + $t), $t === yt.ENDED) this.resetLoadingState();
                                else if (Lt) {
                                    var Ht = Rt.maxFragLookUpTolerance,
                                        Wt = Lt.start - Ht,
                                        Kt = Lt.start + Lt.duration + Ht;
                                    if (!Ut.len || Kt < Ut.start || Wt > Ut.end) {
                                        var Gt = jt > Kt;
                                        (jt < Wt || Gt) && (Gt && Lt.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), Lt.loader.abort()), this.resetLoadingState())
                                    }
                                }
                                Bt && (this.lastCurrentTime = jt), !this.loadedmetadata && !Ut.len && (this.nextLoadPosition = this.startPosition = jt), this.tickImmediate()
                            }, kt.onMediaEnded = function() {
                                this.startPosition = this.lastCurrentTime = 0
                            }, kt.onKeyLoaded = function(Rt, Lt) {
                                if (!(this.state !== yt.KEY_LOADING || Lt.frag !== this.fragCurrent || !this.levels)) {
                                    this.state = yt.IDLE;
                                    var Bt = this.levels[Lt.frag.level].details;
                                    Bt && this.loadFragment(Lt.frag, Bt, Lt.frag.start)
                                }
                            }, kt.onLevelSwitching = function(Rt, Lt) {
                                this.fragLoadError = 0
                            }, kt.onHandlerDestroying = function() {
                                this.stopLoad(), Ft.prototype.onHandlerDestroying.call(this)
                            }, kt.onHandlerDestroyed = function() {
                                this.state = yt.STOPPED, this.hls.off(At.Events.KEY_LOADED, this.onKeyLoaded, this), this.hls.off(At.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), this.fragmentLoader && this.fragmentLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.fragmentLoader = this.fragmentTracker = null, Ft.prototype.onHandlerDestroyed.call(this)
                            }, kt.loadKey = function(Rt, Lt) {
                                this.log("Loading key for " + Rt.sn + " of [" + Lt.startSN + "-" + Lt.endSN + "], " + (this.logPrefix === "[stream-controller]" ? "level" : "track") + " " + Rt.level), this.state = yt.KEY_LOADING, this.fragCurrent = Rt, this.hls.trigger(At.Events.KEY_LOADING, {
                                    frag: Rt
                                })
                            }, kt.loadFragment = function(Rt, Lt, Bt) {
                                this._loadFragForPlayback(Rt, Lt, Bt)
                            }, kt._loadFragForPlayback = function(Rt, Lt, Bt) {
                                var Nt = this,
                                    $t = function(Ut) {
                                        if (Nt.fragContextChanged(Rt)) {
                                            Nt.warn("Fragment " + Rt.sn + (Ut.part ? " p: " + Ut.part.index : "") + " of level " + Rt.level + " was dropped during download."), Nt.fragmentTracker.removeFragment(Rt);
                                            return
                                        }
                                        Rt.stats.chunkCount++, Nt._handleFragmentLoadProgress(Ut)
                                    };
                                this._doFragLoad(Rt, Lt, Bt, $t).then(function(jt) {
                                    if (!!jt) {
                                        Nt.fragLoadError = 0;
                                        var Ut = Nt.state;
                                        if (Nt.fragContextChanged(Rt)) {
                                            (Ut === yt.FRAG_LOADING || !Nt.fragCurrent && Ut === yt.PARSING) && (Nt.fragmentTracker.removeFragment(Rt), Nt.state = yt.IDLE);
                                            return
                                        }
                                        "payload" in jt && (Nt.log("Loaded fragment " + Rt.sn + " of level " + Rt.level), Nt.hls.trigger(At.Events.FRAG_LOADED, jt)), Nt._handleFragmentLoadComplete(jt)
                                    }
                                }).catch(function(jt) {
                                    Nt.state === yt.STOPPED || Nt.state === yt.ERROR || (Nt.warn(jt), Nt.resetFragmentLoading(Rt))
                                })
                            }, kt.flushMainBuffer = function(Rt, Lt, Bt) {
                                if (Bt === void 0 && (Bt = null), !!(Rt - Lt)) {
                                    var Nt = {
                                        startOffset: Rt,
                                        endOffset: Lt,
                                        type: Bt
                                    };
                                    this.fragLoadError = 0, this.hls.trigger(At.Events.BUFFER_FLUSHING, Nt)
                                }
                            }, kt._loadInitSegment = function(Rt) {
                                var Lt = this;
                                this._doFragLoad(Rt).then(function(Bt) {
                                    if (!Bt || Lt.fragContextChanged(Rt) || !Lt.levels) throw new Error("init load aborted");
                                    return Bt
                                }).then(function(Bt) {
                                    var Nt = Lt.hls,
                                        $t = Bt.payload,
                                        jt = Rt.decryptdata;
                                    if ($t && $t.byteLength > 0 && jt && jt.key && jt.iv && jt.method === "AES-128") {
                                        var Ut = self.performance.now();
                                        return Lt.decrypter.webCryptoDecrypt(new Uint8Array($t), jt.key.buffer, jt.iv.buffer).then(function(Ht) {
                                            var Wt = self.performance.now();
                                            return Nt.trigger(At.Events.FRAG_DECRYPTED, {
                                                frag: Rt,
                                                payload: Ht,
                                                stats: {
                                                    tstart: Ut,
                                                    tdecrypt: Wt
                                                }
                                            }), Bt.payload = Ht, Bt
                                        })
                                    }
                                    return Bt
                                }).then(function(Bt) {
                                    var Nt = Lt.fragCurrent,
                                        $t = Lt.hls,
                                        jt = Lt.levels;
                                    if (!jt) throw new Error("init load aborted, missing levels");
                                    var Ut = jt[Rt.level].details;
                                    console.assert(Ut, "Level details are defined when init segment is loaded");
                                    var Ht = Rt.stats;
                                    Lt.state = yt.IDLE, Lt.fragLoadError = 0, Rt.data = new Uint8Array(Bt.payload), Ht.parsing.start = Ht.buffering.start = self.performance.now(), Ht.parsing.end = Ht.buffering.end = self.performance.now(), Bt.frag === Nt && $t.trigger(At.Events.FRAG_BUFFERED, {
                                        stats: Ht,
                                        frag: Nt,
                                        part: null,
                                        id: Rt.type
                                    }), Lt.tick()
                                }).catch(function(Bt) {
                                    Lt.state === yt.STOPPED || Lt.state === yt.ERROR || (Lt.warn(Bt), Lt.resetFragmentLoading(Rt))
                                })
                            }, kt.fragContextChanged = function(Rt) {
                                var Lt = this.fragCurrent;
                                return !Rt || !Lt || Rt.level !== Lt.level || Rt.sn !== Lt.sn || Rt.urlId !== Lt.urlId
                            }, kt.fragBufferedComplete = function(Rt, Lt) {
                                var Bt, Nt, $t = this.mediaBuffer ? this.mediaBuffer : this.media;
                                this.log("Buffered " + Rt.type + " sn: " + Rt.sn + (Lt ? " part: " + Lt.index : "") + " of " + (this.logPrefix === "[stream-controller]" ? "level" : "track") + " " + Rt.level + " " + ($t ? ft.default.toString(pt.BufferHelper.getBuffered($t)) : "(detached)")), this.state = yt.IDLE, $t && (!this.loadedmetadata && Rt.type == dt.PlaylistLevelType.MAIN && $t.buffered.length && ((Bt = this.fragCurrent) === null || Bt === void 0 ? void 0 : Bt.sn) === ((Nt = this.fragPrevious) === null || Nt === void 0 ? void 0 : Nt.sn) && (this.loadedmetadata = !0, this.seekToStartPos()), this.tick())
                            }, kt.seekToStartPos = function() {}, kt._handleFragmentLoadComplete = function(Rt) {
                                var Lt = this.transmuxer;
                                if (!!Lt) {
                                    var Bt = Rt.frag,
                                        Nt = Rt.part,
                                        $t = Rt.partsLoaded,
                                        jt = !$t || $t.length === 0 || $t.some(function(Ht) {
                                            return !Ht
                                        }),
                                        Ut = new ht.ChunkMetadata(Bt.level, Bt.sn, Bt.stats.chunkCount + 1, 0, Nt ? Nt.index : -1, !jt);
                                    Lt.flush(Ut)
                                }
                            }, kt._handleFragmentLoadProgress = function(Rt) {}, kt._doFragLoad = function(Rt, Lt, Bt, Nt) {
                                var $t = this;
                                if (Bt === void 0 && (Bt = null), !this.levels) throw new Error("frag load aborted, missing levels");
                                if (Bt = Math.max(Rt.start, Bt || 0), this.config.lowLatencyMode && Lt) {
                                    var jt = Lt.partList;
                                    if (jt && Nt) {
                                        Bt > Rt.end && Lt.fragmentHint && (Rt = Lt.fragmentHint);
                                        var Ut = this.getNextPart(jt, Rt, Bt);
                                        if (Ut > -1) {
                                            var Ht = jt[Ut];
                                            return this.log("Loading part sn: " + Rt.sn + " p: " + Ht.index + " cc: " + Rt.cc + " of playlist [" + Lt.startSN + "-" + Lt.endSN + "] parts [0-" + Ut + "-" + (jt.length - 1) + "] " + (this.logPrefix === "[stream-controller]" ? "level" : "track") + ": " + Rt.level + ", target: " + parseFloat(Bt.toFixed(3))), this.nextLoadPosition = Ht.start + Ht.duration, this.state = yt.FRAG_LOADING, this.hls.trigger(At.Events.FRAG_LOADING, {
                                                frag: Rt,
                                                part: jt[Ut],
                                                targetBufferTime: Bt
                                            }), this.doFragPartsLoad(Rt, jt, Ut, Nt).catch(function(Wt) {
                                                return $t.handleFragLoadError(Wt)
                                            })
                                        } else if (!Rt.url || this.loadedEndOfParts(jt, Bt)) return Promise.resolve(null)
                                    }
                                }
                                return this.log("Loading fragment " + Rt.sn + " cc: " + Rt.cc + " " + (Lt ? "of [" + Lt.startSN + "-" + Lt.endSN + "] " : "") + (this.logPrefix === "[stream-controller]" ? "level" : "track") + ": " + Rt.level + ", target: " + parseFloat(Bt.toFixed(3))), (0, ut.isFiniteNumber)(Rt.sn) && !this.bitrateTest && (this.nextLoadPosition = Rt.start + Rt.duration), this.state = yt.FRAG_LOADING, this.hls.trigger(At.Events.FRAG_LOADING, {
                                    frag: Rt,
                                    targetBufferTime: Bt
                                }), this.fragmentLoader.load(Rt, Nt).catch(function(Wt) {
                                    return $t.handleFragLoadError(Wt)
                                })
                            }, kt.doFragPartsLoad = function(Rt, Lt, Bt, Nt) {
                                var $t = this;
                                return new Promise(function(jt, Ut) {
                                    var Ht = [],
                                        Wt = function Kt(Gt) {
                                            var Vt = Lt[Gt];
                                            $t.fragmentLoader.loadPart(Rt, Vt, Nt).then(function(zt) {
                                                Ht[Vt.index] = zt;
                                                var Xt = zt.part;
                                                $t.hls.trigger(At.Events.FRAG_LOADED, zt);
                                                var Yt = Lt[Gt + 1];
                                                if (Yt && Yt.fragment === Rt) Kt(Gt + 1);
                                                else return jt({
                                                    frag: Rt,
                                                    part: Xt,
                                                    partsLoaded: Ht
                                                })
                                            }).catch(Ut)
                                        };
                                    Wt(Bt)
                                })
                            }, kt.handleFragLoadError = function(Rt) {
                                var Lt = Rt.data;
                                return Lt && Lt.details === Ct.ErrorDetails.INTERNAL_ABORTED ? this.handleFragLoadAborted(Lt.frag, Lt.part) : this.hls.trigger(At.Events.ERROR, Lt), null
                            }, kt._handleTransmuxerFlush = function(Rt) {
                                var Lt = this.getCurrentContext(Rt);
                                if (!Lt || this.state !== yt.PARSING) {
                                    this.fragCurrent || (this.state = yt.IDLE);
                                    return
                                }
                                var Bt = Lt.frag,
                                    Nt = Lt.part,
                                    $t = Lt.level,
                                    jt = self.performance.now();
                                Bt.stats.parsing.end = jt, Nt && (Nt.stats.parsing.end = jt), this.updateLevelTiming(Bt, Nt, $t, Rt.partial)
                            }, kt.getCurrentContext = function(Rt) {
                                var Lt = this.levels,
                                    Bt = Rt.level,
                                    Nt = Rt.sn,
                                    $t = Rt.part;
                                if (!Lt || !Lt[Bt]) return this.warn("Levels object was unset while buffering fragment " + Nt + " of level " + Bt + ". The current chunk will not be buffered."), null;
                                var jt = Lt[Bt],
                                    Ut = $t > -1 ? (0, Dt.getPartWith)(jt, Nt, $t) : null,
                                    Ht = Ut ? Ut.fragment : (0, Dt.getFragmentWithSN)(jt, Nt, this.fragCurrent);
                                return Ht ? {
                                    frag: Ht,
                                    part: Ut,
                                    level: jt
                                } : null
                            }, kt.bufferFragmentData = function(Rt, Lt, Bt, Nt) {
                                if (!(!Rt || this.state !== yt.PARSING)) {
                                    var $t = Rt.data1,
                                        jt = Rt.data2,
                                        Ut = $t;
                                    if ($t && jt && (Ut = (0, ot.appendUint8Array)($t, jt)), !(!Ut || !Ut.length)) {
                                        var Ht = {
                                            type: Rt.type,
                                            frag: Lt,
                                            part: Bt,
                                            chunkMeta: Nt,
                                            parent: Lt.type,
                                            data: Ut
                                        };
                                        this.hls.trigger(At.Events.BUFFER_APPENDING, Ht), Rt.dropped && Rt.independent && !Bt && this.flushBufferGap(Lt)
                                    }
                                }
                            }, kt.flushBufferGap = function(Rt) {
                                var Lt = this.media;
                                if (!!Lt) {
                                    if (!pt.BufferHelper.isBuffered(Lt, Lt.currentTime)) {
                                        this.flushMainBuffer(0, Rt.start);
                                        return
                                    }
                                    var Bt = Lt.currentTime,
                                        Nt = pt.BufferHelper.bufferInfo(Lt, Bt, 0),
                                        $t = Rt.duration,
                                        jt = Math.min(this.config.maxFragLookUpTolerance * 2, $t * .25),
                                        Ut = Math.max(Math.min(Rt.start - jt, Nt.end - jt), Bt + jt);
                                    Rt.start - Ut > jt && this.flushMainBuffer(Ut, Rt.start)
                                }
                            }, kt.getFwdBufferInfo = function(Rt, Lt) {
                                var Bt = this.config,
                                    Nt = this.getLoadPosition();
                                if (!(0, ut.isFiniteNumber)(Nt)) return null;
                                var $t = pt.BufferHelper.bufferInfo(Rt, Nt, Bt.maxBufferHole);
                                if ($t.len === 0 && $t.nextStart !== void 0) {
                                    var jt = this.fragmentTracker.getBufferedFrag(Nt, Lt);
                                    if (jt && $t.nextStart < jt.end) return pt.BufferHelper.bufferInfo(Rt, Nt, Math.max($t.nextStart, Bt.maxBufferHole))
                                }
                                return $t
                            }, kt.getMaxBufferLength = function(Rt) {
                                var Lt = this.config,
                                    Bt;
                                return Rt ? Bt = Math.max(8 * Lt.maxBufferSize / Rt, Lt.maxBufferLength) : Bt = Lt.maxBufferLength, Math.min(Bt, Lt.maxMaxBufferLength)
                            }, kt.reduceMaxBufferLength = function(Rt) {
                                var Lt = this.config,
                                    Bt = Rt || Lt.maxBufferLength;
                                return Lt.maxMaxBufferLength >= Bt ? (Lt.maxMaxBufferLength /= 2, this.warn("Reduce max buffer length to " + Lt.maxMaxBufferLength + "s"), !0) : !1
                            }, kt.getNextFragment = function(Rt, Lt) {
                                var Bt = Lt.fragments,
                                    Nt = Bt.length;
                                if (!Nt) return null;
                                var $t = this.config,
                                    jt = Bt[0].start,
                                    Ut;
                                if (Lt.live) {
                                    var Ht = $t.initialLiveManifestSize;
                                    if (Nt < Ht) return this.warn("Not enough fragments to start playback (have: " + Nt + ", need: " + Ht + ")"), null;
                                    !Lt.PTSKnown && !this.startFragRequested && this.startPosition === -1 && (Ut = this.getInitialLiveFragment(Lt, Bt), this.startPosition = Ut ? this.hls.liveSyncPosition || Ut.start : Rt)
                                } else Rt <= jt && (Ut = Bt[0]);
                                if (!Ut) {
                                    var Wt = $t.lowLatencyMode ? Lt.partEnd : Lt.fragmentEnd;
                                    Ut = this.getFragmentAtPosition(Rt, Wt, Lt)
                                }
                                return this.mapToInitFragWhenRequired(Ut)
                            }, kt.mapToInitFragWhenRequired = function(Rt) {
                                return Rt != null && Rt.initSegment && !(Rt != null && Rt.initSegment.data) && !this.bitrateTest ? Rt.initSegment : Rt
                            }, kt.getNextPart = function(Rt, Lt, Bt) {
                                for (var Nt = -1, $t = !1, jt = !0, Ut = 0, Ht = Rt.length; Ut < Ht; Ut++) {
                                    var Wt = Rt[Ut];
                                    if (jt = jt && !Wt.independent, Nt > -1 && Bt < Wt.start) break;
                                    var Kt = Wt.loaded;
                                    !Kt && ($t || Wt.independent || jt) && Wt.fragment === Lt && (Nt = Ut), $t = Kt
                                }
                                return Nt
                            }, kt.loadedEndOfParts = function(Rt, Lt) {
                                var Bt = Rt[Rt.length - 1];
                                return Bt && Lt > Bt.start && Bt.loaded
                            }, kt.getInitialLiveFragment = function(Rt, Lt) {
                                var Bt = this.fragPrevious,
                                    Nt = null;
                                if (Bt) {
                                    if (Rt.hasProgramDateTime && (this.log("Live playlist, switching playlist, load frag with same PDT: " + Bt.programDateTime), Nt = (0, Et.findFragmentByPDT)(Lt, Bt.endProgramDateTime, this.config.maxFragLookUpTolerance)), !Nt) {
                                        var $t = Bt.sn + 1;
                                        if ($t >= Rt.startSN && $t <= Rt.endSN) {
                                            var jt = Lt[$t - Rt.startSN];
                                            Bt.cc === jt.cc && (Nt = jt, this.log("Live playlist, switching playlist, load frag with next SN: " + Nt.sn))
                                        }
                                        Nt || (Nt = (0, Et.findFragWithCC)(Lt, Bt.cc), Nt && this.log("Live playlist, switching playlist, load frag with same CC: " + Nt.sn))
                                    }
                                } else {
                                    var Ut = this.hls.liveSyncPosition;
                                    Ut !== null && (Nt = this.getFragmentAtPosition(Ut, this.bitrateTest ? Rt.fragmentEnd : Rt.edge, Rt))
                                }
                                return Nt
                            }, kt.getFragmentAtPosition = function(Rt, Lt, Bt) {
                                var Nt = this.config,
                                    $t = this.fragPrevious,
                                    jt = Bt.fragments,
                                    Ut = Bt.endSN,
                                    Ht = Bt.fragmentHint,
                                    Wt = Nt.maxFragLookUpTolerance,
                                    Kt = !!(Nt.lowLatencyMode && Bt.partList && Ht);
                                Kt && Ht && !this.bitrateTest && (jt = jt.concat(Ht), Ut = Ht.sn);
                                var Gt;
                                if (Rt < Lt) {
                                    var Vt = Rt > Lt - Wt ? 0 : Wt;
                                    Gt = (0, Et.findFragmentByPTS)($t, jt, Rt, Vt)
                                } else Gt = jt[jt.length - 1];
                                if (Gt) {
                                    var zt = Gt.sn - Bt.startSN;
                                    if (this.fragmentTracker.getState(Gt) === bt.FragmentState.OK && ($t = Gt), $t && Gt.sn === $t.sn && !Kt) {
                                        var Xt = $t && Gt.level === $t.level;
                                        if (Xt) {
                                            var Yt = jt[zt + 1];
                                            Gt.sn < Ut && this.fragmentTracker.getState(Yt) !== bt.FragmentState.OK ? (this.log("SN " + Gt.sn + " just loaded, load next one: " + Yt.sn), Gt = Yt) : Gt = null
                                        }
                                    }
                                }
                                return Gt
                            }, kt.synchronizeToLiveEdge = function(Rt) {
                                var Lt = this.config,
                                    Bt = this.media;
                                if (!!Bt) {
                                    var Nt = this.hls.liveSyncPosition,
                                        $t = Bt.currentTime,
                                        jt = Rt.fragments[0].start,
                                        Ut = Rt.edge,
                                        Ht = $t >= jt - Lt.maxFragLookUpTolerance && $t <= Ut;
                                    if (Nt !== null && Bt.duration > Nt && ($t < Nt || !Ht)) {
                                        var Wt = Lt.liveMaxLatencyDuration !== void 0 ? Lt.liveMaxLatencyDuration : Lt.liveMaxLatencyDurationCount * Rt.targetduration;
                                        (!Ht && Bt.readyState < 4 || $t < Ut - Wt) && (this.loadedmetadata || (this.nextLoadPosition = Nt), Bt.readyState && (this.warn("Playback: " + $t.toFixed(3) + " is located too far from the end of live sliding playlist: " + Ut + ", reset currentTime to : " + Nt.toFixed(3)), Bt.currentTime = Nt))
                                    }
                                }
                            }, kt.alignPlaylists = function(Rt, Lt) {
                                var Bt = this.levels,
                                    Nt = this.levelLastLoaded,
                                    $t = this.fragPrevious,
                                    jt = Nt !== null ? Bt[Nt] : null,
                                    Ut = Rt.fragments.length;
                                if (!Ut) return this.warn("No fragments in live playlist"), 0;
                                var Ht = Rt.fragments[0].start,
                                    Wt = !Lt,
                                    Kt = Rt.alignedSliding && (0, ut.isFiniteNumber)(Ht);
                                if (Wt || !Kt && !Ht) {
                                    (0, ct.alignStream)($t, jt, Rt);
                                    var Gt = Rt.fragments[0].start;
                                    return this.log("Live playlist sliding: " + Gt.toFixed(2) + " start-sn: " + (Lt ? Lt.startSN : "na") + "->" + Rt.startSN + " prev-sn: " + ($t ? $t.sn : "na") + " fragments: " + Ut), Gt
                                }
                                return Ht
                            }, kt.waitForCdnTuneIn = function(Rt) {
                                var Lt = 3;
                                return Rt.live && Rt.canBlockReload && Rt.partTarget && Rt.tuneInGoal > Math.max(Rt.partHoldBack, Rt.partTarget * Lt)
                            }, kt.setStartPosition = function(Rt, Lt) {
                                var Bt = this.startPosition;
                                if (Bt < Lt && (Bt = -1), Bt === -1 || this.lastCurrentTime === -1) {
                                    var Nt = Rt.startTimeOffset;
                                    (0, ut.isFiniteNumber)(Nt) ? (Bt = Lt + Nt, Nt < 0 && (Bt += Rt.totalduration), Bt = Math.min(Math.max(Lt, Bt), Lt + Rt.totalduration), this.log("Start time offset " + Nt + " found in playlist, adjust startPosition to " + Bt), this.startPosition = Bt) : Rt.live ? Bt = this.hls.liveSyncPosition || Lt : this.startPosition = Bt = 0, this.lastCurrentTime = Bt
                                }
                                this.nextLoadPosition = Bt
                            }, kt.getLoadPosition = function() {
                                var Rt = this.media,
                                    Lt = 0;
                                return this.loadedmetadata && Rt ? Lt = Rt.currentTime : this.nextLoadPosition && (Lt = this.nextLoadPosition), Lt
                            }, kt.handleFragLoadAborted = function(Rt, Lt) {
                                this.transmuxer && Rt.sn !== "initSegment" && Rt.stats.aborted && (this.warn("Fragment " + Rt.sn + (Lt ? " part" + Lt.index : "") + " of level " + Rt.level + " was aborted"), this.resetFragmentLoading(Rt))
                            }, kt.resetFragmentLoading = function(Rt) {
                                (!this.fragCurrent || !this.fragContextChanged(Rt) && this.state !== yt.FRAG_LOADING_WAITING_RETRY) && (this.state = yt.IDLE)
                            }, kt.onFragmentOrKeyLoadError = function(Rt, Lt) {
                                if (!Lt.fatal) {
                                    var Bt = Lt.frag;
                                    if (!(!Bt || Bt.type !== Rt)) {
                                        var Nt = this.fragCurrent;
                                        console.assert(Nt && Bt.sn === Nt.sn && Bt.level === Nt.level && Bt.urlId === Nt.urlId, "Frag load error must match current frag to retry");
                                        var $t = this.config;
                                        if (this.fragLoadError + 1 <= $t.fragLoadingMaxRetry) {
                                            this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition);
                                            var jt = Math.min(Math.pow(2, this.fragLoadError) * $t.fragLoadingRetryDelay, $t.fragLoadingMaxRetryTimeout);
                                            this.warn("Fragment " + Bt.sn + " of " + Rt + " " + Bt.level + " failed to load, retrying in " + jt + "ms"), this.retryDate = self.performance.now() + jt, this.fragLoadError++, this.state = yt.FRAG_LOADING_WAITING_RETRY
                                        } else Lt.levelRetry ? (Rt === dt.PlaylistLevelType.AUDIO && (this.fragCurrent = null), this.fragLoadError = 0, this.state = yt.IDLE) : (It.logger.error(Lt.details + " reaches max retry, redispatch as fatal ..."), Lt.fatal = !0, this.hls.stopLoad(), this.state = yt.ERROR)
                                    }
                                }
                            }, kt.afterBufferFlushed = function(Rt, Lt, Bt) {
                                if (!!Rt) {
                                    var Nt = pt.BufferHelper.getBuffered(Rt);
                                    this.fragmentTracker.detectEvictedFragments(Lt, Nt, Bt), this.state === yt.ENDED && this.resetLoadingState()
                                }
                            }, kt.resetLoadingState = function() {
                                this.fragCurrent = null, this.fragPrevious = null, this.state = yt.IDLE
                            }, kt.resetStartWhenNotLoaded = function(Rt) {
                                if (!this.loadedmetadata) {
                                    this.startFragRequested = !1;
                                    var Lt = this.levels ? this.levels[Rt].details : null;
                                    Lt != null && Lt.live ? (this.startPosition = -1, this.setStartPosition(Lt, 0), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition
                                }
                            }, kt.updateLevelTiming = function(Rt, Lt, Bt, Nt) {
                                var $t = this,
                                    jt = Bt.details;
                                console.assert(!!jt, "level.details must be defined");
                                var Ut = Object.keys(Rt.elementaryStreams).reduce(function(Ht, Wt) {
                                    var Kt = Rt.elementaryStreams[Wt];
                                    if (Kt) {
                                        var Gt = Kt.endPTS - Kt.startPTS;
                                        if (Gt <= 0) return $t.warn("Could not parse fragment " + Rt.sn + " " + Wt + " duration reliably (" + Gt + ")"), Ht || !1;
                                        var Vt = Nt ? 0 : (0, Dt.updateFragPTSDTS)(jt, Rt, Kt.startPTS, Kt.endPTS, Kt.startDTS, Kt.endDTS);
                                        return $t.hls.trigger(At.Events.LEVEL_PTS_UPDATED, {
                                            details: jt,
                                            level: Bt,
                                            drift: Vt,
                                            type: Wt,
                                            frag: Rt,
                                            start: Kt.startPTS,
                                            end: Kt.endPTS
                                        }), !0
                                    }
                                    return Ht
                                }, !1);
                                Ut || (this.warn("Found no media in fragment " + Rt.sn + " of level " + Bt.id + " resetting transmuxer to fallback to playlist timing"), this.resetTransmuxer()), this.state = yt.PARSED, this.hls.trigger(At.Events.FRAG_PARSED, {
                                    frag: Rt,
                                    part: Lt
                                })
                            }, kt.resetTransmuxer = function() {
                                this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null)
                            }, _t(wt, [{
                                key: "state",
                                get: function() {
                                    return this._state
                                },
                                set: function(Rt) {
                                    var Lt = this._state;
                                    Lt !== Rt && (this._state = Rt, this.log(Lt + "->" + Rt))
                                }
                            }]), wt
                        }(lt.default)
                },
                "./src/controller/buffer-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => Et
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/events.ts"),
                        bt = it("./src/utils/logger.ts"),
                        pt = it("./src/errors.ts"),
                        It = it("./src/utils/buffer-helper.ts"),
                        At = it("./src/utils/mediasource-helper.ts"),
                        Ct = it("./src/loader/fragment.ts"),
                        ht = it("./src/controller/buffer-operation-queue.ts"),
                        ot = (0, At.getMediaSource)(),
                        ct = /([ha]vc.)(?:\.[^.,]+)+/,
                        Et = function() {
                            function Dt(gt) {
                                var ft = this;
                                this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.appendError = 0, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this._onMediaSourceOpen = function() {
                                    var dt = ft.hls,
                                        St = ft.media,
                                        _t = ft.mediaSource;
                                    bt.logger.log("[buffer-controller]: Media source opened"), St && (ft.updateMediaElementDuration(), dt.trigger(lt.Events.MEDIA_ATTACHED, {
                                        media: St
                                    })), _t && _t.removeEventListener("sourceopen", ft._onMediaSourceOpen), ft.checkPendingTracks()
                                }, this._onMediaSourceClose = function() {
                                    bt.logger.log("[buffer-controller]: Media source closed")
                                }, this._onMediaSourceEnded = function() {
                                    bt.logger.log("[buffer-controller]: Media source ended")
                                }, this.hls = gt, this._initSourceBuffer(), this.registerListeners()
                            }
                            var Pt = Dt.prototype;
                            return Pt.hasSourceTypes = function() {
                                return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0
                            }, Pt.destroy = function() {
                                this.unregisterListeners(), this.details = null
                            }, Pt.registerListeners = function() {
                                var ft = this.hls;
                                ft.on(lt.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), ft.on(lt.Events.MEDIA_DETACHING, this.onMediaDetaching, this), ft.on(lt.Events.MANIFEST_PARSED, this.onManifestParsed, this), ft.on(lt.Events.BUFFER_RESET, this.onBufferReset, this), ft.on(lt.Events.BUFFER_APPENDING, this.onBufferAppending, this), ft.on(lt.Events.BUFFER_CODECS, this.onBufferCodecs, this), ft.on(lt.Events.BUFFER_EOS, this.onBufferEos, this), ft.on(lt.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), ft.on(lt.Events.LEVEL_UPDATED, this.onLevelUpdated, this), ft.on(lt.Events.FRAG_PARSED, this.onFragParsed, this), ft.on(lt.Events.FRAG_CHANGED, this.onFragChanged, this)
                            }, Pt.unregisterListeners = function() {
                                var ft = this.hls;
                                ft.off(lt.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), ft.off(lt.Events.MEDIA_DETACHING, this.onMediaDetaching, this), ft.off(lt.Events.MANIFEST_PARSED, this.onManifestParsed, this), ft.off(lt.Events.BUFFER_RESET, this.onBufferReset, this), ft.off(lt.Events.BUFFER_APPENDING, this.onBufferAppending, this), ft.off(lt.Events.BUFFER_CODECS, this.onBufferCodecs, this), ft.off(lt.Events.BUFFER_EOS, this.onBufferEos, this), ft.off(lt.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), ft.off(lt.Events.LEVEL_UPDATED, this.onLevelUpdated, this), ft.off(lt.Events.FRAG_PARSED, this.onFragParsed, this), ft.off(lt.Events.FRAG_CHANGED, this.onFragChanged, this)
                            }, Pt._initSourceBuffer = function() {
                                this.sourceBuffer = {}, this.operationQueue = new ht.default(this.sourceBuffer), this.listeners = {
                                    audio: [],
                                    video: [],
                                    audiovideo: []
                                }
                            }, Pt.onManifestParsed = function(ft, dt) {
                                var St = 2;
                                (dt.audio && !dt.video || !dt.altAudio) && (St = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = St, this.details = null, bt.logger.log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected")
                            }, Pt.onMediaAttaching = function(ft, dt) {
                                var St = this.media = dt.media;
                                if (St && ot) {
                                    var _t = this.mediaSource = new ot;
                                    _t.addEventListener("sourceopen", this._onMediaSourceOpen), _t.addEventListener("sourceended", this._onMediaSourceEnded), _t.addEventListener("sourceclose", this._onMediaSourceClose), St.src = self.URL.createObjectURL(_t), this._objectUrl = St.src
                                }
                            }, Pt.onMediaDetaching = function() {
                                var ft = this.media,
                                    dt = this.mediaSource,
                                    St = this._objectUrl;
                                if (dt) {
                                    if (bt.logger.log("[buffer-controller]: media source detaching"), dt.readyState === "open") try {
                                        dt.endOfStream()
                                    } catch (_t) {
                                        bt.logger.warn("[buffer-controller]: onMediaDetaching: " + _t.message + " while calling endOfStream")
                                    }
                                    this.onBufferReset(), dt.removeEventListener("sourceopen", this._onMediaSourceOpen), dt.removeEventListener("sourceended", this._onMediaSourceEnded), dt.removeEventListener("sourceclose", this._onMediaSourceClose), ft && (St && self.URL.revokeObjectURL(St), ft.src === St ? (ft.removeAttribute("src"), ft.load()) : bt.logger.warn("[buffer-controller]: media.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {}
                                }
                                this.hls.trigger(lt.Events.MEDIA_DETACHED, void 0)
                            }, Pt.onBufferReset = function() {
                                var ft = this;
                                this.getSourceBufferTypes().forEach(function(dt) {
                                    var St = ft.sourceBuffer[dt];
                                    try {
                                        St && (ft.removeBufferListeners(dt), ft.mediaSource && ft.mediaSource.removeSourceBuffer(St), ft.sourceBuffer[dt] = void 0)
                                    } catch (_t) {
                                        bt.logger.warn("[buffer-controller]: Failed to reset the " + dt + " buffer", _t)
                                    }
                                }), this._initSourceBuffer()
                            }, Pt.onBufferCodecs = function(ft, dt) {
                                var St = this,
                                    _t = this.getSourceBufferTypes().length;
                                Object.keys(dt).forEach(function(vt) {
                                    if (_t) {
                                        var mt = St.tracks[vt];
                                        if (mt && typeof mt.buffer.changeType == "function") {
                                            var xt = dt[vt],
                                                yt = xt.id,
                                                Tt = xt.codec,
                                                Ft = xt.levelCodec,
                                                wt = xt.container,
                                                kt = xt.metadata,
                                                Ot = (mt.levelCodec || mt.codec).replace(ct, "$1"),
                                                Rt = (Ft || Tt).replace(ct, "$1");
                                            if (Ot !== Rt) {
                                                var Lt = wt + ";codecs=" + (Ft || Tt);
                                                St.appendChangeType(vt, Lt), bt.logger.log("[buffer-controller]: switching codec " + Ot + " to " + Rt), St.tracks[vt] = {
                                                    buffer: mt.buffer,
                                                    codec: Tt,
                                                    container: wt,
                                                    levelCodec: Ft,
                                                    metadata: kt,
                                                    id: yt
                                                }
                                            }
                                        }
                                    } else St.pendingTracks[vt] = dt[vt]
                                }), !_t && (this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0), this.mediaSource && this.mediaSource.readyState === "open" && this.checkPendingTracks())
                            }, Pt.appendChangeType = function(ft, dt) {
                                var St = this,
                                    _t = this.operationQueue,
                                    vt = {
                                        execute: function() {
                                            var xt = St.sourceBuffer[ft];
                                            xt && (bt.logger.log("[buffer-controller]: changing " + ft + " sourceBuffer type to " + dt), xt.changeType(dt)), _t.shiftAndExecuteNext(ft)
                                        },
                                        onStart: function() {},
                                        onComplete: function() {},
                                        onError: function(xt) {
                                            bt.logger.warn("[buffer-controller]: Failed to change " + ft + " SourceBuffer type", xt)
                                        }
                                    };
                                _t.append(vt, ft)
                            }, Pt.onBufferAppending = function(ft, dt) {
                                var St = this,
                                    _t = this.hls,
                                    vt = this.operationQueue,
                                    mt = this.tracks,
                                    xt = dt.data,
                                    yt = dt.type,
                                    Tt = dt.frag,
                                    Ft = dt.part,
                                    wt = dt.chunkMeta,
                                    kt = wt.buffering[yt],
                                    Ot = self.performance.now();
                                kt.start = Ot;
                                var Rt = Tt.stats.buffering,
                                    Lt = Ft ? Ft.stats.buffering : null;
                                Rt.start === 0 && (Rt.start = Ot), Lt && Lt.start === 0 && (Lt.start = Ot);
                                var Bt = mt.audio,
                                    Nt = yt === "audio" && wt.id === 1 && (Bt == null ? void 0 : Bt.container) === "audio/mpeg",
                                    $t = {
                                        execute: function() {
                                            if (kt.executeStart = self.performance.now(), Nt) {
                                                var Ut = St.sourceBuffer[yt];
                                                if (Ut) {
                                                    var Ht = Tt.start - Ut.timestampOffset;
                                                    Math.abs(Ht) >= .1 && (bt.logger.log("[buffer-controller]: Updating audio SourceBuffer timestampOffset to " + Tt.start + " (delta: " + Ht + ") sn: " + Tt.sn + ")"), Ut.timestampOffset = Tt.start)
                                                }
                                            }
                                            St.appendExecutor(xt, yt)
                                        },
                                        onStart: function() {},
                                        onComplete: function() {
                                            var Ut = self.performance.now();
                                            kt.executeEnd = kt.end = Ut, Rt.first === 0 && (Rt.first = Ut), Lt && Lt.first === 0 && (Lt.first = Ut);
                                            var Ht = St.sourceBuffer,
                                                Wt = {};
                                            for (var Kt in Ht) Wt[Kt] = It.BufferHelper.getBuffered(Ht[Kt]);
                                            St.appendError = 0, St.hls.trigger(lt.Events.BUFFER_APPENDED, {
                                                type: yt,
                                                frag: Tt,
                                                part: Ft,
                                                chunkMeta: wt,
                                                parent: Tt.type,
                                                timeRanges: Wt
                                            })
                                        },
                                        onError: function(Ut) {
                                            bt.logger.error("[buffer-controller]: Error encountered while trying to append to the " + yt + " SourceBuffer", Ut);
                                            var Ht = {
                                                type: pt.ErrorTypes.MEDIA_ERROR,
                                                parent: Tt.type,
                                                details: pt.ErrorDetails.BUFFER_APPEND_ERROR,
                                                err: Ut,
                                                fatal: !1
                                            };
                                            Ut.code === DOMException.QUOTA_EXCEEDED_ERR ? Ht.details = pt.ErrorDetails.BUFFER_FULL_ERROR : (St.appendError++, Ht.details = pt.ErrorDetails.BUFFER_APPEND_ERROR, St.appendError > _t.config.appendErrorMaxRetry && (bt.logger.error("[buffer-controller]: Failed " + _t.config.appendErrorMaxRetry + " times to append segment in sourceBuffer"), Ht.fatal = !0, _t.stopLoad())), _t.trigger(lt.Events.ERROR, Ht)
                                        }
                                    };
                                vt.append($t, yt)
                            }, Pt.onBufferFlushing = function(ft, dt) {
                                var St = this,
                                    _t = this.operationQueue,
                                    vt = function(xt) {
                                        return {
                                            execute: St.removeExecutor.bind(St, xt, dt.startOffset, dt.endOffset),
                                            onStart: function() {},
                                            onComplete: function() {
                                                St.hls.trigger(lt.Events.BUFFER_FLUSHED, {
                                                    type: xt
                                                })
                                            },
                                            onError: function(Tt) {
                                                bt.logger.warn("[buffer-controller]: Failed to remove from " + xt + " SourceBuffer", Tt)
                                            }
                                        }
                                    };
                                dt.type ? _t.append(vt(dt.type), dt.type) : this.getSourceBufferTypes().forEach(function(mt) {
                                    _t.append(vt(mt), mt)
                                })
                            }, Pt.onFragParsed = function(ft, dt) {
                                var St = this,
                                    _t = dt.frag,
                                    vt = dt.part,
                                    mt = [],
                                    xt = vt ? vt.elementaryStreams : _t.elementaryStreams;
                                xt[Ct.ElementaryStreamTypes.AUDIOVIDEO] ? mt.push("audiovideo") : (xt[Ct.ElementaryStreamTypes.AUDIO] && mt.push("audio"), xt[Ct.ElementaryStreamTypes.VIDEO] && mt.push("video"));
                                var yt = function() {
                                    var Ft = self.performance.now();
                                    _t.stats.buffering.end = Ft, vt && (vt.stats.buffering.end = Ft);
                                    var wt = vt ? vt.stats : _t.stats;
                                    St.hls.trigger(lt.Events.FRAG_BUFFERED, {
                                        frag: _t,
                                        part: vt,
                                        stats: wt,
                                        id: _t.type
                                    })
                                };
                                mt.length === 0 && bt.logger.warn("Fragments must have at least one ElementaryStreamType set. type: " + _t.type + " level: " + _t.level + " sn: " + _t.sn), this.blockBuffers(yt, mt)
                            }, Pt.onFragChanged = function(ft, dt) {
                                this.flushBackBuffer()
                            }, Pt.onBufferEos = function(ft, dt) {
                                var St = this,
                                    _t = this.getSourceBufferTypes().reduce(function(vt, mt) {
                                        var xt = St.sourceBuffer[mt];
                                        return (!dt.type || dt.type === mt) && xt && !xt.ended && (xt.ended = !0, bt.logger.log("[buffer-controller]: " + mt + " sourceBuffer now EOS")), vt && !!(!xt || xt.ended)
                                    }, !0);
                                _t && this.blockBuffers(function() {
                                    var vt = St.mediaSource;
                                    !vt || vt.readyState !== "open" || vt.endOfStream()
                                })
                            }, Pt.onLevelUpdated = function(ft, dt) {
                                var St = dt.details;
                                !St.fragments.length || (this.details = St, this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration())
                            }, Pt.flushBackBuffer = function() {
                                var ft = this.hls,
                                    dt = this.details,
                                    St = this.media,
                                    _t = this.sourceBuffer;
                                if (!(!St || dt === null)) {
                                    var vt = this.getSourceBufferTypes();
                                    if (!!vt.length) {
                                        var mt = dt.live && ft.config.liveBackBufferLength !== null ? ft.config.liveBackBufferLength : ft.config.backBufferLength;
                                        if (!(!(0, ut.isFiniteNumber)(mt) || mt < 0)) {
                                            var xt = St.currentTime,
                                                yt = dt.levelTargetDuration,
                                                Tt = Math.max(mt, yt),
                                                Ft = Math.floor(xt / yt) * yt - Tt;
                                            vt.forEach(function(wt) {
                                                var kt = _t[wt];
                                                if (kt) {
                                                    var Ot = It.BufferHelper.getBuffered(kt);
                                                    Ot.length > 0 && Ft > Ot.start(0) && (ft.trigger(lt.Events.BACK_BUFFER_REACHED, {
                                                        bufferEnd: Ft
                                                    }), dt.live && ft.trigger(lt.Events.LIVE_BACK_BUFFER_REACHED, {
                                                        bufferEnd: Ft
                                                    }), ft.trigger(lt.Events.BUFFER_FLUSHING, {
                                                        startOffset: 0,
                                                        endOffset: Ft,
                                                        type: wt
                                                    }))
                                                }
                                            })
                                        }
                                    }
                                }
                            }, Pt.updateMediaElementDuration = function() {
                                if (!(!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== "open")) {
                                    var ft = this.details,
                                        dt = this.hls,
                                        St = this.media,
                                        _t = this.mediaSource,
                                        vt = ft.fragments[0].start + ft.totalduration,
                                        mt = St.duration,
                                        xt = (0, ut.isFiniteNumber)(_t.duration) ? _t.duration : 0;
                                    ft.live && dt.config.liveDurationInfinity ? (bt.logger.log("[buffer-controller]: Media Source duration is set to Infinity"), _t.duration = 1 / 0, this.updateSeekableRange(ft)) : (vt > xt && vt > mt || !(0, ut.isFiniteNumber)(mt)) && (bt.logger.log("[buffer-controller]: Updating Media Source duration to " + vt.toFixed(3)), _t.duration = vt)
                                }
                            }, Pt.updateSeekableRange = function(ft) {
                                var dt = this.mediaSource,
                                    St = ft.fragments,
                                    _t = St.length;
                                if (_t && ft.live && dt !== null && dt !== void 0 && dt.setLiveSeekableRange) {
                                    var vt = Math.max(0, St[0].start),
                                        mt = Math.max(vt, vt + ft.totalduration);
                                    dt.setLiveSeekableRange(vt, mt)
                                }
                            }, Pt.checkPendingTracks = function() {
                                var ft = this.bufferCodecEventsExpected,
                                    dt = this.operationQueue,
                                    St = this.pendingTracks,
                                    _t = Object.keys(St).length;
                                if (_t && !ft || _t === 2) {
                                    this.createSourceBuffers(St), this.pendingTracks = {};
                                    var vt = this.getSourceBufferTypes();
                                    if (vt.length === 0) {
                                        this.hls.trigger(lt.Events.ERROR, {
                                            type: pt.ErrorTypes.MEDIA_ERROR,
                                            details: pt.ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,
                                            fatal: !0,
                                            reason: "could not create source buffer for media codec(s)"
                                        });
                                        return
                                    }
                                    vt.forEach(function(mt) {
                                        dt.executeNext(mt)
                                    })
                                }
                            }, Pt.createSourceBuffers = function(ft) {
                                var dt = this.sourceBuffer,
                                    St = this.mediaSource;
                                if (!St) throw Error("createSourceBuffers called when mediaSource was null");
                                var _t = 0;
                                for (var vt in ft)
                                    if (!dt[vt]) {
                                        var mt = ft[vt];
                                        if (!mt) throw Error("source buffer exists for track " + vt + ", however track does not");
                                        var xt = mt.levelCodec || mt.codec,
                                            yt = mt.container + ";codecs=" + xt;
                                        bt.logger.log("[buffer-controller]: creating sourceBuffer(" + yt + ")");
                                        try {
                                            var Tt = dt[vt] = St.addSourceBuffer(yt),
                                                Ft = vt;
                                            this.addBufferListener(Ft, "updatestart", this._onSBUpdateStart), this.addBufferListener(Ft, "updateend", this._onSBUpdateEnd), this.addBufferListener(Ft, "error", this._onSBUpdateError), this.tracks[vt] = {
                                                buffer: Tt,
                                                codec: xt,
                                                container: mt.container,
                                                levelCodec: mt.levelCodec,
                                                metadata: mt.metadata,
                                                id: mt.id
                                            }, _t++
                                        } catch (wt) {
                                            bt.logger.error("[buffer-controller]: error while trying to add sourceBuffer: " + wt.message), this.hls.trigger(lt.Events.ERROR, {
                                                type: pt.ErrorTypes.MEDIA_ERROR,
                                                details: pt.ErrorDetails.BUFFER_ADD_CODEC_ERROR,
                                                fatal: !1,
                                                error: wt,
                                                mimeType: yt
                                            })
                                        }
                                    } _t && this.hls.trigger(lt.Events.BUFFER_CREATED, {
                                    tracks: this.tracks
                                })
                            }, Pt._onSBUpdateStart = function(ft) {
                                var dt = this.operationQueue,
                                    St = dt.current(ft);
                                St.onStart()
                            }, Pt._onSBUpdateEnd = function(ft) {
                                var dt = this.operationQueue,
                                    St = dt.current(ft);
                                St.onComplete(), dt.shiftAndExecuteNext(ft)
                            }, Pt._onSBUpdateError = function(ft, dt) {
                                bt.logger.error("[buffer-controller]: " + ft + " SourceBuffer error", dt), this.hls.trigger(lt.Events.ERROR, {
                                    type: pt.ErrorTypes.MEDIA_ERROR,
                                    details: pt.ErrorDetails.BUFFER_APPENDING_ERROR,
                                    fatal: !1
                                });
                                var St = this.operationQueue.current(ft);
                                St && St.onError(dt)
                            }, Pt.removeExecutor = function(ft, dt, St) {
                                var _t = this.media,
                                    vt = this.mediaSource,
                                    mt = this.operationQueue,
                                    xt = this.sourceBuffer,
                                    yt = xt[ft];
                                if (!_t || !vt || !yt) {
                                    bt.logger.warn("[buffer-controller]: Attempting to remove from the " + ft + " SourceBuffer, but it does not exist"), mt.shiftAndExecuteNext(ft);
                                    return
                                }
                                var Tt = (0, ut.isFiniteNumber)(_t.duration) ? _t.duration : 1 / 0,
                                    Ft = (0, ut.isFiniteNumber)(vt.duration) ? vt.duration : 1 / 0,
                                    wt = Math.max(0, dt),
                                    kt = Math.min(St, Tt, Ft);
                                kt > wt ? (bt.logger.log("[buffer-controller]: Removing [" + wt + "," + kt + "] from the " + ft + " SourceBuffer"), console.assert(!yt.updating, ft + " sourceBuffer must not be updating"), yt.remove(wt, kt)) : mt.shiftAndExecuteNext(ft)
                            }, Pt.appendExecutor = function(ft, dt) {
                                var St = this.operationQueue,
                                    _t = this.sourceBuffer,
                                    vt = _t[dt];
                                if (!vt) {
                                    bt.logger.warn("[buffer-controller]: Attempting to append to the " + dt + " SourceBuffer, but it does not exist"), St.shiftAndExecuteNext(dt);
                                    return
                                }
                                vt.ended = !1, console.assert(!vt.updating, dt + " sourceBuffer must not be updating"), vt.appendBuffer(ft)
                            }, Pt.blockBuffers = function(ft, dt) {
                                var St = this;
                                if (dt === void 0 && (dt = this.getSourceBufferTypes()), !dt.length) {
                                    bt.logger.log("[buffer-controller]: Blocking operation requested, but no SourceBuffers exist"), Promise.resolve().then(ft);
                                    return
                                }
                                var _t = this.operationQueue,
                                    vt = dt.map(function(mt) {
                                        return _t.appendBlocker(mt)
                                    });
                                Promise.all(vt).then(function() {
                                    ft(), dt.forEach(function(mt) {
                                        var xt = St.sourceBuffer[mt];
                                        (!xt || !xt.updating) && _t.shiftAndExecuteNext(mt)
                                    })
                                })
                            }, Pt.getSourceBufferTypes = function() {
                                return Object.keys(this.sourceBuffer)
                            }, Pt.addBufferListener = function(ft, dt, St) {
                                var _t = this.sourceBuffer[ft];
                                if (!!_t) {
                                    var vt = St.bind(this, ft);
                                    this.listeners[ft].push({
                                        event: dt,
                                        listener: vt
                                    }), _t.addEventListener(dt, vt)
                                }
                            }, Pt.removeBufferListeners = function(ft) {
                                var dt = this.sourceBuffer[ft];
                                !dt || this.listeners[ft].forEach(function(St) {
                                    dt.removeEventListener(St.event, St.listener)
                                })
                            }, Dt
                        }()
                },
                "./src/controller/buffer-operation-queue.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => lt
                    });
                    var ut = it("./src/utils/logger.ts"),
                        lt = function() {
                            function bt(It) {
                                this.buffers = void 0, this.queues = {
                                    video: [],
                                    audio: [],
                                    audiovideo: []
                                }, this.buffers = It
                            }
                            var pt = bt.prototype;
                            return pt.append = function(At, Ct) {
                                var ht = this.queues[Ct];
                                ht.push(At), ht.length === 1 && this.buffers[Ct] && this.executeNext(Ct)
                            }, pt.insertAbort = function(At, Ct) {
                                var ht = this.queues[Ct];
                                ht.unshift(At), this.executeNext(Ct)
                            }, pt.appendBlocker = function(At) {
                                var Ct, ht = new Promise(function(ct) {
                                        Ct = ct
                                    }),
                                    ot = {
                                        execute: Ct,
                                        onStart: function() {},
                                        onComplete: function() {},
                                        onError: function() {}
                                    };
                                return this.append(ot, At), ht
                            }, pt.executeNext = function(At) {
                                var Ct = this.buffers,
                                    ht = this.queues,
                                    ot = Ct[At],
                                    ct = ht[At];
                                if (ct.length) {
                                    var Et = ct[0];
                                    try {
                                        Et.execute()
                                    } catch (Dt) {
                                        ut.logger.warn("[buffer-operation-queue]: Unhandled exception executing the current operation"), Et.onError(Dt), (!ot || !ot.updating) && (ct.shift(), this.executeNext(At))
                                    }
                                }
                            }, pt.shiftAndExecuteNext = function(At) {
                                this.queues[At].shift(), this.executeNext(At)
                            }, pt.current = function(At) {
                                return this.queues[At][0]
                            }, bt
                        }()
                },
                "./src/controller/cap-level-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => It
                    });
                    var ut = it("./src/events.ts");

                    function lt(At, Ct) {
                        for (var ht = 0; ht < Ct.length; ht++) {
                            var ot = Ct[ht];
                            ot.enumerable = ot.enumerable || !1, ot.configurable = !0, "value" in ot && (ot.writable = !0), Object.defineProperty(At, ot.key, ot)
                        }
                    }

                    function bt(At, Ct, ht) {
                        return Ct && lt(At.prototype, Ct), ht && lt(At, ht), Object.defineProperty(At, "prototype", {
                            writable: !1
                        }), At
                    }
                    var pt = function() {
                        function At(ht) {
                            this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.hls = void 0, this.streamController = void 0, this.clientRect = void 0, this.hls = ht, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners()
                        }
                        var Ct = At.prototype;
                        return Ct.setStreamController = function(ot) {
                            this.streamController = ot
                        }, Ct.destroy = function() {
                            this.unregisterListener(), this.hls.config.capLevelToPlayerSize && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null
                        }, Ct.registerListeners = function() {
                            var ot = this.hls;
                            ot.on(ut.Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), ot.on(ut.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), ot.on(ut.Events.MANIFEST_PARSED, this.onManifestParsed, this), ot.on(ut.Events.BUFFER_CODECS, this.onBufferCodecs, this), ot.on(ut.Events.MEDIA_DETACHING, this.onMediaDetaching, this)
                        }, Ct.unregisterListener = function() {
                            var ot = this.hls;
                            ot.off(ut.Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), ot.off(ut.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), ot.off(ut.Events.MANIFEST_PARSED, this.onManifestParsed, this), ot.off(ut.Events.BUFFER_CODECS, this.onBufferCodecs, this), ot.off(ut.Events.MEDIA_DETACHING, this.onMediaDetaching, this)
                        }, Ct.onFpsDropLevelCapping = function(ot, ct) {
                            At.isLevelAllowed(ct.droppedLevel, this.restrictedLevels) && this.restrictedLevels.push(ct.droppedLevel)
                        }, Ct.onMediaAttaching = function(ot, ct) {
                            this.media = ct.media instanceof HTMLVideoElement ? ct.media : null
                        }, Ct.onManifestParsed = function(ot, ct) {
                            var Et = this.hls;
                            this.restrictedLevels = [], this.firstLevel = ct.firstLevel, Et.config.capLevelToPlayerSize && ct.video && this.startCapping()
                        }, Ct.onBufferCodecs = function(ot, ct) {
                            var Et = this.hls;
                            Et.config.capLevelToPlayerSize && ct.video && this.startCapping()
                        }, Ct.onMediaDetaching = function() {
                            this.stopCapping()
                        }, Ct.detectPlayerSize = function() {
                            if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {
                                var ot = this.hls.levels;
                                if (ot.length) {
                                    var ct = this.hls;
                                    ct.autoLevelCapping = this.getMaxLevel(ot.length - 1), ct.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = ct.autoLevelCapping
                                }
                            }
                        }, Ct.getMaxLevel = function(ot) {
                            var ct = this,
                                Et = this.hls.levels;
                            if (!Et.length) return -1;
                            var Dt = Et.filter(function(Pt, gt) {
                                return At.isLevelAllowed(gt, ct.restrictedLevels) && gt <= ot
                            });
                            return this.clientRect = null, At.getMaxLevelByMediaSize(Dt, this.mediaWidth, this.mediaHeight)
                        }, Ct.startCapping = function() {
                            this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.hls.firstLevel = this.getMaxLevel(this.firstLevel), self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize())
                        }, Ct.stopCapping = function() {
                            this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0)
                        }, Ct.getDimensions = function() {
                            if (this.clientRect) return this.clientRect;
                            var ot = this.media,
                                ct = {
                                    width: 0,
                                    height: 0
                                };
                            if (ot) {
                                var Et = ot.getBoundingClientRect();
                                ct.width = Et.width, ct.height = Et.height, !ct.width && !ct.height && (ct.width = Et.right - Et.left || ot.width || 0, ct.height = Et.bottom - Et.top || ot.height || 0)
                            }
                            return this.clientRect = ct, ct
                        }, At.isLevelAllowed = function(ot, ct) {
                            return ct === void 0 && (ct = []), ct.indexOf(ot) === -1
                        }, At.getMaxLevelByMediaSize = function(ot, ct, Et) {
                            if (!ot || !ot.length) return -1;
                            for (var Dt = function(St, _t) {
                                    return _t ? St.width !== _t.width || St.height !== _t.height : !0
                                }, Pt = ot.length - 1, gt = 0; gt < ot.length; gt += 1) {
                                var ft = ot[gt];
                                if ((ft.width >= ct || ft.height >= Et) && Dt(ft, ot[gt + 1])) {
                                    Pt = gt;
                                    break
                                }
                            }
                            return Pt
                        }, bt(At, [{
                            key: "mediaWidth",
                            get: function() {
                                return this.getDimensions().width * this.contentScaleFactor
                            }
                        }, {
                            key: "mediaHeight",
                            get: function() {
                                return this.getDimensions().height * this.contentScaleFactor
                            }
                        }, {
                            key: "contentScaleFactor",
                            get: function() {
                                var ot = 1;
                                if (!this.hls.config.ignoreDevicePixelRatio) try {
                                    ot = self.devicePixelRatio
                                } catch {}
                                return ot
                            }
                        }]), At
                    }();
                    const It = pt
                },
                "./src/controller/cmcd-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => Et
                    });
                    var ut = it("./src/events.ts"),
                        lt = it("./src/types/cmcd.ts"),
                        bt = it("./src/utils/buffer-helper.ts"),
                        pt = it("./src/utils/logger.ts");

                    function It(Dt, Pt) {
                        for (var gt = 0; gt < Pt.length; gt++) {
                            var ft = Pt[gt];
                            ft.enumerable = ft.enumerable || !1, ft.configurable = !0, "value" in ft && (ft.writable = !0), Object.defineProperty(Dt, ft.key, ft)
                        }
                    }

                    function At(Dt, Pt, gt) {
                        return Pt && It(Dt.prototype, Pt), gt && It(Dt, gt), Object.defineProperty(Dt, "prototype", {
                            writable: !1
                        }), Dt
                    }

                    function Ct(Dt, Pt) {
                        var gt = typeof Symbol < "u" && Dt[Symbol.iterator] || Dt["@@iterator"];
                        if (gt) return (gt = gt.call(Dt)).next.bind(gt);
                        if (Array.isArray(Dt) || (gt = ht(Dt)) || Pt && Dt && typeof Dt.length == "number") {
                            gt && (Dt = gt);
                            var ft = 0;
                            return function() {
                                return ft >= Dt.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: Dt[ft++]
                                }
                            }
                        }
                        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                    }

                    function ht(Dt, Pt) {
                        if (!!Dt) {
                            if (typeof Dt == "string") return ot(Dt, Pt);
                            var gt = Object.prototype.toString.call(Dt).slice(8, -1);
                            if (gt === "Object" && Dt.constructor && (gt = Dt.constructor.name), gt === "Map" || gt === "Set") return Array.from(Dt);
                            if (gt === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(gt)) return ot(Dt, Pt)
                        }
                    }

                    function ot(Dt, Pt) {
                        (Pt == null || Pt > Dt.length) && (Pt = Dt.length);
                        for (var gt = 0, ft = new Array(Pt); gt < Pt; gt++) ft[gt] = Dt[gt];
                        return ft
                    }

                    function ct() {
                        return ct = Object.assign ? Object.assign.bind() : function(Dt) {
                            for (var Pt = 1; Pt < arguments.length; Pt++) {
                                var gt = arguments[Pt];
                                for (var ft in gt) Object.prototype.hasOwnProperty.call(gt, ft) && (Dt[ft] = gt[ft])
                            }
                            return Dt
                        }, ct.apply(this, arguments)
                    }
                    var Et = function() {
                        function Dt(gt) {
                            var ft = this;
                            this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = function() {
                                ft.initialized && (ft.starved = !0), ft.buffering = !0
                            }, this.onPlaying = function() {
                                ft.initialized || (ft.initialized = !0), ft.buffering = !1
                            }, this.applyPlaylistData = function(_t) {
                                try {
                                    ft.apply(_t, {
                                        ot: lt.CMCDObjectType.MANIFEST,
                                        su: !ft.initialized
                                    })
                                } catch (vt) {
                                    pt.logger.warn("Could not generate manifest CMCD data.", vt)
                                }
                            }, this.applyFragmentData = function(_t) {
                                try {
                                    var vt = _t.frag,
                                        mt = ft.hls.levels[vt.level],
                                        xt = ft.getObjectType(vt),
                                        yt = {
                                            d: vt.duration * 1e3,
                                            ot: xt
                                        };
                                    (xt === lt.CMCDObjectType.VIDEO || xt === lt.CMCDObjectType.AUDIO || xt == lt.CMCDObjectType.MUXED) && (yt.br = mt.bitrate / 1e3, yt.tb = ft.getTopBandwidth(xt) / 1e3, yt.bl = ft.getBufferLength(xt)), ft.apply(_t, yt)
                                } catch (Tt) {
                                    pt.logger.warn("Could not generate segment CMCD data.", Tt)
                                }
                            }, this.hls = gt;
                            var dt = this.config = gt.config,
                                St = dt.cmcd;
                            St != null && (dt.pLoader = this.createPlaylistLoader(), dt.fLoader = this.createFragmentLoader(), this.sid = St.sessionId || Dt.uuid(), this.cid = St.contentId, this.useHeaders = St.useHeaders === !0, this.registerListeners())
                        }
                        var Pt = Dt.prototype;
                        return Pt.registerListeners = function() {
                            var ft = this.hls;
                            ft.on(ut.Events.MEDIA_ATTACHED, this.onMediaAttached, this), ft.on(ut.Events.MEDIA_DETACHED, this.onMediaDetached, this), ft.on(ut.Events.BUFFER_CREATED, this.onBufferCreated, this)
                        }, Pt.unregisterListeners = function() {
                            var ft = this.hls;
                            ft.off(ut.Events.MEDIA_ATTACHED, this.onMediaAttached, this), ft.off(ut.Events.MEDIA_DETACHED, this.onMediaDetached, this), ft.off(ut.Events.BUFFER_CREATED, this.onBufferCreated, this), this.onMediaDetached()
                        }, Pt.destroy = function() {
                            this.unregisterListeners(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null
                        }, Pt.onMediaAttached = function(ft, dt) {
                            this.media = dt.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying)
                        }, Pt.onMediaDetached = function() {
                            !this.media || (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null)
                        }, Pt.onBufferCreated = function(ft, dt) {
                            var St, _t;
                            this.audioBuffer = (St = dt.tracks.audio) === null || St === void 0 ? void 0 : St.buffer, this.videoBuffer = (_t = dt.tracks.video) === null || _t === void 0 ? void 0 : _t.buffer
                        }, Pt.createData = function() {
                            var ft;
                            return {
                                v: lt.CMCDVersion,
                                sf: lt.CMCDStreamingFormat.HLS,
                                sid: this.sid,
                                cid: this.cid,
                                pr: (ft = this.media) === null || ft === void 0 ? void 0 : ft.playbackRate,
                                mtp: this.hls.bandwidthEstimate / 1e3
                            }
                        }, Pt.apply = function(ft, dt) {
                            dt === void 0 && (dt = {}), ct(dt, this.createData());
                            var St = dt.ot === lt.CMCDObjectType.INIT || dt.ot === lt.CMCDObjectType.VIDEO || dt.ot === lt.CMCDObjectType.MUXED;
                            if (this.starved && St && (dt.bs = !0, dt.su = !0, this.starved = !1), dt.su == null && (dt.su = this.buffering), this.useHeaders) {
                                var _t = Dt.toHeaders(dt);
                                if (!Object.keys(_t).length) return;
                                ft.headers || (ft.headers = {}), ct(ft.headers, _t)
                            } else {
                                var vt = Dt.toQuery(dt);
                                if (!vt) return;
                                ft.url = Dt.appendQueryToUri(ft.url, vt)
                            }
                        }, Pt.getObjectType = function(ft) {
                            var dt = ft.type;
                            if (dt === "subtitle") return lt.CMCDObjectType.TIMED_TEXT;
                            if (ft.sn === "initSegment") return lt.CMCDObjectType.INIT;
                            if (dt === "audio") return lt.CMCDObjectType.AUDIO;
                            if (dt === "main") return this.hls.audioTracks.length ? lt.CMCDObjectType.VIDEO : lt.CMCDObjectType.MUXED
                        }, Pt.getTopBandwidth = function(ft) {
                            var dt = 0,
                                St, _t = this.hls;
                            if (ft === lt.CMCDObjectType.AUDIO) St = _t.audioTracks;
                            else {
                                var vt = _t.maxAutoLevel,
                                    mt = vt > -1 ? vt + 1 : _t.levels.length;
                                St = _t.levels.slice(0, mt)
                            }
                            for (var xt = Ct(St), yt; !(yt = xt()).done;) {
                                var Tt = yt.value;
                                Tt.bitrate > dt && (dt = Tt.bitrate)
                            }
                            return dt > 0 ? dt : NaN
                        }, Pt.getBufferLength = function(ft) {
                            var dt = this.hls.media,
                                St = ft === lt.CMCDObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;
                            if (!St || !dt) return NaN;
                            var _t = bt.BufferHelper.bufferInfo(St, dt.currentTime, this.config.maxBufferHole);
                            return _t.len * 1e3
                        }, Pt.createPlaylistLoader = function() {
                            var ft = this.config.pLoader,
                                dt = this.applyPlaylistData,
                                St = ft || this.config.loader;
                            return function() {
                                function _t(mt) {
                                    this.loader = void 0, this.loader = new St(mt)
                                }
                                var vt = _t.prototype;
                                return vt.destroy = function() {
                                    this.loader.destroy()
                                }, vt.abort = function() {
                                    this.loader.abort()
                                }, vt.load = function(xt, yt, Tt) {
                                    dt(xt), this.loader.load(xt, yt, Tt)
                                }, At(_t, [{
                                    key: "stats",
                                    get: function() {
                                        return this.loader.stats
                                    }
                                }, {
                                    key: "context",
                                    get: function() {
                                        return this.loader.context
                                    }
                                }]), _t
                            }()
                        }, Pt.createFragmentLoader = function() {
                            var ft = this.config.fLoader,
                                dt = this.applyFragmentData,
                                St = ft || this.config.loader;
                            return function() {
                                function _t(mt) {
                                    this.loader = void 0, this.loader = new St(mt)
                                }
                                var vt = _t.prototype;
                                return vt.destroy = function() {
                                    this.loader.destroy()
                                }, vt.abort = function() {
                                    this.loader.abort()
                                }, vt.load = function(xt, yt, Tt) {
                                    dt(xt), this.loader.load(xt, yt, Tt)
                                }, At(_t, [{
                                    key: "stats",
                                    get: function() {
                                        return this.loader.stats
                                    }
                                }, {
                                    key: "context",
                                    get: function() {
                                        return this.loader.context
                                    }
                                }]), _t
                            }()
                        }, Dt.uuid = function() {
                            var ft = URL.createObjectURL(new Blob),
                                dt = ft.toString();
                            return URL.revokeObjectURL(ft), dt.slice(dt.lastIndexOf("/") + 1)
                        }, Dt.serialize = function(ft) {
                            for (var dt = [], St = function(Nt) {
                                    return !Number.isNaN(Nt) && Nt != null && Nt !== "" && Nt !== !1
                                }, _t = function(Nt) {
                                    return Math.round(Nt)
                                }, vt = function(Nt) {
                                    return _t(Nt / 100) * 100
                                }, mt = function(Nt) {
                                    return encodeURIComponent(Nt)
                                }, xt = {
                                    br: _t,
                                    d: _t,
                                    bl: vt,
                                    dl: vt,
                                    mtp: vt,
                                    nor: mt,
                                    rtp: vt,
                                    tb: _t
                                }, yt = Object.keys(ft || {}).sort(), Tt = Ct(yt), Ft; !(Ft = Tt()).done;) {
                                var wt = Ft.value,
                                    kt = ft[wt];
                                if (!!St(kt) && !(wt === "v" && kt === 1) && !(wt == "pr" && kt === 1)) {
                                    var Ot = xt[wt];
                                    Ot && (kt = Ot(kt));
                                    var Rt = typeof kt,
                                        Lt = void 0;
                                    wt === "ot" || wt === "sf" || wt === "st" ? Lt = wt + "=" + kt : Rt === "boolean" ? Lt = wt : Rt === "number" ? Lt = wt + "=" + kt : Lt = wt + "=" + JSON.stringify(kt), dt.push(Lt)
                                }
                            }
                            return dt.join(",")
                        }, Dt.toHeaders = function(ft) {
                            for (var dt = Object.keys(ft), St = {}, _t = ["Object", "Request", "Session", "Status"], vt = [{}, {}, {}, {}], mt = {
                                    br: 0,
                                    d: 0,
                                    ot: 0,
                                    tb: 0,
                                    bl: 1,
                                    dl: 1,
                                    mtp: 1,
                                    nor: 1,
                                    nrr: 1,
                                    su: 1,
                                    cid: 2,
                                    pr: 2,
                                    sf: 2,
                                    sid: 2,
                                    st: 2,
                                    v: 2,
                                    bs: 3,
                                    rtp: 3
                                }, xt = 0, yt = dt; xt < yt.length; xt++) {
                                var Tt = yt[xt],
                                    Ft = mt[Tt] != null ? mt[Tt] : 1;
                                vt[Ft][Tt] = ft[Tt]
                            }
                            for (var wt = 0; wt < vt.length; wt++) {
                                var kt = Dt.serialize(vt[wt]);
                                kt && (St["CMCD-" + _t[wt]] = kt)
                            }
                            return St
                        }, Dt.toQuery = function(ft) {
                            return "CMCD=" + encodeURIComponent(Dt.serialize(ft))
                        }, Dt.appendQueryToUri = function(ft, dt) {
                            if (!dt) return ft;
                            var St = ft.includes("?") ? "&" : "?";
                            return "" + ft + St + dt
                        }, Dt
                    }()
                },
                "./src/controller/eme-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => Et
                    });
                    var ut = it("./src/events.ts"),
                        lt = it("./src/errors.ts"),
                        bt = it("./src/utils/logger.ts"),
                        pt = it("./src/utils/mediakeys-helper.ts");

                    function It(Dt, Pt) {
                        for (var gt = 0; gt < Pt.length; gt++) {
                            var ft = Pt[gt];
                            ft.enumerable = ft.enumerable || !1, ft.configurable = !0, "value" in ft && (ft.writable = !0), Object.defineProperty(Dt, ft.key, ft)
                        }
                    }

                    function At(Dt, Pt, gt) {
                        return Pt && It(Dt.prototype, Pt), gt && It(Dt, gt), Object.defineProperty(Dt, "prototype", {
                            writable: !1
                        }), Dt
                    }
                    var Ct = 3,
                        ht = function(Pt, gt, ft) {
                            var dt = {
                                audioCapabilities: [],
                                videoCapabilities: []
                            };
                            return Pt.forEach(function(St) {
                                dt.audioCapabilities.push({
                                    contentType: 'audio/mp4; codecs="' + St + '"',
                                    robustness: ft.audioRobustness || ""
                                })
                            }), gt.forEach(function(St) {
                                dt.videoCapabilities.push({
                                    contentType: 'video/mp4; codecs="' + St + '"',
                                    robustness: ft.videoRobustness || ""
                                })
                            }), [dt]
                        },
                        ot = function(Pt, gt, ft, dt) {
                            switch (Pt) {
                                case pt.KeySystems.WIDEVINE:
                                    return ht(gt, ft, dt);
                                default:
                                    throw new Error("Unknown key-system: " + Pt)
                            }
                        },
                        ct = function() {
                            function Dt(gt) {
                                this.hls = void 0, this._widevineLicenseUrl = void 0, this._licenseXhrSetup = void 0, this._licenseResponseCallback = void 0, this._emeEnabled = void 0, this._requestMediaKeySystemAccess = void 0, this._drmSystemOptions = void 0, this._config = void 0, this._mediaKeysList = [], this._media = null, this._hasSetMediaKeys = !1, this._requestLicenseFailureCount = 0, this.mediaKeysPromise = null, this._onMediaEncrypted = this.onMediaEncrypted.bind(this), this.hls = gt, this._config = gt.config, this._widevineLicenseUrl = this._config.widevineLicenseUrl, this._licenseXhrSetup = this._config.licenseXhrSetup, this._licenseResponseCallback = this._config.licenseResponseCallback, this._emeEnabled = this._config.emeEnabled, this._requestMediaKeySystemAccess = this._config.requestMediaKeySystemAccessFunc, this._drmSystemOptions = this._config.drmSystemOptions, this._registerListeners()
                            }
                            var Pt = Dt.prototype;
                            return Pt.destroy = function() {
                                this._unregisterListeners(), this.hls = this._onMediaEncrypted = null, this._requestMediaKeySystemAccess = null
                            }, Pt._registerListeners = function() {
                                this.hls.on(ut.Events.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(ut.Events.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(ut.Events.MANIFEST_PARSED, this.onManifestParsed, this)
                            }, Pt._unregisterListeners = function() {
                                this.hls.off(ut.Events.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(ut.Events.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(ut.Events.MANIFEST_PARSED, this.onManifestParsed, this)
                            }, Pt.getLicenseServerUrl = function(ft) {
                                switch (ft) {
                                    case pt.KeySystems.WIDEVINE:
                                        if (!this._widevineLicenseUrl) break;
                                        return this._widevineLicenseUrl
                                }
                                throw new Error('no license server URL configured for key-system "' + ft + '"')
                            }, Pt._attemptKeySystemAccess = function(ft, dt, St) {
                                var _t = this,
                                    vt = ot(ft, dt, St, this._drmSystemOptions);
                                bt.logger.log("Requesting encrypted media key-system access");
                                var mt = this.requestMediaKeySystemAccess(ft, vt);
                                this.mediaKeysPromise = mt.then(function(xt) {
                                    return _t._onMediaKeySystemAccessObtained(ft, xt)
                                }), mt.catch(function(xt) {
                                    bt.logger.error('Failed to obtain key-system "' + ft + '" access:', xt)
                                })
                            }, Pt._onMediaKeySystemAccessObtained = function(ft, dt) {
                                var St = this;
                                bt.logger.log('Access for key-system "' + ft + '" obtained');
                                var _t = {
                                    mediaKeysSessionInitialized: !1,
                                    mediaKeySystemAccess: dt,
                                    mediaKeySystemDomain: ft
                                };
                                this._mediaKeysList.push(_t);
                                var vt = Promise.resolve().then(function() {
                                    return dt.createMediaKeys()
                                }).then(function(mt) {
                                    return _t.mediaKeys = mt, bt.logger.log('Media-keys created for key-system "' + ft + '"'), St._onMediaKeysCreated(), mt
                                });
                                return vt.catch(function(mt) {
                                    bt.logger.error("Failed to create media-keys:", mt)
                                }), vt
                            }, Pt._onMediaKeysCreated = function() {
                                var ft = this;
                                this._mediaKeysList.forEach(function(dt) {
                                    dt.mediaKeysSession || (dt.mediaKeysSession = dt.mediaKeys.createSession(), ft._onNewMediaKeySession(dt.mediaKeysSession))
                                })
                            }, Pt._onNewMediaKeySession = function(ft) {
                                var dt = this;
                                bt.logger.log("New key-system session " + ft.sessionId), ft.addEventListener("message", function(St) {
                                    dt._onKeySessionMessage(ft, St.message)
                                }, !1)
                            }, Pt._onKeySessionMessage = function(ft, dt) {
                                bt.logger.log("Got EME message event, creating license request"), this._requestLicense(dt, function(St) {
                                    bt.logger.log("Received license data (length: " + (St && St.byteLength) + "), updating key-session"), ft.update(St).catch(function(_t) {
                                        bt.logger.warn("Updating key-session failed: " + _t)
                                    })
                                })
                            }, Pt.onMediaEncrypted = function(ft) {
                                var dt = this;
                                if (bt.logger.log('Media is encrypted using "' + ft.initDataType + '" init data type'), !this.mediaKeysPromise) {
                                    bt.logger.error("Fatal: Media is encrypted but no CDM access or no keys have been requested"), this.hls.trigger(ut.Events.ERROR, {
                                        type: lt.ErrorTypes.KEY_SYSTEM_ERROR,
                                        details: lt.ErrorDetails.KEY_SYSTEM_NO_KEYS,
                                        fatal: !0
                                    });
                                    return
                                }
                                var St = function(vt) {
                                    !dt._media || (dt._attemptSetMediaKeys(vt), dt._generateRequestWithPreferredKeySession(ft.initDataType, ft.initData))
                                };
                                this.mediaKeysPromise.then(St).catch(St)
                            }, Pt._attemptSetMediaKeys = function(ft) {
                                if (!this._media) throw new Error("Attempted to set mediaKeys without first attaching a media element");
                                if (!this._hasSetMediaKeys) {
                                    var dt = this._mediaKeysList[0];
                                    if (!dt || !dt.mediaKeys) {
                                        bt.logger.error("Fatal: Media is encrypted but no CDM access or no keys have been obtained yet"), this.hls.trigger(ut.Events.ERROR, {
                                            type: lt.ErrorTypes.KEY_SYSTEM_ERROR,
                                            details: lt.ErrorDetails.KEY_SYSTEM_NO_KEYS,
                                            fatal: !0
                                        });
                                        return
                                    }
                                    bt.logger.log("Setting keys for encrypted media"), this._media.setMediaKeys(dt.mediaKeys), this._hasSetMediaKeys = !0
                                }
                            }, Pt._generateRequestWithPreferredKeySession = function(ft, dt) {
                                var St = this,
                                    _t = this._mediaKeysList[0];
                                if (!_t) {
                                    bt.logger.error("Fatal: Media is encrypted but not any key-system access has been obtained yet"), this.hls.trigger(ut.Events.ERROR, {
                                        type: lt.ErrorTypes.KEY_SYSTEM_ERROR,
                                        details: lt.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
                                        fatal: !0
                                    });
                                    return
                                }
                                if (_t.mediaKeysSessionInitialized) {
                                    bt.logger.warn("Key-Session already initialized but requested again");
                                    return
                                }
                                var vt = _t.mediaKeysSession;
                                if (!vt) {
                                    bt.logger.error("Fatal: Media is encrypted but no key-session existing"), this.hls.trigger(ut.Events.ERROR, {
                                        type: lt.ErrorTypes.KEY_SYSTEM_ERROR,
                                        details: lt.ErrorDetails.KEY_SYSTEM_NO_SESSION,
                                        fatal: !0
                                    });
                                    return
                                }
                                if (!dt) {
                                    bt.logger.warn("Fatal: initData required for generating a key session is null"), this.hls.trigger(ut.Events.ERROR, {
                                        type: lt.ErrorTypes.KEY_SYSTEM_ERROR,
                                        details: lt.ErrorDetails.KEY_SYSTEM_NO_INIT_DATA,
                                        fatal: !0
                                    });
                                    return
                                }
                                bt.logger.log('Generating key-session request for "' + ft + '" init data type'), _t.mediaKeysSessionInitialized = !0, vt.generateRequest(ft, dt).then(function() {
                                    bt.logger.debug("Key-session generation succeeded")
                                }).catch(function(mt) {
                                    bt.logger.error("Error generating key-session request:", mt), St.hls.trigger(ut.Events.ERROR, {
                                        type: lt.ErrorTypes.KEY_SYSTEM_ERROR,
                                        details: lt.ErrorDetails.KEY_SYSTEM_NO_SESSION,
                                        fatal: !1
                                    })
                                })
                            }, Pt._createLicenseXhr = function(ft, dt, St) {
                                var _t = new XMLHttpRequest;
                                _t.responseType = "arraybuffer", _t.onreadystatechange = this._onLicenseRequestReadyStageChange.bind(this, _t, ft, dt, St);
                                var vt = this._licenseXhrSetup;
                                if (vt) try {
                                    vt.call(this.hls, _t, ft), vt = void 0
                                } catch (mt) {
                                    bt.logger.error(mt)
                                }
                                try {
                                    _t.readyState || _t.open("POST", ft, !0), vt && vt.call(this.hls, _t, ft)
                                } catch (mt) {
                                    throw new Error("issue setting up KeySystem license XHR " + mt)
                                }
                                return _t
                            }, Pt._onLicenseRequestReadyStageChange = function(ft, dt, St, _t) {
                                switch (ft.readyState) {
                                    case 4:
                                        if (ft.status === 200) {
                                            this._requestLicenseFailureCount = 0, bt.logger.log("License request succeeded");
                                            var vt = ft.response,
                                                mt = this._licenseResponseCallback;
                                            if (mt) try {
                                                vt = mt.call(this.hls, ft, dt)
                                            } catch (yt) {
                                                bt.logger.error(yt)
                                            }
                                            _t(vt)
                                        } else {
                                            if (bt.logger.error("License Request XHR failed (" + dt + "). Status: " + ft.status + " (" + ft.statusText + ")"), this._requestLicenseFailureCount++, this._requestLicenseFailureCount > Ct) {
                                                this.hls.trigger(ut.Events.ERROR, {
                                                    type: lt.ErrorTypes.KEY_SYSTEM_ERROR,
                                                    details: lt.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                                                    fatal: !0
                                                });
                                                return
                                            }
                                            var xt = Ct - this._requestLicenseFailureCount + 1;
                                            bt.logger.warn("Retrying license request, " + xt + " attempts left"), this._requestLicense(St, _t)
                                        }
                                        break
                                }
                            }, Pt._generateLicenseRequestChallenge = function(ft, dt) {
                                switch (ft.mediaKeySystemDomain) {
                                    case pt.KeySystems.WIDEVINE:
                                        return dt
                                }
                                throw new Error("unsupported key-system: " + ft.mediaKeySystemDomain)
                            }, Pt._requestLicense = function(ft, dt) {
                                bt.logger.log("Requesting content license for key-system");
                                var St = this._mediaKeysList[0];
                                if (!St) {
                                    bt.logger.error("Fatal error: Media is encrypted but no key-system access has been obtained yet"), this.hls.trigger(ut.Events.ERROR, {
                                        type: lt.ErrorTypes.KEY_SYSTEM_ERROR,
                                        details: lt.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
                                        fatal: !0
                                    });
                                    return
                                }
                                try {
                                    var _t = this.getLicenseServerUrl(St.mediaKeySystemDomain),
                                        vt = this._createLicenseXhr(_t, ft, dt);
                                    bt.logger.log("Sending license request to URL: " + _t);
                                    var mt = this._generateLicenseRequestChallenge(St, ft);
                                    vt.send(mt)
                                } catch (xt) {
                                    bt.logger.error("Failure requesting DRM license: " + xt), this.hls.trigger(ut.Events.ERROR, {
                                        type: lt.ErrorTypes.KEY_SYSTEM_ERROR,
                                        details: lt.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                                        fatal: !0
                                    })
                                }
                            }, Pt.onMediaAttached = function(ft, dt) {
                                if (!!this._emeEnabled) {
                                    var St = dt.media;
                                    this._media = St, St.addEventListener("encrypted", this._onMediaEncrypted)
                                }
                            }, Pt.onMediaDetached = function() {
                                var ft = this._media,
                                    dt = this._mediaKeysList;
                                !ft || (ft.removeEventListener("encrypted", this._onMediaEncrypted), this._media = null, this._mediaKeysList = [], Promise.all(dt.map(function(St) {
                                    if (St.mediaKeysSession) return St.mediaKeysSession.close().catch(function() {})
                                })).then(function() {
                                    return ft.setMediaKeys(null)
                                }).catch(function() {}))
                            }, Pt.onManifestParsed = function(ft, dt) {
                                if (!!this._emeEnabled) {
                                    var St = dt.levels.map(function(vt) {
                                            return vt.audioCodec
                                        }).filter(function(vt) {
                                            return !!vt
                                        }),
                                        _t = dt.levels.map(function(vt) {
                                            return vt.videoCodec
                                        }).filter(function(vt) {
                                            return !!vt
                                        });
                                    this._attemptKeySystemAccess(pt.KeySystems.WIDEVINE, St, _t)
                                }
                            }, At(Dt, [{
                                key: "requestMediaKeySystemAccess",
                                get: function() {
                                    if (!this._requestMediaKeySystemAccess) throw new Error("No requestMediaKeySystemAccess function configured");
                                    return this._requestMediaKeySystemAccess
                                }
                            }]), Dt
                        }();
                    const Et = ct
                },
                "./src/controller/fps-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => pt
                    });
                    var ut = it("./src/events.ts"),
                        lt = it("./src/utils/logger.ts"),
                        bt = function() {
                            function It(Ct) {
                                this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = Ct, this.registerListeners()
                            }
                            var At = It.prototype;
                            return At.setStreamController = function(ht) {
                                this.streamController = ht
                            }, At.registerListeners = function() {
                                this.hls.on(ut.Events.MEDIA_ATTACHING, this.onMediaAttaching, this)
                            }, At.unregisterListeners = function() {
                                this.hls.off(ut.Events.MEDIA_ATTACHING, this.onMediaAttaching)
                            }, At.destroy = function() {
                                this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null
                            }, At.onMediaAttaching = function(ht, ot) {
                                var ct = this.hls.config;
                                if (ct.capLevelOnFPSDrop) {
                                    var Et = ot.media instanceof self.HTMLVideoElement ? ot.media : null;
                                    this.media = Et, Et && typeof Et.getVideoPlaybackQuality == "function" && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), ct.fpsDroppedMonitoringPeriod)
                                }
                            }, At.checkFPS = function(ht, ot, ct) {
                                var Et = performance.now();
                                if (ot) {
                                    if (this.lastTime) {
                                        var Dt = Et - this.lastTime,
                                            Pt = ct - this.lastDroppedFrames,
                                            gt = ot - this.lastDecodedFrames,
                                            ft = 1e3 * Pt / Dt,
                                            dt = this.hls;
                                        if (dt.trigger(ut.Events.FPS_DROP, {
                                                currentDropped: Pt,
                                                currentDecoded: gt,
                                                totalDroppedFrames: ct
                                            }), ft > 0 && Pt > dt.config.fpsDroppedMonitoringThreshold * gt) {
                                            var St = dt.currentLevel;
                                            lt.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + St), St > 0 && (dt.autoLevelCapping === -1 || dt.autoLevelCapping >= St) && (St = St - 1, dt.trigger(ut.Events.FPS_DROP_LEVEL_CAPPING, {
                                                level: St,
                                                droppedLevel: dt.currentLevel
                                            }), dt.autoLevelCapping = St, this.streamController.nextLevelSwitch())
                                        }
                                    }
                                    this.lastTime = Et, this.lastDroppedFrames = ct, this.lastDecodedFrames = ot
                                }
                            }, At.checkFPSInterval = function() {
                                var ht = this.media;
                                if (ht)
                                    if (this.isVideoPlaybackQualityAvailable) {
                                        var ot = ht.getVideoPlaybackQuality();
                                        this.checkFPS(ht, ot.totalVideoFrames, ot.droppedVideoFrames)
                                    } else this.checkFPS(ht, ht.webkitDecodedFrameCount, ht.webkitDroppedFrameCount)
                            }, It
                        }();
                    const pt = bt
                },
                "./src/controller/fragment-finders.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        findFragWithCC: () => Ct,
                        findFragmentByPDT: () => bt,
                        findFragmentByPTS: () => pt,
                        fragmentWithinToleranceTest: () => It,
                        pdtWithinToleranceTest: () => At
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/utils/binary-search.ts");

                    function bt(ht, ot, ct) {
                        if (ot === null || !Array.isArray(ht) || !ht.length || !(0, ut.isFiniteNumber)(ot)) return null;
                        var Et = ht[0].programDateTime;
                        if (ot < (Et || 0)) return null;
                        var Dt = ht[ht.length - 1].endProgramDateTime;
                        if (ot >= (Dt || 0)) return null;
                        ct = ct || 0;
                        for (var Pt = 0; Pt < ht.length; ++Pt) {
                            var gt = ht[Pt];
                            if (At(ot, ct, gt)) return gt
                        }
                        return null
                    }

                    function pt(ht, ot, ct, Et) {
                        ct === void 0 && (ct = 0), Et === void 0 && (Et = 0);
                        var Dt = null;
                        if (ht ? Dt = ot[ht.sn - ot[0].sn + 1] || null : ct === 0 && ot[0].start === 0 && (Dt = ot[0]), Dt && It(ct, Et, Dt) === 0) return Dt;
                        var Pt = lt.default.search(ot, It.bind(null, ct, Et));
                        return Pt || Dt
                    }

                    function It(ht, ot, ct) {
                        ht === void 0 && (ht = 0), ot === void 0 && (ot = 0);
                        var Et = Math.min(ot, ct.duration + (ct.deltaPTS ? ct.deltaPTS : 0));
                        return ct.start + ct.duration - Et <= ht ? 1 : ct.start - Et > ht && ct.start ? -1 : 0
                    }

                    function At(ht, ot, ct) {
                        var Et = Math.min(ot, ct.duration + (ct.deltaPTS ? ct.deltaPTS : 0)) * 1e3,
                            Dt = ct.endProgramDateTime || 0;
                        return Dt - Et > ht
                    }

                    function Ct(ht, ot) {
                        return lt.default.search(ht, function(ct) {
                            return ct.cc < ot ? 1 : ct.cc > ot ? -1 : 0
                        })
                    }
                },
                "./src/controller/fragment-tracker.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        FragmentState: () => bt,
                        FragmentTracker: () => pt
                    });
                    var ut = it("./src/events.ts"),
                        lt = it("./src/types/loader.ts"),
                        bt;
                    (function(Ct) {
                        Ct.NOT_LOADED = "NOT_LOADED", Ct.APPENDING = "APPENDING", Ct.PARTIAL = "PARTIAL", Ct.OK = "OK"
                    })(bt || (bt = {}));
                    var pt = function() {
                        function Ct(ot) {
                            this.activeFragment = null, this.activeParts = null, this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hls = ot, this._registerListeners()
                        }
                        var ht = Ct.prototype;
                        return ht._registerListeners = function() {
                            var ct = this.hls;
                            ct.on(ut.Events.BUFFER_APPENDED, this.onBufferAppended, this), ct.on(ut.Events.FRAG_BUFFERED, this.onFragBuffered, this), ct.on(ut.Events.FRAG_LOADED, this.onFragLoaded, this)
                        }, ht._unregisterListeners = function() {
                            var ct = this.hls;
                            ct.off(ut.Events.BUFFER_APPENDED, this.onBufferAppended, this), ct.off(ut.Events.FRAG_BUFFERED, this.onFragBuffered, this), ct.off(ut.Events.FRAG_LOADED, this.onFragLoaded, this)
                        }, ht.destroy = function() {
                            this._unregisterListeners(), this.fragments = this.timeRanges = null
                        }, ht.getAppendedFrag = function(ct, Et) {
                            if (Et === lt.PlaylistLevelType.MAIN) {
                                var Dt = this.activeFragment,
                                    Pt = this.activeParts;
                                if (!Dt) return null;
                                if (Pt)
                                    for (var gt = Pt.length; gt--;) {
                                        var ft = Pt[gt],
                                            dt = ft ? ft.end : Dt.appendedPTS;
                                        if (ft.start <= ct && dt !== void 0 && ct <= dt) return gt > 9 && (this.activeParts = Pt.slice(gt - 9)), ft
                                    } else if (Dt.start <= ct && Dt.appendedPTS !== void 0 && ct <= Dt.appendedPTS) return Dt
                            }
                            return this.getBufferedFrag(ct, Et)
                        }, ht.getBufferedFrag = function(ct, Et) {
                            for (var Dt = this.fragments, Pt = Object.keys(Dt), gt = Pt.length; gt--;) {
                                var ft = Dt[Pt[gt]];
                                if ((ft == null ? void 0 : ft.body.type) === Et && ft.buffered) {
                                    var dt = ft.body;
                                    if (dt.start <= ct && ct <= dt.end) return dt
                                }
                            }
                            return null
                        }, ht.detectEvictedFragments = function(ct, Et, Dt) {
                            var Pt = this;
                            Object.keys(this.fragments).forEach(function(gt) {
                                var ft = Pt.fragments[gt];
                                if (!!ft) {
                                    if (!ft.buffered) {
                                        ft.body.type === Dt && Pt.removeFragment(ft.body);
                                        return
                                    }
                                    var dt = ft.range[ct];
                                    !dt || dt.time.some(function(St) {
                                        var _t = !Pt.isTimeBuffered(St.startPTS, St.endPTS, Et);
                                        return _t && Pt.removeFragment(ft.body), _t
                                    })
                                }
                            })
                        }, ht.detectPartialFragments = function(ct) {
                            var Et = this,
                                Dt = this.timeRanges,
                                Pt = ct.frag,
                                gt = ct.part;
                            if (!(!Dt || Pt.sn === "initSegment")) {
                                var ft = At(Pt),
                                    dt = this.fragments[ft];
                                !dt || (Object.keys(Dt).forEach(function(St) {
                                    var _t = Pt.elementaryStreams[St];
                                    if (!!_t) {
                                        var vt = Dt[St],
                                            mt = gt !== null || _t.partial === !0;
                                        dt.range[St] = Et.getBufferedTimes(Pt, gt, mt, vt)
                                    }
                                }), dt.loaded = null, Object.keys(dt.range).length ? dt.buffered = !0 : this.removeFragment(dt.body))
                            }
                        }, ht.fragBuffered = function(ct) {
                            var Et = At(ct),
                                Dt = this.fragments[Et];
                            Dt && (Dt.loaded = null, Dt.buffered = !0)
                        }, ht.getBufferedTimes = function(ct, Et, Dt, Pt) {
                            for (var gt = {
                                    time: [],
                                    partial: Dt
                                }, ft = Et ? Et.start : ct.start, dt = Et ? Et.end : ct.end, St = ct.minEndPTS || dt, _t = ct.maxStartPTS || ft, vt = 0; vt < Pt.length; vt++) {
                                var mt = Pt.start(vt) - this.bufferPadding,
                                    xt = Pt.end(vt) + this.bufferPadding;
                                if (_t >= mt && St <= xt) {
                                    gt.time.push({
                                        startPTS: Math.max(ft, Pt.start(vt)),
                                        endPTS: Math.min(dt, Pt.end(vt))
                                    });
                                    break
                                } else if (ft < xt && dt > mt) gt.partial = !0, gt.time.push({
                                    startPTS: Math.max(ft, Pt.start(vt)),
                                    endPTS: Math.min(dt, Pt.end(vt))
                                });
                                else if (dt <= mt) break
                            }
                            return gt
                        }, ht.getPartialFragment = function(ct) {
                            var Et = null,
                                Dt, Pt, gt, ft = 0,
                                dt = this.bufferPadding,
                                St = this.fragments;
                            return Object.keys(St).forEach(function(_t) {
                                var vt = St[_t];
                                !vt || It(vt) && (Pt = vt.body.start - dt, gt = vt.body.end + dt, ct >= Pt && ct <= gt && (Dt = Math.min(ct - Pt, gt - ct), ft <= Dt && (Et = vt.body, ft = Dt)))
                            }), Et
                        }, ht.getState = function(ct) {
                            var Et = At(ct),
                                Dt = this.fragments[Et];
                            return Dt ? Dt.buffered ? It(Dt) ? bt.PARTIAL : bt.OK : bt.APPENDING : bt.NOT_LOADED
                        }, ht.isTimeBuffered = function(ct, Et, Dt) {
                            for (var Pt, gt, ft = 0; ft < Dt.length; ft++) {
                                if (Pt = Dt.start(ft) - this.bufferPadding, gt = Dt.end(ft) + this.bufferPadding, ct >= Pt && Et <= gt) return !0;
                                if (Et <= Pt) return !1
                            }
                            return !1
                        }, ht.onFragLoaded = function(ct, Et) {
                            var Dt = Et.frag,
                                Pt = Et.part;
                            if (!(Dt.sn === "initSegment" || Dt.bitrateTest || Pt)) {
                                var gt = At(Dt);
                                this.fragments[gt] = {
                                    body: Dt,
                                    loaded: Et,
                                    buffered: !1,
                                    range: Object.create(null)
                                }
                            }
                        }, ht.onBufferAppended = function(ct, Et) {
                            var Dt = this,
                                Pt = Et.frag,
                                gt = Et.part,
                                ft = Et.timeRanges;
                            if (Pt.type === lt.PlaylistLevelType.MAIN)
                                if (this.activeFragment = Pt, gt) {
                                    var dt = this.activeParts;
                                    dt || (this.activeParts = dt = []), dt.push(gt)
                                } else this.activeParts = null;
                            this.timeRanges = ft, Object.keys(ft).forEach(function(St) {
                                var _t = ft[St];
                                if (Dt.detectEvictedFragments(St, _t), !gt)
                                    for (var vt = 0; vt < _t.length; vt++) Pt.appendedPTS = Math.max(_t.end(vt), Pt.appendedPTS || 0)
                            })
                        }, ht.onFragBuffered = function(ct, Et) {
                            this.detectPartialFragments(Et)
                        }, ht.hasFragment = function(ct) {
                            var Et = At(ct);
                            return !!this.fragments[Et]
                        }, ht.removeFragmentsInRange = function(ct, Et, Dt) {
                            var Pt = this;
                            Object.keys(this.fragments).forEach(function(gt) {
                                var ft = Pt.fragments[gt];
                                if (!!ft && ft.buffered) {
                                    var dt = ft.body;
                                    dt.type === Dt && dt.start < Et && dt.end > ct && Pt.removeFragment(dt)
                                }
                            })
                        }, ht.removeFragment = function(ct) {
                            var Et = At(ct);
                            ct.stats.loaded = 0, ct.clearElementaryStreamInfo(), delete this.fragments[Et]
                        }, ht.removeAllFragments = function() {
                            this.fragments = Object.create(null), this.activeFragment = null, this.activeParts = null
                        }, Ct
                    }();

                    function It(Ct) {
                        var ht, ot;
                        return Ct.buffered && (((ht = Ct.range.video) === null || ht === void 0 ? void 0 : ht.partial) || ((ot = Ct.range.audio) === null || ot === void 0 ? void 0 : ot.partial))
                    }

                    function At(Ct) {
                        return Ct.type + "_" + Ct.level + "_" + Ct.urlId + "_" + Ct.sn
                    }
                },
                "./src/controller/gap-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        MAX_START_GAP_JUMP: () => At,
                        SKIP_BUFFER_HOLE_STEP_SECONDS: () => Ct,
                        SKIP_BUFFER_RANGE_START: () => ht,
                        STALL_MINIMUM_DURATION_MS: () => It,
                        default: () => ot
                    });
                    var ut = it("./src/utils/buffer-helper.ts"),
                        lt = it("./src/errors.ts"),
                        bt = it("./src/events.ts"),
                        pt = it("./src/utils/logger.ts"),
                        It = 250,
                        At = 2,
                        Ct = .1,
                        ht = .05,
                        ot = function() {
                            function ct(Dt, Pt, gt, ft) {
                                this.config = void 0, this.media = null, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = Dt, this.media = Pt, this.fragmentTracker = gt, this.hls = ft
                            }
                            var Et = ct.prototype;
                            return Et.destroy = function() {
                                this.media = null, this.hls = this.fragmentTracker = null
                            }, Et.poll = function(Pt, gt) {
                                var ft = this.config,
                                    dt = this.media,
                                    St = this.stalled;
                                if (dt !== null) {
                                    var _t = dt.currentTime,
                                        vt = dt.seeking,
                                        mt = this.seeking && !vt,
                                        xt = !this.seeking && vt;
                                    if (this.seeking = vt, _t !== Pt) {
                                        if (this.moved = !0, St !== null) {
                                            if (this.stallReported) {
                                                var yt = self.performance.now() - St;
                                                pt.logger.warn("playback not stuck anymore @" + _t + ", after " + Math.round(yt) + "ms"), this.stallReported = !1
                                            }
                                            this.stalled = null, this.nudgeRetry = 0
                                        }
                                        return
                                    }
                                    if ((xt || mt) && (this.stalled = null), !(dt.paused && !vt || dt.ended || dt.playbackRate === 0 || !ut.BufferHelper.getBuffered(dt).length)) {
                                        var Tt = ut.BufferHelper.bufferInfo(dt, _t, 0),
                                            Ft = Tt.len > 0,
                                            wt = Tt.nextStart || 0;
                                        if (!(!Ft && !wt)) {
                                            if (vt) {
                                                var kt = Tt.len > At,
                                                    Ot = !wt || gt && gt.start <= _t || wt - _t > At && !this.fragmentTracker.getPartialFragment(_t);
                                                if (kt || Ot) return;
                                                this.moved = !1
                                            }
                                            if (!this.moved && this.stalled !== null) {
                                                var Rt, Lt = Math.max(wt, Tt.start || 0) - _t,
                                                    Bt = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null,
                                                    Nt = Bt == null || (Rt = Bt.details) === null || Rt === void 0 ? void 0 : Rt.live,
                                                    $t = Nt ? Bt.details.targetduration * 2 : At;
                                                if (Lt > 0 && Lt <= $t) {
                                                    this._trySkipBufferHole(null);
                                                    return
                                                }
                                            }
                                            var jt = self.performance.now();
                                            if (St === null) {
                                                this.stalled = jt;
                                                return
                                            }
                                            var Ut = jt - St;
                                            if (!(!vt && Ut >= It && (this._reportStall(Tt), !this.media))) {
                                                var Ht = ut.BufferHelper.bufferInfo(dt, _t, ft.maxBufferHole);
                                                this._tryFixBufferStall(Ht, Ut)
                                            }
                                        }
                                    }
                                }
                            }, Et._tryFixBufferStall = function(Pt, gt) {
                                var ft = this.config,
                                    dt = this.fragmentTracker,
                                    St = this.media;
                                if (St !== null) {
                                    var _t = St.currentTime,
                                        vt = dt.getPartialFragment(_t);
                                    if (vt) {
                                        var mt = this._trySkipBufferHole(vt);
                                        if (mt || !this.media) return
                                    }
                                    Pt.len > ft.maxBufferHole && gt > ft.highBufferWatchdogPeriod * 1e3 && (pt.logger.warn("Trying to nudge playhead over buffer-hole"), this.stalled = null, this._tryNudgeBuffer())
                                }
                            }, Et._reportStall = function(Pt) {
                                var gt = this.hls,
                                    ft = this.media,
                                    dt = this.stallReported;
                                !dt && ft && (this.stallReported = !0, pt.logger.warn("Playback stalling at @" + ft.currentTime + " due to low buffer (" + JSON.stringify(Pt) + ")"), gt.trigger(bt.Events.ERROR, {
                                    type: lt.ErrorTypes.MEDIA_ERROR,
                                    details: lt.ErrorDetails.BUFFER_STALLED_ERROR,
                                    fatal: !1,
                                    buffer: Pt.len
                                }))
                            }, Et._trySkipBufferHole = function(Pt) {
                                var gt = this.config,
                                    ft = this.hls,
                                    dt = this.media;
                                if (dt === null) return 0;
                                for (var St = dt.currentTime, _t = 0, vt = ut.BufferHelper.getBuffered(dt), mt = 0; mt < vt.length; mt++) {
                                    var xt = vt.start(mt);
                                    if (St + gt.maxBufferHole >= _t && St < xt) {
                                        var yt = Math.max(xt + ht, dt.currentTime + Ct);
                                        return pt.logger.warn("skipping hole, adjusting currentTime from " + St + " to " + yt), this.moved = !0, this.stalled = null, dt.currentTime = yt, Pt && ft.trigger(bt.Events.ERROR, {
                                            type: lt.ErrorTypes.MEDIA_ERROR,
                                            details: lt.ErrorDetails.BUFFER_SEEK_OVER_HOLE,
                                            fatal: !1,
                                            reason: "fragment loaded with buffer holes, seeking from " + St + " to " + yt,
                                            frag: Pt
                                        }), yt
                                    }
                                    _t = vt.end(mt)
                                }
                                return 0
                            }, Et._tryNudgeBuffer = function() {
                                var Pt = this.config,
                                    gt = this.hls,
                                    ft = this.media,
                                    dt = this.nudgeRetry;
                                if (ft !== null) {
                                    var St = ft.currentTime;
                                    if (this.nudgeRetry++, dt < Pt.nudgeMaxRetry) {
                                        var _t = St + (dt + 1) * Pt.nudgeOffset;
                                        pt.logger.warn("Nudging 'currentTime' from " + St + " to " + _t), ft.currentTime = _t, gt.trigger(bt.Events.ERROR, {
                                            type: lt.ErrorTypes.MEDIA_ERROR,
                                            details: lt.ErrorDetails.BUFFER_NUDGE_ON_STALL,
                                            fatal: !1
                                        })
                                    } else pt.logger.error("Playhead still not moving while enough data buffered @" + St + " after " + Pt.nudgeMaxRetry + " nudges"), gt.trigger(bt.Events.ERROR, {
                                        type: lt.ErrorTypes.MEDIA_ERROR,
                                        details: lt.ErrorDetails.BUFFER_STALLED_ERROR,
                                        fatal: !0
                                    })
                                }
                            }, ct
                        }()
                },
                "./src/controller/id3-track-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => Pt
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/events.ts"),
                        bt = it("./src/utils/texttrack-utils.ts"),
                        pt = it("./src/demux/id3.ts"),
                        It = it("./src/loader/date-range.ts"),
                        At = it("./src/types/demuxer.ts"),
                        Ct = .25;

                    function ht() {
                        return self.WebKitDataCue || self.VTTCue || self.TextTrackCue
                    }
                    var ot = function() {
                        var gt = ht();
                        try {
                            new gt(0, Number.POSITIVE_INFINITY, "")
                        } catch {
                            return Number.MAX_VALUE
                        }
                        return Number.POSITIVE_INFINITY
                    }();

                    function ct(gt, ft) {
                        return gt.getTime() / 1e3 - ft
                    }

                    function Et(gt) {
                        return Uint8Array.from(gt.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer
                    }
                    var Dt = function() {
                        function gt(dt) {
                            this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = dt, this._registerListeners()
                        }
                        var ft = gt.prototype;
                        return ft.destroy = function() {
                            this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = null
                        }, ft._registerListeners = function() {
                            var St = this.hls;
                            St.on(lt.Events.MEDIA_ATTACHED, this.onMediaAttached, this), St.on(lt.Events.MEDIA_DETACHING, this.onMediaDetaching, this), St.on(lt.Events.MANIFEST_LOADING, this.onManifestLoading, this), St.on(lt.Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), St.on(lt.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), St.on(lt.Events.LEVEL_UPDATED, this.onLevelUpdated, this)
                        }, ft._unregisterListeners = function() {
                            var St = this.hls;
                            St.off(lt.Events.MEDIA_ATTACHED, this.onMediaAttached, this), St.off(lt.Events.MEDIA_DETACHING, this.onMediaDetaching, this), St.off(lt.Events.MANIFEST_LOADING, this.onManifestLoading, this), St.off(lt.Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), St.off(lt.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), St.off(lt.Events.LEVEL_UPDATED, this.onLevelUpdated, this)
                        }, ft.onMediaAttached = function(St, _t) {
                            this.media = _t.media
                        }, ft.onMediaDetaching = function() {
                            !this.id3Track || ((0, bt.clearCurrentCues)(this.id3Track), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {})
                        }, ft.onManifestLoading = function() {
                            this.dateRangeCuesAppended = {}
                        }, ft.createTrack = function(St) {
                            var _t = this.getID3Track(St.textTracks);
                            return _t.mode = "hidden", _t
                        }, ft.getID3Track = function(St) {
                            if (!!this.media) {
                                for (var _t = 0; _t < St.length; _t++) {
                                    var vt = St[_t];
                                    if (vt.kind === "metadata" && vt.label === "id3") return (0, bt.sendAddTrackEvent)(vt, this.media), vt
                                }
                                return this.media.addTextTrack("metadata", "id3")
                            }
                        }, ft.onFragParsingMetadata = function(St, _t) {
                            if (!!this.media) {
                                var vt = this.hls.config,
                                    mt = vt.enableEmsgMetadataCues,
                                    xt = vt.enableID3MetadataCues;
                                if (!(!mt && !xt)) {
                                    _t.frag;
                                    var yt = _t.samples;
                                    _t.details, this.id3Track || (this.id3Track = this.createTrack(this.media));
                                    for (var Tt = ht(), Ft = 0; Ft < yt.length; Ft++) {
                                        var wt = yt[Ft].type;
                                        if (!(wt === At.MetadataSchema.emsg && !mt || !xt)) {
                                            var kt = pt.getID3Frames(yt[Ft].data);
                                            if (kt) {
                                                var Ot = yt[Ft].pts,
                                                    Rt = Ot + yt[Ft].duration;
                                                Rt > ot && (Rt = ot);
                                                var Lt = Rt - Ot;
                                                Lt <= 0 && (Rt = Ot + Ct);
                                                for (var Bt = 0; Bt < kt.length; Bt++) {
                                                    var Nt = kt[Bt];
                                                    if (!pt.isTimeStampFrame(Nt)) {
                                                        this.updateId3CueEnds(Ot);
                                                        var $t = new Tt(Ot, Rt, "");
                                                        $t.value = Nt, wt && ($t.type = wt), this.id3Track.addCue($t)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }, ft.updateId3CueEnds = function(St) {
                            var _t, vt = (_t = this.id3Track) === null || _t === void 0 ? void 0 : _t.cues;
                            if (vt)
                                for (var mt = vt.length; mt--;) {
                                    var xt = vt[mt];
                                    xt.startTime < St && xt.endTime === ot && (xt.endTime = St)
                                }
                        }, ft.onBufferFlushing = function(St, _t) {
                            var vt = _t.startOffset,
                                mt = _t.endOffset,
                                xt = _t.type,
                                yt = this.id3Track,
                                Tt = this.hls;
                            if (!!Tt) {
                                var Ft = Tt.config,
                                    wt = Ft.enableEmsgMetadataCues,
                                    kt = Ft.enableID3MetadataCues;
                                if (yt && (wt || kt)) {
                                    var Ot;
                                    xt === "audio" ? Ot = function(Lt) {
                                        return Lt.type === At.MetadataSchema.audioId3 && kt
                                    } : xt === "video" ? Ot = function(Lt) {
                                        return Lt.type === At.MetadataSchema.emsg && wt
                                    } : Ot = function(Lt) {
                                        return Lt.type === At.MetadataSchema.audioId3 && kt || Lt.type === At.MetadataSchema.emsg && wt
                                    }, (0, bt.removeCuesInRange)(yt, vt, mt, Ot)
                                }
                            }
                        }, ft.onLevelUpdated = function(St, _t) {
                            var vt = this,
                                mt = _t.details;
                            if (!(!this.media || !mt.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues)) {
                                var xt = this.dateRangeCuesAppended,
                                    yt = this.id3Track,
                                    Tt = mt.dateRanges,
                                    Ft = Object.keys(Tt);
                                if (yt)
                                    for (var wt = Object.keys(xt).filter(function(jt) {
                                            return !Ft.includes(jt)
                                        }), kt = function(Ut) {
                                            var Ht = wt[Ut];
                                            Object.keys(xt[Ht].cues).forEach(function(Wt) {
                                                yt.removeCue(xt[Ht].cues[Wt])
                                            }), delete xt[Ht]
                                        }, Ot = wt.length; Ot--;) kt(Ot);
                                var Rt = mt.fragments[mt.fragments.length - 1];
                                if (!(Ft.length === 0 || !(0, ut.isFiniteNumber)(Rt == null ? void 0 : Rt.programDateTime))) {
                                    this.id3Track || (this.id3Track = this.createTrack(this.media));
                                    for (var Lt = Rt.programDateTime / 1e3 - Rt.start, Bt = ht(), Nt = function(Ut) {
                                            var Ht = Ft[Ut],
                                                Wt = Tt[Ht],
                                                Kt = xt[Ht],
                                                Gt = (Kt == null ? void 0 : Kt.cues) || {},
                                                Vt = (Kt == null ? void 0 : Kt.durationKnown) || !1,
                                                zt = ct(Wt.startDate, Lt),
                                                Xt = ot,
                                                Yt = Wt.endDate;
                                            if (Yt) Xt = ct(Yt, Lt), Vt = !0;
                                            else if (Wt.endOnNext && !Vt) {
                                                var Zt = Ft.reduce(function(nr, rr) {
                                                    var ir = Tt[rr];
                                                    return ir.class === Wt.class && ir.id !== rr && ir.startDate > Wt.startDate && nr.push(ir), nr
                                                }, []).sort(function(nr, rr) {
                                                    return nr.startDate.getTime() - rr.startDate.getTime()
                                                })[0];
                                                Zt && (Xt = ct(Zt.startDate, Lt), Vt = !0)
                                            }
                                            for (var qt = Object.keys(Wt.attr), er = 0; er < qt.length; er++) {
                                                var tr = qt[er];
                                                if (!(tr === It.DateRangeAttribute.ID || tr === It.DateRangeAttribute.CLASS || tr === It.DateRangeAttribute.START_DATE || tr === It.DateRangeAttribute.DURATION || tr === It.DateRangeAttribute.END_DATE || tr === It.DateRangeAttribute.END_ON_NEXT)) {
                                                    var Qt = Gt[tr];
                                                    if (Qt) Vt && !Kt.durationKnown && (Qt.endTime = Xt);
                                                    else {
                                                        var Jt = Wt.attr[tr];
                                                        Qt = new Bt(zt, Xt, ""), (tr === It.DateRangeAttribute.SCTE35_OUT || tr === It.DateRangeAttribute.SCTE35_IN) && (Jt = Et(Jt)), Qt.value = {
                                                            key: tr,
                                                            data: Jt
                                                        }, Qt.type = At.MetadataSchema.dateRange, vt.id3Track.addCue(Qt), Gt[tr] = Qt
                                                    }
                                                }
                                            }
                                            xt[Ht] = {
                                                cues: Gt,
                                                dateRange: Wt,
                                                durationKnown: Vt
                                            }
                                        }, $t = 0; $t < Ft.length; $t++) Nt($t)
                                }
                            }
                        }, gt
                    }();
                    const Pt = Dt
                },
                "./src/controller/latency-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => At
                    });
                    var ut = it("./src/errors.ts"),
                        lt = it("./src/events.ts"),
                        bt = it("./src/utils/logger.ts");

                    function pt(Ct, ht) {
                        for (var ot = 0; ot < ht.length; ot++) {
                            var ct = ht[ot];
                            ct.enumerable = ct.enumerable || !1, ct.configurable = !0, "value" in ct && (ct.writable = !0), Object.defineProperty(Ct, ct.key, ct)
                        }
                    }

                    function It(Ct, ht, ot) {
                        return ht && pt(Ct.prototype, ht), ot && pt(Ct, ot), Object.defineProperty(Ct, "prototype", {
                            writable: !1
                        }), Ct
                    }
                    var At = function() {
                        function Ct(ot) {
                            var ct = this;
                            this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = function() {
                                return ct.timeupdate()
                            }, this.hls = ot, this.config = ot.config, this.registerListeners()
                        }
                        var ht = Ct.prototype;
                        return ht.destroy = function() {
                            this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null
                        }, ht.registerListeners = function() {
                            this.hls.on(lt.Events.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(lt.Events.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(lt.Events.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(lt.Events.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(lt.Events.ERROR, this.onError, this)
                        }, ht.unregisterListeners = function() {
                            this.hls.off(lt.Events.MEDIA_ATTACHED, this.onMediaAttached), this.hls.off(lt.Events.MEDIA_DETACHING, this.onMediaDetaching), this.hls.off(lt.Events.MANIFEST_LOADING, this.onManifestLoading), this.hls.off(lt.Events.LEVEL_UPDATED, this.onLevelUpdated), this.hls.off(lt.Events.ERROR, this.onError)
                        }, ht.onMediaAttached = function(ct, Et) {
                            this.media = Et.media, this.media.addEventListener("timeupdate", this.timeupdateHandler)
                        }, ht.onMediaDetaching = function() {
                            this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler), this.media = null)
                        }, ht.onManifestLoading = function() {
                            this.levelDetails = null, this._latency = null, this.stallCount = 0
                        }, ht.onLevelUpdated = function(ct, Et) {
                            var Dt = Et.details;
                            this.levelDetails = Dt, Dt.advanced && this.timeupdate(), !Dt.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler)
                        }, ht.onError = function(ct, Et) {
                            Et.details === ut.ErrorDetails.BUFFER_STALLED_ERROR && (this.stallCount++, bt.logger.warn("[playback-rate-controller]: Stall detected, adjusting target latency"))
                        }, ht.timeupdate = function() {
                            var ct = this.media,
                                Et = this.levelDetails;
                            if (!(!ct || !Et)) {
                                this.currentTime = ct.currentTime;
                                var Dt = this.computeLatency();
                                if (Dt !== null) {
                                    this._latency = Dt;
                                    var Pt = this.config,
                                        gt = Pt.lowLatencyMode,
                                        ft = Pt.maxLiveSyncPlaybackRate;
                                    if (!(!gt || ft === 1)) {
                                        var dt = this.targetLatency;
                                        if (dt !== null) {
                                            var St = Dt - dt,
                                                _t = Math.min(this.maxLatency, dt + Et.targetduration),
                                                vt = St < _t;
                                            if (Et.live && vt && St > .05 && this.forwardBufferLength > 1) {
                                                var mt = Math.min(2, Math.max(1, ft)),
                                                    xt = Math.round(2 / (1 + Math.exp(-.75 * St - this.edgeStalled)) * 20) / 20;
                                                ct.playbackRate = Math.min(mt, Math.max(1, xt))
                                            } else ct.playbackRate !== 1 && ct.playbackRate !== 0 && (ct.playbackRate = 1)
                                        }
                                    }
                                }
                            }
                        }, ht.estimateLiveEdge = function() {
                            var ct = this.levelDetails;
                            return ct === null ? null : ct.edge + ct.age
                        }, ht.computeLatency = function() {
                            var ct = this.estimateLiveEdge();
                            return ct === null ? null : ct - this.currentTime
                        }, It(Ct, [{
                            key: "latency",
                            get: function() {
                                return this._latency || 0
                            }
                        }, {
                            key: "maxLatency",
                            get: function() {
                                var ct = this.config,
                                    Et = this.levelDetails;
                                return ct.liveMaxLatencyDuration !== void 0 ? ct.liveMaxLatencyDuration : Et ? ct.liveMaxLatencyDurationCount * Et.targetduration : 0
                            }
                        }, {
                            key: "targetLatency",
                            get: function() {
                                var ct = this.levelDetails;
                                if (ct === null) return null;
                                var Et = ct.holdBack,
                                    Dt = ct.partHoldBack,
                                    Pt = ct.targetduration,
                                    gt = this.config,
                                    ft = gt.liveSyncDuration,
                                    dt = gt.liveSyncDurationCount,
                                    St = gt.lowLatencyMode,
                                    _t = this.hls.userConfig,
                                    vt = St && Dt || Et;
                                (_t.liveSyncDuration || _t.liveSyncDurationCount || vt === 0) && (vt = ft !== void 0 ? ft : dt * Pt);
                                var mt = Pt,
                                    xt = 1;
                                return vt + Math.min(this.stallCount * xt, mt)
                            }
                        }, {
                            key: "liveSyncPosition",
                            get: function() {
                                var ct = this.estimateLiveEdge(),
                                    Et = this.targetLatency,
                                    Dt = this.levelDetails;
                                if (ct === null || Et === null || Dt === null) return null;
                                var Pt = Dt.edge,
                                    gt = ct - Et - this.edgeStalled,
                                    ft = Pt - Dt.totalduration,
                                    dt = Pt - (this.config.lowLatencyMode && Dt.partTarget || Dt.targetduration);
                                return Math.min(Math.max(ft, gt), dt)
                            }
                        }, {
                            key: "drift",
                            get: function() {
                                var ct = this.levelDetails;
                                return ct === null ? 1 : ct.drift
                            }
                        }, {
                            key: "edgeStalled",
                            get: function() {
                                var ct = this.levelDetails;
                                if (ct === null) return 0;
                                var Et = (this.config.lowLatencyMode && ct.partTarget || ct.targetduration) * 3;
                                return Math.max(ct.age - Et, 0)
                            }
                        }, {
                            key: "forwardBufferLength",
                            get: function() {
                                var ct = this.media,
                                    Et = this.levelDetails;
                                if (!ct || !Et) return 0;
                                var Dt = ct.buffered.length;
                                return (Dt ? ct.buffered.end(Dt - 1) : Et.edge) - this.currentTime
                            }
                        }]), Ct
                    }()
                },
                "./src/controller/level-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => gt
                    });
                    var ut = it("./src/types/level.ts"),
                        lt = it("./src/events.ts"),
                        bt = it("./src/errors.ts"),
                        pt = it("./src/utils/codecs.ts"),
                        It = it("./src/controller/level-helper.ts"),
                        At = it("./src/controller/base-playlist-controller.ts"),
                        Ct = it("./src/types/loader.ts");

                    function ht() {
                        return ht = Object.assign ? Object.assign.bind() : function(ft) {
                            for (var dt = 1; dt < arguments.length; dt++) {
                                var St = arguments[dt];
                                for (var _t in St) Object.prototype.hasOwnProperty.call(St, _t) && (ft[_t] = St[_t])
                            }
                            return ft
                        }, ht.apply(this, arguments)
                    }

                    function ot(ft, dt) {
                        for (var St = 0; St < dt.length; St++) {
                            var _t = dt[St];
                            _t.enumerable = _t.enumerable || !1, _t.configurable = !0, "value" in _t && (_t.writable = !0), Object.defineProperty(ft, _t.key, _t)
                        }
                    }

                    function ct(ft, dt, St) {
                        return dt && ot(ft.prototype, dt), St && ot(ft, St), Object.defineProperty(ft, "prototype", {
                            writable: !1
                        }), ft
                    }

                    function Et(ft, dt) {
                        ft.prototype = Object.create(dt.prototype), ft.prototype.constructor = ft, Dt(ft, dt)
                    }

                    function Dt(ft, dt) {
                        return Dt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(_t, vt) {
                            return _t.__proto__ = vt, _t
                        }, Dt(ft, dt)
                    }
                    var Pt = /chrome|firefox/.test(navigator.userAgent.toLowerCase()),
                        gt = function(ft) {
                            Et(dt, ft);

                            function dt(_t) {
                                var vt;
                                return vt = ft.call(this, _t, "[level-controller]") || this, vt._levels = [], vt._firstLevel = -1, vt._startLevel = void 0, vt.currentLevelIndex = -1, vt.manualLevelIndex = -1, vt.onParsedComplete = void 0, vt._registerListeners(), vt
                            }
                            var St = dt.prototype;
                            return St._registerListeners = function() {
                                var vt = this.hls;
                                vt.on(lt.Events.MANIFEST_LOADED, this.onManifestLoaded, this), vt.on(lt.Events.LEVEL_LOADED, this.onLevelLoaded, this), vt.on(lt.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), vt.on(lt.Events.FRAG_LOADED, this.onFragLoaded, this), vt.on(lt.Events.ERROR, this.onError, this)
                            }, St._unregisterListeners = function() {
                                var vt = this.hls;
                                vt.off(lt.Events.MANIFEST_LOADED, this.onManifestLoaded, this), vt.off(lt.Events.LEVEL_LOADED, this.onLevelLoaded, this), vt.off(lt.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), vt.off(lt.Events.FRAG_LOADED, this.onFragLoaded, this), vt.off(lt.Events.ERROR, this.onError, this)
                            }, St.destroy = function() {
                                this._unregisterListeners(), this.manualLevelIndex = -1, this._levels.length = 0, ft.prototype.destroy.call(this)
                            }, St.startLoad = function() {
                                var vt = this._levels;
                                vt.forEach(function(mt) {
                                    mt.loadError = 0
                                }), ft.prototype.startLoad.call(this)
                            }, St.onManifestLoaded = function(vt, mt) {
                                var xt = [],
                                    yt = [],
                                    Tt = [],
                                    Ft, wt = {},
                                    kt, Ot = !1,
                                    Rt = !1,
                                    Lt = !1;
                                if (mt.levels.forEach(function(jt) {
                                        var Ut = jt.attrs;
                                        Ot = Ot || !!(jt.width && jt.height), Rt = Rt || !!jt.videoCodec, Lt = Lt || !!jt.audioCodec, Pt && jt.audioCodec && jt.audioCodec.indexOf("mp4a.40.34") !== -1 && (jt.audioCodec = void 0);
                                        var Ht = jt.bitrate + "-" + jt.attrs.RESOLUTION + "-" + jt.attrs.CODECS;
                                        kt = wt[Ht], kt ? kt.url.push(jt.url) : (kt = new ut.Level(jt), wt[Ht] = kt, xt.push(kt)), Ut && (Ut.AUDIO && (0, It.addGroupId)(kt, "audio", Ut.AUDIO), Ut.SUBTITLES && (0, It.addGroupId)(kt, "text", Ut.SUBTITLES))
                                    }), (Ot || Rt) && Lt && (xt = xt.filter(function(jt) {
                                        var Ut = jt.videoCodec,
                                            Ht = jt.width,
                                            Wt = jt.height;
                                        return !!Ut || !!(Ht && Wt)
                                    })), xt = xt.filter(function(jt) {
                                        var Ut = jt.audioCodec,
                                            Ht = jt.videoCodec;
                                        return (!Ut || (0, pt.isCodecSupportedInMp4)(Ut, "audio")) && (!Ht || (0, pt.isCodecSupportedInMp4)(Ht, "video"))
                                    }), mt.audioTracks && (yt = mt.audioTracks.filter(function(jt) {
                                        return !jt.audioCodec || (0, pt.isCodecSupportedInMp4)(jt.audioCodec, "audio")
                                    }), (0, It.assignTrackIdsByGroup)(yt)), mt.subtitles && (Tt = mt.subtitles, (0, It.assignTrackIdsByGroup)(Tt)), xt.length > 0) {
                                    Ft = xt[0].bitrate, xt.sort(function(jt, Ut) {
                                        return jt.bitrate - Ut.bitrate
                                    }), this._levels = xt;
                                    for (var Bt = 0; Bt < xt.length; Bt++)
                                        if (xt[Bt].bitrate === Ft) {
                                            this._firstLevel = Bt, this.log("manifest loaded, " + xt.length + " level(s) found, first bitrate: " + Ft);
                                            break
                                        } var Nt = Lt && !Rt,
                                        $t = {
                                            levels: xt,
                                            audioTracks: yt,
                                            subtitleTracks: Tt,
                                            firstLevel: this._firstLevel,
                                            stats: mt.stats,
                                            audio: Lt,
                                            video: Rt,
                                            altAudio: !Nt && yt.some(function(jt) {
                                                return !!jt.url
                                            })
                                        };
                                    this.hls.trigger(lt.Events.MANIFEST_PARSED, $t), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition)
                                } else this.hls.trigger(lt.Events.ERROR, {
                                    type: bt.ErrorTypes.MEDIA_ERROR,
                                    details: bt.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                                    fatal: !0,
                                    url: mt.url,
                                    reason: "no level with compatible codecs found in manifest"
                                })
                            }, St.onError = function(vt, mt) {
                                var xt;
                                if (ft.prototype.onError.call(this, vt, mt), !mt.fatal) {
                                    var yt = mt.context,
                                        Tt = this._levels[this.currentLevelIndex];
                                    if (yt && (yt.type === Ct.PlaylistContextType.AUDIO_TRACK && Tt.audioGroupIds && yt.groupId === Tt.audioGroupIds[Tt.urlId] || yt.type === Ct.PlaylistContextType.SUBTITLE_TRACK && Tt.textGroupIds && yt.groupId === Tt.textGroupIds[Tt.urlId])) {
                                        this.redundantFailover(this.currentLevelIndex);
                                        return
                                    }
                                    var Ft = !1,
                                        wt = !0,
                                        kt;
                                    switch (mt.details) {
                                        case bt.ErrorDetails.FRAG_LOAD_ERROR:
                                        case bt.ErrorDetails.FRAG_LOAD_TIMEOUT:
                                        case bt.ErrorDetails.KEY_LOAD_ERROR:
                                        case bt.ErrorDetails.KEY_LOAD_TIMEOUT:
                                            if (mt.frag) {
                                                var Ot = mt.frag.type === Ct.PlaylistLevelType.MAIN ? mt.frag.level : this.currentLevelIndex,
                                                    Rt = this._levels[Ot];
                                                Rt ? (Rt.fragmentError++, Rt.fragmentError > this.hls.config.fragLoadingMaxRetry && (kt = Ot)) : kt = Ot
                                            }
                                            break;
                                        case bt.ErrorDetails.LEVEL_LOAD_ERROR:
                                        case bt.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                                            yt && (yt.deliveryDirectives && (wt = !1), kt = yt.level), Ft = !0;
                                            break;
                                        case bt.ErrorDetails.REMUX_ALLOC_ERROR:
                                            kt = (xt = mt.level) != null ? xt : this.currentLevelIndex, Ft = !0;
                                            break
                                    }
                                    kt !== void 0 && this.recoverLevel(mt, kt, Ft, wt)
                                }
                            }, St.recoverLevel = function(vt, mt, xt, yt) {
                                var Tt = vt.details,
                                    Ft = this._levels[mt];
                                if (Ft.loadError++, xt) {
                                    var wt = this.retryLoadingOrFail(vt);
                                    if (wt) vt.levelRetry = !0;
                                    else {
                                        this.currentLevelIndex = -1;
                                        return
                                    }
                                }
                                if (yt) {
                                    var kt = Ft.url.length;
                                    if (kt > 1 && Ft.loadError < kt) vt.levelRetry = !0, this.redundantFailover(mt);
                                    else if (this.manualLevelIndex === -1) {
                                        for (var Ot = -1, Rt = this._levels, Lt = Rt.length; Lt--;) {
                                            var Bt = (Lt + this.currentLevelIndex) % Rt.length;
                                            if (Bt !== this.currentLevelIndex && Rt[Bt].loadError === 0) {
                                                Ot = Bt;
                                                break
                                            }
                                        }
                                        Ot > -1 && this.currentLevelIndex !== Ot && (this.warn(Tt + ": switch to " + Ot), vt.levelRetry = !0, this.hls.nextAutoLevel = Ot)
                                    }
                                }
                            }, St.redundantFailover = function(vt) {
                                var mt = this._levels[vt],
                                    xt = mt.url.length;
                                if (xt > 1) {
                                    var yt = (mt.urlId + 1) % xt;
                                    this.warn("Switching to redundant URL-id " + yt), this._levels.forEach(function(Tt) {
                                        Tt.urlId = yt
                                    }), this.level = vt
                                }
                            }, St.onFragLoaded = function(vt, mt) {
                                var xt = mt.frag;
                                if (xt !== void 0 && xt.type === Ct.PlaylistLevelType.MAIN) {
                                    var yt = this._levels[xt.level];
                                    yt !== void 0 && (yt.fragmentError = 0, yt.loadError = 0)
                                }
                            }, St.onLevelLoaded = function(vt, mt) {
                                var xt, yt = mt.level,
                                    Tt = mt.details,
                                    Ft = this._levels[yt];
                                if (!Ft) {
                                    var wt;
                                    this.warn("Invalid level index " + yt), (wt = mt.deliveryDirectives) !== null && wt !== void 0 && wt.skip && (Tt.deltaUpdateFailed = !0);
                                    return
                                }
                                yt === this.currentLevelIndex ? (Ft.fragmentError === 0 && (Ft.loadError = 0, this.retryCount = 0), this.playlistLoaded(yt, mt, Ft.details)) : (xt = mt.deliveryDirectives) !== null && xt !== void 0 && xt.skip && (Tt.deltaUpdateFailed = !0)
                            }, St.onAudioTrackSwitched = function(vt, mt) {
                                var xt = this.hls.levels[this.currentLevelIndex];
                                if (!!xt && xt.audioGroupIds) {
                                    for (var yt = -1, Tt = this.hls.audioTracks[mt.id].groupId, Ft = 0; Ft < xt.audioGroupIds.length; Ft++)
                                        if (xt.audioGroupIds[Ft] === Tt) {
                                            yt = Ft;
                                            break
                                        } yt !== xt.urlId && (xt.urlId = yt, this.startLoad())
                                }
                            }, St.loadPlaylist = function(vt) {
                                var mt = this.currentLevelIndex,
                                    xt = this._levels[mt];
                                if (this.canLoad && xt && xt.url.length > 0) {
                                    var yt = xt.urlId,
                                        Tt = xt.url[yt];
                                    if (vt) try {
                                        Tt = vt.addDirectives(Tt)
                                    } catch (Ft) {
                                        this.warn("Could not construct new URL with HLS Delivery Directives: " + Ft)
                                    }
                                    this.log("Attempt loading level index " + mt + (vt ? " at sn " + vt.msn + " part " + vt.part : "") + " with URL-id " + yt + " " + Tt), this.clearTimer(), this.hls.trigger(lt.Events.LEVEL_LOADING, {
                                        url: Tt,
                                        level: mt,
                                        id: yt,
                                        deliveryDirectives: vt || null
                                    })
                                }
                            }, St.removeLevel = function(vt, mt) {
                                var xt = function(Ft, wt) {
                                        return wt !== mt
                                    },
                                    yt = this._levels.filter(function(Tt, Ft) {
                                        return Ft !== vt ? !0 : Tt.url.length > 1 && mt !== void 0 ? (Tt.url = Tt.url.filter(xt), Tt.audioGroupIds && (Tt.audioGroupIds = Tt.audioGroupIds.filter(xt)), Tt.textGroupIds && (Tt.textGroupIds = Tt.textGroupIds.filter(xt)), Tt.urlId = 0, !0) : !1
                                    }).map(function(Tt, Ft) {
                                        var wt = Tt.details;
                                        return wt != null && wt.fragments && wt.fragments.forEach(function(kt) {
                                            kt.level = Ft
                                        }), Tt
                                    });
                                this._levels = yt, this.hls.trigger(lt.Events.LEVELS_UPDATED, {
                                    levels: yt
                                })
                            }, ct(dt, [{
                                key: "levels",
                                get: function() {
                                    return this._levels.length === 0 ? null : this._levels
                                }
                            }, {
                                key: "level",
                                get: function() {
                                    return this.currentLevelIndex
                                },
                                set: function(vt) {
                                    var mt, xt = this._levels;
                                    if (xt.length !== 0 && !(this.currentLevelIndex === vt && (mt = xt[vt]) !== null && mt !== void 0 && mt.details)) {
                                        if (vt < 0 || vt >= xt.length) {
                                            var yt = vt < 0;
                                            if (this.hls.trigger(lt.Events.ERROR, {
                                                    type: bt.ErrorTypes.OTHER_ERROR,
                                                    details: bt.ErrorDetails.LEVEL_SWITCH_ERROR,
                                                    level: vt,
                                                    fatal: yt,
                                                    reason: "invalid level idx"
                                                }), yt) return;
                                            vt = Math.min(vt, xt.length - 1)
                                        }
                                        this.clearTimer();
                                        var Tt = this.currentLevelIndex,
                                            Ft = xt[Tt],
                                            wt = xt[vt];
                                        this.log("switching to level " + vt + " from " + Tt), this.currentLevelIndex = vt;
                                        var kt = ht({}, wt, {
                                            level: vt,
                                            maxBitrate: wt.maxBitrate,
                                            uri: wt.uri,
                                            urlId: wt.urlId
                                        });
                                        delete kt._urlId, this.hls.trigger(lt.Events.LEVEL_SWITCHING, kt);
                                        var Ot = wt.details;
                                        if (!Ot || Ot.live) {
                                            var Rt = this.switchParams(wt.uri, Ft == null ? void 0 : Ft.details);
                                            this.loadPlaylist(Rt)
                                        }
                                    }
                                }
                            }, {
                                key: "manualLevel",
                                get: function() {
                                    return this.manualLevelIndex
                                },
                                set: function(vt) {
                                    this.manualLevelIndex = vt, this._startLevel === void 0 && (this._startLevel = vt), vt !== -1 && (this.level = vt)
                                }
                            }, {
                                key: "firstLevel",
                                get: function() {
                                    return this._firstLevel
                                },
                                set: function(vt) {
                                    this._firstLevel = vt
                                }
                            }, {
                                key: "startLevel",
                                get: function() {
                                    if (this._startLevel === void 0) {
                                        var vt = this.hls.config.startLevel;
                                        return vt !== void 0 ? vt : this._firstLevel
                                    } else return this._startLevel
                                },
                                set: function(vt) {
                                    this._startLevel = vt
                                }
                            }, {
                                key: "nextLoadLevel",
                                get: function() {
                                    return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel
                                },
                                set: function(vt) {
                                    this.level = vt, this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = vt)
                                }
                            }]), dt
                        }(At.default)
                },
                "./src/controller/level-helper.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        addGroupId: () => It,
                        addSliding: () => ft,
                        adjustSliding: () => gt,
                        assignTrackIdsByGroup: () => At,
                        computeReloadInterval: () => dt,
                        getFragmentWithSN: () => St,
                        getPartWith: () => _t,
                        mapFragmentIntersection: () => Pt,
                        mapPartIntersection: () => Dt,
                        mergeDetails: () => ct,
                        updateFragPTSDTS: () => ot,
                        updatePTS: () => Ct
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/utils/logger.ts"),
                        bt = it("./src/loader/date-range.ts");

                    function pt() {
                        return pt = Object.assign ? Object.assign.bind() : function(vt) {
                            for (var mt = 1; mt < arguments.length; mt++) {
                                var xt = arguments[mt];
                                for (var yt in xt) Object.prototype.hasOwnProperty.call(xt, yt) && (vt[yt] = xt[yt])
                            }
                            return vt
                        }, pt.apply(this, arguments)
                    }

                    function It(vt, mt, xt) {
                        switch (mt) {
                            case "audio":
                                vt.audioGroupIds || (vt.audioGroupIds = []), vt.audioGroupIds.push(xt);
                                break;
                            case "text":
                                vt.textGroupIds || (vt.textGroupIds = []), vt.textGroupIds.push(xt);
                                break
                        }
                    }

                    function At(vt) {
                        var mt = {};
                        vt.forEach(function(xt) {
                            var yt = xt.groupId || "";
                            xt.id = mt[yt] = mt[yt] || 0, mt[yt]++
                        })
                    }

                    function Ct(vt, mt, xt) {
                        var yt = vt[mt],
                            Tt = vt[xt];
                        ht(yt, Tt)
                    }

                    function ht(vt, mt) {
                        var xt = mt.startPTS;
                        if ((0, ut.isFiniteNumber)(xt)) {
                            var yt = 0,
                                Tt;
                            mt.sn > vt.sn ? (yt = xt - vt.start, Tt = vt) : (yt = vt.start - xt, Tt = mt), Tt.duration !== yt && (Tt.duration = yt)
                        } else if (mt.sn > vt.sn) {
                            var Ft = vt.cc === mt.cc;
                            Ft && vt.minEndPTS ? mt.start = vt.start + (vt.minEndPTS - vt.start) : mt.start = vt.start + vt.duration
                        } else mt.start = Math.max(vt.start - mt.duration, 0)
                    }

                    function ot(vt, mt, xt, yt, Tt, Ft) {
                        var wt = yt - xt;
                        wt <= 0 && (lt.logger.warn("Fragment should have a positive duration", mt), yt = xt + mt.duration, Ft = Tt + mt.duration);
                        var kt = xt,
                            Ot = yt,
                            Rt = mt.startPTS,
                            Lt = mt.endPTS;
                        if ((0, ut.isFiniteNumber)(Rt)) {
                            var Bt = Math.abs(Rt - xt);
                            (0, ut.isFiniteNumber)(mt.deltaPTS) ? mt.deltaPTS = Math.max(Bt, mt.deltaPTS): mt.deltaPTS = Bt, kt = Math.max(xt, Rt), xt = Math.min(xt, Rt), Tt = Math.min(Tt, mt.startDTS), Ot = Math.min(yt, Lt), yt = Math.max(yt, Lt), Ft = Math.max(Ft, mt.endDTS)
                        }
                        mt.duration = yt - xt;
                        var Nt = xt - mt.start;
                        mt.appendedPTS = yt, mt.start = mt.startPTS = xt, mt.maxStartPTS = kt, mt.startDTS = Tt, mt.endPTS = yt, mt.minEndPTS = Ot, mt.endDTS = Ft;
                        var $t = mt.sn;
                        if (!vt || $t < vt.startSN || $t > vt.endSN) return 0;
                        var jt, Ut = $t - vt.startSN,
                            Ht = vt.fragments;
                        for (Ht[Ut] = mt, jt = Ut; jt > 0; jt--) ht(Ht[jt], Ht[jt - 1]);
                        for (jt = Ut; jt < Ht.length - 1; jt++) ht(Ht[jt], Ht[jt + 1]);
                        return vt.fragmentHint && ht(Ht[Ht.length - 1], vt.fragmentHint), vt.PTSKnown = vt.alignedSliding = !0, Nt
                    }

                    function ct(vt, mt) {
                        for (var xt = null, yt = vt.fragments, Tt = yt.length - 1; Tt >= 0; Tt--) {
                            var Ft = yt[Tt].initSegment;
                            if (Ft) {
                                xt = Ft;
                                break
                            }
                        }
                        vt.fragmentHint && delete vt.fragmentHint.endPTS;
                        var wt = 0,
                            kt;
                        if (Pt(vt, mt, function(jt, Ut) {
                                jt.relurl && (wt = jt.cc - Ut.cc), (0, ut.isFiniteNumber)(jt.startPTS) && (0, ut.isFiniteNumber)(jt.endPTS) && (Ut.start = Ut.startPTS = jt.startPTS, Ut.startDTS = jt.startDTS, Ut.appendedPTS = jt.appendedPTS, Ut.maxStartPTS = jt.maxStartPTS, Ut.endPTS = jt.endPTS, Ut.endDTS = jt.endDTS, Ut.minEndPTS = jt.minEndPTS, Ut.duration = jt.endPTS - jt.startPTS, Ut.duration && (kt = Ut), mt.PTSKnown = mt.alignedSliding = !0), Ut.elementaryStreams = jt.elementaryStreams, Ut.loader = jt.loader, Ut.stats = jt.stats, Ut.urlId = jt.urlId, jt.initSegment && (Ut.initSegment = jt.initSegment, xt = jt.initSegment)
                            }), xt) {
                            var Ot = mt.fragmentHint ? mt.fragments.concat(mt.fragmentHint) : mt.fragments;
                            Ot.forEach(function(jt) {
                                var Ut;
                                (!jt.initSegment || jt.initSegment.relurl === ((Ut = xt) === null || Ut === void 0 ? void 0 : Ut.relurl)) && (jt.initSegment = xt)
                            })
                        }
                        if (mt.skippedSegments)
                            if (mt.deltaUpdateFailed = mt.fragments.some(function(jt) {
                                    return !jt
                                }), mt.deltaUpdateFailed) {
                                lt.logger.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
                                for (var Rt = mt.skippedSegments; Rt--;) mt.fragments.shift();
                                mt.startSN = mt.fragments[0].sn, mt.startCC = mt.fragments[0].cc
                            } else mt.canSkipDateRanges && (mt.dateRanges = Et(vt.dateRanges, mt.dateRanges, mt.recentlyRemovedDateranges));
                        var Lt = mt.fragments;
                        if (wt) {
                            lt.logger.warn("discontinuity sliding from playlist, take drift into account");
                            for (var Bt = 0; Bt < Lt.length; Bt++) Lt[Bt].cc += wt
                        }
                        mt.skippedSegments && (mt.startCC = mt.fragments[0].cc), Dt(vt.partList, mt.partList, function(jt, Ut) {
                            Ut.elementaryStreams = jt.elementaryStreams, Ut.stats = jt.stats
                        }), kt ? ot(mt, kt, kt.startPTS, kt.endPTS, kt.startDTS, kt.endDTS) : gt(vt, mt), Lt.length && (mt.totalduration = mt.edge - Lt[0].start), mt.driftStartTime = vt.driftStartTime, mt.driftStart = vt.driftStart;
                        var Nt = mt.advancedDateTime;
                        if (mt.advanced && Nt) {
                            var $t = mt.edge;
                            mt.driftStart || (mt.driftStartTime = Nt, mt.driftStart = $t), mt.driftEndTime = Nt, mt.driftEnd = $t
                        } else mt.driftEndTime = vt.driftEndTime, mt.driftEnd = vt.driftEnd, mt.advancedDateTime = vt.advancedDateTime
                    }

                    function Et(vt, mt, xt) {
                        var yt = pt({}, vt);
                        return xt && xt.forEach(function(Tt) {
                            delete yt[Tt]
                        }), Object.keys(mt).forEach(function(Tt) {
                            var Ft = new bt.DateRange(mt[Tt].attr, yt[Tt]);
                            Ft.isValid ? yt[Tt] = Ft : lt.logger.warn('Ignoring invalid Playlist Delta Update DATERANGE tag: "' + JSON.stringify(mt[Tt].attr) + '"')
                        }), yt
                    }

                    function Dt(vt, mt, xt) {
                        if (vt && mt)
                            for (var yt = 0, Tt = 0, Ft = vt.length; Tt <= Ft; Tt++) {
                                var wt = vt[Tt],
                                    kt = mt[Tt + yt];
                                wt && kt && wt.index === kt.index && wt.fragment.sn === kt.fragment.sn ? xt(wt, kt) : yt--
                            }
                    }

                    function Pt(vt, mt, xt) {
                        for (var yt = mt.skippedSegments, Tt = Math.max(vt.startSN, mt.startSN) - mt.startSN, Ft = (vt.fragmentHint ? 1 : 0) + (yt ? mt.endSN : Math.min(vt.endSN, mt.endSN)) - mt.startSN, wt = mt.startSN - vt.startSN, kt = mt.fragmentHint ? mt.fragments.concat(mt.fragmentHint) : mt.fragments, Ot = vt.fragmentHint ? vt.fragments.concat(vt.fragmentHint) : vt.fragments, Rt = Tt; Rt <= Ft; Rt++) {
                            var Lt = Ot[wt + Rt],
                                Bt = kt[Rt];
                            yt && !Bt && Rt < yt && (Bt = mt.fragments[Rt] = Lt), Lt && Bt && xt(Lt, Bt)
                        }
                    }

                    function gt(vt, mt) {
                        var xt = mt.startSN + mt.skippedSegments - vt.startSN,
                            yt = vt.fragments;
                        xt < 0 || xt >= yt.length || ft(mt, yt[xt].start)
                    }

                    function ft(vt, mt) {
                        if (mt) {
                            for (var xt = vt.fragments, yt = vt.skippedSegments; yt < xt.length; yt++) xt[yt].start += mt;
                            vt.fragmentHint && (vt.fragmentHint.start += mt)
                        }
                    }

                    function dt(vt, mt) {
                        var xt = 1e3 * vt.levelTargetDuration,
                            yt = xt / 2,
                            Tt = vt.age,
                            Ft = Tt > 0 && Tt < xt * 3,
                            wt = mt.loading.end - mt.loading.start,
                            kt, Ot = vt.availabilityDelay;
                        if (vt.updated === !1)
                            if (Ft) {
                                var Rt = 333 * vt.misses;
                                kt = Math.max(Math.min(yt, wt * 2), Rt), vt.availabilityDelay = (vt.availabilityDelay || 0) + kt
                            } else kt = yt;
                        else Ft ? (Ot = Math.min(Ot || xt / 2, Tt), vt.availabilityDelay = Ot, kt = Ot + xt - Tt) : kt = xt - wt;
                        return Math.round(kt)
                    }

                    function St(vt, mt, xt) {
                        if (!vt || !vt.details) return null;
                        var yt = vt.details,
                            Tt = yt.fragments[mt - yt.startSN];
                        return Tt || (Tt = yt.fragmentHint, Tt && Tt.sn === mt) ? Tt : mt < yt.startSN && xt && xt.sn === mt ? xt : null
                    }

                    function _t(vt, mt, xt) {
                        if (!vt || !vt.details) return null;
                        var yt = vt.details.partList;
                        if (yt)
                            for (var Tt = yt.length; Tt--;) {
                                var Ft = yt[Tt];
                                if (Ft.index === xt && Ft.fragment.sn === mt) return Ft
                            }
                        return null
                    }
                },
                "./src/controller/stream-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => _t
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/controller/base-stream-controller.ts"),
                        bt = it("./src/is-supported.ts"),
                        pt = it("./src/events.ts"),
                        It = it("./src/utils/buffer-helper.ts"),
                        At = it("./src/controller/fragment-tracker.ts"),
                        Ct = it("./src/types/loader.ts"),
                        ht = it("./src/loader/fragment.ts"),
                        ot = it("./src/demux/transmuxer-interface.ts"),
                        ct = it("./src/types/transmuxer.ts"),
                        Et = it("./src/controller/gap-controller.ts"),
                        Dt = it("./src/errors.ts");

                    function Pt(vt, mt) {
                        for (var xt = 0; xt < mt.length; xt++) {
                            var yt = mt[xt];
                            yt.enumerable = yt.enumerable || !1, yt.configurable = !0, "value" in yt && (yt.writable = !0), Object.defineProperty(vt, yt.key, yt)
                        }
                    }

                    function gt(vt, mt, xt) {
                        return mt && Pt(vt.prototype, mt), xt && Pt(vt, xt), Object.defineProperty(vt, "prototype", {
                            writable: !1
                        }), vt
                    }

                    function ft(vt, mt) {
                        vt.prototype = Object.create(mt.prototype), vt.prototype.constructor = vt, dt(vt, mt)
                    }

                    function dt(vt, mt) {
                        return dt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(yt, Tt) {
                            return yt.__proto__ = Tt, yt
                        }, dt(vt, mt)
                    }
                    var St = 100,
                        _t = function(vt) {
                            ft(mt, vt);

                            function mt(yt, Tt) {
                                var Ft;
                                return Ft = vt.call(this, yt, Tt, "[stream-controller]") || this, Ft.audioCodecSwap = !1, Ft.gapController = null, Ft.level = -1, Ft._forceStartLoad = !1, Ft.altAudio = !1, Ft.audioOnly = !1, Ft.fragPlaying = null, Ft.onvplaying = null, Ft.onvseeked = null, Ft.fragLastKbps = 0, Ft.couldBacktrack = !1, Ft.backtrackFragment = null, Ft.audioCodecSwitch = !1, Ft.videoBuffer = null, Ft._registerListeners(), Ft
                            }
                            var xt = mt.prototype;
                            return xt._registerListeners = function() {
                                var Tt = this.hls;
                                Tt.on(pt.Events.MEDIA_ATTACHED, this.onMediaAttached, this), Tt.on(pt.Events.MEDIA_DETACHING, this.onMediaDetaching, this), Tt.on(pt.Events.MANIFEST_LOADING, this.onManifestLoading, this), Tt.on(pt.Events.MANIFEST_PARSED, this.onManifestParsed, this), Tt.on(pt.Events.LEVEL_LOADING, this.onLevelLoading, this), Tt.on(pt.Events.LEVEL_LOADED, this.onLevelLoaded, this), Tt.on(pt.Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), Tt.on(pt.Events.ERROR, this.onError, this), Tt.on(pt.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), Tt.on(pt.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), Tt.on(pt.Events.BUFFER_CREATED, this.onBufferCreated, this), Tt.on(pt.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), Tt.on(pt.Events.LEVELS_UPDATED, this.onLevelsUpdated, this), Tt.on(pt.Events.FRAG_BUFFERED, this.onFragBuffered, this)
                            }, xt._unregisterListeners = function() {
                                var Tt = this.hls;
                                Tt.off(pt.Events.MEDIA_ATTACHED, this.onMediaAttached, this), Tt.off(pt.Events.MEDIA_DETACHING, this.onMediaDetaching, this), Tt.off(pt.Events.MANIFEST_LOADING, this.onManifestLoading, this), Tt.off(pt.Events.MANIFEST_PARSED, this.onManifestParsed, this), Tt.off(pt.Events.LEVEL_LOADED, this.onLevelLoaded, this), Tt.off(pt.Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), Tt.off(pt.Events.ERROR, this.onError, this), Tt.off(pt.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), Tt.off(pt.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), Tt.off(pt.Events.BUFFER_CREATED, this.onBufferCreated, this), Tt.off(pt.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), Tt.off(pt.Events.LEVELS_UPDATED, this.onLevelsUpdated, this), Tt.off(pt.Events.FRAG_BUFFERED, this.onFragBuffered, this)
                            }, xt.onHandlerDestroying = function() {
                                this._unregisterListeners(), this.onMediaDetaching()
                            }, xt.startLoad = function(Tt) {
                                if (this.levels) {
                                    var Ft = this.lastCurrentTime,
                                        wt = this.hls;
                                    if (this.stopLoad(), this.setInterval(St), this.level = -1, this.fragLoadError = 0, !this.startFragRequested) {
                                        var kt = wt.startLevel;
                                        kt === -1 && (wt.config.testBandwidth && this.levels.length > 1 ? (kt = 0, this.bitrateTest = !0) : kt = wt.nextAutoLevel), this.level = wt.nextLoadLevel = kt, this.loadedmetadata = !1
                                    }
                                    Ft > 0 && Tt === -1 && (this.log("Override startPosition with lastCurrentTime @" + Ft.toFixed(3)), Tt = Ft), this.state = lt.State.IDLE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = Tt, this.tick()
                                } else this._forceStartLoad = !0, this.state = lt.State.STOPPED
                            }, xt.stopLoad = function() {
                                this._forceStartLoad = !1, vt.prototype.stopLoad.call(this)
                            }, xt.doTick = function() {
                                switch (this.state) {
                                    case lt.State.IDLE:
                                        this.doTickIdle();
                                        break;
                                    case lt.State.WAITING_LEVEL: {
                                        var Tt, Ft = this.levels,
                                            wt = this.level,
                                            kt = Ft == null || (Tt = Ft[wt]) === null || Tt === void 0 ? void 0 : Tt.details;
                                        if (kt && (!kt.live || this.levelLastLoaded === this.level)) {
                                            if (this.waitForCdnTuneIn(kt)) break;
                                            this.state = lt.State.IDLE;
                                            break
                                        }
                                        break
                                    }
                                    case lt.State.FRAG_LOADING_WAITING_RETRY: {
                                        var Ot, Rt = self.performance.now(),
                                            Lt = this.retryDate;
                                        (!Lt || Rt >= Lt || (Ot = this.media) !== null && Ot !== void 0 && Ot.seeking) && (this.log("retryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded(this.level), this.state = lt.State.IDLE)
                                    }
                                    break
                                }
                                this.onTickEnd()
                            }, xt.onTickEnd = function() {
                                vt.prototype.onTickEnd.call(this), this.checkBuffer(), this.checkFragmentChanged()
                            }, xt.doTickIdle = function() {
                                var Tt, Ft, wt = this.hls,
                                    kt = this.levelLastLoaded,
                                    Ot = this.levels,
                                    Rt = this.media,
                                    Lt = wt.config,
                                    Bt = wt.nextLoadLevel;
                                if (!(kt === null || !Rt && (this.startFragRequested || !Lt.startFragPrefetch)) && !(this.altAudio && this.audioOnly) && !(!Ot || !Ot[Bt])) {
                                    var Nt = Ot[Bt];
                                    this.level = wt.nextLoadLevel = Bt;
                                    var $t = Nt.details;
                                    if (!$t || this.state === lt.State.WAITING_LEVEL || $t.live && this.levelLastLoaded !== Bt) {
                                        this.state = lt.State.WAITING_LEVEL;
                                        return
                                    }
                                    var jt = this.getMainFwdBufferInfo();
                                    if (jt !== null) {
                                        var Ut = jt.len,
                                            Ht = this.getMaxBufferLength(Nt.maxBitrate);
                                        if (!(Ut >= Ht)) {
                                            if (this._streamEnded(jt, $t)) {
                                                var Wt = {};
                                                this.altAudio && (Wt.type = "video"), this.hls.trigger(pt.Events.BUFFER_EOS, Wt), this.state = lt.State.ENDED;
                                                return
                                            }
                                            this.backtrackFragment && this.backtrackFragment.start > jt.end && (this.backtrackFragment = null);
                                            var Kt = this.backtrackFragment ? this.backtrackFragment.start : jt.end,
                                                Gt = this.getNextFragment(Kt, $t);
                                            if (this.couldBacktrack && !this.fragPrevious && Gt && Gt.sn !== "initSegment" && this.fragmentTracker.getState(Gt) !== At.FragmentState.OK) {
                                                var Vt, zt = ((Vt = this.backtrackFragment) != null ? Vt : Gt).sn,
                                                    Xt = zt - $t.startSN,
                                                    Yt = $t.fragments[Xt - 1];
                                                Yt && Gt.cc === Yt.cc && (Gt = Yt, this.fragmentTracker.removeFragment(Yt))
                                            } else this.backtrackFragment && jt.len && (this.backtrackFragment = null);
                                            if (Gt && this.fragmentTracker.getState(Gt) === At.FragmentState.OK && this.nextLoadPosition > Kt) {
                                                var Zt = this.audioOnly && !this.altAudio ? ht.ElementaryStreamTypes.AUDIO : ht.ElementaryStreamTypes.VIDEO;
                                                Rt && this.afterBufferFlushed(Rt, Zt, Ct.PlaylistLevelType.MAIN), Gt = this.getNextFragment(this.nextLoadPosition, $t)
                                            }!Gt || (Gt.initSegment && !Gt.initSegment.data && !this.bitrateTest && (Gt = Gt.initSegment), ((Tt = Gt.decryptdata) === null || Tt === void 0 ? void 0 : Tt.keyFormat) === "identity" && !((Ft = Gt.decryptdata) !== null && Ft !== void 0 && Ft.key) ? this.loadKey(Gt, $t) : this.loadFragment(Gt, $t, Kt))
                                        }
                                    }
                                }
                            }, xt.loadFragment = function(Tt, Ft, wt) {
                                var kt, Ot = this.fragmentTracker.getState(Tt);
                                this.fragCurrent = Tt, Ot === At.FragmentState.NOT_LOADED ? Tt.sn === "initSegment" ? this._loadInitSegment(Tt) : this.bitrateTest ? (this.log("Fragment " + Tt.sn + " of level " + Tt.level + " is being downloaded to test bitrate and will not be buffered"), this._loadBitrateTestFrag(Tt)) : (this.startFragRequested = !0, vt.prototype.loadFragment.call(this, Tt, Ft, wt)) : Ot === At.FragmentState.APPENDING ? this.reduceMaxBufferLength(Tt.duration) && this.fragmentTracker.removeFragment(Tt) : ((kt = this.media) === null || kt === void 0 ? void 0 : kt.buffered.length) === 0 && this.fragmentTracker.removeAllFragments()
                            }, xt.getAppendedFrag = function(Tt) {
                                var Ft = this.fragmentTracker.getAppendedFrag(Tt, Ct.PlaylistLevelType.MAIN);
                                return Ft && "fragment" in Ft ? Ft.fragment : Ft
                            }, xt.getBufferedFrag = function(Tt) {
                                return this.fragmentTracker.getBufferedFrag(Tt, Ct.PlaylistLevelType.MAIN)
                            }, xt.followingBufferedFrag = function(Tt) {
                                return Tt ? this.getBufferedFrag(Tt.end + .5) : null
                            }, xt.immediateLevelSwitch = function() {
                                this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
                            }, xt.nextLevelSwitch = function() {
                                var Tt = this.levels,
                                    Ft = this.media;
                                if (Ft != null && Ft.readyState) {
                                    var wt, kt = this.getAppendedFrag(Ft.currentTime);
                                    if (kt && kt.start > 1 && this.flushMainBuffer(0, kt.start - 1), !Ft.paused && Tt) {
                                        var Ot = this.hls.nextLoadLevel,
                                            Rt = Tt[Ot],
                                            Lt = this.fragLastKbps;
                                        Lt && this.fragCurrent ? wt = this.fragCurrent.duration * Rt.maxBitrate / (1e3 * Lt) + 1 : wt = 0
                                    } else wt = 0;
                                    var Bt = this.getBufferedFrag(Ft.currentTime + wt);
                                    if (Bt) {
                                        var Nt = this.followingBufferedFrag(Bt);
                                        if (Nt) {
                                            this.abortCurrentFrag();
                                            var $t = Nt.maxStartPTS ? Nt.maxStartPTS : Nt.start,
                                                jt = Nt.duration,
                                                Ut = Math.max(Bt.end, $t + Math.min(Math.max(jt - this.config.maxFragLookUpTolerance, jt * .5), jt * .75));
                                            this.flushMainBuffer(Ut, Number.POSITIVE_INFINITY)
                                        }
                                    }
                                }
                            }, xt.abortCurrentFrag = function() {
                                var Tt = this.fragCurrent;
                                switch (this.fragCurrent = null, this.backtrackFragment = null, Tt != null && Tt.loader && Tt.loader.abort(), this.state) {
                                    case lt.State.KEY_LOADING:
                                    case lt.State.FRAG_LOADING:
                                    case lt.State.FRAG_LOADING_WAITING_RETRY:
                                    case lt.State.PARSING:
                                    case lt.State.PARSED:
                                        this.state = lt.State.IDLE;
                                        break
                                }
                                this.nextLoadPosition = this.getLoadPosition()
                            }, xt.flushMainBuffer = function(Tt, Ft) {
                                vt.prototype.flushMainBuffer.call(this, Tt, Ft, this.altAudio ? "video" : null)
                            }, xt.onMediaAttached = function(Tt, Ft) {
                                vt.prototype.onMediaAttached.call(this, Tt, Ft);
                                var wt = Ft.media;
                                this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), wt.addEventListener("playing", this.onvplaying), wt.addEventListener("seeked", this.onvseeked), this.gapController = new Et.default(this.config, wt, this.fragmentTracker, this.hls)
                            }, xt.onMediaDetaching = function() {
                                var Tt = this.media;
                                Tt && this.onvplaying && this.onvseeked && (Tt.removeEventListener("playing", this.onvplaying), Tt.removeEventListener("seeked", this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), vt.prototype.onMediaDetaching.call(this)
                            }, xt.onMediaPlaying = function() {
                                this.tick()
                            }, xt.onMediaSeeked = function() {
                                var Tt = this.media,
                                    Ft = Tt ? Tt.currentTime : null;
                                (0, ut.isFiniteNumber)(Ft) && this.log("Media seeked to " + Ft.toFixed(3)), this.tick()
                            }, xt.onManifestLoading = function() {
                                this.log("Trigger BUFFER_RESET"), this.hls.trigger(pt.Events.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = !1, this.startPosition = this.lastCurrentTime = 0, this.fragPlaying = null, this.backtrackFragment = null
                            }, xt.onManifestParsed = function(Tt, Ft) {
                                var wt = !1,
                                    kt = !1,
                                    Ot;
                                Ft.levels.forEach(function(Rt) {
                                    Ot = Rt.audioCodec, Ot && (Ot.indexOf("mp4a.40.2") !== -1 && (wt = !0), Ot.indexOf("mp4a.40.5") !== -1 && (kt = !0))
                                }), this.audioCodecSwitch = wt && kt && !(0, bt.changeTypeSupported)(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = Ft.levels, this.startFragRequested = !1
                            }, xt.onLevelLoading = function(Tt, Ft) {
                                var wt = this.levels;
                                if (!(!wt || this.state !== lt.State.IDLE)) {
                                    var kt = wt[Ft.level];
                                    (!kt.details || kt.details.live && this.levelLastLoaded !== Ft.level || this.waitForCdnTuneIn(kt.details)) && (this.state = lt.State.WAITING_LEVEL)
                                }
                            }, xt.onLevelLoaded = function(Tt, Ft) {
                                var wt, kt = this.levels,
                                    Ot = Ft.level,
                                    Rt = Ft.details,
                                    Lt = Rt.totalduration;
                                if (!kt) {
                                    this.warn("Levels were reset while loading level " + Ot);
                                    return
                                }
                                this.log("Level " + Ot + " loaded [" + Rt.startSN + "," + Rt.endSN + "], cc [" + Rt.startCC + ", " + Rt.endCC + "] duration:" + Lt);
                                var Bt = this.fragCurrent;
                                Bt && (this.state === lt.State.FRAG_LOADING || this.state === lt.State.FRAG_LOADING_WAITING_RETRY) && Bt.level !== Ft.level && Bt.loader && (this.state = lt.State.IDLE, this.backtrackFragment = null, Bt.loader.abort());
                                var Nt = kt[Ot],
                                    $t = 0;
                                if (Rt.live || (wt = Nt.details) !== null && wt !== void 0 && wt.live) {
                                    if (Rt.fragments[0] || (Rt.deltaUpdateFailed = !0), Rt.deltaUpdateFailed) return;
                                    $t = this.alignPlaylists(Rt, Nt.details)
                                }
                                if (Nt.details = Rt, this.levelLastLoaded = Ot, this.hls.trigger(pt.Events.LEVEL_UPDATED, {
                                        details: Rt,
                                        level: Ot
                                    }), this.state === lt.State.WAITING_LEVEL) {
                                    if (this.waitForCdnTuneIn(Rt)) return;
                                    this.state = lt.State.IDLE
                                }
                                this.startFragRequested ? Rt.live && this.synchronizeToLiveEdge(Rt) : this.setStartPosition(Rt, $t), this.tick()
                            }, xt._handleFragmentLoadProgress = function(Tt) {
                                var Ft, wt = Tt.frag,
                                    kt = Tt.part,
                                    Ot = Tt.payload,
                                    Rt = this.levels;
                                if (!Rt) {
                                    this.warn("Levels were reset while fragment load was in progress. Fragment " + wt.sn + " of level " + wt.level + " will not be buffered");
                                    return
                                }
                                var Lt = Rt[wt.level],
                                    Bt = Lt.details;
                                if (!Bt) {
                                    this.warn("Dropping fragment " + wt.sn + " of level " + wt.level + " after level details were reset");
                                    return
                                }
                                var Nt = Lt.videoCodec,
                                    $t = Bt.PTSKnown || !Bt.live,
                                    jt = (Ft = wt.initSegment) === null || Ft === void 0 ? void 0 : Ft.data,
                                    Ut = this._getAudioCodec(Lt),
                                    Ht = this.transmuxer = this.transmuxer || new ot.default(this.hls, Ct.PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)),
                                    Wt = kt ? kt.index : -1,
                                    Kt = Wt !== -1,
                                    Gt = new ct.ChunkMetadata(wt.level, wt.sn, wt.stats.chunkCount, Ot.byteLength, Wt, Kt),
                                    Vt = this.initPTS[wt.cc];
                                Ht.push(Ot, jt, Ut, Nt, wt, kt, Bt.totalduration, $t, Gt, Vt)
                            }, xt.onAudioTrackSwitching = function(Tt, Ft) {
                                var wt = this.altAudio,
                                    kt = !!Ft.url,
                                    Ot = Ft.id;
                                if (!kt) {
                                    if (this.mediaBuffer !== this.media) {
                                        this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
                                        var Rt = this.fragCurrent;
                                        Rt != null && Rt.loader && (this.log("Switching to main audio track, cancel main fragment load"), Rt.loader.abort()), this.resetTransmuxer(), this.resetLoadingState()
                                    } else this.audioOnly && this.resetTransmuxer();
                                    var Lt = this.hls;
                                    wt && Lt.trigger(pt.Events.BUFFER_FLUSHING, {
                                        startOffset: 0,
                                        endOffset: Number.POSITIVE_INFINITY,
                                        type: "audio"
                                    }), Lt.trigger(pt.Events.AUDIO_TRACK_SWITCHED, {
                                        id: Ot
                                    })
                                }
                            }, xt.onAudioTrackSwitched = function(Tt, Ft) {
                                var wt = Ft.id,
                                    kt = !!this.hls.audioTracks[wt].url;
                                if (kt) {
                                    var Ot = this.videoBuffer;
                                    Ot && this.mediaBuffer !== Ot && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = Ot)
                                }
                                this.altAudio = kt, this.tick()
                            }, xt.onBufferCreated = function(Tt, Ft) {
                                var wt = Ft.tracks,
                                    kt, Ot, Rt = !1;
                                for (var Lt in wt) {
                                    var Bt = wt[Lt];
                                    if (Bt.id === "main") {
                                        if (Ot = Lt, kt = Bt, Lt === "video") {
                                            var Nt = wt[Lt];
                                            Nt && (this.videoBuffer = Nt.buffer)
                                        }
                                    } else Rt = !0
                                }
                                Rt && kt ? (this.log("Alternate track found, use " + Ot + ".buffered to schedule main fragment loading"), this.mediaBuffer = kt.buffer) : this.mediaBuffer = this.media
                            }, xt.onFragBuffered = function(Tt, Ft) {
                                var wt = Ft.frag,
                                    kt = Ft.part;
                                if (!(wt && wt.type !== Ct.PlaylistLevelType.MAIN)) {
                                    if (this.fragContextChanged(wt)) {
                                        this.warn("Fragment " + wt.sn + (kt ? " p: " + kt.index : "") + " of level " + wt.level + " finished buffering, but was aborted. state: " + this.state), this.state === lt.State.PARSED && (this.state = lt.State.IDLE);
                                        return
                                    }
                                    var Ot = kt ? kt.stats : wt.stats;
                                    this.fragLastKbps = Math.round(8 * Ot.total / (Ot.buffering.end - Ot.loading.first)), wt.sn !== "initSegment" && (this.fragPrevious = wt), this.fragBufferedComplete(wt, kt)
                                }
                            }, xt.onError = function(Tt, Ft) {
                                switch (Ft.details) {
                                    case Dt.ErrorDetails.FRAG_LOAD_ERROR:
                                    case Dt.ErrorDetails.FRAG_LOAD_TIMEOUT:
                                    case Dt.ErrorDetails.KEY_LOAD_ERROR:
                                    case Dt.ErrorDetails.KEY_LOAD_TIMEOUT:
                                        this.onFragmentOrKeyLoadError(Ct.PlaylistLevelType.MAIN, Ft);
                                        break;
                                    case Dt.ErrorDetails.LEVEL_LOAD_ERROR:
                                    case Dt.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                                        this.state !== lt.State.ERROR && (Ft.fatal ? (this.warn("" + Ft.details), this.state = lt.State.ERROR) : !Ft.levelRetry && this.state === lt.State.WAITING_LEVEL && (this.state = lt.State.IDLE));
                                        break;
                                    case Dt.ErrorDetails.BUFFER_FULL_ERROR:
                                        if (Ft.parent === "main" && (this.state === lt.State.PARSING || this.state === lt.State.PARSED)) {
                                            var wt = !0,
                                                kt = this.getFwdBufferInfo(this.media, Ct.PlaylistLevelType.MAIN);
                                            kt && kt.len > .5 && (wt = !this.reduceMaxBufferLength(kt.len)), wt && (this.warn("buffer full error also media.currentTime is not buffered, flush main"), this.immediateLevelSwitch()), this.resetLoadingState()
                                        }
                                        break
                                }
                            }, xt.checkBuffer = function() {
                                var Tt = this.media,
                                    Ft = this.gapController;
                                if (!(!Tt || !Ft || !Tt.readyState)) {
                                    if (this.loadedmetadata || !It.BufferHelper.getBuffered(Tt).length) {
                                        var wt = this.state !== lt.State.IDLE ? this.fragCurrent : null;
                                        Ft.poll(this.lastCurrentTime, wt)
                                    }
                                    this.lastCurrentTime = Tt.currentTime
                                }
                            }, xt.onFragLoadEmergencyAborted = function() {
                                this.state = lt.State.IDLE, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tickImmediate()
                            }, xt.onBufferFlushed = function(Tt, Ft) {
                                var wt = Ft.type;
                                if (wt !== ht.ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {
                                    var kt = (wt === ht.ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
                                    this.afterBufferFlushed(kt, wt, Ct.PlaylistLevelType.MAIN)
                                }
                            }, xt.onLevelsUpdated = function(Tt, Ft) {
                                this.levels = Ft.levels
                            }, xt.swapAudioCodec = function() {
                                this.audioCodecSwap = !this.audioCodecSwap
                            }, xt.seekToStartPos = function() {
                                var Tt = this.media;
                                if (!!Tt) {
                                    var Ft = Tt.currentTime,
                                        wt = this.startPosition;
                                    if (wt >= 0 && Ft < wt) {
                                        if (Tt.seeking) {
                                            this.log("could not seek to " + wt + ", already seeking at " + Ft);
                                            return
                                        }
                                        var kt = It.BufferHelper.getBuffered(Tt),
                                            Ot = kt.length ? kt.start(0) : 0,
                                            Rt = Ot - wt;
                                        Rt > 0 && (Rt < this.config.maxBufferHole || Rt < this.config.maxFragLookUpTolerance) && (this.log("adjusting start position by " + Rt + " to match buffer start"), wt += Rt, this.startPosition = wt), this.log("seek to target start position " + wt + " from current time " + Ft), Tt.currentTime = wt
                                    }
                                }
                            }, xt._getAudioCodec = function(Tt) {
                                var Ft = this.config.defaultAudioCodec || Tt.audioCodec;
                                return this.audioCodecSwap && Ft && (this.log("Swapping audio codec"), Ft.indexOf("mp4a.40.5") !== -1 ? Ft = "mp4a.40.2" : Ft = "mp4a.40.5"), Ft
                            }, xt._loadBitrateTestFrag = function(Tt) {
                                var Ft = this;
                                Tt.bitrateTest = !0, this._doFragLoad(Tt).then(function(wt) {
                                    var kt = Ft.hls;
                                    if (!(!wt || kt.nextLoadLevel || Ft.fragContextChanged(Tt))) {
                                        Ft.fragLoadError = 0, Ft.state = lt.State.IDLE, Ft.startFragRequested = !1, Ft.bitrateTest = !1;
                                        var Ot = Tt.stats;
                                        Ot.parsing.start = Ot.parsing.end = Ot.buffering.start = Ot.buffering.end = self.performance.now(), kt.trigger(pt.Events.FRAG_LOADED, wt), Tt.bitrateTest = !1
                                    }
                                })
                            }, xt._handleTransmuxComplete = function(Tt) {
                                var Ft, wt = "main",
                                    kt = this.hls,
                                    Ot = Tt.remuxResult,
                                    Rt = Tt.chunkMeta,
                                    Lt = this.getCurrentContext(Rt);
                                if (!Lt) {
                                    this.warn("The loading context changed while buffering fragment " + Rt.sn + " of level " + Rt.level + ". This chunk will not be buffered."), this.resetStartWhenNotLoaded(Rt.level);
                                    return
                                }
                                var Bt = Lt.frag,
                                    Nt = Lt.part,
                                    $t = Lt.level,
                                    jt = Ot.video,
                                    Ut = Ot.text,
                                    Ht = Ot.id3,
                                    Wt = Ot.initSegment,
                                    Kt = $t.details,
                                    Gt = this.altAudio ? void 0 : Ot.audio;
                                if (!this.fragContextChanged(Bt)) {
                                    if (this.state = lt.State.PARSING, Wt) {
                                        Wt.tracks && (this._bufferInitSegment($t, Wt.tracks, Bt, Rt), kt.trigger(pt.Events.FRAG_PARSING_INIT_SEGMENT, {
                                            frag: Bt,
                                            id: wt,
                                            tracks: Wt.tracks
                                        }));
                                        var Vt = Wt.initPTS,
                                            zt = Wt.timescale;
                                        (0, ut.isFiniteNumber)(Vt) && (this.initPTS[Bt.cc] = Vt, kt.trigger(pt.Events.INIT_PTS_FOUND, {
                                            frag: Bt,
                                            id: wt,
                                            initPTS: Vt,
                                            timescale: zt
                                        }))
                                    }
                                    if (jt && Ot.independent !== !1) {
                                        if (Kt) {
                                            var Xt = jt.startPTS,
                                                Yt = jt.endPTS,
                                                Zt = jt.startDTS,
                                                qt = jt.endDTS;
                                            if (Nt) Nt.elementaryStreams[jt.type] = {
                                                startPTS: Xt,
                                                endPTS: Yt,
                                                startDTS: Zt,
                                                endDTS: qt
                                            };
                                            else if (jt.firstKeyFrame && jt.independent && (this.couldBacktrack = !0), jt.dropped && jt.independent) {
                                                var er = this.getMainFwdBufferInfo(),
                                                    tr = (er ? er.end : this.getLoadPosition()) + this.config.maxBufferHole,
                                                    Qt = jt.firstKeyFramePTS ? jt.firstKeyFramePTS : Xt;
                                                if (tr < Qt - this.config.maxBufferHole) {
                                                    this.backtrack(Bt);
                                                    return
                                                }
                                                Bt.setElementaryStreamInfo(jt.type, Bt.start, Yt, Bt.start, qt, !0)
                                            }
                                            Bt.setElementaryStreamInfo(jt.type, Xt, Yt, Zt, qt), this.backtrackFragment && (this.backtrackFragment = Bt), this.bufferFragmentData(jt, Bt, Nt, Rt)
                                        }
                                    } else if (Ot.independent === !1) {
                                        this.backtrack(Bt);
                                        return
                                    }
                                    if (Gt) {
                                        var Jt = Gt.startPTS,
                                            nr = Gt.endPTS,
                                            rr = Gt.startDTS,
                                            ir = Gt.endDTS;
                                        Nt && (Nt.elementaryStreams[ht.ElementaryStreamTypes.AUDIO] = {
                                            startPTS: Jt,
                                            endPTS: nr,
                                            startDTS: rr,
                                            endDTS: ir
                                        }), Bt.setElementaryStreamInfo(ht.ElementaryStreamTypes.AUDIO, Jt, nr, rr, ir), this.bufferFragmentData(Gt, Bt, Nt, Rt)
                                    }
                                    if (Kt && Ht !== null && Ht !== void 0 && (Ft = Ht.samples) !== null && Ft !== void 0 && Ft.length) {
                                        var ur = {
                                            id: wt,
                                            frag: Bt,
                                            details: Kt,
                                            samples: Ht.samples
                                        };
                                        kt.trigger(pt.Events.FRAG_PARSING_METADATA, ur)
                                    }
                                    if (Kt && Ut) {
                                        var ar = {
                                            id: wt,
                                            frag: Bt,
                                            details: Kt,
                                            samples: Ut.samples
                                        };
                                        kt.trigger(pt.Events.FRAG_PARSING_USERDATA, ar)
                                    }
                                }
                            }, xt._bufferInitSegment = function(Tt, Ft, wt, kt) {
                                var Ot = this;
                                if (this.state === lt.State.PARSING) {
                                    this.audioOnly = !!Ft.audio && !Ft.video, this.altAudio && !this.audioOnly && delete Ft.audio;
                                    var Rt = Ft.audio,
                                        Lt = Ft.video,
                                        Bt = Ft.audiovideo;
                                    if (Rt) {
                                        var Nt = Tt.audioCodec,
                                            $t = navigator.userAgent.toLowerCase();
                                        this.audioCodecSwitch && (Nt && (Nt.indexOf("mp4a.40.5") !== -1 ? Nt = "mp4a.40.2" : Nt = "mp4a.40.5"), Rt.metadata.channelCount !== 1 && $t.indexOf("firefox") === -1 && (Nt = "mp4a.40.5")), $t.indexOf("android") !== -1 && Rt.container !== "audio/mpeg" && (Nt = "mp4a.40.2", this.log("Android: force audio codec to " + Nt)), Tt.audioCodec && Tt.audioCodec !== Nt && this.log('Swapping manifest audio codec "' + Tt.audioCodec + '" for "' + Nt + '"'), Rt.levelCodec = Nt, Rt.id = "main", this.log("Init audio buffer, container:" + Rt.container + ", codecs[selected/level/parsed]=[" + (Nt || "") + "/" + (Tt.audioCodec || "") + "/" + Rt.codec + "]")
                                    }
                                    Lt && (Lt.levelCodec = Tt.videoCodec, Lt.id = "main", this.log("Init video buffer, container:" + Lt.container + ", codecs[level/parsed]=[" + (Tt.videoCodec || "") + "/" + Lt.codec + "]")), Bt && this.log("Init audiovideo buffer, container:" + Bt.container + ", codecs[level/parsed]=[" + (Tt.attrs.CODECS || "") + "/" + Bt.codec + "]"), this.hls.trigger(pt.Events.BUFFER_CODECS, Ft), Object.keys(Ft).forEach(function(jt) {
                                        var Ut = Ft[jt],
                                            Ht = Ut.initSegment;
                                        Ht != null && Ht.byteLength && Ot.hls.trigger(pt.Events.BUFFER_APPENDING, {
                                            type: jt,
                                            data: Ht,
                                            frag: wt,
                                            part: null,
                                            chunkMeta: kt,
                                            parent: wt.type
                                        })
                                    }), this.tick()
                                }
                            }, xt.getMainFwdBufferInfo = function() {
                                return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, Ct.PlaylistLevelType.MAIN)
                            }, xt.backtrack = function(Tt) {
                                this.couldBacktrack = !0, this.backtrackFragment = Tt, this.resetTransmuxer(), this.flushBufferGap(Tt), this.fragmentTracker.removeFragment(Tt), this.fragPrevious = null, this.nextLoadPosition = Tt.start, this.state = lt.State.IDLE
                            }, xt.checkFragmentChanged = function() {
                                var Tt = this.media,
                                    Ft = null;
                                if (Tt && Tt.readyState > 1 && Tt.seeking === !1) {
                                    var wt = Tt.currentTime;
                                    if (It.BufferHelper.isBuffered(Tt, wt) ? Ft = this.getAppendedFrag(wt) : It.BufferHelper.isBuffered(Tt, wt + .1) && (Ft = this.getAppendedFrag(wt + .1)), Ft) {
                                        this.backtrackFragment = null;
                                        var kt = this.fragPlaying,
                                            Ot = Ft.level;
                                        (!kt || Ft.sn !== kt.sn || kt.level !== Ot || Ft.urlId !== kt.urlId) && (this.hls.trigger(pt.Events.FRAG_CHANGED, {
                                            frag: Ft
                                        }), (!kt || kt.level !== Ot) && this.hls.trigger(pt.Events.LEVEL_SWITCHED, {
                                            level: Ot
                                        }), this.fragPlaying = Ft)
                                    }
                                }
                            }, gt(mt, [{
                                key: "nextLevel",
                                get: function() {
                                    var Tt = this.nextBufferedFrag;
                                    return Tt ? Tt.level : -1
                                }
                            }, {
                                key: "currentFrag",
                                get: function() {
                                    var Tt = this.media;
                                    return Tt ? this.fragPlaying || this.getAppendedFrag(Tt.currentTime) : null
                                }
                            }, {
                                key: "currentProgramDateTime",
                                get: function() {
                                    var Tt = this.media;
                                    if (Tt) {
                                        var Ft = Tt.currentTime,
                                            wt = this.currentFrag;
                                        if (wt && (0, ut.isFiniteNumber)(Ft) && (0, ut.isFiniteNumber)(wt.programDateTime)) {
                                            var kt = wt.programDateTime + (Ft - wt.start) * 1e3;
                                            return new Date(kt)
                                        }
                                    }
                                    return null
                                }
                            }, {
                                key: "currentLevel",
                                get: function() {
                                    var Tt = this.currentFrag;
                                    return Tt ? Tt.level : -1
                                }
                            }, {
                                key: "nextBufferedFrag",
                                get: function() {
                                    var Tt = this.currentFrag;
                                    return Tt ? this.followingBufferedFrag(Tt) : null
                                }
                            }, {
                                key: "forceStartLoad",
                                get: function() {
                                    return this._forceStartLoad
                                }
                            }]), mt
                        }(lt.default)
                },
                "./src/controller/subtitle-stream-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        SubtitleStreamController: () => ft
                    });
                    var ut = it("./src/events.ts"),
                        lt = it("./src/utils/buffer-helper.ts"),
                        bt = it("./src/controller/fragment-finders.ts"),
                        pt = it("./src/utils/discontinuities.ts"),
                        It = it("./src/controller/level-helper.ts"),
                        At = it("./src/controller/fragment-tracker.ts"),
                        Ct = it("./src/controller/base-stream-controller.ts"),
                        ht = it("./src/types/loader.ts"),
                        ot = it("./src/types/level.ts");

                    function ct(St, _t) {
                        for (var vt = 0; vt < _t.length; vt++) {
                            var mt = _t[vt];
                            mt.enumerable = mt.enumerable || !1, mt.configurable = !0, "value" in mt && (mt.writable = !0), Object.defineProperty(St, mt.key, mt)
                        }
                    }

                    function Et(St, _t, vt) {
                        return _t && ct(St.prototype, _t), vt && ct(St, vt), Object.defineProperty(St, "prototype", {
                            writable: !1
                        }), St
                    }

                    function Dt(St, _t) {
                        St.prototype = Object.create(_t.prototype), St.prototype.constructor = St, Pt(St, _t)
                    }

                    function Pt(St, _t) {
                        return Pt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(mt, xt) {
                            return mt.__proto__ = xt, mt
                        }, Pt(St, _t)
                    }
                    var gt = 500,
                        ft = function(St) {
                            Dt(_t, St);

                            function _t(mt, xt) {
                                var yt;
                                return yt = St.call(this, mt, xt, "[subtitle-stream-controller]") || this, yt.levels = [], yt.currentTrackId = -1, yt.tracksBuffered = [], yt.mainDetails = null, yt._registerListeners(), yt
                            }
                            var vt = _t.prototype;
                            return vt.onHandlerDestroying = function() {
                                this._unregisterListeners(), this.mainDetails = null
                            }, vt._registerListeners = function() {
                                var xt = this.hls;
                                xt.on(ut.Events.MEDIA_ATTACHED, this.onMediaAttached, this), xt.on(ut.Events.MEDIA_DETACHING, this.onMediaDetaching, this), xt.on(ut.Events.MANIFEST_LOADING, this.onManifestLoading, this), xt.on(ut.Events.LEVEL_LOADED, this.onLevelLoaded, this), xt.on(ut.Events.ERROR, this.onError, this), xt.on(ut.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), xt.on(ut.Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), xt.on(ut.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), xt.on(ut.Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), xt.on(ut.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), xt.on(ut.Events.FRAG_BUFFERED, this.onFragBuffered, this)
                            }, vt._unregisterListeners = function() {
                                var xt = this.hls;
                                xt.off(ut.Events.MEDIA_ATTACHED, this.onMediaAttached, this), xt.off(ut.Events.MEDIA_DETACHING, this.onMediaDetaching, this), xt.off(ut.Events.MANIFEST_LOADING, this.onManifestLoading, this), xt.off(ut.Events.LEVEL_LOADED, this.onLevelLoaded, this), xt.off(ut.Events.ERROR, this.onError, this), xt.off(ut.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), xt.off(ut.Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), xt.off(ut.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), xt.off(ut.Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), xt.off(ut.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), xt.off(ut.Events.FRAG_BUFFERED, this.onFragBuffered, this)
                            }, vt.startLoad = function(xt) {
                                this.stopLoad(), this.state = Ct.State.IDLE, this.setInterval(gt), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = xt, this.tick()
                            }, vt.onManifestLoading = function() {
                                this.mainDetails = null, this.fragmentTracker.removeAllFragments()
                            }, vt.onLevelLoaded = function(xt, yt) {
                                this.mainDetails = yt.details
                            }, vt.onSubtitleFragProcessed = function(xt, yt) {
                                var Tt = yt.frag,
                                    Ft = yt.success;
                                if (this.fragPrevious = Tt, this.state = Ct.State.IDLE, !!Ft) {
                                    var wt = this.tracksBuffered[this.currentTrackId];
                                    if (!!wt) {
                                        for (var kt, Ot = Tt.start, Rt = 0; Rt < wt.length; Rt++)
                                            if (Ot >= wt[Rt].start && Ot <= wt[Rt].end) {
                                                kt = wt[Rt];
                                                break
                                            } var Lt = Tt.start + Tt.duration;
                                        kt ? kt.end = Lt : (kt = {
                                            start: Ot,
                                            end: Lt
                                        }, wt.push(kt)), this.fragmentTracker.fragBuffered(Tt)
                                    }
                                }
                            }, vt.onBufferFlushing = function(xt, yt) {
                                var Tt = yt.startOffset,
                                    Ft = yt.endOffset;
                                if (Tt === 0 && Ft !== Number.POSITIVE_INFINITY) {
                                    var wt = this.currentTrackId,
                                        kt = this.levels;
                                    if (!kt.length || !kt[wt] || !kt[wt].details) return;
                                    var Ot = kt[wt].details,
                                        Rt = Ot.targetduration,
                                        Lt = Ft - Rt;
                                    if (Lt <= 0) return;
                                    yt.endOffsetSubtitles = Math.max(0, Lt), this.tracksBuffered.forEach(function(Bt) {
                                        for (var Nt = 0; Nt < Bt.length;) {
                                            if (Bt[Nt].end <= Lt) {
                                                Bt.shift();
                                                continue
                                            } else if (Bt[Nt].start < Lt) Bt[Nt].start = Lt;
                                            else break;
                                            Nt++
                                        }
                                    }), this.fragmentTracker.removeFragmentsInRange(Tt, Lt, ht.PlaylistLevelType.SUBTITLE)
                                }
                            }, vt.onFragBuffered = function(xt, yt) {
                                if (!this.loadedmetadata && yt.frag.type === ht.PlaylistLevelType.MAIN) {
                                    var Tt;
                                    (Tt = this.media) !== null && Tt !== void 0 && Tt.buffered.length && (this.loadedmetadata = !0)
                                }
                            }, vt.onError = function(xt, yt) {
                                var Tt, Ft = yt.frag;
                                !Ft || Ft.type !== ht.PlaylistLevelType.SUBTITLE || ((Tt = this.fragCurrent) !== null && Tt !== void 0 && Tt.loader && this.fragCurrent.loader.abort(), this.state = Ct.State.IDLE)
                            }, vt.onSubtitleTracksUpdated = function(xt, yt) {
                                var Tt = this,
                                    Ft = yt.subtitleTracks;
                                this.tracksBuffered = [], this.levels = Ft.map(function(wt) {
                                    return new ot.Level(wt)
                                }), this.fragmentTracker.removeAllFragments(), this.fragPrevious = null, this.levels.forEach(function(wt) {
                                    Tt.tracksBuffered[wt.id] = []
                                }), this.mediaBuffer = null
                            }, vt.onSubtitleTrackSwitch = function(xt, yt) {
                                if (this.currentTrackId = yt.id, !this.levels.length || this.currentTrackId === -1) {
                                    this.clearInterval();
                                    return
                                }
                                var Tt = this.levels[this.currentTrackId];
                                Tt != null && Tt.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, Tt && this.setInterval(gt)
                            }, vt.onSubtitleTrackLoaded = function(xt, yt) {
                                var Tt, Ft = yt.details,
                                    wt = yt.id,
                                    kt = this.currentTrackId,
                                    Ot = this.levels;
                                if (!!Ot.length) {
                                    var Rt = Ot[kt];
                                    if (!(wt >= Ot.length || wt !== kt || !Rt)) {
                                        this.mediaBuffer = this.mediaBufferTimeRanges;
                                        var Lt = 0;
                                        if (Ft.live || (Tt = Rt.details) !== null && Tt !== void 0 && Tt.live) {
                                            var Bt = this.mainDetails;
                                            if (Ft.deltaUpdateFailed || !Bt) return;
                                            var Nt = Bt.fragments[0];
                                            Rt.details ? (Lt = this.alignPlaylists(Ft, Rt.details), Lt === 0 && Nt && (Lt = Nt.start, (0, It.addSliding)(Ft, Lt))) : Ft.hasProgramDateTime && Bt.hasProgramDateTime ? ((0, pt.alignMediaPlaylistByPDT)(Ft, Bt), Lt = Ft.fragments[0].start) : Nt && (Lt = Nt.start, (0, It.addSliding)(Ft, Lt))
                                        }
                                        if (Rt.details = Ft, this.levelLastLoaded = wt, !this.startFragRequested && (this.mainDetails || !Ft.live) && this.setStartPosition(Rt.details, Lt), this.tick(), Ft.live && !this.fragCurrent && this.media && this.state === Ct.State.IDLE) {
                                            var $t = (0, bt.findFragmentByPTS)(null, Ft.fragments, this.media.currentTime, 0);
                                            $t || (this.warn("Subtitle playlist not aligned with playback"), Rt.details = void 0)
                                        }
                                    }
                                }
                            }, vt._handleFragmentLoadComplete = function(xt) {
                                var yt = xt.frag,
                                    Tt = xt.payload,
                                    Ft = yt.decryptdata,
                                    wt = this.hls;
                                if (!this.fragContextChanged(yt) && Tt && Tt.byteLength > 0 && Ft && Ft.key && Ft.iv && Ft.method === "AES-128") {
                                    var kt = performance.now();
                                    this.decrypter.webCryptoDecrypt(new Uint8Array(Tt), Ft.key.buffer, Ft.iv.buffer).then(function(Ot) {
                                        var Rt = performance.now();
                                        wt.trigger(ut.Events.FRAG_DECRYPTED, {
                                            frag: yt,
                                            payload: Ot,
                                            stats: {
                                                tstart: kt,
                                                tdecrypt: Rt
                                            }
                                        })
                                    })
                                }
                            }, vt.doTick = function() {
                                if (!this.media) {
                                    this.state = Ct.State.IDLE;
                                    return
                                }
                                if (this.state === Ct.State.IDLE) {
                                    var xt = this.currentTrackId,
                                        yt = this.levels;
                                    if (!yt.length || !yt[xt] || !yt[xt].details) return;
                                    var Tt = yt[xt].details,
                                        Ft = Tt.targetduration,
                                        wt = this.config,
                                        kt = this.getLoadPosition(),
                                        Ot = lt.BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], kt - Ft, wt.maxBufferHole),
                                        Rt = Ot.end,
                                        Lt = Ot.len,
                                        Bt = this.getFwdBufferInfo(this.media, ht.PlaylistLevelType.MAIN),
                                        Nt = this.getMaxBufferLength(Bt == null ? void 0 : Bt.len) + Ft;
                                    if (Lt > Nt) return;
                                    console.assert(Tt, "Subtitle track details are defined on idle subtitle stream controller tick");
                                    var $t = Tt.fragments,
                                        jt = $t.length,
                                        Ut = Tt.edge,
                                        Ht, Wt = this.fragPrevious;
                                    if (Rt < Ut) {
                                        var Kt = wt.maxFragLookUpTolerance;
                                        Ht = (0, bt.findFragmentByPTS)(Wt, $t, Math.max($t[0].start, Rt), Kt), !Ht && Wt && Wt.start < $t[0].start && (Ht = $t[0])
                                    } else Ht = $t[jt - 1];
                                    if (Ht = this.mapToInitFragWhenRequired(Ht), !Ht || this.fragmentTracker.getState(Ht) !== At.FragmentState.NOT_LOADED) return;
                                    Ht.encrypted ? this.loadKey(Ht, Tt) : this.loadFragment(Ht, Tt, Rt)
                                }
                            }, vt.getMaxBufferLength = function(xt) {
                                var yt = St.prototype.getMaxBufferLength.call(this);
                                return xt ? Math.max(yt, xt) : yt
                            }, vt.loadFragment = function(xt, yt, Tt) {
                                this.fragCurrent = xt, xt.sn === "initSegment" ? this._loadInitSegment(xt) : (this.startFragRequested = !0, St.prototype.loadFragment.call(this, xt, yt, Tt))
                            }, Et(_t, [{
                                key: "mediaBufferTimeRanges",
                                get: function() {
                                    return new dt(this.tracksBuffered[this.currentTrackId] || [])
                                }
                            }]), _t
                        }(Ct.default),
                        dt = function(_t) {
                            this.buffered = void 0;
                            var vt = function(xt, yt, Tt) {
                                if (yt = yt >>> 0, yt > Tt - 1) throw new DOMException("Failed to execute '" + xt + "' on 'TimeRanges': The index provided (" + yt + ") is greater than the maximum bound (" + Tt + ")");
                                return _t[yt][xt]
                            };
                            this.buffered = {
                                get length() {
                                    return _t.length
                                },
                                end: function(xt) {
                                    return vt("end", xt, _t.length)
                                },
                                start: function(xt) {
                                    return vt("start", xt, _t.length)
                                }
                            }
                        }
                },
                "./src/controller/subtitle-track-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => Et
                    });
                    var ut = it("./src/events.ts"),
                        lt = it("./src/utils/texttrack-utils.ts"),
                        bt = it("./src/controller/base-playlist-controller.ts"),
                        pt = it("./src/types/loader.ts");

                    function It(Dt, Pt) {
                        for (var gt = 0; gt < Pt.length; gt++) {
                            var ft = Pt[gt];
                            ft.enumerable = ft.enumerable || !1, ft.configurable = !0, "value" in ft && (ft.writable = !0), Object.defineProperty(Dt, ft.key, ft)
                        }
                    }

                    function At(Dt, Pt, gt) {
                        return Pt && It(Dt.prototype, Pt), gt && It(Dt, gt), Object.defineProperty(Dt, "prototype", {
                            writable: !1
                        }), Dt
                    }

                    function Ct(Dt, Pt) {
                        Dt.prototype = Object.create(Pt.prototype), Dt.prototype.constructor = Dt, ht(Dt, Pt)
                    }

                    function ht(Dt, Pt) {
                        return ht = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ft, dt) {
                            return ft.__proto__ = dt, ft
                        }, ht(Dt, Pt)
                    }
                    var ot = function(Dt) {
                        Ct(Pt, Dt);

                        function Pt(ft) {
                            var dt;
                            return dt = Dt.call(this, ft, "[subtitle-track-controller]") || this, dt.media = null, dt.tracks = [], dt.groupId = null, dt.tracksInGroup = [], dt.trackId = -1, dt.selectDefaultTrack = !0, dt.queuedDefaultTrack = -1, dt.trackChangeListener = function() {
                                return dt.onTextTracksChanged()
                            }, dt.asyncPollTrackChange = function() {
                                return dt.pollTrackChange(0)
                            }, dt.useTextTrackPolling = !1, dt.subtitlePollingInterval = -1, dt._subtitleDisplay = !0, dt.registerListeners(), dt
                        }
                        var gt = Pt.prototype;
                        return gt.destroy = function() {
                            this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.trackChangeListener = this.asyncPollTrackChange = null, Dt.prototype.destroy.call(this)
                        }, gt.registerListeners = function() {
                            var dt = this.hls;
                            dt.on(ut.Events.MEDIA_ATTACHED, this.onMediaAttached, this), dt.on(ut.Events.MEDIA_DETACHING, this.onMediaDetaching, this), dt.on(ut.Events.MANIFEST_LOADING, this.onManifestLoading, this), dt.on(ut.Events.MANIFEST_PARSED, this.onManifestParsed, this), dt.on(ut.Events.LEVEL_LOADING, this.onLevelLoading, this), dt.on(ut.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), dt.on(ut.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), dt.on(ut.Events.ERROR, this.onError, this)
                        }, gt.unregisterListeners = function() {
                            var dt = this.hls;
                            dt.off(ut.Events.MEDIA_ATTACHED, this.onMediaAttached, this), dt.off(ut.Events.MEDIA_DETACHING, this.onMediaDetaching, this), dt.off(ut.Events.MANIFEST_LOADING, this.onManifestLoading, this), dt.off(ut.Events.MANIFEST_PARSED, this.onManifestParsed, this), dt.off(ut.Events.LEVEL_LOADING, this.onLevelLoading, this), dt.off(ut.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), dt.off(ut.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), dt.off(ut.Events.ERROR, this.onError, this)
                        }, gt.onMediaAttached = function(dt, St) {
                            this.media = St.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange))
                        }, gt.pollTrackChange = function(dt) {
                            self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, dt)
                        }, gt.onMediaDetaching = function() {
                            if (!!this.media) {
                                self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId);
                                var dt = ct(this.media.textTracks);
                                dt.forEach(function(St) {
                                    (0, lt.clearCurrentCues)(St)
                                }), this.subtitleTrack = -1, this.media = null
                            }
                        }, gt.onManifestLoading = function() {
                            this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.selectDefaultTrack = !0
                        }, gt.onManifestParsed = function(dt, St) {
                            this.tracks = St.subtitleTracks
                        }, gt.onSubtitleTrackLoaded = function(dt, St) {
                            var _t = St.id,
                                vt = St.details,
                                mt = this.trackId,
                                xt = this.tracksInGroup[mt];
                            if (!xt) {
                                this.warn("Invalid subtitle track id " + _t);
                                return
                            }
                            var yt = xt.details;
                            xt.details = St.details, this.log("subtitle track " + _t + " loaded [" + vt.startSN + "-" + vt.endSN + "]"), _t === this.trackId && (this.retryCount = 0, this.playlistLoaded(_t, St, yt))
                        }, gt.onLevelLoading = function(dt, St) {
                            this.switchLevel(St.level)
                        }, gt.onLevelSwitching = function(dt, St) {
                            this.switchLevel(St.level)
                        }, gt.switchLevel = function(dt) {
                            var St = this.hls.levels[dt];
                            if (!!(St != null && St.textGroupIds)) {
                                var _t = St.textGroupIds[St.urlId];
                                if (this.groupId !== _t) {
                                    var vt = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0,
                                        mt = this.tracks.filter(function(Tt) {
                                            return !_t || Tt.groupId === _t
                                        });
                                    this.tracksInGroup = mt;
                                    var xt = this.findTrackId(vt == null ? void 0 : vt.name) || this.findTrackId();
                                    this.groupId = _t;
                                    var yt = {
                                        subtitleTracks: mt
                                    };
                                    this.log("Updating subtitle tracks, " + mt.length + ' track(s) found in "' + _t + '" group-id'), this.hls.trigger(ut.Events.SUBTITLE_TRACKS_UPDATED, yt), xt !== -1 && this.setSubtitleTrack(xt, vt)
                                }
                            }
                        }, gt.findTrackId = function(dt) {
                            for (var St = this.tracksInGroup, _t = 0; _t < St.length; _t++) {
                                var vt = St[_t];
                                if ((!this.selectDefaultTrack || vt.default) && (!dt || dt === vt.name)) return vt.id
                            }
                            return -1
                        }, gt.onError = function(dt, St) {
                            Dt.prototype.onError.call(this, dt, St), !(St.fatal || !St.context) && St.context.type === pt.PlaylistContextType.SUBTITLE_TRACK && St.context.id === this.trackId && St.context.groupId === this.groupId && this.retryLoadingOrFail(St)
                        }, gt.loadPlaylist = function(dt) {
                            var St = this.tracksInGroup[this.trackId];
                            if (this.shouldLoadTrack(St)) {
                                var _t = St.id,
                                    vt = St.groupId,
                                    mt = St.url;
                                if (dt) try {
                                    mt = dt.addDirectives(mt)
                                } catch (xt) {
                                    this.warn("Could not construct new URL with HLS Delivery Directives: " + xt)
                                }
                                this.log("Loading subtitle playlist for id " + _t), this.hls.trigger(ut.Events.SUBTITLE_TRACK_LOADING, {
                                    url: mt,
                                    id: _t,
                                    groupId: vt,
                                    deliveryDirectives: dt || null
                                })
                            }
                        }, gt.toggleTrackModes = function(dt) {
                            var St = this,
                                _t = this.media,
                                vt = this.trackId;
                            if (!!_t) {
                                var mt = ct(_t.textTracks),
                                    xt = mt.filter(function(Ft) {
                                        return Ft.groupId === St.groupId
                                    });
                                if (dt === -1)[].slice.call(mt).forEach(function(Ft) {
                                    Ft.mode = "disabled"
                                });
                                else {
                                    var yt = xt[vt];
                                    yt && (yt.mode = "disabled")
                                }
                                var Tt = xt[dt];
                                Tt && (Tt.mode = this.subtitleDisplay ? "showing" : "hidden")
                            }
                        }, gt.setSubtitleTrack = function(dt, St) {
                            var _t, vt = this.tracksInGroup;
                            if (!this.media) {
                                this.queuedDefaultTrack = dt;
                                return
                            }
                            if (this.trackId !== dt && this.toggleTrackModes(dt), !(this.trackId === dt && (dt === -1 || (_t = vt[dt]) !== null && _t !== void 0 && _t.details) || dt < -1 || dt >= vt.length)) {
                                this.clearTimer();
                                var mt = vt[dt];
                                if (this.log("Switching to subtitle track " + dt), this.trackId = dt, mt) {
                                    var xt = mt.id,
                                        yt = mt.groupId,
                                        Tt = yt === void 0 ? "" : yt,
                                        Ft = mt.name,
                                        wt = mt.type,
                                        kt = mt.url;
                                    this.hls.trigger(ut.Events.SUBTITLE_TRACK_SWITCH, {
                                        id: xt,
                                        groupId: Tt,
                                        name: Ft,
                                        type: wt,
                                        url: kt
                                    });
                                    var Ot = this.switchParams(mt.url, St == null ? void 0 : St.details);
                                    this.loadPlaylist(Ot)
                                } else this.hls.trigger(ut.Events.SUBTITLE_TRACK_SWITCH, {
                                    id: dt
                                })
                            }
                        }, gt.onTextTracksChanged = function() {
                            if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !(!this.media || !this.hls.config.renderTextTracksNatively)) {
                                for (var dt = -1, St = ct(this.media.textTracks), _t = 0; _t < St.length; _t++)
                                    if (St[_t].mode === "hidden") dt = _t;
                                    else if (St[_t].mode === "showing") {
                                    dt = _t;
                                    break
                                }
                                this.subtitleTrack !== dt && (this.subtitleTrack = dt)
                            }
                        }, At(Pt, [{
                            key: "subtitleDisplay",
                            get: function() {
                                return this._subtitleDisplay
                            },
                            set: function(dt) {
                                this._subtitleDisplay = dt, this.trackId > -1 && this.toggleTrackModes(this.trackId)
                            }
                        }, {
                            key: "subtitleTracks",
                            get: function() {
                                return this.tracksInGroup
                            }
                        }, {
                            key: "subtitleTrack",
                            get: function() {
                                return this.trackId
                            },
                            set: function(dt) {
                                this.selectDefaultTrack = !1;
                                var St = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
                                this.setSubtitleTrack(dt, St)
                            }
                        }]), Pt
                    }(bt.default);

                    function ct(Dt) {
                        for (var Pt = [], gt = 0; gt < Dt.length; gt++) {
                            var ft = Dt[gt];
                            ft.kind === "subtitles" && ft.label && Pt.push(Dt[gt])
                        }
                        return Pt
                    }
                    const Et = ot
                },
                "./src/controller/timeline-controller.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        TimelineController: () => Et
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/events.ts"),
                        bt = it("./src/utils/cea-608-parser.ts"),
                        pt = it("./src/utils/output-filter.ts"),
                        It = it("./src/utils/webvtt-parser.ts"),
                        At = it("./src/utils/texttrack-utils.ts"),
                        Ct = it("./src/utils/imsc1-ttml-parser.ts"),
                        ht = it("./src/utils/mp4-tools.ts"),
                        ot = it("./src/types/loader.ts"),
                        ct = it("./src/utils/logger.ts"),
                        Et = function() {
                            function ft(St) {
                                if (this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.timescale = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = gt(), this.captionsProperties = void 0, this.hls = St, this.config = St.config, this.Cues = St.config.cueHandler, this.captionsProperties = {
                                        textTrack1: {
                                            label: this.config.captionsTextTrack1Label,
                                            languageCode: this.config.captionsTextTrack1LanguageCode
                                        },
                                        textTrack2: {
                                            label: this.config.captionsTextTrack2Label,
                                            languageCode: this.config.captionsTextTrack2LanguageCode
                                        },
                                        textTrack3: {
                                            label: this.config.captionsTextTrack3Label,
                                            languageCode: this.config.captionsTextTrack3LanguageCode
                                        },
                                        textTrack4: {
                                            label: this.config.captionsTextTrack4Label,
                                            languageCode: this.config.captionsTextTrack4LanguageCode
                                        }
                                    }, this.config.enableCEA708Captions) {
                                    var _t = new pt.default(this, "textTrack1"),
                                        vt = new pt.default(this, "textTrack2"),
                                        mt = new pt.default(this, "textTrack3"),
                                        xt = new pt.default(this, "textTrack4");
                                    this.cea608Parser1 = new bt.default(1, _t, vt), this.cea608Parser2 = new bt.default(3, mt, xt)
                                }
                                St.on(lt.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), St.on(lt.Events.MEDIA_DETACHING, this.onMediaDetaching, this), St.on(lt.Events.MANIFEST_LOADING, this.onManifestLoading, this), St.on(lt.Events.MANIFEST_LOADED, this.onManifestLoaded, this), St.on(lt.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), St.on(lt.Events.FRAG_LOADING, this.onFragLoading, this), St.on(lt.Events.FRAG_LOADED, this.onFragLoaded, this), St.on(lt.Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), St.on(lt.Events.FRAG_DECRYPTED, this.onFragDecrypted, this), St.on(lt.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), St.on(lt.Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), St.on(lt.Events.BUFFER_FLUSHING, this.onBufferFlushing, this)
                            }
                            var dt = ft.prototype;
                            return dt.destroy = function() {
                                var _t = this.hls;
                                _t.off(lt.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), _t.off(lt.Events.MEDIA_DETACHING, this.onMediaDetaching, this), _t.off(lt.Events.MANIFEST_LOADING, this.onManifestLoading, this), _t.off(lt.Events.MANIFEST_LOADED, this.onManifestLoaded, this), _t.off(lt.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), _t.off(lt.Events.FRAG_LOADING, this.onFragLoading, this), _t.off(lt.Events.FRAG_LOADED, this.onFragLoaded, this), _t.off(lt.Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), _t.off(lt.Events.FRAG_DECRYPTED, this.onFragDecrypted, this), _t.off(lt.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), _t.off(lt.Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), _t.off(lt.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null
                            }, dt.addCues = function(_t, vt, mt, xt, yt) {
                                for (var Tt = !1, Ft = yt.length; Ft--;) {
                                    var wt = yt[Ft],
                                        kt = Pt(wt[0], wt[1], vt, mt);
                                    if (kt >= 0 && (wt[0] = Math.min(wt[0], vt), wt[1] = Math.max(wt[1], mt), Tt = !0, kt / (mt - vt) > .5)) return
                                }
                                if (Tt || yt.push([vt, mt]), this.config.renderTextTracksNatively) {
                                    var Ot = this.captionsTracks[_t];
                                    this.Cues.newCue(Ot, vt, mt, xt)
                                } else {
                                    var Rt = this.Cues.newCue(null, vt, mt, xt);
                                    this.hls.trigger(lt.Events.CUES_PARSED, {
                                        type: "captions",
                                        cues: Rt,
                                        track: _t
                                    })
                                }
                            }, dt.onInitPtsFound = function(_t, vt) {
                                var mt = this,
                                    xt = vt.frag,
                                    yt = vt.id,
                                    Tt = vt.initPTS,
                                    Ft = vt.timescale,
                                    wt = this.unparsedVttFrags;
                                yt === "main" && (this.initPTS[xt.cc] = Tt, this.timescale[xt.cc] = Ft), wt.length && (this.unparsedVttFrags = [], wt.forEach(function(kt) {
                                    mt.onFragLoaded(lt.Events.FRAG_LOADED, kt)
                                }))
                            }, dt.getExistingTrack = function(_t) {
                                var vt = this.media;
                                if (vt)
                                    for (var mt = 0; mt < vt.textTracks.length; mt++) {
                                        var xt = vt.textTracks[mt];
                                        if (xt[_t]) return xt
                                    }
                                return null
                            }, dt.createCaptionsTrack = function(_t) {
                                this.config.renderTextTracksNatively ? this.createNativeTrack(_t) : this.createNonNativeTrack(_t)
                            }, dt.createNativeTrack = function(_t) {
                                if (!this.captionsTracks[_t]) {
                                    var vt = this.captionsProperties,
                                        mt = this.captionsTracks,
                                        xt = this.media,
                                        yt = vt[_t],
                                        Tt = yt.label,
                                        Ft = yt.languageCode,
                                        wt = this.getExistingTrack(_t);
                                    if (wt) mt[_t] = wt, (0, At.clearCurrentCues)(mt[_t]), (0, At.sendAddTrackEvent)(mt[_t], xt);
                                    else {
                                        var kt = this.createTextTrack("captions", Tt, Ft);
                                        kt && (kt[_t] = !0, mt[_t] = kt)
                                    }
                                }
                            }, dt.createNonNativeTrack = function(_t) {
                                if (!this.nonNativeCaptionsTracks[_t]) {
                                    var vt = this.captionsProperties[_t];
                                    if (!!vt) {
                                        var mt = vt.label,
                                            xt = {
                                                _id: _t,
                                                label: mt,
                                                kind: "captions",
                                                default: vt.media ? !!vt.media.default : !1,
                                                closedCaptions: vt.media
                                            };
                                        this.nonNativeCaptionsTracks[_t] = xt, this.hls.trigger(lt.Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
                                            tracks: [xt]
                                        })
                                    }
                                }
                            }, dt.createTextTrack = function(_t, vt, mt) {
                                var xt = this.media;
                                if (!!xt) return xt.addTextTrack(_t, vt, mt)
                            }, dt.onMediaAttaching = function(_t, vt) {
                                this.media = vt.media, this._cleanTracks()
                            }, dt.onMediaDetaching = function() {
                                var _t = this.captionsTracks;
                                Object.keys(_t).forEach(function(vt) {
                                    (0, At.clearCurrentCues)(_t[vt]), delete _t[vt]
                                }), this.nonNativeCaptionsTracks = {}
                            }, dt.onManifestLoading = function() {
                                this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = gt(), this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = this.unparsedVttFrags || [], this.initPTS = [], this.timescale = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset())
                            }, dt._cleanTracks = function() {
                                var _t = this.media;
                                if (!!_t) {
                                    var vt = _t.textTracks;
                                    if (vt)
                                        for (var mt = 0; mt < vt.length; mt++)(0, At.clearCurrentCues)(vt[mt])
                                }
                            }, dt.onSubtitleTracksUpdated = function(_t, vt) {
                                var mt = this;
                                this.textTracks = [];
                                var xt = vt.subtitleTracks || [],
                                    yt = xt.some(function(kt) {
                                        return kt.textCodec === Ct.IMSC1_CODEC
                                    });
                                if (this.config.enableWebVTT || yt && this.config.enableIMSC1) {
                                    var Tt = this.tracks && xt && this.tracks.length === xt.length;
                                    if (this.tracks = xt || [], this.config.renderTextTracksNatively) {
                                        var Ft = this.media ? this.media.textTracks : [];
                                        this.tracks.forEach(function(kt, Ot) {
                                            var Rt;
                                            if (Ot < Ft.length) {
                                                for (var Lt = null, Bt = 0; Bt < Ft.length; Bt++)
                                                    if (Dt(Ft[Bt], kt)) {
                                                        Lt = Ft[Bt];
                                                        break
                                                    } Lt && (Rt = Lt)
                                            }
                                            if (Rt)(0, At.clearCurrentCues)(Rt);
                                            else {
                                                var Nt = mt._captionsOrSubtitlesFromCharacteristics(kt);
                                                Rt = mt.createTextTrack(Nt, kt.name, kt.lang), Rt && (Rt.mode = "disabled")
                                            }
                                            Rt && (Rt.groupId = kt.groupId, mt.textTracks.push(Rt))
                                        })
                                    } else if (!Tt && this.tracks && this.tracks.length) {
                                        var wt = this.tracks.map(function(kt) {
                                            return {
                                                label: kt.name,
                                                kind: kt.type.toLowerCase(),
                                                default: kt.default,
                                                subtitleTrack: kt
                                            }
                                        });
                                        this.hls.trigger(lt.Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
                                            tracks: wt
                                        })
                                    }
                                }
                            }, dt._captionsOrSubtitlesFromCharacteristics = function(_t) {
                                var vt;
                                if ((vt = _t.attrs) !== null && vt !== void 0 && vt.CHARACTERISTICS) {
                                    var mt = /transcribes-spoken-dialog/gi.test(_t.attrs.CHARACTERISTICS),
                                        xt = /describes-music-and-sound/gi.test(_t.attrs.CHARACTERISTICS);
                                    if (mt && xt) return "captions"
                                }
                                return "subtitles"
                            }, dt.onManifestLoaded = function(_t, vt) {
                                var mt = this;
                                this.config.enableCEA708Captions && vt.captions && vt.captions.forEach(function(xt) {
                                    var yt = /(?:CC|SERVICE)([1-4])/.exec(xt.instreamId);
                                    if (!!yt) {
                                        var Tt = "textTrack" + yt[1],
                                            Ft = mt.captionsProperties[Tt];
                                        !Ft || (Ft.label = xt.name, xt.lang && (Ft.languageCode = xt.lang), Ft.media = xt)
                                    }
                                })
                            }, dt.closedCaptionsForLevel = function(_t) {
                                var vt = this.hls.levels[_t.level];
                                return vt == null ? void 0 : vt.attrs["CLOSED-CAPTIONS"]
                            }, dt.onFragLoading = function(_t, vt) {
                                var mt = this.cea608Parser1,
                                    xt = this.cea608Parser2,
                                    yt = this.lastSn,
                                    Tt = this.lastPartIndex;
                                if (!(!this.enabled || !(mt && xt)) && vt.frag.type === ot.PlaylistLevelType.MAIN) {
                                    var Ft, wt, kt = vt.frag.sn,
                                        Ot = (Ft = vt == null || (wt = vt.part) === null || wt === void 0 ? void 0 : wt.index) != null ? Ft : -1;
                                    kt === yt + 1 || kt === yt && Ot === Tt + 1 || (mt.reset(), xt.reset()), this.lastSn = kt, this.lastPartIndex = Ot
                                }
                            }, dt.onFragLoaded = function(_t, vt) {
                                var mt = vt.frag,
                                    xt = vt.payload,
                                    yt = this.initPTS,
                                    Tt = this.unparsedVttFrags;
                                if (mt.type === ot.PlaylistLevelType.SUBTITLE)
                                    if (xt.byteLength) {
                                        if (!(0, ut.isFiniteNumber)(yt[mt.cc])) {
                                            Tt.push(vt), yt.length && this.hls.trigger(lt.Events.SUBTITLE_FRAG_PROCESSED, {
                                                success: !1,
                                                frag: mt,
                                                error: new Error("Missing initial subtitle PTS")
                                            });
                                            return
                                        }
                                        var Ft = mt.decryptdata,
                                            wt = "stats" in vt;
                                        if (Ft == null || Ft.key == null || Ft.method !== "AES-128" || wt) {
                                            var kt = this.tracks[mt.level],
                                                Ot = this.vttCCs;
                                            Ot[mt.cc] || (Ot[mt.cc] = {
                                                start: mt.start,
                                                prevCC: this.prevCC,
                                                new: !0
                                            }, this.prevCC = mt.cc), kt && kt.textCodec === Ct.IMSC1_CODEC ? this._parseIMSC1(mt, xt) : this._parseVTTs(mt, xt, Ot)
                                        }
                                    } else this.hls.trigger(lt.Events.SUBTITLE_FRAG_PROCESSED, {
                                        success: !1,
                                        frag: mt,
                                        error: new Error("Empty subtitle payload")
                                    })
                            }, dt._parseIMSC1 = function(_t, vt) {
                                var mt = this,
                                    xt = this.hls;
                                (0, Ct.parseIMSC1)(vt, this.initPTS[_t.cc], this.timescale[_t.cc], function(yt) {
                                    mt._appendCues(yt, _t.level), xt.trigger(lt.Events.SUBTITLE_FRAG_PROCESSED, {
                                        success: !0,
                                        frag: _t
                                    })
                                }, function(yt) {
                                    ct.logger.log("Failed to parse IMSC1: " + yt), xt.trigger(lt.Events.SUBTITLE_FRAG_PROCESSED, {
                                        success: !1,
                                        frag: _t,
                                        error: yt
                                    })
                                })
                            }, dt._parseVTTs = function(_t, vt, mt) {
                                var xt, yt = this,
                                    Tt = this.hls,
                                    Ft = (xt = _t.initSegment) !== null && xt !== void 0 && xt.data ? (0, ht.appendUint8Array)(_t.initSegment.data, new Uint8Array(vt)) : vt;
                                (0, It.parseWebVTT)(Ft, this.initPTS[_t.cc], this.timescale[_t.cc], mt, _t.cc, _t.start, function(wt) {
                                    yt._appendCues(wt, _t.level), Tt.trigger(lt.Events.SUBTITLE_FRAG_PROCESSED, {
                                        success: !0,
                                        frag: _t
                                    })
                                }, function(wt) {
                                    yt._fallbackToIMSC1(_t, vt), ct.logger.log("Failed to parse VTT cue: " + wt), Tt.trigger(lt.Events.SUBTITLE_FRAG_PROCESSED, {
                                        success: !1,
                                        frag: _t,
                                        error: wt
                                    })
                                })
                            }, dt._fallbackToIMSC1 = function(_t, vt) {
                                var mt = this,
                                    xt = this.tracks[_t.level];
                                xt.textCodec || (0, Ct.parseIMSC1)(vt, this.initPTS[_t.cc], this.timescale[_t.cc], function() {
                                    xt.textCodec = Ct.IMSC1_CODEC, mt._parseIMSC1(_t, vt)
                                }, function() {
                                    xt.textCodec = "wvtt"
                                })
                            }, dt._appendCues = function(_t, vt) {
                                var mt = this.hls;
                                if (this.config.renderTextTracksNatively) {
                                    var xt = this.textTracks[vt];
                                    if (!xt || xt.mode === "disabled") return;
                                    _t.forEach(function(Ft) {
                                        return (0, At.addCueToTrack)(xt, Ft)
                                    })
                                } else {
                                    var yt = this.tracks[vt];
                                    if (!yt) return;
                                    var Tt = yt.default ? "default" : "subtitles" + vt;
                                    mt.trigger(lt.Events.CUES_PARSED, {
                                        type: "subtitles",
                                        cues: _t,
                                        track: Tt
                                    })
                                }
                            }, dt.onFragDecrypted = function(_t, vt) {
                                var mt = vt.frag;
                                if (mt.type === ot.PlaylistLevelType.SUBTITLE) {
                                    if (!(0, ut.isFiniteNumber)(this.initPTS[mt.cc])) {
                                        this.unparsedVttFrags.push(vt);
                                        return
                                    }
                                    this.onFragLoaded(lt.Events.FRAG_LOADED, vt)
                                }
                            }, dt.onSubtitleTracksCleared = function() {
                                this.tracks = [], this.captionsTracks = {}
                            }, dt.onFragParsingUserdata = function(_t, vt) {
                                var mt = this.cea608Parser1,
                                    xt = this.cea608Parser2;
                                if (!(!this.enabled || !(mt && xt))) {
                                    var yt = vt.frag,
                                        Tt = vt.samples;
                                    if (!(yt.type === ot.PlaylistLevelType.MAIN && this.closedCaptionsForLevel(yt) === "NONE"))
                                        for (var Ft = 0; Ft < Tt.length; Ft++) {
                                            var wt = Tt[Ft].bytes;
                                            if (wt) {
                                                var kt = this.extractCea608Data(wt);
                                                mt.addData(Tt[Ft].pts, kt[0]), xt.addData(Tt[Ft].pts, kt[1])
                                            }
                                        }
                                }
                            }, dt.onBufferFlushing = function(_t, vt) {
                                var mt = vt.startOffset,
                                    xt = vt.endOffset,
                                    yt = vt.endOffsetSubtitles,
                                    Tt = vt.type,
                                    Ft = this.media;
                                if (!(!Ft || Ft.currentTime < xt)) {
                                    if (!Tt || Tt === "video") {
                                        var wt = this.captionsTracks;
                                        Object.keys(wt).forEach(function(Ot) {
                                            return (0, At.removeCuesInRange)(wt[Ot], mt, xt)
                                        })
                                    }
                                    if (this.config.renderTextTracksNatively && mt === 0 && yt !== void 0) {
                                        var kt = this.textTracks;
                                        Object.keys(kt).forEach(function(Ot) {
                                            return (0, At.removeCuesInRange)(kt[Ot], mt, yt)
                                        })
                                    }
                                }
                            }, dt.extractCea608Data = function(_t) {
                                for (var vt = [
                                        [],
                                        []
                                    ], mt = _t[0] & 31, xt = 2, yt = 0; yt < mt; yt++) {
                                    var Tt = _t[xt++],
                                        Ft = 127 & _t[xt++],
                                        wt = 127 & _t[xt++];
                                    if (!(Ft === 0 && wt === 0)) {
                                        var kt = (4 & Tt) !== 0;
                                        if (kt) {
                                            var Ot = 3 & Tt;
                                            (Ot === 0 || Ot === 1) && (vt[Ot].push(Ft), vt[Ot].push(wt))
                                        }
                                    }
                                }
                                return vt
                            }, ft
                        }();

                    function Dt(ft, dt) {
                        return ft && ft.label === dt.name && !(ft.textTrack1 || ft.textTrack2)
                    }

                    function Pt(ft, dt, St, _t) {
                        return Math.min(dt, _t) - Math.max(ft, St)
                    }

                    function gt() {
                        return {
                            ccOffset: 0,
                            presentationOffset: 0,
                            0: {
                                start: 0,
                                prevCC: -1,
                                new: !0
                            }
                        }
                    }
                },
                "./src/crypt/aes-crypto.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => ut
                    });
                    var ut = function() {
                        function lt(pt, It) {
                            this.subtle = void 0, this.aesIV = void 0, this.subtle = pt, this.aesIV = It
                        }
                        var bt = lt.prototype;
                        return bt.decrypt = function(It, At) {
                            return this.subtle.decrypt({
                                name: "AES-CBC",
                                iv: this.aesIV
                            }, At, It)
                        }, lt
                    }()
                },
                "./src/crypt/aes-decryptor.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => bt,
                        removePadding: () => lt
                    });
                    var ut = it("./src/utils/typed-array.ts");

                    function lt(pt) {
                        var It = pt.byteLength,
                            At = It && new DataView(pt.buffer).getUint8(It - 1);
                        return At ? (0, ut.sliceUint8)(pt, 0, It - At) : pt
                    }
                    var bt = function() {
                        function pt() {
                            this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable()
                        }
                        var It = pt.prototype;
                        return It.uint8ArrayToUint32Array_ = function(Ct) {
                            for (var ht = new DataView(Ct), ot = new Uint32Array(4), ct = 0; ct < 4; ct++) ot[ct] = ht.getUint32(ct * 4);
                            return ot
                        }, It.initTable = function() {
                            var Ct = this.sBox,
                                ht = this.invSBox,
                                ot = this.subMix,
                                ct = ot[0],
                                Et = ot[1],
                                Dt = ot[2],
                                Pt = ot[3],
                                gt = this.invSubMix,
                                ft = gt[0],
                                dt = gt[1],
                                St = gt[2],
                                _t = gt[3],
                                vt = new Uint32Array(256),
                                mt = 0,
                                xt = 0,
                                yt = 0;
                            for (yt = 0; yt < 256; yt++) yt < 128 ? vt[yt] = yt << 1 : vt[yt] = yt << 1 ^ 283;
                            for (yt = 0; yt < 256; yt++) {
                                var Tt = xt ^ xt << 1 ^ xt << 2 ^ xt << 3 ^ xt << 4;
                                Tt = Tt >>> 8 ^ Tt & 255 ^ 99, Ct[mt] = Tt, ht[Tt] = mt;
                                var Ft = vt[mt],
                                    wt = vt[Ft],
                                    kt = vt[wt],
                                    Ot = vt[Tt] * 257 ^ Tt * 16843008;
                                ct[mt] = Ot << 24 | Ot >>> 8, Et[mt] = Ot << 16 | Ot >>> 16, Dt[mt] = Ot << 8 | Ot >>> 24, Pt[mt] = Ot, Ot = kt * 16843009 ^ wt * 65537 ^ Ft * 257 ^ mt * 16843008, ft[Tt] = Ot << 24 | Ot >>> 8, dt[Tt] = Ot << 16 | Ot >>> 16, St[Tt] = Ot << 8 | Ot >>> 24, _t[Tt] = Ot, mt ? (mt = Ft ^ vt[vt[vt[kt ^ Ft]]], xt ^= vt[vt[xt]]) : mt = xt = 1
                            }
                        }, It.expandKey = function(Ct) {
                            for (var ht = this.uint8ArrayToUint32Array_(Ct), ot = !0, ct = 0; ct < ht.length && ot;) ot = ht[ct] === this.key[ct], ct++;
                            if (!ot) {
                                this.key = ht;
                                var Et = this.keySize = ht.length;
                                if (Et !== 4 && Et !== 6 && Et !== 8) throw new Error("Invalid aes key size=" + Et);
                                var Dt = this.ksRows = (Et + 6 + 1) * 4,
                                    Pt, gt, ft = this.keySchedule = new Uint32Array(Dt),
                                    dt = this.invKeySchedule = new Uint32Array(Dt),
                                    St = this.sBox,
                                    _t = this.rcon,
                                    vt = this.invSubMix,
                                    mt = vt[0],
                                    xt = vt[1],
                                    yt = vt[2],
                                    Tt = vt[3],
                                    Ft, wt;
                                for (Pt = 0; Pt < Dt; Pt++) {
                                    if (Pt < Et) {
                                        Ft = ft[Pt] = ht[Pt];
                                        continue
                                    }
                                    wt = Ft, Pt % Et === 0 ? (wt = wt << 8 | wt >>> 24, wt = St[wt >>> 24] << 24 | St[wt >>> 16 & 255] << 16 | St[wt >>> 8 & 255] << 8 | St[wt & 255], wt ^= _t[Pt / Et | 0] << 24) : Et > 6 && Pt % Et === 4 && (wt = St[wt >>> 24] << 24 | St[wt >>> 16 & 255] << 16 | St[wt >>> 8 & 255] << 8 | St[wt & 255]), ft[Pt] = Ft = (ft[Pt - Et] ^ wt) >>> 0
                                }
                                for (gt = 0; gt < Dt; gt++) Pt = Dt - gt, gt & 3 ? wt = ft[Pt] : wt = ft[Pt - 4], gt < 4 || Pt <= 4 ? dt[gt] = wt : dt[gt] = mt[St[wt >>> 24]] ^ xt[St[wt >>> 16 & 255]] ^ yt[St[wt >>> 8 & 255]] ^ Tt[St[wt & 255]], dt[gt] = dt[gt] >>> 0
                            }
                        }, It.networkToHostOrderSwap = function(Ct) {
                            return Ct << 24 | (Ct & 65280) << 8 | (Ct & 16711680) >> 8 | Ct >>> 24
                        }, It.decrypt = function(Ct, ht, ot) {
                            for (var ct = this.keySize + 6, Et = this.invKeySchedule, Dt = this.invSBox, Pt = this.invSubMix, gt = Pt[0], ft = Pt[1], dt = Pt[2], St = Pt[3], _t = this.uint8ArrayToUint32Array_(ot), vt = _t[0], mt = _t[1], xt = _t[2], yt = _t[3], Tt = new Int32Array(Ct), Ft = new Int32Array(Tt.length), wt, kt, Ot, Rt, Lt, Bt, Nt, $t, jt, Ut, Ht, Wt, Kt, Gt, Vt = this.networkToHostOrderSwap; ht < Tt.length;) {
                                for (jt = Vt(Tt[ht]), Ut = Vt(Tt[ht + 1]), Ht = Vt(Tt[ht + 2]), Wt = Vt(Tt[ht + 3]), Lt = jt ^ Et[0], Bt = Wt ^ Et[1], Nt = Ht ^ Et[2], $t = Ut ^ Et[3], Kt = 4, Gt = 1; Gt < ct; Gt++) wt = gt[Lt >>> 24] ^ ft[Bt >> 16 & 255] ^ dt[Nt >> 8 & 255] ^ St[$t & 255] ^ Et[Kt], kt = gt[Bt >>> 24] ^ ft[Nt >> 16 & 255] ^ dt[$t >> 8 & 255] ^ St[Lt & 255] ^ Et[Kt + 1], Ot = gt[Nt >>> 24] ^ ft[$t >> 16 & 255] ^ dt[Lt >> 8 & 255] ^ St[Bt & 255] ^ Et[Kt + 2], Rt = gt[$t >>> 24] ^ ft[Lt >> 16 & 255] ^ dt[Bt >> 8 & 255] ^ St[Nt & 255] ^ Et[Kt + 3], Lt = wt, Bt = kt, Nt = Ot, $t = Rt, Kt = Kt + 4;
                                wt = Dt[Lt >>> 24] << 24 ^ Dt[Bt >> 16 & 255] << 16 ^ Dt[Nt >> 8 & 255] << 8 ^ Dt[$t & 255] ^ Et[Kt], kt = Dt[Bt >>> 24] << 24 ^ Dt[Nt >> 16 & 255] << 16 ^ Dt[$t >> 8 & 255] << 8 ^ Dt[Lt & 255] ^ Et[Kt + 1], Ot = Dt[Nt >>> 24] << 24 ^ Dt[$t >> 16 & 255] << 16 ^ Dt[Lt >> 8 & 255] << 8 ^ Dt[Bt & 255] ^ Et[Kt + 2], Rt = Dt[$t >>> 24] << 24 ^ Dt[Lt >> 16 & 255] << 16 ^ Dt[Bt >> 8 & 255] << 8 ^ Dt[Nt & 255] ^ Et[Kt + 3], Ft[ht] = Vt(wt ^ vt), Ft[ht + 1] = Vt(Rt ^ mt), Ft[ht + 2] = Vt(Ot ^ xt), Ft[ht + 3] = Vt(kt ^ yt), vt = jt, mt = Ut, xt = Ht, yt = Wt, ht = ht + 4
                            }
                            return Ft.buffer
                        }, pt
                    }()
                },
                "./src/crypt/decrypter.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => ht
                    });
                    var ut = it("./src/crypt/aes-crypto.ts"),
                        lt = it("./src/crypt/fast-aes-key.ts"),
                        bt = it("./src/crypt/aes-decryptor.ts"),
                        pt = it("./src/utils/logger.ts"),
                        It = it("./src/utils/mp4-tools.ts"),
                        At = it("./src/utils/typed-array.ts"),
                        Ct = 16,
                        ht = function() {
                            function ot(Et, Dt, Pt) {
                                var gt = Pt === void 0 ? {} : Pt,
                                    ft = gt.removePKCS7Padding,
                                    dt = ft === void 0 ? !0 : ft;
                                if (this.logEnabled = !0, this.observer = void 0, this.config = void 0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.observer = Et, this.config = Dt, this.removePKCS7Padding = dt, dt) try {
                                    var St = self.crypto;
                                    St && (this.subtle = St.subtle || St.webkitSubtle)
                                } catch {}
                                this.subtle === null && (this.config.enableSoftwareAES = !0)
                            }
                            var ct = ot.prototype;
                            return ct.destroy = function() {
                                this.observer = null
                            }, ct.isSync = function() {
                                return this.config.enableSoftwareAES
                            }, ct.flush = function() {
                                var Dt = this.currentResult;
                                if (!Dt) {
                                    this.reset();
                                    return
                                }
                                var Pt = new Uint8Array(Dt);
                                return this.reset(), this.removePKCS7Padding ? (0, bt.removePadding)(Pt) : Pt
                            }, ct.reset = function() {
                                this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null)
                            }, ct.decrypt = function(Dt, Pt, gt, ft) {
                                if (this.config.enableSoftwareAES) {
                                    this.softwareDecrypt(new Uint8Array(Dt), Pt, gt);
                                    var dt = this.flush();
                                    dt && ft(dt.buffer)
                                } else this.webCryptoDecrypt(new Uint8Array(Dt), Pt, gt).then(ft)
                            }, ct.softwareDecrypt = function(Dt, Pt, gt) {
                                var ft = this.currentIV,
                                    dt = this.currentResult,
                                    St = this.remainderData;
                                this.logOnce("JS AES decrypt"), St && (Dt = (0, It.appendUint8Array)(St, Dt), this.remainderData = null);
                                var _t = this.getValidChunk(Dt);
                                if (!_t.length) return null;
                                ft && (gt = ft);
                                var vt = this.softwareDecrypter;
                                vt || (vt = this.softwareDecrypter = new bt.default), vt.expandKey(Pt);
                                var mt = dt;
                                return this.currentResult = vt.decrypt(_t.buffer, 0, gt), this.currentIV = (0, At.sliceUint8)(_t, -16).buffer, mt || null
                            }, ct.webCryptoDecrypt = function(Dt, Pt, gt) {
                                var ft = this,
                                    dt = this.subtle;
                                return (this.key !== Pt || !this.fastAesKey) && (this.key = Pt, this.fastAesKey = new lt.default(dt, Pt)), this.fastAesKey.expandKey().then(function(St) {
                                    if (!dt) return Promise.reject(new Error("web crypto not initialized"));
                                    var _t = new ut.default(dt, gt);
                                    return _t.decrypt(Dt.buffer, St)
                                }).catch(function(St) {
                                    return ft.onWebCryptoError(St, Dt, Pt, gt)
                                })
                            }, ct.onWebCryptoError = function(Dt, Pt, gt, ft) {
                                return pt.logger.warn("[decrypter.ts]: WebCrypto Error, disable WebCrypto API:", Dt), this.config.enableSoftwareAES = !0, this.logEnabled = !0, this.softwareDecrypt(Pt, gt, ft)
                            }, ct.getValidChunk = function(Dt) {
                                var Pt = Dt,
                                    gt = Dt.length - Dt.length % Ct;
                                return gt !== Dt.length && (Pt = (0, At.sliceUint8)(Dt, 0, gt), this.remainderData = (0, At.sliceUint8)(Dt, gt)), Pt
                            }, ct.logOnce = function(Dt) {
                                !this.logEnabled || (pt.logger.log("[decrypter.ts]: " + Dt), this.logEnabled = !1)
                            }, ot
                        }()
                },
                "./src/crypt/fast-aes-key.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => ut
                    });
                    var ut = function() {
                        function lt(pt, It) {
                            this.subtle = void 0, this.key = void 0, this.subtle = pt, this.key = It
                        }
                        var bt = lt.prototype;
                        return bt.expandKey = function() {
                            return this.subtle.importKey("raw", this.key, {
                                name: "AES-CBC"
                            }, !1, ["encrypt", "decrypt"])
                        }, lt
                    }()
                },
                "./src/demux/aacdemuxer.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => ht
                    });
                    var ut = it("./src/demux/base-audio-demuxer.ts"),
                        lt = it("./src/demux/adts.ts"),
                        bt = it("./src/utils/logger.ts"),
                        pt = it("./src/demux/id3.ts");

                    function It(ot, ct) {
                        ot.prototype = Object.create(ct.prototype), ot.prototype.constructor = ot, At(ot, ct)
                    }

                    function At(ot, ct) {
                        return At = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(Dt, Pt) {
                            return Dt.__proto__ = Pt, Dt
                        }, At(ot, ct)
                    }
                    var Ct = function(ot) {
                        It(ct, ot);

                        function ct(Dt, Pt) {
                            var gt;
                            return gt = ot.call(this) || this, gt.observer = void 0, gt.config = void 0, gt.observer = Dt, gt.config = Pt, gt
                        }
                        var Et = ct.prototype;
                        return Et.resetInitSegment = function(Pt, gt, ft, dt) {
                            ot.prototype.resetInitSegment.call(this, Pt, gt, ft, dt), this._audioTrack = {
                                container: "audio/adts",
                                type: "audio",
                                id: 2,
                                pid: -1,
                                sequenceNumber: 0,
                                segmentCodec: "aac",
                                samples: [],
                                manifestCodec: gt,
                                duration: dt,
                                inputTimeScale: 9e4,
                                dropped: 0
                            }
                        }, ct.probe = function(Pt) {
                            if (!Pt) return !1;
                            for (var gt = pt.getID3Data(Pt, 0) || [], ft = gt.length, dt = Pt.length; ft < dt; ft++)
                                if (lt.probe(Pt, ft)) return bt.logger.log("ADTS sync word found !"), !0;
                            return !1
                        }, Et.canParse = function(Pt, gt) {
                            return lt.canParse(Pt, gt)
                        }, Et.appendFrame = function(Pt, gt, ft) {
                            lt.initTrackConfig(Pt, this.observer, gt, ft, Pt.manifestCodec);
                            var dt = lt.appendFrame(Pt, gt, ft, this.basePTS, this.frameIndex);
                            if (dt && dt.missing === 0) return dt
                        }, ct
                    }(ut.default);
                    const ht = Ct
                },
                "./src/demux/adts.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        appendFrame: () => ft,
                        canGetFrameLength: () => ht,
                        canParse: () => ct,
                        getAudioConfig: () => pt,
                        getFrameDuration: () => Pt,
                        getFullFrameLength: () => Ct,
                        getHeaderLength: () => At,
                        initTrackConfig: () => Dt,
                        isHeader: () => ot,
                        isHeaderPattern: () => It,
                        parseFrameHeader: () => gt,
                        probe: () => Et
                    });
                    var ut = it("./src/utils/logger.ts"),
                        lt = it("./src/errors.ts"),
                        bt = it("./src/events.ts");

                    function pt(dt, St, _t, vt) {
                        var mt, xt, yt, Tt, Ft = navigator.userAgent.toLowerCase(),
                            wt = vt,
                            kt = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
                        mt = ((St[_t + 2] & 192) >>> 6) + 1;
                        var Ot = (St[_t + 2] & 60) >>> 2;
                        if (Ot > kt.length - 1) {
                            dt.trigger(bt.Events.ERROR, {
                                type: lt.ErrorTypes.MEDIA_ERROR,
                                details: lt.ErrorDetails.FRAG_PARSING_ERROR,
                                fatal: !0,
                                reason: "invalid ADTS sampling index:" + Ot
                            });
                            return
                        }
                        return yt = (St[_t + 2] & 1) << 2, yt |= (St[_t + 3] & 192) >>> 6, ut.logger.log("manifest codec:" + vt + ", ADTS type:" + mt + ", samplingIndex:" + Ot), /firefox/i.test(Ft) ? Ot >= 6 ? (mt = 5, Tt = new Array(4), xt = Ot - 3) : (mt = 2, Tt = new Array(2), xt = Ot) : Ft.indexOf("android") !== -1 ? (mt = 2, Tt = new Array(2), xt = Ot) : (mt = 5, Tt = new Array(4), vt && (vt.indexOf("mp4a.40.29") !== -1 || vt.indexOf("mp4a.40.5") !== -1) || !vt && Ot >= 6 ? xt = Ot - 3 : ((vt && vt.indexOf("mp4a.40.2") !== -1 && (Ot >= 6 && yt === 1 || /vivaldi/i.test(Ft)) || !vt && yt === 1) && (mt = 2, Tt = new Array(2)), xt = Ot)), Tt[0] = mt << 3, Tt[0] |= (Ot & 14) >> 1, Tt[1] |= (Ot & 1) << 7, Tt[1] |= yt << 3, mt === 5 && (Tt[1] |= (xt & 14) >> 1, Tt[2] = (xt & 1) << 7, Tt[2] |= 8, Tt[3] = 0), {
                            config: Tt,
                            samplerate: kt[Ot],
                            channelCount: yt,
                            codec: "mp4a.40." + mt,
                            manifestCodec: wt
                        }
                    }

                    function It(dt, St) {
                        return dt[St] === 255 && (dt[St + 1] & 246) === 240
                    }

                    function At(dt, St) {
                        return dt[St + 1] & 1 ? 7 : 9
                    }

                    function Ct(dt, St) {
                        return (dt[St + 3] & 3) << 11 | dt[St + 4] << 3 | (dt[St + 5] & 224) >>> 5
                    }

                    function ht(dt, St) {
                        return St + 5 < dt.length
                    }

                    function ot(dt, St) {
                        return St + 1 < dt.length && It(dt, St)
                    }

                    function ct(dt, St) {
                        return ht(dt, St) && It(dt, St) && Ct(dt, St) <= dt.length - St
                    }

                    function Et(dt, St) {
                        if (ot(dt, St)) {
                            var _t = At(dt, St);
                            if (St + _t >= dt.length) return !1;
                            var vt = Ct(dt, St);
                            if (vt <= _t) return !1;
                            var mt = St + vt;
                            return mt === dt.length || ot(dt, mt)
                        }
                        return !1
                    }

                    function Dt(dt, St, _t, vt, mt) {
                        if (!dt.samplerate) {
                            var xt = pt(St, _t, vt, mt);
                            if (!xt) return;
                            dt.config = xt.config, dt.samplerate = xt.samplerate, dt.channelCount = xt.channelCount, dt.codec = xt.codec, dt.manifestCodec = xt.manifestCodec, ut.logger.log("parsed codec:" + dt.codec + ", rate:" + xt.samplerate + ", channels:" + xt.channelCount)
                        }
                    }

                    function Pt(dt) {
                        return 9216e4 / dt
                    }

                    function gt(dt, St) {
                        var _t = At(dt, St);
                        if (St + _t <= dt.length) {
                            var vt = Ct(dt, St) - _t;
                            if (vt > 0) return {
                                headerLength: _t,
                                frameLength: vt
                            }
                        }
                    }

                    function ft(dt, St, _t, vt, mt) {
                        var xt = Pt(dt.samplerate),
                            yt = vt + mt * xt,
                            Tt = gt(St, _t),
                            Ft;
                        if (Tt) {
                            var wt = Tt.frameLength,
                                kt = Tt.headerLength,
                                Ot = kt + wt,
                                Rt = Math.max(0, _t + Ot - St.length);
                            Rt ? (Ft = new Uint8Array(Ot - kt), Ft.set(St.subarray(_t + kt, St.length), 0)) : Ft = St.subarray(_t + kt, _t + Ot);
                            var Lt = {
                                unit: Ft,
                                pts: yt
                            };
                            return Rt || dt.samples.push(Lt), {
                                sample: Lt,
                                length: Ot,
                                missing: Rt
                            }
                        }
                        var Bt = St.length - _t;
                        Ft = new Uint8Array(Bt), Ft.set(St.subarray(_t, St.length), 0);
                        var Nt = {
                            unit: Ft,
                            pts: yt
                        };
                        return {
                            sample: Nt,
                            length: Bt,
                            missing: -1
                        }
                    }
                },
                "./src/demux/base-audio-demuxer.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => ot,
                        initPTSFn: () => ht
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/demux/id3.ts"),
                        bt = it("./src/types/demuxer.ts"),
                        pt = it("./src/demux/dummy-demuxed-track.ts"),
                        It = it("./src/utils/mp4-tools.ts"),
                        At = it("./src/utils/typed-array.ts"),
                        Ct = function() {
                            function ct() {
                                this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null
                            }
                            var Et = ct.prototype;
                            return Et.resetInitSegment = function(Pt, gt, ft, dt) {
                                this._id3Track = {
                                    type: "id3",
                                    id: 3,
                                    pid: -1,
                                    inputTimeScale: 9e4,
                                    sequenceNumber: 0,
                                    samples: [],
                                    dropped: 0
                                }
                            }, Et.resetTimeStamp = function(Pt) {
                                this.initPTS = Pt, this.resetContiguity()
                            }, Et.resetContiguity = function() {
                                this.basePTS = null, this.lastPTS = null, this.frameIndex = 0
                            }, Et.canParse = function(Pt, gt) {
                                return !1
                            }, Et.appendFrame = function(Pt, gt, ft) {}, Et.demux = function(Pt, gt) {
                                this.cachedData && (Pt = (0, It.appendUint8Array)(this.cachedData, Pt), this.cachedData = null);
                                var ft = lt.getID3Data(Pt, 0),
                                    dt = ft ? ft.length : 0,
                                    St, _t = this._audioTrack,
                                    vt = this._id3Track,
                                    mt = ft ? lt.getTimeStamp(ft) : void 0,
                                    xt = Pt.length;
                                for ((this.basePTS === null || this.frameIndex === 0 && (0, ut.isFiniteNumber)(mt)) && (this.basePTS = ht(mt, gt, this.initPTS), this.lastPTS = this.basePTS), this.lastPTS === null && (this.lastPTS = this.basePTS), ft && ft.length > 0 && vt.samples.push({
                                        pts: this.lastPTS,
                                        dts: this.lastPTS,
                                        data: ft,
                                        type: bt.MetadataSchema.audioId3,
                                        duration: Number.POSITIVE_INFINITY
                                    }); dt < xt;) {
                                    if (this.canParse(Pt, dt)) {
                                        var yt = this.appendFrame(_t, Pt, dt);
                                        yt ? (this.frameIndex++, this.lastPTS = yt.sample.pts, dt += yt.length, St = dt) : dt = xt
                                    } else lt.canParse(Pt, dt) ? (ft = lt.getID3Data(Pt, dt), vt.samples.push({
                                        pts: this.lastPTS,
                                        dts: this.lastPTS,
                                        data: ft,
                                        type: bt.MetadataSchema.audioId3,
                                        duration: Number.POSITIVE_INFINITY
                                    }), dt += ft.length, St = dt) : dt++;
                                    if (dt === xt && St !== xt) {
                                        var Tt = (0, At.sliceUint8)(Pt, St);
                                        this.cachedData ? this.cachedData = (0, It.appendUint8Array)(this.cachedData, Tt) : this.cachedData = Tt
                                    }
                                }
                                return {
                                    audioTrack: _t,
                                    videoTrack: (0, pt.dummyTrack)(),
                                    id3Track: vt,
                                    textTrack: (0, pt.dummyTrack)()
                                }
                            }, Et.demuxSampleAes = function(Pt, gt, ft) {
                                return Promise.reject(new Error("[" + this + "] This demuxer does not support Sample-AES decryption"))
                            }, Et.flush = function(Pt) {
                                var gt = this.cachedData;
                                return gt && (this.cachedData = null, this.demux(gt, 0)), {
                                    audioTrack: this._audioTrack,
                                    videoTrack: (0, pt.dummyTrack)(),
                                    id3Track: this._id3Track,
                                    textTrack: (0, pt.dummyTrack)()
                                }
                            }, Et.destroy = function() {}, ct
                        }(),
                        ht = function(Et, Dt, Pt) {
                            return (0, ut.isFiniteNumber)(Et) ? Et * 90 : Dt * 9e4 + (Pt || 0)
                        };
                    const ot = Ct
                },
                "./src/demux/chunk-cache.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => ut
                    });
                    var ut = function() {
                        function bt() {
                            this.chunks = [], this.dataLength = 0
                        }
                        var pt = bt.prototype;
                        return pt.push = function(At) {
                            this.chunks.push(At), this.dataLength += At.length
                        }, pt.flush = function() {
                            var At = this.chunks,
                                Ct = this.dataLength,
                                ht;
                            if (At.length) At.length === 1 ? ht = At[0] : ht = lt(At, Ct);
                            else return new Uint8Array(0);
                            return this.reset(), ht
                        }, pt.reset = function() {
                            this.chunks.length = 0, this.dataLength = 0
                        }, bt
                    }();

                    function lt(bt, pt) {
                        for (var It = new Uint8Array(pt), At = 0, Ct = 0; Ct < bt.length; Ct++) {
                            var ht = bt[Ct];
                            It.set(ht, At), At += ht.length
                        }
                        return It
                    }
                },
                "./src/demux/dummy-demuxed-track.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        dummyTrack: () => ut
                    });

                    function ut(lt, bt) {
                        return lt === void 0 && (lt = ""), bt === void 0 && (bt = 9e4), {
                            type: lt,
                            id: -1,
                            pid: -1,
                            inputTimeScale: bt,
                            sequenceNumber: -1,
                            samples: [],
                            dropped: 0
                        }
                    }
                },
                "./src/demux/exp-golomb.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => bt
                    });
                    var ut = it("./src/utils/logger.ts"),
                        lt = function() {
                            function pt(At) {
                                this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = At, this.bytesAvailable = At.byteLength, this.word = 0, this.bitsAvailable = 0
                            }
                            var It = pt.prototype;
                            return It.loadWord = function() {
                                var Ct = this.data,
                                    ht = this.bytesAvailable,
                                    ot = Ct.byteLength - ht,
                                    ct = new Uint8Array(4),
                                    Et = Math.min(4, ht);
                                if (Et === 0) throw new Error("no bytes available");
                                ct.set(Ct.subarray(ot, ot + Et)), this.word = new DataView(ct.buffer).getUint32(0), this.bitsAvailable = Et * 8, this.bytesAvailable -= Et
                            }, It.skipBits = function(Ct) {
                                var ht;
                                this.bitsAvailable > Ct ? (this.word <<= Ct, this.bitsAvailable -= Ct) : (Ct -= this.bitsAvailable, ht = Ct >> 3, Ct -= ht >> 3, this.bytesAvailable -= ht, this.loadWord(), this.word <<= Ct, this.bitsAvailable -= Ct)
                            }, It.readBits = function(Ct) {
                                var ht = Math.min(this.bitsAvailable, Ct),
                                    ot = this.word >>> 32 - ht;
                                return Ct > 32 && ut.logger.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= ht, this.bitsAvailable > 0 ? this.word <<= ht : this.bytesAvailable > 0 && this.loadWord(), ht = Ct - ht, ht > 0 && this.bitsAvailable ? ot << ht | this.readBits(ht) : ot
                            }, It.skipLZ = function() {
                                var Ct;
                                for (Ct = 0; Ct < this.bitsAvailable; ++Ct)
                                    if (this.word & 2147483648 >>> Ct) return this.word <<= Ct, this.bitsAvailable -= Ct, Ct;
                                return this.loadWord(), Ct + this.skipLZ()
                            }, It.skipUEG = function() {
                                this.skipBits(1 + this.skipLZ())
                            }, It.skipEG = function() {
                                this.skipBits(1 + this.skipLZ())
                            }, It.readUEG = function() {
                                var Ct = this.skipLZ();
                                return this.readBits(Ct + 1) - 1
                            }, It.readEG = function() {
                                var Ct = this.readUEG();
                                return 1 & Ct ? 1 + Ct >>> 1 : -1 * (Ct >>> 1)
                            }, It.readBoolean = function() {
                                return this.readBits(1) === 1
                            }, It.readUByte = function() {
                                return this.readBits(8)
                            }, It.readUShort = function() {
                                return this.readBits(16)
                            }, It.readUInt = function() {
                                return this.readBits(32)
                            }, It.skipScalingList = function(Ct) {
                                for (var ht = 8, ot = 8, ct, Et = 0; Et < Ct; Et++) ot !== 0 && (ct = this.readEG(), ot = (ht + ct + 256) % 256), ht = ot === 0 ? ht : ot
                            }, It.readSPS = function() {
                                var Ct = 0,
                                    ht = 0,
                                    ot = 0,
                                    ct = 0,
                                    Et, Dt, Pt, gt = this.readUByte.bind(this),
                                    ft = this.readBits.bind(this),
                                    dt = this.readUEG.bind(this),
                                    St = this.readBoolean.bind(this),
                                    _t = this.skipBits.bind(this),
                                    vt = this.skipEG.bind(this),
                                    mt = this.skipUEG.bind(this),
                                    xt = this.skipScalingList.bind(this);
                                gt();
                                var yt = gt();
                                if (ft(5), _t(3), gt(), mt(), yt === 100 || yt === 110 || yt === 122 || yt === 244 || yt === 44 || yt === 83 || yt === 86 || yt === 118 || yt === 128) {
                                    var Tt = dt();
                                    if (Tt === 3 && _t(1), mt(), mt(), _t(1), St())
                                        for (Dt = Tt !== 3 ? 8 : 12, Pt = 0; Pt < Dt; Pt++) St() && (Pt < 6 ? xt(16) : xt(64))
                                }
                                mt();
                                var Ft = dt();
                                if (Ft === 0) dt();
                                else if (Ft === 1)
                                    for (_t(1), vt(), vt(), Et = dt(), Pt = 0; Pt < Et; Pt++) vt();
                                mt(), _t(1);
                                var wt = dt(),
                                    kt = dt(),
                                    Ot = ft(1);
                                Ot === 0 && _t(1), _t(1), St() && (Ct = dt(), ht = dt(), ot = dt(), ct = dt());
                                var Rt = [1, 1];
                                if (St() && St()) {
                                    var Lt = gt();
                                    switch (Lt) {
                                        case 1:
                                            Rt = [1, 1];
                                            break;
                                        case 2:
                                            Rt = [12, 11];
                                            break;
                                        case 3:
                                            Rt = [10, 11];
                                            break;
                                        case 4:
                                            Rt = [16, 11];
                                            break;
                                        case 5:
                                            Rt = [40, 33];
                                            break;
                                        case 6:
                                            Rt = [24, 11];
                                            break;
                                        case 7:
                                            Rt = [20, 11];
                                            break;
                                        case 8:
                                            Rt = [32, 11];
                                            break;
                                        case 9:
                                            Rt = [80, 33];
                                            break;
                                        case 10:
                                            Rt = [18, 11];
                                            break;
                                        case 11:
                                            Rt = [15, 11];
                                            break;
                                        case 12:
                                            Rt = [64, 33];
                                            break;
                                        case 13:
                                            Rt = [160, 99];
                                            break;
                                        case 14:
                                            Rt = [4, 3];
                                            break;
                                        case 15:
                                            Rt = [3, 2];
                                            break;
                                        case 16:
                                            Rt = [2, 1];
                                            break;
                                        case 255: {
                                            Rt = [gt() << 8 | gt(), gt() << 8 | gt()];
                                            break
                                        }
                                    }
                                }
                                return {
                                    width: Math.ceil((wt + 1) * 16 - Ct * 2 - ht * 2),
                                    height: (2 - Ot) * (kt + 1) * 16 - (Ot ? 2 : 4) * (ot + ct),
                                    pixelRatio: Rt
                                }
                            }, It.readSliceType = function() {
                                return this.readUByte(), this.readUEG(), this.readUEG()
                            }, pt
                        }();
                    const bt = lt
                },
                "./src/demux/id3.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        canParse: () => It,
                        decodeFrame: () => ct,
                        getID3Data: () => bt,
                        getID3Frames: () => ot,
                        getTimeStamp: () => At,
                        isFooter: () => lt,
                        isHeader: () => ut,
                        isTimeStampFrame: () => Ct,
                        testables: () => dt,
                        utf8ArrayToStr: () => ft
                    });
                    var ut = function(mt, xt) {
                            return xt + 10 <= mt.length && mt[xt] === 73 && mt[xt + 1] === 68 && mt[xt + 2] === 51 && mt[xt + 3] < 255 && mt[xt + 4] < 255 && mt[xt + 6] < 128 && mt[xt + 7] < 128 && mt[xt + 8] < 128 && mt[xt + 9] < 128
                        },
                        lt = function(mt, xt) {
                            return xt + 10 <= mt.length && mt[xt] === 51 && mt[xt + 1] === 68 && mt[xt + 2] === 73 && mt[xt + 3] < 255 && mt[xt + 4] < 255 && mt[xt + 6] < 128 && mt[xt + 7] < 128 && mt[xt + 8] < 128 && mt[xt + 9] < 128
                        },
                        bt = function(mt, xt) {
                            for (var yt = xt, Tt = 0; ut(mt, xt);) {
                                Tt += 10;
                                var Ft = pt(mt, xt + 6);
                                Tt += Ft, lt(mt, xt + 10) && (Tt += 10), xt += Tt
                            }
                            if (Tt > 0) return mt.subarray(yt, yt + Tt)
                        },
                        pt = function(mt, xt) {
                            var yt = 0;
                            return yt = (mt[xt] & 127) << 21, yt |= (mt[xt + 1] & 127) << 14, yt |= (mt[xt + 2] & 127) << 7, yt |= mt[xt + 3] & 127, yt
                        },
                        It = function(mt, xt) {
                            return ut(mt, xt) && pt(mt, xt + 6) + 10 <= mt.length - xt
                        },
                        At = function(mt) {
                            for (var xt = ot(mt), yt = 0; yt < xt.length; yt++) {
                                var Tt = xt[yt];
                                if (Ct(Tt)) return gt(Tt)
                            }
                        },
                        Ct = function(mt) {
                            return mt && mt.key === "PRIV" && mt.info === "com.apple.streaming.transportStreamTimestamp"
                        },
                        ht = function(mt) {
                            var xt = String.fromCharCode(mt[0], mt[1], mt[2], mt[3]),
                                yt = pt(mt, 4),
                                Tt = 10;
                            return {
                                type: xt,
                                size: yt,
                                data: mt.subarray(Tt, Tt + yt)
                            }
                        },
                        ot = function(mt) {
                            for (var xt = 0, yt = []; ut(mt, xt);) {
                                var Tt = pt(mt, xt + 6);
                                xt += 10;
                                for (var Ft = xt + Tt; xt + 8 < Ft;) {
                                    var wt = ht(mt.subarray(xt)),
                                        kt = ct(wt);
                                    kt && yt.push(kt), xt += wt.size + 10
                                }
                                lt(mt, xt) && (xt += 10)
                            }
                            return yt
                        },
                        ct = function(mt) {
                            return mt.type === "PRIV" ? Et(mt) : mt.type[0] === "W" ? Pt(mt) : Dt(mt)
                        },
                        Et = function(mt) {
                            if (!(mt.size < 2)) {
                                var xt = ft(mt.data, !0),
                                    yt = new Uint8Array(mt.data.subarray(xt.length + 1));
                                return {
                                    key: mt.type,
                                    info: xt,
                                    data: yt.buffer
                                }
                            }
                        },
                        Dt = function(mt) {
                            if (!(mt.size < 2)) {
                                if (mt.type === "TXXX") {
                                    var xt = 1,
                                        yt = ft(mt.data.subarray(xt), !0);
                                    xt += yt.length + 1;
                                    var Tt = ft(mt.data.subarray(xt));
                                    return {
                                        key: mt.type,
                                        info: yt,
                                        data: Tt
                                    }
                                }
                                var Ft = ft(mt.data.subarray(1));
                                return {
                                    key: mt.type,
                                    data: Ft
                                }
                            }
                        },
                        Pt = function(mt) {
                            if (mt.type === "WXXX") {
                                if (mt.size < 2) return;
                                var xt = 1,
                                    yt = ft(mt.data.subarray(xt), !0);
                                xt += yt.length + 1;
                                var Tt = ft(mt.data.subarray(xt));
                                return {
                                    key: mt.type,
                                    info: yt,
                                    data: Tt
                                }
                            }
                            var Ft = ft(mt.data);
                            return {
                                key: mt.type,
                                data: Ft
                            }
                        },
                        gt = function(mt) {
                            if (mt.data.byteLength === 8) {
                                var xt = new Uint8Array(mt.data),
                                    yt = xt[3] & 1,
                                    Tt = (xt[4] << 23) + (xt[5] << 15) + (xt[6] << 7) + xt[7];
                                return Tt /= 45, yt && (Tt += 4772185884e-2), Math.round(Tt)
                            }
                        },
                        ft = function(mt, xt) {
                            xt === void 0 && (xt = !1);
                            var yt = _t();
                            if (yt) {
                                var Tt = yt.decode(mt);
                                if (xt) {
                                    var Ft = Tt.indexOf("\0");
                                    return Ft !== -1 ? Tt.substring(0, Ft) : Tt
                                }
                                return Tt.replace(/\0/g, "")
                            }
                            for (var wt = mt.length, kt, Ot, Rt, Lt = "", Bt = 0; Bt < wt;) {
                                if (kt = mt[Bt++], kt === 0 && xt) return Lt;
                                if (kt === 0 || kt === 3) continue;
                                switch (kt >> 4) {
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                    case 4:
                                    case 5:
                                    case 6:
                                    case 7:
                                        Lt += String.fromCharCode(kt);
                                        break;
                                    case 12:
                                    case 13:
                                        Ot = mt[Bt++], Lt += String.fromCharCode((kt & 31) << 6 | Ot & 63);
                                        break;
                                    case 14:
                                        Ot = mt[Bt++], Rt = mt[Bt++], Lt += String.fromCharCode((kt & 15) << 12 | (Ot & 63) << 6 | (Rt & 63) << 0);
                                        break
                                }
                            }
                            return Lt
                        },
                        dt = {
                            decodeTextFrame: Dt
                        },
                        St;

                    function _t() {
                        return !St && typeof self.TextDecoder < "u" && (St = new self.TextDecoder("utf-8")), St
                    }
                },
                "./src/demux/mp3demuxer.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => ht
                    });
                    var ut = it("./src/demux/base-audio-demuxer.ts"),
                        lt = it("./src/demux/id3.ts"),
                        bt = it("./src/utils/logger.ts"),
                        pt = it("./src/demux/mpegaudio.ts");

                    function It(ot, ct) {
                        ot.prototype = Object.create(ct.prototype), ot.prototype.constructor = ot, At(ot, ct)
                    }

                    function At(ot, ct) {
                        return At = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(Dt, Pt) {
                            return Dt.__proto__ = Pt, Dt
                        }, At(ot, ct)
                    }
                    var Ct = function(ot) {
                        It(ct, ot);

                        function ct() {
                            return ot.apply(this, arguments) || this
                        }
                        var Et = ct.prototype;
                        return Et.resetInitSegment = function(Pt, gt, ft, dt) {
                            ot.prototype.resetInitSegment.call(this, Pt, gt, ft, dt), this._audioTrack = {
                                container: "audio/mpeg",
                                type: "audio",
                                id: 2,
                                pid: -1,
                                sequenceNumber: 0,
                                segmentCodec: "mp3",
                                samples: [],
                                manifestCodec: gt,
                                duration: dt,
                                inputTimeScale: 9e4,
                                dropped: 0
                            }
                        }, ct.probe = function(Pt) {
                            if (!Pt) return !1;
                            for (var gt = lt.getID3Data(Pt, 0) || [], ft = gt.length, dt = Pt.length; ft < dt; ft++)
                                if (pt.probe(Pt, ft)) return bt.logger.log("MPEG Audio sync word found !"), !0;
                            return !1
                        }, Et.canParse = function(Pt, gt) {
                            return pt.canParse(Pt, gt)
                        }, Et.appendFrame = function(Pt, gt, ft) {
                            if (this.basePTS !== null) return pt.appendFrame(Pt, gt, ft, this.basePTS, this.frameIndex)
                        }, ct
                    }(ut.default);
                    const ht = Ct
                },
                "./src/demux/mp4demuxer.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => Ct
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/types/demuxer.ts"),
                        bt = it("./src/utils/mp4-tools.ts"),
                        pt = it("./src/demux/dummy-demuxed-track.ts"),
                        It = /\/emsg[-/]ID3/i,
                        At = function() {
                            function ht(ct, Et) {
                                this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = Et
                            }
                            var ot = ht.prototype;
                            return ot.resetTimeStamp = function() {}, ot.resetInitSegment = function(Et, Dt, Pt, gt) {
                                var ft = (0, bt.parseInitSegment)(Et),
                                    dt = this.videoTrack = (0, pt.dummyTrack)("video", 1),
                                    St = this.audioTrack = (0, pt.dummyTrack)("audio", 1),
                                    _t = this.txtTrack = (0, pt.dummyTrack)("text", 1);
                                if (this.id3Track = (0, pt.dummyTrack)("id3", 1), this.timeOffset = 0, ft.video) {
                                    var vt = ft.video,
                                        mt = vt.id,
                                        xt = vt.timescale,
                                        yt = vt.codec;
                                    dt.id = mt, dt.timescale = _t.timescale = xt, dt.codec = yt
                                }
                                if (ft.audio) {
                                    var Tt = ft.audio,
                                        Ft = Tt.id,
                                        wt = Tt.timescale,
                                        kt = Tt.codec;
                                    St.id = Ft, St.timescale = wt, St.codec = kt
                                }
                                _t.id = bt.RemuxerTrackIdConfig.text, dt.sampleDuration = 0, dt.duration = St.duration = gt
                            }, ot.resetContiguity = function() {}, ht.probe = function(Et) {
                                return Et = Et.length > 16384 ? Et.subarray(0, 16384) : Et, (0, bt.findBox)(Et, ["moof"]).length > 0
                            }, ot.demux = function(Et, Dt) {
                                this.timeOffset = Dt;
                                var Pt = Et,
                                    gt = this.videoTrack,
                                    ft = this.txtTrack;
                                if (this.config.progressive) {
                                    this.remainderData && (Pt = (0, bt.appendUint8Array)(this.remainderData, Et));
                                    var dt = (0, bt.segmentValidRange)(Pt);
                                    this.remainderData = dt.remainder, gt.samples = dt.valid || new Uint8Array
                                } else gt.samples = Pt;
                                var St = this.extractID3Track(gt, Dt);
                                return ft.samples = (0, bt.parseSamples)(Dt, gt), {
                                    videoTrack: gt,
                                    audioTrack: this.audioTrack,
                                    id3Track: St,
                                    textTrack: this.txtTrack
                                }
                            }, ot.flush = function() {
                                var Et = this.timeOffset,
                                    Dt = this.videoTrack,
                                    Pt = this.txtTrack;
                                Dt.samples = this.remainderData || new Uint8Array, this.remainderData = null;
                                var gt = this.extractID3Track(Dt, this.timeOffset);
                                return Pt.samples = (0, bt.parseSamples)(Et, Dt), {
                                    videoTrack: Dt,
                                    audioTrack: (0, pt.dummyTrack)(),
                                    id3Track: gt,
                                    textTrack: (0, pt.dummyTrack)()
                                }
                            }, ot.extractID3Track = function(Et, Dt) {
                                var Pt = this.id3Track;
                                if (Et.samples.length) {
                                    var gt = (0, bt.findBox)(Et.samples, ["emsg"]);
                                    gt && gt.forEach(function(ft) {
                                        var dt = (0, bt.parseEmsg)(ft);
                                        if (It.test(dt.schemeIdUri)) {
                                            var St = (0, ut.isFiniteNumber)(dt.presentationTime) ? dt.presentationTime / dt.timeScale : Dt + dt.presentationTimeDelta / dt.timeScale,
                                                _t = dt.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : dt.eventDuration / dt.timeScale;
                                            _t <= .001 && (_t = Number.POSITIVE_INFINITY);
                                            var vt = dt.payload;
                                            Pt.samples.push({
                                                data: vt,
                                                len: vt.byteLength,
                                                dts: St,
                                                pts: St,
                                                type: lt.MetadataSchema.emsg,
                                                duration: _t
                                            })
                                        }
                                    })
                                }
                                return Pt
                            }, ot.demuxSampleAes = function(Et, Dt, Pt) {
                                return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"))
                            }, ot.destroy = function() {}, ht
                        }();
                    const Ct = At
                },
                "./src/demux/mpegaudio.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        appendFrame: () => At,
                        canParse: () => ct,
                        isHeader: () => ot,
                        isHeaderPattern: () => ht,
                        parseHeader: () => Ct,
                        probe: () => Et
                    });
                    var ut = null,
                        lt = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
                        bt = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
                        pt = [
                            [0, 72, 144, 12],
                            [0, 0, 0, 0],
                            [0, 72, 144, 12],
                            [0, 144, 144, 12]
                        ],
                        It = [0, 1, 1, 4];

                    function At(Dt, Pt, gt, ft, dt) {
                        if (!(gt + 24 > Pt.length)) {
                            var St = Ct(Pt, gt);
                            if (St && gt + St.frameLength <= Pt.length) {
                                var _t = St.samplesPerFrame * 9e4 / St.sampleRate,
                                    vt = ft + dt * _t,
                                    mt = {
                                        unit: Pt.subarray(gt, gt + St.frameLength),
                                        pts: vt,
                                        dts: vt
                                    };
                                return Dt.config = [], Dt.channelCount = St.channelCount, Dt.samplerate = St.sampleRate, Dt.samples.push(mt), {
                                    sample: mt,
                                    length: St.frameLength,
                                    missing: 0
                                }
                            }
                        }
                    }

                    function Ct(Dt, Pt) {
                        var gt = Dt[Pt + 1] >> 3 & 3,
                            ft = Dt[Pt + 1] >> 1 & 3,
                            dt = Dt[Pt + 2] >> 4 & 15,
                            St = Dt[Pt + 2] >> 2 & 3;
                        if (gt !== 1 && dt !== 0 && dt !== 15 && St !== 3) {
                            var _t = Dt[Pt + 2] >> 1 & 1,
                                vt = Dt[Pt + 3] >> 6,
                                mt = gt === 3 ? 3 - ft : ft === 3 ? 3 : 4,
                                xt = lt[mt * 14 + dt - 1] * 1e3,
                                yt = gt === 3 ? 0 : gt === 2 ? 1 : 2,
                                Tt = bt[yt * 3 + St],
                                Ft = vt === 3 ? 1 : 2,
                                wt = pt[gt][ft],
                                kt = It[ft],
                                Ot = wt * 8 * kt,
                                Rt = Math.floor(wt * xt / Tt + _t) * kt;
                            if (ut === null) {
                                var Lt = navigator.userAgent || "",
                                    Bt = Lt.match(/Chrome\/(\d+)/i);
                                ut = Bt ? parseInt(Bt[1]) : 0
                            }
                            var Nt = !!ut && ut <= 87;
                            return Nt && ft === 2 && xt >= 224e3 && vt === 0 && (Dt[Pt + 3] = Dt[Pt + 3] | 128), {
                                sampleRate: Tt,
                                channelCount: Ft,
                                frameLength: Rt,
                                samplesPerFrame: Ot
                            }
                        }
                    }

                    function ht(Dt, Pt) {
                        return Dt[Pt] === 255 && (Dt[Pt + 1] & 224) === 224 && (Dt[Pt + 1] & 6) !== 0
                    }

                    function ot(Dt, Pt) {
                        return Pt + 1 < Dt.length && ht(Dt, Pt)
                    }

                    function ct(Dt, Pt) {
                        var gt = 4;
                        return ht(Dt, Pt) && gt <= Dt.length - Pt
                    }

                    function Et(Dt, Pt) {
                        if (Pt + 1 < Dt.length && ht(Dt, Pt)) {
                            var gt = 4,
                                ft = Ct(Dt, Pt),
                                dt = gt;
                            ft != null && ft.frameLength && (dt = ft.frameLength);
                            var St = Pt + dt;
                            return St === Dt.length || ot(Dt, St)
                        }
                        return !1
                    }
                },
                "./src/demux/sample-aes.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => pt
                    });
                    var ut = it("./src/crypt/decrypter.ts"),
                        lt = it("./src/utils/mp4-tools.ts"),
                        bt = function() {
                            function It(Ct, ht, ot) {
                                this.keyData = void 0, this.decrypter = void 0, this.keyData = ot, this.decrypter = new ut.default(Ct, ht, {
                                    removePKCS7Padding: !1
                                })
                            }
                            var At = It.prototype;
                            return At.decryptBuffer = function(ht, ot) {
                                this.decrypter.decrypt(ht, this.keyData.key.buffer, this.keyData.iv.buffer, ot)
                            }, At.decryptAacSample = function(ht, ot, ct, Et) {
                                var Dt = ht[ot].unit;
                                if (!(Dt.length <= 16)) {
                                    var Pt = Dt.subarray(16, Dt.length - Dt.length % 16),
                                        gt = Pt.buffer.slice(Pt.byteOffset, Pt.byteOffset + Pt.length),
                                        ft = this;
                                    this.decryptBuffer(gt, function(dt) {
                                        var St = new Uint8Array(dt);
                                        Dt.set(St, 16), Et || ft.decryptAacSamples(ht, ot + 1, ct)
                                    })
                                }
                            }, At.decryptAacSamples = function(ht, ot, ct) {
                                for (;; ot++) {
                                    if (ot >= ht.length) {
                                        ct();
                                        return
                                    }
                                    if (!(ht[ot].unit.length < 32)) {
                                        var Et = this.decrypter.isSync();
                                        if (this.decryptAacSample(ht, ot, ct, Et), !Et) return
                                    }
                                }
                            }, At.getAvcEncryptedData = function(ht) {
                                for (var ot = Math.floor((ht.length - 48) / 160) * 16 + 16, ct = new Int8Array(ot), Et = 0, Dt = 32; Dt < ht.length - 16; Dt += 160, Et += 16) ct.set(ht.subarray(Dt, Dt + 16), Et);
                                return ct
                            }, At.getAvcDecryptedUnit = function(ht, ot) {
                                for (var ct = new Uint8Array(ot), Et = 0, Dt = 32; Dt < ht.length - 16; Dt += 160, Et += 16) ht.set(ct.subarray(Et, Et + 16), Dt);
                                return ht
                            }, At.decryptAvcSample = function(ht, ot, ct, Et, Dt, Pt) {
                                var gt = (0, lt.discardEPB)(Dt.data),
                                    ft = this.getAvcEncryptedData(gt),
                                    dt = this;
                                this.decryptBuffer(ft.buffer, function(St) {
                                    Dt.data = dt.getAvcDecryptedUnit(gt, St), Pt || dt.decryptAvcSamples(ht, ot, ct + 1, Et)
                                })
                            }, At.decryptAvcSamples = function(ht, ot, ct, Et) {
                                if (ht instanceof Uint8Array) throw new Error("Cannot decrypt samples of type Uint8Array");
                                for (;; ot++, ct = 0) {
                                    if (ot >= ht.length) {
                                        Et();
                                        return
                                    }
                                    for (var Dt = ht[ot].units; !(ct >= Dt.length); ct++) {
                                        var Pt = Dt[ct];
                                        if (!(Pt.data.length <= 48 || Pt.type !== 1 && Pt.type !== 5)) {
                                            var gt = this.decrypter.isSync();
                                            if (this.decryptAvcSample(ht, ot, ct, Et, Pt, gt), !gt) return
                                        }
                                    }
                                }
                            }, It
                        }();
                    const pt = bt
                },
                "./src/demux/transmuxer-interface.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => ot
                    });
                    var ut = it("./src/demux/webworkify-webpack.js"),
                        lt = it("./src/events.ts"),
                        bt = it("./src/demux/transmuxer.ts"),
                        pt = it("./src/utils/logger.ts"),
                        It = it("./src/errors.ts"),
                        At = it("./src/utils/mediasource-helper.ts"),
                        Ct = it("./node_modules/eventemitter3/index.js"),
                        ht = (0, At.getMediaSource)() || {
                            isTypeSupported: function() {
                                return !1
                            }
                        },
                        ot = function() {
                            function ct(Dt, Pt, gt, ft) {
                                var dt = this;
                                this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.worker = void 0, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0;
                                var St = Dt.config;
                                this.hls = Dt, this.id = Pt, this.useWorker = !!St.enableWorker, this.onTransmuxComplete = gt, this.onFlush = ft;
                                var _t = function(Tt, Ft) {
                                    Ft = Ft || {}, Ft.frag = dt.frag, Ft.id = dt.id, dt.hls.trigger(Tt, Ft)
                                };
                                this.observer = new Ct.EventEmitter, this.observer.on(lt.Events.FRAG_DECRYPTED, _t), this.observer.on(lt.Events.ERROR, _t);
                                var vt = {
                                        mp4: ht.isTypeSupported("video/mp4"),
                                        mpeg: ht.isTypeSupported("audio/mpeg"),
                                        mp3: ht.isTypeSupported('audio/mp4; codecs="mp3"')
                                    },
                                    mt = navigator.vendor;
                                if (this.useWorker && typeof Worker < "u") {
                                    pt.logger.log("demuxing in webworker");
                                    var xt;
                                    try {
                                        xt = this.worker = (0, ut.default)("./src/demux/transmuxer-worker.ts"), this.onwmsg = this.onWorkerMessage.bind(this), xt.addEventListener("message", this.onwmsg), xt.onerror = function(yt) {
                                            dt.useWorker = !1, pt.logger.warn("Exception in webworker, fallback to inline"), dt.hls.trigger(lt.Events.ERROR, {
                                                type: It.ErrorTypes.OTHER_ERROR,
                                                details: It.ErrorDetails.INTERNAL_EXCEPTION,
                                                fatal: !1,
                                                event: "demuxerWorker",
                                                error: new Error(yt.message + "  (" + yt.filename + ":" + yt.lineno + ")")
                                            })
                                        }, xt.postMessage({
                                            cmd: "init",
                                            typeSupported: vt,
                                            vendor: mt,
                                            id: Pt,
                                            config: JSON.stringify(St)
                                        })
                                    } catch (yt) {
                                        pt.logger.warn("Error in worker:", yt), pt.logger.error("Error while initializing DemuxerWorker, fallback to inline"), xt && self.URL.revokeObjectURL(xt.objectURL), this.transmuxer = new bt.default(this.observer, vt, St, mt, Pt), this.worker = null
                                    }
                                } else this.transmuxer = new bt.default(this.observer, vt, St, mt, Pt)
                            }
                            var Et = ct.prototype;
                            return Et.destroy = function() {
                                var Pt = this.worker;
                                if (Pt) Pt.removeEventListener("message", this.onwmsg), Pt.terminate(), this.worker = null, this.onwmsg = void 0;
                                else {
                                    var gt = this.transmuxer;
                                    gt && (gt.destroy(), this.transmuxer = null)
                                }
                                var ft = this.observer;
                                ft && ft.removeAllListeners(), this.frag = null, this.observer = null, this.hls = null
                            }, Et.push = function(Pt, gt, ft, dt, St, _t, vt, mt, xt, yt) {
                                var Tt, Ft, wt = this;
                                xt.transmuxing.start = self.performance.now();
                                var kt = this.transmuxer,
                                    Ot = this.worker,
                                    Rt = _t ? _t.start : St.start,
                                    Lt = St.decryptdata,
                                    Bt = this.frag,
                                    Nt = !(Bt && St.cc === Bt.cc),
                                    $t = !(Bt && xt.level === Bt.level),
                                    jt = Bt ? xt.sn - Bt.sn : -1,
                                    Ut = this.part ? xt.part - this.part.index : -1,
                                    Ht = jt === 0 && xt.id > 1 && xt.id === (Bt == null ? void 0 : Bt.stats.chunkCount),
                                    Wt = !$t && (jt === 1 || jt === 0 && (Ut === 1 || Ht && Ut <= 0)),
                                    Kt = self.performance.now();
                                ($t || jt || St.stats.parsing.start === 0) && (St.stats.parsing.start = Kt), _t && (Ut || !Wt) && (_t.stats.parsing.start = Kt);
                                var Gt = !(Bt && ((Tt = St.initSegment) === null || Tt === void 0 ? void 0 : Tt.url) === ((Ft = Bt.initSegment) === null || Ft === void 0 ? void 0 : Ft.url)),
                                    Vt = new bt.TransmuxState(Nt, Wt, mt, $t, Rt, Gt);
                                if (!Wt || Nt || Gt) {
                                    pt.logger.log("[transmuxer-interface, " + St.type + "]: Starting new transmux session for sn: " + xt.sn + " p: " + xt.part + " level: " + xt.level + " id: " + xt.id + `
        discontinuity: ` + Nt + `
        trackSwitch: ` + $t + `
        contiguous: ` + Wt + `
        accurateTimeOffset: ` + mt + `
        timeOffset: ` + Rt + `
        initSegmentChange: ` + Gt);
                                    var zt = new bt.TransmuxConfig(ft, dt, gt, vt, yt);
                                    this.configureTransmuxer(zt)
                                }
                                if (this.frag = St, this.part = _t, Ot) Ot.postMessage({
                                    cmd: "demux",
                                    data: Pt,
                                    decryptdata: Lt,
                                    chunkMeta: xt,
                                    state: Vt
                                }, Pt instanceof ArrayBuffer ? [Pt] : []);
                                else if (kt) {
                                    var Xt = kt.push(Pt, Lt, xt, Vt);
                                    (0, bt.isPromise)(Xt) ? Xt.then(function(Yt) {
                                        wt.handleTransmuxComplete(Yt)
                                    }): this.handleTransmuxComplete(Xt)
                                }
                            }, Et.flush = function(Pt) {
                                var gt = this;
                                Pt.transmuxing.start = self.performance.now();
                                var ft = this.transmuxer,
                                    dt = this.worker;
                                if (dt) dt.postMessage({
                                    cmd: "flush",
                                    chunkMeta: Pt
                                });
                                else if (ft) {
                                    var St = ft.flush(Pt);
                                    (0, bt.isPromise)(St) ? St.then(function(_t) {
                                        gt.handleFlushResult(_t, Pt)
                                    }): this.handleFlushResult(St, Pt)
                                }
                            }, Et.handleFlushResult = function(Pt, gt) {
                                var ft = this;
                                Pt.forEach(function(dt) {
                                    ft.handleTransmuxComplete(dt)
                                }), this.onFlush(gt)
                            }, Et.onWorkerMessage = function(Pt) {
                                var gt = Pt.data,
                                    ft = this.hls;
                                switch (gt.event) {
                                    case "init": {
                                        self.URL.revokeObjectURL(this.worker.objectURL);
                                        break
                                    }
                                    case "transmuxComplete": {
                                        this.handleTransmuxComplete(gt.data);
                                        break
                                    }
                                    case "flush": {
                                        this.onFlush(gt.data);
                                        break
                                    }
                                    case "workerLog":
                                        pt.logger[gt.data.logType] && pt.logger[gt.data.logType](gt.data.message);
                                        break;
                                    default: {
                                        gt.data = gt.data || {}, gt.data.frag = this.frag, gt.data.id = this.id, ft.trigger(gt.event, gt.data);
                                        break
                                    }
                                }
                            }, Et.configureTransmuxer = function(Pt) {
                                var gt = this.worker,
                                    ft = this.transmuxer;
                                gt ? gt.postMessage({
                                    cmd: "configure",
                                    config: Pt
                                }) : ft && ft.configure(Pt)
                            }, Et.handleTransmuxComplete = function(Pt) {
                                Pt.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(Pt)
                            }, ct
                        }()
                },
                "./src/demux/transmuxer-worker.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => It
                    });
                    var ut = it("./src/demux/transmuxer.ts"),
                        lt = it("./src/events.ts"),
                        bt = it("./src/utils/logger.ts"),
                        pt = it("./node_modules/eventemitter3/index.js");

                    function It(ct) {
                        var Et = new pt.EventEmitter,
                            Dt = function(ft, dt) {
                                ct.postMessage({
                                    event: ft,
                                    data: dt
                                })
                            };
                        Et.on(lt.Events.FRAG_DECRYPTED, Dt), Et.on(lt.Events.ERROR, Dt);
                        var Pt = function() {
                            var ft = function(_t) {
                                var vt = function(xt) {
                                    Dt("workerLog", {
                                        logType: _t,
                                        message: xt
                                    })
                                };
                                bt.logger[_t] = vt
                            };
                            for (var dt in bt.logger) ft(dt)
                        };
                        ct.addEventListener("message", function(gt) {
                            var ft = gt.data;
                            switch (ft.cmd) {
                                case "init": {
                                    var dt = JSON.parse(ft.config);
                                    ct.transmuxer = new ut.default(Et, ft.typeSupported, dt, ft.vendor, ft.id), (0, bt.enableLogs)(dt.debug, ft.id), Pt(), Dt("init", null);
                                    break
                                }
                                case "configure": {
                                    ct.transmuxer.configure(ft.config);
                                    break
                                }
                                case "demux": {
                                    var St = ct.transmuxer.push(ft.data, ft.decryptdata, ft.chunkMeta, ft.state);
                                    (0, ut.isPromise)(St) ? St.then(function(mt) {
                                        At(ct, mt)
                                    }): At(ct, St);
                                    break
                                }
                                case "flush": {
                                    var _t = ft.chunkMeta,
                                        vt = ct.transmuxer.flush(_t);
                                    (0, ut.isPromise)(vt) ? vt.then(function(mt) {
                                        ht(ct, mt, _t)
                                    }): ht(ct, vt, _t);
                                    break
                                }
                            }
                        })
                    }

                    function At(ct, Et) {
                        if (ot(Et.remuxResult)) return !1;
                        var Dt = [],
                            Pt = Et.remuxResult,
                            gt = Pt.audio,
                            ft = Pt.video;
                        return gt && Ct(Dt, gt), ft && Ct(Dt, ft), ct.postMessage({
                            event: "transmuxComplete",
                            data: Et
                        }, Dt), !0
                    }

                    function Ct(ct, Et) {
                        Et.data1 && ct.push(Et.data1.buffer), Et.data2 && ct.push(Et.data2.buffer)
                    }

                    function ht(ct, Et, Dt) {
                        var Pt = Et.reduce(function(gt, ft) {
                            return At(ct, ft) || gt
                        }, !1);
                        Pt || ct.postMessage({
                            event: "transmuxComplete",
                            data: Et[0]
                        }), ct.postMessage({
                            event: "flush",
                            data: Dt
                        })
                    }

                    function ot(ct) {
                        return !ct.audio && !ct.video && !ct.text && !ct.id3 && !ct.initSegment
                    }
                },
                "./src/demux/transmuxer.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        TransmuxConfig: () => St,
                        TransmuxState: () => _t,
                        default: () => Pt,
                        isPromise: () => dt
                    });
                    var ut = it("./src/events.ts"),
                        lt = it("./src/errors.ts"),
                        bt = it("./src/crypt/decrypter.ts"),
                        pt = it("./src/demux/aacdemuxer.ts"),
                        It = it("./src/demux/mp4demuxer.ts"),
                        At = it("./src/demux/tsdemuxer.ts"),
                        Ct = it("./src/demux/mp3demuxer.ts"),
                        ht = it("./src/remux/mp4-remuxer.ts"),
                        ot = it("./src/remux/passthrough-remuxer.ts"),
                        ct = it("./src/utils/logger.ts"),
                        Et;
                    try {
                        Et = self.performance.now.bind(self.performance)
                    } catch {
                        ct.logger.debug("Unable to use Performance API on this environment"), Et = self.Date.now
                    }
                    var Dt = [{
                            demux: At.default,
                            remux: ht.default
                        }, {
                            demux: It.default,
                            remux: ot.default
                        }, {
                            demux: pt.default,
                            remux: ht.default
                        }, {
                            demux: Ct.default,
                            remux: ht.default
                        }],
                        Pt = function() {
                            function vt(xt, yt, Tt, Ft, wt) {
                                this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = xt, this.typeSupported = yt, this.config = Tt, this.vendor = Ft, this.id = wt
                            }
                            var mt = vt.prototype;
                            return mt.configure = function(yt) {
                                this.transmuxConfig = yt, this.decrypter && this.decrypter.reset()
                            }, mt.push = function(yt, Tt, Ft, wt) {
                                var kt = this,
                                    Ot = Ft.transmuxing;
                                Ot.executeStart = Et();
                                var Rt = new Uint8Array(yt),
                                    Lt = this.config,
                                    Bt = this.currentTransmuxState,
                                    Nt = this.transmuxConfig;
                                wt && (this.currentTransmuxState = wt);
                                var $t = wt || Bt,
                                    jt = $t.contiguous,
                                    Ut = $t.discontinuity,
                                    Ht = $t.trackSwitch,
                                    Wt = $t.accurateTimeOffset,
                                    Kt = $t.timeOffset,
                                    Gt = $t.initSegmentChange,
                                    Vt = Nt.audioCodec,
                                    zt = Nt.videoCodec,
                                    Xt = Nt.defaultInitPts,
                                    Yt = Nt.duration,
                                    Zt = Nt.initSegmentData;
                                (Ut || Ht || Gt) && this.resetInitSegment(Zt, Vt, zt, Yt), (Ut || Gt) && this.resetInitialTimestamp(Xt), jt || this.resetContiguity();
                                var qt = gt(Rt, Tt);
                                if (qt && qt.method === "AES-128") {
                                    var er = this.getDecrypter();
                                    if (Lt.enableSoftwareAES) {
                                        var tr = er.softwareDecrypt(Rt, qt.key.buffer, qt.iv.buffer);
                                        if (!tr) return Ot.executeEnd = Et(), ft(Ft);
                                        Rt = new Uint8Array(tr)
                                    } else return this.decryptionPromise = er.webCryptoDecrypt(Rt, qt.key.buffer, qt.iv.buffer).then(function(nr) {
                                        var rr = kt.push(nr, null, Ft);
                                        return kt.decryptionPromise = null, rr
                                    }), this.decryptionPromise
                                }
                                this.needsProbing(Rt, Ut, Ht) && this.configureTransmuxer(Rt, Nt);
                                var Qt = this.transmux(Rt, qt, Kt, Wt, Ft),
                                    Jt = this.currentTransmuxState;
                                return Jt.contiguous = !0, Jt.discontinuity = !1, Jt.trackSwitch = !1, Ot.executeEnd = Et(), Qt
                            }, mt.flush = function(yt) {
                                var Tt = this,
                                    Ft = yt.transmuxing;
                                Ft.executeStart = Et();
                                var wt = this.decrypter,
                                    kt = this.currentTransmuxState,
                                    Ot = this.decryptionPromise;
                                if (Ot) return Ot.then(function() {
                                    return Tt.flush(yt)
                                });
                                var Rt = [],
                                    Lt = kt.timeOffset;
                                if (wt) {
                                    var Bt = wt.flush();
                                    Bt && Rt.push(this.push(Bt, null, yt))
                                }
                                var Nt = this.demuxer,
                                    $t = this.remuxer;
                                if (!Nt || !$t) return this.observer.emit(ut.Events.ERROR, ut.Events.ERROR, {
                                    type: lt.ErrorTypes.MEDIA_ERROR,
                                    details: lt.ErrorDetails.FRAG_PARSING_ERROR,
                                    fatal: !0,
                                    reason: "no demux matching with content found"
                                }), Ft.executeEnd = Et(), [ft(yt)];
                                var jt = Nt.flush(Lt);
                                return dt(jt) ? jt.then(function(Ut) {
                                    return Tt.flushRemux(Rt, Ut, yt), Rt
                                }) : (this.flushRemux(Rt, jt, yt), Rt)
                            }, mt.flushRemux = function(yt, Tt, Ft) {
                                var wt = Tt.audioTrack,
                                    kt = Tt.videoTrack,
                                    Ot = Tt.id3Track,
                                    Rt = Tt.textTrack,
                                    Lt = this.currentTransmuxState,
                                    Bt = Lt.accurateTimeOffset,
                                    Nt = Lt.timeOffset;
                                ct.logger.log("[transmuxer.ts]: Flushed fragment " + Ft.sn + (Ft.part > -1 ? " p: " + Ft.part : "") + " of level " + Ft.level);
                                var $t = this.remuxer.remux(wt, kt, Ot, Rt, Nt, Bt, !0, this.id);
                                yt.push({
                                    remuxResult: $t,
                                    chunkMeta: Ft
                                }), Ft.transmuxing.executeEnd = Et()
                            }, mt.resetInitialTimestamp = function(yt) {
                                var Tt = this.demuxer,
                                    Ft = this.remuxer;
                                !Tt || !Ft || (Tt.resetTimeStamp(yt), Ft.resetTimeStamp(yt))
                            }, mt.resetContiguity = function() {
                                var yt = this.demuxer,
                                    Tt = this.remuxer;
                                !yt || !Tt || (yt.resetContiguity(), Tt.resetNextTimestamp())
                            }, mt.resetInitSegment = function(yt, Tt, Ft, wt) {
                                var kt = this.demuxer,
                                    Ot = this.remuxer;
                                !kt || !Ot || (kt.resetInitSegment(yt, Tt, Ft, wt), Ot.resetInitSegment(yt, Tt, Ft))
                            }, mt.destroy = function() {
                                this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0)
                            }, mt.transmux = function(yt, Tt, Ft, wt, kt) {
                                var Ot;
                                return Tt && Tt.method === "SAMPLE-AES" ? Ot = this.transmuxSampleAes(yt, Tt, Ft, wt, kt) : Ot = this.transmuxUnencrypted(yt, Ft, wt, kt), Ot
                            }, mt.transmuxUnencrypted = function(yt, Tt, Ft, wt) {
                                var kt = this.demuxer.demux(yt, Tt, !1, !this.config.progressive),
                                    Ot = kt.audioTrack,
                                    Rt = kt.videoTrack,
                                    Lt = kt.id3Track,
                                    Bt = kt.textTrack,
                                    Nt = this.remuxer.remux(Ot, Rt, Lt, Bt, Tt, Ft, !1, this.id);
                                return {
                                    remuxResult: Nt,
                                    chunkMeta: wt
                                }
                            }, mt.transmuxSampleAes = function(yt, Tt, Ft, wt, kt) {
                                var Ot = this;
                                return this.demuxer.demuxSampleAes(yt, Tt, Ft).then(function(Rt) {
                                    var Lt = Ot.remuxer.remux(Rt.audioTrack, Rt.videoTrack, Rt.id3Track, Rt.textTrack, Ft, wt, !1, Ot.id);
                                    return {
                                        remuxResult: Lt,
                                        chunkMeta: kt
                                    }
                                })
                            }, mt.configureTransmuxer = function(yt, Tt) {
                                for (var Ft = this.config, wt = this.observer, kt = this.typeSupported, Ot = this.vendor, Rt = Tt.audioCodec, Lt = Tt.defaultInitPts, Bt = Tt.duration, Nt = Tt.initSegmentData, $t = Tt.videoCodec, jt, Ut = 0, Ht = Dt.length; Ut < Ht; Ut++)
                                    if (Dt[Ut].demux.probe(yt)) {
                                        jt = Dt[Ut];
                                        break
                                    } jt || (ct.logger.warn("Failed to find demuxer by probing frag, treating as mp4 passthrough"), jt = {
                                    demux: It.default,
                                    remux: ot.default
                                });
                                var Wt = this.demuxer,
                                    Kt = this.remuxer,
                                    Gt = jt.remux,
                                    Vt = jt.demux;
                                (!Kt || !(Kt instanceof Gt)) && (this.remuxer = new Gt(wt, Ft, kt, Ot)), (!Wt || !(Wt instanceof Vt)) && (this.demuxer = new Vt(wt, Ft, kt), this.probe = Vt.probe), this.resetInitSegment(Nt, Rt, $t, Bt), this.resetInitialTimestamp(Lt)
                            }, mt.needsProbing = function(yt, Tt, Ft) {
                                return !this.demuxer || !this.remuxer || Tt || Ft
                            }, mt.getDecrypter = function() {
                                var yt = this.decrypter;
                                return yt || (yt = this.decrypter = new bt.default(this.observer, this.config)), yt
                            }, vt
                        }();

                    function gt(vt, mt) {
                        var xt = null;
                        return vt.byteLength > 0 && mt != null && mt.key != null && mt.iv !== null && mt.method != null && (xt = mt), xt
                    }
                    var ft = function(mt) {
                        return {
                            remuxResult: {},
                            chunkMeta: mt
                        }
                    };

                    function dt(vt) {
                        return "then" in vt && vt.then instanceof Function
                    }
                    var St = function(mt, xt, yt, Tt, Ft) {
                            this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = mt, this.videoCodec = xt, this.initSegmentData = yt, this.duration = Tt, this.defaultInitPts = Ft
                        },
                        _t = function(mt, xt, yt, Tt, Ft, wt) {
                            this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = mt, this.contiguous = xt, this.accurateTimeOffset = yt, this.trackSwitch = Tt, this.timeOffset = Ft, this.initSegmentChange = wt
                        }
                },
                "./src/demux/tsdemuxer.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => _t
                    });
                    var ut = it("./src/demux/adts.ts"),
                        lt = it("./src/demux/mpegaudio.ts"),
                        bt = it("./src/demux/exp-golomb.ts"),
                        pt = it("./src/demux/sample-aes.ts"),
                        It = it("./src/events.ts"),
                        At = it("./src/utils/mp4-tools.ts"),
                        Ct = it("./src/utils/logger.ts"),
                        ht = it("./src/errors.ts"),
                        ot = it("./src/types/demuxer.ts");

                    function ct() {
                        return ct = Object.assign ? Object.assign.bind() : function(vt) {
                            for (var mt = 1; mt < arguments.length; mt++) {
                                var xt = arguments[mt];
                                for (var yt in xt) Object.prototype.hasOwnProperty.call(xt, yt) && (vt[yt] = xt[yt])
                            }
                            return vt
                        }, ct.apply(this, arguments)
                    }
                    var Et = 188,
                        Dt = function() {
                            function vt(xt, yt, Tt) {
                                this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this._pmtId = -1, this._avcTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.observer = xt, this.config = yt, this.typeSupported = Tt
                            }
                            vt.probe = function(yt) {
                                var Tt = vt.syncOffset(yt);
                                return Tt > 0 && Ct.logger.warn("MPEG2-TS detected but first sync word found @ offset " + Tt), Tt !== -1
                            }, vt.syncOffset = function(yt) {
                                for (var Tt = Math.min(Et * 5, yt.length - Et * 2) + 1, Ft = 0; Ft < Tt;) {
                                    if (yt[Ft] === 71 && yt[Ft + Et] === 71) return Ft;
                                    Ft++
                                }
                                return -1
                            }, vt.createTrack = function(yt, Tt) {
                                return {
                                    container: yt === "video" || yt === "audio" ? "video/mp2t" : void 0,
                                    type: yt,
                                    id: At.RemuxerTrackIdConfig[yt],
                                    pid: -1,
                                    inputTimeScale: 9e4,
                                    sequenceNumber: 0,
                                    samples: [],
                                    dropped: 0,
                                    duration: yt === "audio" ? Tt : void 0
                                }
                            };
                            var mt = vt.prototype;
                            return mt.resetInitSegment = function(yt, Tt, Ft, wt) {
                                this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = vt.createTrack("video"), this._audioTrack = vt.createTrack("audio", wt), this._id3Track = vt.createTrack("id3"), this._txtTrack = vt.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.audioCodec = Tt, this.videoCodec = Ft, this._duration = wt
                            }, mt.resetTimeStamp = function() {}, mt.resetContiguity = function() {
                                var yt = this._audioTrack,
                                    Tt = this._avcTrack,
                                    Ft = this._id3Track;
                                yt && (yt.pesData = null), Tt && (Tt.pesData = null), Ft && (Ft.pesData = null), this.aacOverFlow = null, this.avcSample = null, this.remainderData = null
                            }, mt.demux = function(yt, Tt, Ft, wt) {
                                Ft === void 0 && (Ft = !1), wt === void 0 && (wt = !1), Ft || (this.sampleAes = null);
                                var kt, Ot = this._avcTrack,
                                    Rt = this._audioTrack,
                                    Lt = this._id3Track,
                                    Bt = this._txtTrack,
                                    Nt = Ot.pid,
                                    $t = Ot.pesData,
                                    jt = Rt.pid,
                                    Ut = Lt.pid,
                                    Ht = Rt.pesData,
                                    Wt = Lt.pesData,
                                    Kt = null,
                                    Gt = this.pmtParsed,
                                    Vt = this._pmtId,
                                    zt = yt.length;
                                if (this.remainderData && (yt = (0, At.appendUint8Array)(this.remainderData, yt), zt = yt.length, this.remainderData = null), zt < Et && !wt) return this.remainderData = yt, {
                                    audioTrack: Rt,
                                    videoTrack: Ot,
                                    id3Track: Lt,
                                    textTrack: Bt
                                };
                                var Xt = Math.max(0, vt.syncOffset(yt));
                                zt -= (zt - Xt) % Et, zt < yt.byteLength && !wt && (this.remainderData = new Uint8Array(yt.buffer, zt, yt.buffer.byteLength - zt));
                                for (var Yt = 0, Zt = Xt; Zt < zt; Zt += Et)
                                    if (yt[Zt] === 71) {
                                        var qt = !!(yt[Zt + 1] & 64),
                                            er = ((yt[Zt + 1] & 31) << 8) + yt[Zt + 2],
                                            tr = (yt[Zt + 3] & 48) >> 4,
                                            Qt = void 0;
                                        if (tr > 1) {
                                            if (Qt = Zt + 5 + yt[Zt + 4], Qt === Zt + Et) continue
                                        } else Qt = Zt + 4;
                                        switch (er) {
                                            case Nt:
                                                qt && ($t && (kt = dt($t)) && this.parseAVCPES(Ot, Bt, kt, !1), $t = {
                                                    data: [],
                                                    size: 0
                                                }), $t && ($t.data.push(yt.subarray(Qt, Zt + Et)), $t.size += Zt + Et - Qt);
                                                break;
                                            case jt:
                                                if (qt) {
                                                    if (Ht && (kt = dt(Ht))) switch (Rt.segmentCodec) {
                                                        case "aac":
                                                            this.parseAACPES(Rt, kt);
                                                            break;
                                                        case "mp3":
                                                            this.parseMPEGPES(Rt, kt);
                                                            break
                                                    }
                                                    Ht = {
                                                        data: [],
                                                        size: 0
                                                    }
                                                }
                                                Ht && (Ht.data.push(yt.subarray(Qt, Zt + Et)), Ht.size += Zt + Et - Qt);
                                                break;
                                            case Ut:
                                                qt && (Wt && (kt = dt(Wt)) && this.parseID3PES(Lt, kt), Wt = {
                                                    data: [],
                                                    size: 0
                                                }), Wt && (Wt.data.push(yt.subarray(Qt, Zt + Et)), Wt.size += Zt + Et - Qt);
                                                break;
                                            case 0:
                                                qt && (Qt += yt[Qt] + 1), Vt = this._pmtId = gt(yt, Qt);
                                                break;
                                            case Vt: {
                                                qt && (Qt += yt[Qt] + 1);
                                                var Jt = ft(yt, Qt, this.typeSupported, Ft);
                                                Nt = Jt.avc, Nt > 0 && (Ot.pid = Nt), jt = Jt.audio, jt > 0 && (Rt.pid = jt, Rt.segmentCodec = Jt.segmentCodec), Ut = Jt.id3, Ut > 0 && (Lt.pid = Ut), Kt !== null && !Gt && (Ct.logger.log("unknown PID '" + Kt + "' in TS found"), Kt = null, Zt = Xt - 188), Gt = this.pmtParsed = !0;
                                                break
                                            }
                                            case 17:
                                            case 8191:
                                                break;
                                            default:
                                                Kt = er;
                                                break
                                        }
                                    } else Yt++;
                                Yt > 0 && this.observer.emit(It.Events.ERROR, It.Events.ERROR, {
                                    type: ht.ErrorTypes.MEDIA_ERROR,
                                    details: ht.ErrorDetails.FRAG_PARSING_ERROR,
                                    fatal: !1,
                                    reason: "Found " + Yt + " TS packet/s that do not start with 0x47"
                                }), Ot.pesData = $t, Rt.pesData = Ht, Lt.pesData = Wt;
                                var nr = {
                                    audioTrack: Rt,
                                    videoTrack: Ot,
                                    id3Track: Lt,
                                    textTrack: Bt
                                };
                                return wt && this.extractRemainingSamples(nr), nr
                            }, mt.flush = function() {
                                var yt = this.remainderData;
                                this.remainderData = null;
                                var Tt;
                                return yt ? Tt = this.demux(yt, -1, !1, !0) : Tt = {
                                    videoTrack: this._avcTrack,
                                    audioTrack: this._audioTrack,
                                    id3Track: this._id3Track,
                                    textTrack: this._txtTrack
                                }, this.extractRemainingSamples(Tt), this.sampleAes ? this.decrypt(Tt, this.sampleAes) : Tt
                            }, mt.extractRemainingSamples = function(yt) {
                                var Tt = yt.audioTrack,
                                    Ft = yt.videoTrack,
                                    wt = yt.id3Track,
                                    kt = yt.textTrack,
                                    Ot = Ft.pesData,
                                    Rt = Tt.pesData,
                                    Lt = wt.pesData,
                                    Bt;
                                if (Ot && (Bt = dt(Ot)) ? (this.parseAVCPES(Ft, kt, Bt, !0), Ft.pesData = null) : Ft.pesData = Ot, Rt && (Bt = dt(Rt))) {
                                    switch (Tt.segmentCodec) {
                                        case "aac":
                                            this.parseAACPES(Tt, Bt);
                                            break;
                                        case "mp3":
                                            this.parseMPEGPES(Tt, Bt);
                                            break
                                    }
                                    Tt.pesData = null
                                } else Rt != null && Rt.size && Ct.logger.log("last AAC PES packet truncated,might overlap between fragments"), Tt.pesData = Rt;
                                Lt && (Bt = dt(Lt)) ? (this.parseID3PES(wt, Bt), wt.pesData = null) : wt.pesData = Lt
                            }, mt.demuxSampleAes = function(yt, Tt, Ft) {
                                var wt = this.demux(yt, Ft, !0, !this.config.progressive),
                                    kt = this.sampleAes = new pt.default(this.observer, this.config, Tt);
                                return this.decrypt(wt, kt)
                            }, mt.decrypt = function(yt, Tt) {
                                return new Promise(function(Ft) {
                                    var wt = yt.audioTrack,
                                        kt = yt.videoTrack;
                                    wt.samples && wt.segmentCodec === "aac" ? Tt.decryptAacSamples(wt.samples, 0, function() {
                                        kt.samples ? Tt.decryptAvcSamples(kt.samples, 0, 0, function() {
                                            Ft(yt)
                                        }) : Ft(yt)
                                    }) : kt.samples && Tt.decryptAvcSamples(kt.samples, 0, 0, function() {
                                        Ft(yt)
                                    })
                                })
                            }, mt.destroy = function() {
                                this._duration = 0
                            }, mt.parseAVCPES = function(yt, Tt, Ft, wt) {
                                var kt = this,
                                    Ot = this.parseAVCNALu(yt, Ft.data),
                                    Rt = this.avcSample,
                                    Lt, Bt = !1;
                                Ft.data = null, Rt && Ot.length && !yt.audFound && (St(Rt, yt), Rt = this.avcSample = Pt(!1, Ft.pts, Ft.dts, "")), Ot.forEach(function(Nt) {
                                    switch (Nt.type) {
                                        case 1: {
                                            Lt = !0, Rt || (Rt = kt.avcSample = Pt(!0, Ft.pts, Ft.dts, "")), Rt.frame = !0;
                                            var $t = Nt.data;
                                            if (Bt && $t.length > 4) {
                                                var jt = new bt.default($t).readSliceType();
                                                (jt === 2 || jt === 4 || jt === 7 || jt === 9) && (Rt.key = !0)
                                            }
                                            break
                                        }
                                        case 5:
                                            Lt = !0, Rt || (Rt = kt.avcSample = Pt(!0, Ft.pts, Ft.dts, "")), Rt.key = !0, Rt.frame = !0;
                                            break;
                                        case 6: {
                                            Lt = !0, (0, At.parseSEIMessageFromNALu)(Nt.data, 1, Ft.pts, Tt.samples);
                                            break
                                        }
                                        case 7:
                                            if (Lt = !0, Bt = !0, !yt.sps) {
                                                var Ut = new bt.default(Nt.data),
                                                    Ht = Ut.readSPS();
                                                yt.width = Ht.width, yt.height = Ht.height, yt.pixelRatio = Ht.pixelRatio, yt.sps = [Nt.data], yt.duration = kt._duration;
                                                for (var Wt = Nt.data.subarray(1, 4), Kt = "avc1.", Gt = 0; Gt < 3; Gt++) {
                                                    var Vt = Wt[Gt].toString(16);
                                                    Vt.length < 2 && (Vt = "0" + Vt), Kt += Vt
                                                }
                                                yt.codec = Kt
                                            }
                                            break;
                                        case 8:
                                            Lt = !0, yt.pps || (yt.pps = [Nt.data]);
                                            break;
                                        case 9:
                                            Lt = !1, yt.audFound = !0, Rt && St(Rt, yt), Rt = kt.avcSample = Pt(!1, Ft.pts, Ft.dts, "");
                                            break;
                                        case 12:
                                            Lt = !0;
                                            break;
                                        default:
                                            Lt = !1, Rt && (Rt.debug += "unknown NAL " + Nt.type + " ");
                                            break
                                    }
                                    if (Rt && Lt) {
                                        var zt = Rt.units;
                                        zt.push(Nt)
                                    }
                                }), wt && Rt && (St(Rt, yt), this.avcSample = null)
                            }, mt.getLastNalUnit = function(yt) {
                                var Tt, Ft = this.avcSample,
                                    wt;
                                if ((!Ft || Ft.units.length === 0) && (Ft = yt[yt.length - 1]), (Tt = Ft) !== null && Tt !== void 0 && Tt.units) {
                                    var kt = Ft.units;
                                    wt = kt[kt.length - 1]
                                }
                                return wt
                            }, mt.parseAVCNALu = function(yt, Tt) {
                                var Ft = Tt.byteLength,
                                    wt = yt.naluState || 0,
                                    kt = wt,
                                    Ot = [],
                                    Rt = 0,
                                    Lt, Bt, Nt, $t = -1,
                                    jt = 0;
                                for (wt === -1 && ($t = 0, jt = Tt[0] & 31, wt = 0, Rt = 1); Rt < Ft;) {
                                    if (Lt = Tt[Rt++], !wt) {
                                        wt = Lt ? 0 : 1;
                                        continue
                                    }
                                    if (wt === 1) {
                                        wt = Lt ? 0 : 2;
                                        continue
                                    }
                                    if (!Lt) wt = 3;
                                    else if (Lt === 1) {
                                        if ($t >= 0) {
                                            var Ut = {
                                                data: Tt.subarray($t, Rt - wt - 1),
                                                type: jt
                                            };
                                            Ot.push(Ut)
                                        } else {
                                            var Ht = this.getLastNalUnit(yt.samples);
                                            if (Ht && (kt && Rt <= 4 - kt && Ht.state && (Ht.data = Ht.data.subarray(0, Ht.data.byteLength - kt)), Bt = Rt - wt - 1, Bt > 0)) {
                                                var Wt = new Uint8Array(Ht.data.byteLength + Bt);
                                                Wt.set(Ht.data, 0), Wt.set(Tt.subarray(0, Bt), Ht.data.byteLength), Ht.data = Wt, Ht.state = 0
                                            }
                                        }
                                        Rt < Ft ? (Nt = Tt[Rt] & 31, $t = Rt, jt = Nt, wt = 0) : wt = -1
                                    } else wt = 0
                                }
                                if ($t >= 0 && wt >= 0) {
                                    var Kt = {
                                        data: Tt.subarray($t, Ft),
                                        type: jt,
                                        state: wt
                                    };
                                    Ot.push(Kt)
                                }
                                if (Ot.length === 0) {
                                    var Gt = this.getLastNalUnit(yt.samples);
                                    if (Gt) {
                                        var Vt = new Uint8Array(Gt.data.byteLength + Tt.byteLength);
                                        Vt.set(Gt.data, 0), Vt.set(Tt, Gt.data.byteLength), Gt.data = Vt
                                    }
                                }
                                return yt.naluState = wt, Ot
                            }, mt.parseAACPES = function(yt, Tt) {
                                var Ft = 0,
                                    wt = this.aacOverFlow,
                                    kt = Tt.data;
                                if (wt) {
                                    this.aacOverFlow = null;
                                    var Ot = wt.missing,
                                        Rt = wt.sample.unit.byteLength;
                                    if (Ot === -1) {
                                        var Lt = new Uint8Array(Rt + kt.byteLength);
                                        Lt.set(wt.sample.unit, 0), Lt.set(kt, Rt), kt = Lt
                                    } else {
                                        var Bt = Rt - Ot;
                                        wt.sample.unit.set(kt.subarray(0, Ot), Bt), yt.samples.push(wt.sample), Ft = wt.missing
                                    }
                                }
                                var Nt, $t;
                                for (Nt = Ft, $t = kt.length; Nt < $t - 1 && !ut.isHeader(kt, Nt); Nt++);
                                if (Nt !== Ft) {
                                    var jt, Ut;
                                    if (Nt < $t - 1 ? (jt = "AAC PES did not start with ADTS header,offset:" + Nt, Ut = !1) : (jt = "no ADTS header found in AAC PES", Ut = !0), Ct.logger.warn("parsing error:" + jt), this.observer.emit(It.Events.ERROR, It.Events.ERROR, {
                                            type: ht.ErrorTypes.MEDIA_ERROR,
                                            details: ht.ErrorDetails.FRAG_PARSING_ERROR,
                                            fatal: Ut,
                                            reason: jt
                                        }), Ut) return
                                }
                                ut.initTrackConfig(yt, this.observer, kt, Nt, this.audioCodec);
                                var Ht;
                                if (Tt.pts !== void 0) Ht = Tt.pts;
                                else if (wt) {
                                    var Wt = ut.getFrameDuration(yt.samplerate);
                                    Ht = wt.sample.pts + Wt
                                } else {
                                    Ct.logger.warn("[tsdemuxer]: AAC PES unknown PTS");
                                    return
                                }
                                for (var Kt = 0, Gt; Nt < $t;)
                                    if (Gt = ut.appendFrame(yt, kt, Nt, Ht, Kt), Nt += Gt.length, Gt.missing) {
                                        this.aacOverFlow = Gt;
                                        break
                                    } else
                                        for (Kt++; Nt < $t - 1 && !ut.isHeader(kt, Nt); Nt++);
                            }, mt.parseMPEGPES = function(yt, Tt) {
                                var Ft = Tt.data,
                                    wt = Ft.length,
                                    kt = 0,
                                    Ot = 0,
                                    Rt = Tt.pts;
                                if (Rt === void 0) {
                                    Ct.logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
                                    return
                                }
                                for (; Ot < wt;)
                                    if (lt.isHeader(Ft, Ot)) {
                                        var Lt = lt.appendFrame(yt, Ft, Ot, Rt, kt);
                                        if (Lt) Ot += Lt.length, kt++;
                                        else break
                                    } else Ot++
                            }, mt.parseID3PES = function(yt, Tt) {
                                if (Tt.pts === void 0) {
                                    Ct.logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
                                    return
                                }
                                var Ft = ct({}, Tt, {
                                    type: this._avcTrack ? ot.MetadataSchema.emsg : ot.MetadataSchema.audioId3,
                                    duration: Number.POSITIVE_INFINITY
                                });
                                yt.samples.push(Ft)
                            }, vt
                        }();

                    function Pt(vt, mt, xt, yt) {
                        return {
                            key: vt,
                            frame: !1,
                            pts: mt,
                            dts: xt,
                            units: [],
                            debug: yt,
                            length: 0
                        }
                    }

                    function gt(vt, mt) {
                        return (vt[mt + 10] & 31) << 8 | vt[mt + 11]
                    }

                    function ft(vt, mt, xt, yt) {
                        var Tt = {
                                audio: -1,
                                avc: -1,
                                id3: -1,
                                segmentCodec: "aac"
                            },
                            Ft = (vt[mt + 1] & 15) << 8 | vt[mt + 2],
                            wt = mt + 3 + Ft - 4,
                            kt = (vt[mt + 10] & 15) << 8 | vt[mt + 11];
                        for (mt += 12 + kt; mt < wt;) {
                            var Ot = (vt[mt + 1] & 31) << 8 | vt[mt + 2];
                            switch (vt[mt]) {
                                case 207:
                                    if (!yt) {
                                        Ct.logger.log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
                                        break
                                    }
                                case 15:
                                    Tt.audio === -1 && (Tt.audio = Ot);
                                    break;
                                case 21:
                                    Tt.id3 === -1 && (Tt.id3 = Ot);
                                    break;
                                case 219:
                                    if (!yt) {
                                        Ct.logger.log("H.264 with AES-128-CBC slice encryption found in unencrypted stream");
                                        break
                                    }
                                case 27:
                                    Tt.avc === -1 && (Tt.avc = Ot);
                                    break;
                                case 3:
                                case 4:
                                    xt.mpeg !== !0 && xt.mp3 !== !0 ? Ct.logger.log("MPEG audio found, not supported in this browser") : Tt.audio === -1 && (Tt.audio = Ot, Tt.segmentCodec = "mp3");
                                    break;
                                case 36:
                                    Ct.logger.warn("Unsupported HEVC stream type found");
                                    break
                            }
                            mt += ((vt[mt + 3] & 15) << 8 | vt[mt + 4]) + 5
                        }
                        return Tt
                    }

                    function dt(vt) {
                        var mt = 0,
                            xt, yt, Tt, Ft, wt, kt = vt.data;
                        if (!vt || vt.size === 0) return null;
                        for (; kt[0].length < 19 && kt.length > 1;) {
                            var Ot = new Uint8Array(kt[0].length + kt[1].length);
                            Ot.set(kt[0]), Ot.set(kt[1], kt[0].length), kt[0] = Ot, kt.splice(1, 1)
                        }
                        xt = kt[0];
                        var Rt = (xt[0] << 16) + (xt[1] << 8) + xt[2];
                        if (Rt === 1) {
                            if (yt = (xt[4] << 8) + xt[5], yt && yt > vt.size - 6) return null;
                            var Lt = xt[7];
                            Lt & 192 && (Ft = (xt[9] & 14) * 536870912 + (xt[10] & 255) * 4194304 + (xt[11] & 254) * 16384 + (xt[12] & 255) * 128 + (xt[13] & 254) / 2, Lt & 64 ? (wt = (xt[14] & 14) * 536870912 + (xt[15] & 255) * 4194304 + (xt[16] & 254) * 16384 + (xt[17] & 255) * 128 + (xt[18] & 254) / 2, Ft - wt > 54e5 && (Ct.logger.warn(Math.round((Ft - wt) / 9e4) + "s delta between PTS and DTS, align them"), Ft = wt)) : wt = Ft), Tt = xt[8];
                            var Bt = Tt + 9;
                            if (vt.size <= Bt) return null;
                            vt.size -= Bt;
                            for (var Nt = new Uint8Array(vt.size), $t = 0, jt = kt.length; $t < jt; $t++) {
                                xt = kt[$t];
                                var Ut = xt.byteLength;
                                if (Bt)
                                    if (Bt > Ut) {
                                        Bt -= Ut;
                                        continue
                                    } else xt = xt.subarray(Bt), Ut -= Bt, Bt = 0;
                                Nt.set(xt, mt), mt += Ut
                            }
                            return yt && (yt -= Tt + 3), {
                                data: Nt,
                                pts: Ft,
                                dts: wt,
                                len: yt
                            }
                        }
                        return null
                    }

                    function St(vt, mt) {
                        if (vt.units.length && vt.frame) {
                            if (vt.pts === void 0) {
                                var xt = mt.samples,
                                    yt = xt.length;
                                if (yt) {
                                    var Tt = xt[yt - 1];
                                    vt.pts = Tt.pts, vt.dts = Tt.dts
                                } else {
                                    mt.dropped++;
                                    return
                                }
                            }
                            mt.samples.push(vt)
                        }
                        vt.debug.length && Ct.logger.log(vt.pts + "/" + vt.dts + ":" + vt.debug)
                    }
                    const _t = Dt
                },
                "./src/demux/webworkify-webpack.js": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => Et
                    });
                    var ut = function() {
                            var Pt = ENTRY_MODULE,
                                gt = {},
                                ft = function St(_t) {
                                    var vt = gt[_t];
                                    if (vt !== void 0) return vt.exports;
                                    var mt = gt[_t] = {
                                        exports: {}
                                    };
                                    return Pt[_t].call(mt.exports, mt, mt.exports, St), mt.exports
                                };
                            ft.m = Pt,
                                function() {
                                    ft.n = function(St) {
                                        var _t = St && St.__esModule ? function() {
                                            return St.default
                                        } : function() {
                                            return St
                                        };
                                        return ft.d(_t, {
                                            a: _t
                                        }), _t
                                    }
                                }(),
                                function() {
                                    ft.d = function(St, _t) {
                                        for (var vt in _t) ft.o(_t, vt) && !ft.o(St, vt) && Object.defineProperty(St, vt, {
                                            enumerable: !0,
                                            get: _t[vt]
                                        })
                                    }
                                }(),
                                function() {
                                    ft.o = function(St, _t) {
                                        return Object.prototype.hasOwnProperty.call(St, _t)
                                    }
                                }(),
                                function() {
                                    ft.r = function(St) {
                                        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(St, Symbol.toStringTag, {
                                            value: "Module"
                                        }), Object.defineProperty(St, "__esModule", {
                                            value: !0
                                        })
                                    }
                                }();
                            var dt = ft(ENTRY_MODULE);
                            return dt.default || dt
                        },
                        lt = ut.toString().split("ENTRY_MODULE"),
                        bt = "[\\.|\\-|\\+|\\w|/|@]+",
                        pt = "\\(\\s*(/\\*.*?\\*/)?\\s*.*?(" + bt + ").*?\\)";

                    function It(Dt) {
                        return (Dt + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&")
                    }

                    function At(Dt) {
                        return !isNaN(1 * Dt)
                    }

                    function Ct(Dt, Pt, gt) {
                        var ft = {};
                        ft[gt] = [];
                        var dt = Pt.toString().replace(/^"[^"]+"/, "function"),
                            St = dt.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/) || dt.match(/^\(\w+,\s*\w+,\s*(\w+)\)\s?\=\s?\>/);
                        if (!St) return ft;
                        for (var _t = St[1], vt = new RegExp("(\\\\n|\\W)" + It(_t) + pt, "g"), mt; mt = vt.exec(dt);) mt[3] !== "dll-reference" && ft[gt].push(mt[3]);
                        for (vt = new RegExp("\\(" + It(_t) + '\\("(dll-reference\\s(' + bt + '))"\\)\\)' + pt, "g"); mt = vt.exec(dt);) Dt[mt[2]] || (ft[gt].push(mt[1]), Dt[mt[2]] = it(mt[1]).m), ft[mt[2]] = ft[mt[2]] || [], ft[mt[2]].push(mt[4]);
                        for (var xt = Object.keys(ft), yt = 0; yt < xt.length; yt++)
                            for (var Tt = 0; Tt < ft[xt[yt]].length; Tt++) At(ft[xt[yt]][Tt]) && (ft[xt[yt]][Tt] = 1 * ft[xt[yt]][Tt]);
                        return ft
                    }

                    function ht(Dt) {
                        var Pt = Object.keys(Dt);
                        return Pt.reduce(function(gt, ft) {
                            return gt || Dt[ft].length > 0
                        }, !1)
                    }

                    function ot(Dt, Pt) {
                        for (var gt = {
                                main: [Pt]
                            }, ft = {
                                main: []
                            }, dt = {
                                main: {}
                            }; ht(gt);)
                            for (var St = Object.keys(gt), _t = 0; _t < St.length; _t++) {
                                var vt = St[_t],
                                    mt = gt[vt],
                                    xt = mt.pop();
                                if (dt[vt] = dt[vt] || {}, !(dt[vt][xt] || !Dt[vt][xt])) {
                                    dt[vt][xt] = !0, ft[vt] = ft[vt] || [], ft[vt].push(xt);
                                    for (var yt = Ct(Dt, Dt[vt][xt], vt), Tt = Object.keys(yt), Ft = 0; Ft < Tt.length; Ft++) gt[Tt[Ft]] = gt[Tt[Ft]] || [], gt[Tt[Ft]] = gt[Tt[Ft]].concat(yt[Tt[Ft]])
                                }
                            }
                        return ft
                    }

                    function ct(Dt, Pt, gt, ft) {
                        var dt = Dt[ft].map(function(St) {
                            return '"' + St + '": ' + Pt[ft][St].toString().replace(/^"[^"]+"/, "function")
                        }).join(",");
                        return lt[0] + "{" + dt + "}" + lt[1] + '"' + gt + '"' + lt[2]
                    }

                    function Et(Dt, Pt) {
                        Pt = Pt || {};
                        var gt = {
                                main: it.m
                            },
                            ft = Pt.all ? {
                                main: Object.keys(gt.main)
                            } : ot(gt, Dt),
                            dt = "";
                        Object.keys(ft).filter(function(xt) {
                            return xt !== "main"
                        }).forEach(function(xt) {
                            for (var yt = 0; ft[xt][yt];) yt++;
                            ft[xt].push(yt), gt[xt][yt] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })", dt = dt + ("var " + xt + " = (" + ct(ft, gt, yt, modules) + `)();
`)
                        }), dt = dt + ("new ((" + ct(ft, gt, Dt, "main") + ")())(self);");
                        var St = new window.Blob([dt], {
                                type: "text/javascript"
                            }),
                            _t = window.URL || window.webkitURL || window.mozURL || window.msURL,
                            vt = _t.createObjectURL(St),
                            mt = new window.Worker(vt);
                        return mt.objectURL = vt, mt
                    }
                },
                "./src/errors.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        ErrorDetails: () => lt,
                        ErrorTypes: () => ut
                    });
                    var ut;
                    (function(bt) {
                        bt.NETWORK_ERROR = "networkError", bt.MEDIA_ERROR = "mediaError", bt.KEY_SYSTEM_ERROR = "keySystemError", bt.MUX_ERROR = "muxError", bt.OTHER_ERROR = "otherError"
                    })(ut || (ut = {}));
                    var lt;
                    (function(bt) {
                        bt.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", bt.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", bt.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", bt.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", bt.KEY_SYSTEM_NO_INIT_DATA = "keySystemNoInitData", bt.MANIFEST_LOAD_ERROR = "manifestLoadError", bt.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", bt.MANIFEST_PARSING_ERROR = "manifestParsingError", bt.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", bt.LEVEL_EMPTY_ERROR = "levelEmptyError", bt.LEVEL_LOAD_ERROR = "levelLoadError", bt.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", bt.LEVEL_SWITCH_ERROR = "levelSwitchError", bt.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", bt.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", bt.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", bt.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", bt.FRAG_LOAD_ERROR = "fragLoadError", bt.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", bt.FRAG_DECRYPT_ERROR = "fragDecryptError", bt.FRAG_PARSING_ERROR = "fragParsingError", bt.REMUX_ALLOC_ERROR = "remuxAllocError", bt.KEY_LOAD_ERROR = "keyLoadError", bt.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", bt.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", bt.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", bt.BUFFER_APPEND_ERROR = "bufferAppendError", bt.BUFFER_APPENDING_ERROR = "bufferAppendingError", bt.BUFFER_STALLED_ERROR = "bufferStalledError", bt.BUFFER_FULL_ERROR = "bufferFullError", bt.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", bt.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", bt.INTERNAL_EXCEPTION = "internalException", bt.INTERNAL_ABORTED = "aborted", bt.UNKNOWN = "unknown"
                    })(lt || (lt = {}))
                },
                "./src/events.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        Events: () => ut
                    });
                    var ut;
                    (function(lt) {
                        lt.MEDIA_ATTACHING = "hlsMediaAttaching", lt.MEDIA_ATTACHED = "hlsMediaAttached", lt.MEDIA_DETACHING = "hlsMediaDetaching", lt.MEDIA_DETACHED = "hlsMediaDetached", lt.BUFFER_RESET = "hlsBufferReset", lt.BUFFER_CODECS = "hlsBufferCodecs", lt.BUFFER_CREATED = "hlsBufferCreated", lt.BUFFER_APPENDING = "hlsBufferAppending", lt.BUFFER_APPENDED = "hlsBufferAppended", lt.BUFFER_EOS = "hlsBufferEos", lt.BUFFER_FLUSHING = "hlsBufferFlushing", lt.BUFFER_FLUSHED = "hlsBufferFlushed", lt.MANIFEST_LOADING = "hlsManifestLoading", lt.MANIFEST_LOADED = "hlsManifestLoaded", lt.MANIFEST_PARSED = "hlsManifestParsed", lt.LEVEL_SWITCHING = "hlsLevelSwitching", lt.LEVEL_SWITCHED = "hlsLevelSwitched", lt.LEVEL_LOADING = "hlsLevelLoading", lt.LEVEL_LOADED = "hlsLevelLoaded", lt.LEVEL_UPDATED = "hlsLevelUpdated", lt.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", lt.LEVELS_UPDATED = "hlsLevelsUpdated", lt.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", lt.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", lt.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", lt.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", lt.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", lt.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", lt.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", lt.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", lt.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", lt.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", lt.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", lt.CUES_PARSED = "hlsCuesParsed", lt.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", lt.INIT_PTS_FOUND = "hlsInitPtsFound", lt.FRAG_LOADING = "hlsFragLoading", lt.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", lt.FRAG_LOADED = "hlsFragLoaded", lt.FRAG_DECRYPTED = "hlsFragDecrypted", lt.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", lt.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", lt.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", lt.FRAG_PARSED = "hlsFragParsed", lt.FRAG_BUFFERED = "hlsFragBuffered", lt.FRAG_CHANGED = "hlsFragChanged", lt.FPS_DROP = "hlsFpsDrop", lt.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", lt.ERROR = "hlsError", lt.DESTROYING = "hlsDestroying", lt.KEY_LOADING = "hlsKeyLoading", lt.KEY_LOADED = "hlsKeyLoaded", lt.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", lt.BACK_BUFFER_REACHED = "hlsBackBufferReached"
                    })(ut || (ut = {}))
                },
                "./src/hls.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => St
                    });
                    var ut = it("./node_modules/url-toolkit/src/url-toolkit.js"),
                        lt = it("./src/loader/playlist-loader.ts"),
                        bt = it("./src/loader/key-loader.ts"),
                        pt = it("./src/controller/id3-track-controller.ts"),
                        It = it("./src/controller/latency-controller.ts"),
                        At = it("./src/controller/level-controller.ts"),
                        Ct = it("./src/controller/fragment-tracker.ts"),
                        ht = it("./src/controller/stream-controller.ts"),
                        ot = it("./src/is-supported.ts"),
                        ct = it("./src/utils/logger.ts"),
                        Et = it("./src/config.ts"),
                        Dt = it("./node_modules/eventemitter3/index.js"),
                        Pt = it("./src/events.ts"),
                        gt = it("./src/errors.ts");

                    function ft(_t, vt) {
                        for (var mt = 0; mt < vt.length; mt++) {
                            var xt = vt[mt];
                            xt.enumerable = xt.enumerable || !1, xt.configurable = !0, "value" in xt && (xt.writable = !0), Object.defineProperty(_t, xt.key, xt)
                        }
                    }

                    function dt(_t, vt, mt) {
                        return vt && ft(_t.prototype, vt), mt && ft(_t, mt), Object.defineProperty(_t, "prototype", {
                            writable: !1
                        }), _t
                    }
                    var St = function() {
                        _t.isSupported = function() {
                            return (0, ot.isSupported)()
                        };

                        function _t(mt) {
                            mt === void 0 && (mt = {}), this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new Dt.EventEmitter, this._autoLevelCapping = void 0, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null;
                            var xt = this.config = (0, Et.mergeConfig)(_t.DefaultConfig, mt);
                            this.userConfig = mt, (0, ct.enableLogs)(xt.debug, "Hls instance"), this._autoLevelCapping = -1, xt.progressive && (0, Et.enableStreamingMode)(xt);
                            var yt = xt.abrController,
                                Tt = xt.bufferController,
                                Ft = xt.capLevelController,
                                wt = xt.fpsController,
                                kt = this.abrController = new yt(this),
                                Ot = this.bufferController = new Tt(this),
                                Rt = this.capLevelController = new Ft(this),
                                Lt = new wt(this),
                                Bt = new lt.default(this),
                                Nt = new bt.default(this),
                                $t = new pt.default(this),
                                jt = this.levelController = new At.default(this),
                                Ut = new Ct.FragmentTracker(this),
                                Ht = this.streamController = new ht.default(this, Ut);
                            Rt.setStreamController(Ht), Lt.setStreamController(Ht);
                            var Wt = [Bt, Nt, jt, Ht];
                            this.networkControllers = Wt;
                            var Kt = [kt, Ot, Rt, Lt, $t, Ut];
                            this.audioTrackController = this.createController(xt.audioTrackController, null, Wt), this.createController(xt.audioStreamController, Ut, Wt), this.subtitleTrackController = this.createController(xt.subtitleTrackController, null, Wt), this.createController(xt.subtitleStreamController, Ut, Wt), this.createController(xt.timelineController, null, Kt), this.emeController = this.createController(xt.emeController, null, Kt), this.cmcdController = this.createController(xt.cmcdController, null, Kt), this.latencyController = this.createController(It.default, null, Kt), this.coreComponents = Kt
                        }
                        var vt = _t.prototype;
                        return vt.createController = function(xt, yt, Tt) {
                            if (xt) {
                                var Ft = yt ? new xt(this, yt) : new xt(this);
                                return Tt && Tt.push(Ft), Ft
                            }
                            return null
                        }, vt.on = function(xt, yt, Tt) {
                            Tt === void 0 && (Tt = this), this._emitter.on(xt, yt, Tt)
                        }, vt.once = function(xt, yt, Tt) {
                            Tt === void 0 && (Tt = this), this._emitter.once(xt, yt, Tt)
                        }, vt.removeAllListeners = function(xt) {
                            this._emitter.removeAllListeners(xt)
                        }, vt.off = function(xt, yt, Tt, Ft) {
                            Tt === void 0 && (Tt = this), this._emitter.off(xt, yt, Tt, Ft)
                        }, vt.listeners = function(xt) {
                            return this._emitter.listeners(xt)
                        }, vt.emit = function(xt, yt, Tt) {
                            return this._emitter.emit(xt, yt, Tt)
                        }, vt.trigger = function(xt, yt) {
                            if (this.config.debug) return this.emit(xt, xt, yt);
                            try {
                                return this.emit(xt, xt, yt)
                            } catch (Tt) {
                                ct.logger.error("An internal error happened while handling event " + xt + '. Error message: "' + Tt.message + '". Here is a stacktrace:', Tt), this.trigger(Pt.Events.ERROR, {
                                    type: gt.ErrorTypes.OTHER_ERROR,
                                    details: gt.ErrorDetails.INTERNAL_EXCEPTION,
                                    fatal: !1,
                                    event: xt,
                                    error: Tt
                                })
                            }
                            return !1
                        }, vt.listenerCount = function(xt) {
                            return this._emitter.listenerCount(xt)
                        }, vt.destroy = function() {
                            ct.logger.log("destroy"), this.trigger(Pt.Events.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach(function(xt) {
                                return xt.destroy()
                            }), this.networkControllers.length = 0, this.coreComponents.forEach(function(xt) {
                                return xt.destroy()
                            }), this.coreComponents.length = 0
                        }, vt.attachMedia = function(xt) {
                            ct.logger.log("attachMedia"), this._media = xt, this.trigger(Pt.Events.MEDIA_ATTACHING, {
                                media: xt
                            })
                        }, vt.detachMedia = function() {
                            ct.logger.log("detachMedia"), this.trigger(Pt.Events.MEDIA_DETACHING, void 0), this._media = null
                        }, vt.loadSource = function(xt) {
                            this.stopLoad();
                            var yt = this.media,
                                Tt = this.url,
                                Ft = this.url = ut.buildAbsoluteURL(self.location.href, xt, {
                                    alwaysNormalize: !0
                                });
                            ct.logger.log("loadSource:" + Ft), yt && Tt && Tt !== Ft && this.bufferController.hasSourceTypes() && (this.detachMedia(), this.attachMedia(yt)), this.trigger(Pt.Events.MANIFEST_LOADING, {
                                url: xt
                            })
                        }, vt.startLoad = function(xt) {
                            xt === void 0 && (xt = -1), ct.logger.log("startLoad(" + xt + ")"), this.networkControllers.forEach(function(yt) {
                                yt.startLoad(xt)
                            })
                        }, vt.stopLoad = function() {
                            ct.logger.log("stopLoad"), this.networkControllers.forEach(function(xt) {
                                xt.stopLoad()
                            })
                        }, vt.swapAudioCodec = function() {
                            ct.logger.log("swapAudioCodec"), this.streamController.swapAudioCodec()
                        }, vt.recoverMediaError = function() {
                            ct.logger.log("recoverMediaError");
                            var xt = this._media;
                            this.detachMedia(), xt && this.attachMedia(xt)
                        }, vt.removeLevel = function(xt, yt) {
                            yt === void 0 && (yt = 0), this.levelController.removeLevel(xt, yt)
                        }, dt(_t, [{
                            key: "levels",
                            get: function() {
                                var xt = this.levelController.levels;
                                return xt || []
                            }
                        }, {
                            key: "currentLevel",
                            get: function() {
                                return this.streamController.currentLevel
                            },
                            set: function(xt) {
                                ct.logger.log("set currentLevel:" + xt), this.loadLevel = xt, this.abrController.clearTimer(), this.streamController.immediateLevelSwitch()
                            }
                        }, {
                            key: "nextLevel",
                            get: function() {
                                return this.streamController.nextLevel
                            },
                            set: function(xt) {
                                ct.logger.log("set nextLevel:" + xt), this.levelController.manualLevel = xt, this.streamController.nextLevelSwitch()
                            }
                        }, {
                            key: "loadLevel",
                            get: function() {
                                return this.levelController.level
                            },
                            set: function(xt) {
                                ct.logger.log("set loadLevel:" + xt), this.levelController.manualLevel = xt
                            }
                        }, {
                            key: "nextLoadLevel",
                            get: function() {
                                return this.levelController.nextLoadLevel
                            },
                            set: function(xt) {
                                this.levelController.nextLoadLevel = xt
                            }
                        }, {
                            key: "firstLevel",
                            get: function() {
                                return Math.max(this.levelController.firstLevel, this.minAutoLevel)
                            },
                            set: function(xt) {
                                ct.logger.log("set firstLevel:" + xt), this.levelController.firstLevel = xt
                            }
                        }, {
                            key: "startLevel",
                            get: function() {
                                return this.levelController.startLevel
                            },
                            set: function(xt) {
                                ct.logger.log("set startLevel:" + xt), xt !== -1 && (xt = Math.max(xt, this.minAutoLevel)), this.levelController.startLevel = xt
                            }
                        }, {
                            key: "capLevelToPlayerSize",
                            get: function() {
                                return this.config.capLevelToPlayerSize
                            },
                            set: function(xt) {
                                var yt = !!xt;
                                yt !== this.config.capLevelToPlayerSize && (yt ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = yt)
                            }
                        }, {
                            key: "autoLevelCapping",
                            get: function() {
                                return this._autoLevelCapping
                            },
                            set: function(xt) {
                                this._autoLevelCapping !== xt && (ct.logger.log("set autoLevelCapping:" + xt), this._autoLevelCapping = xt)
                            }
                        }, {
                            key: "bandwidthEstimate",
                            get: function() {
                                var xt = this.abrController.bwEstimator;
                                return xt ? xt.getEstimate() : NaN
                            }
                        }, {
                            key: "autoLevelEnabled",
                            get: function() {
                                return this.levelController.manualLevel === -1
                            }
                        }, {
                            key: "manualLevel",
                            get: function() {
                                return this.levelController.manualLevel
                            }
                        }, {
                            key: "minAutoLevel",
                            get: function() {
                                var xt = this.levels,
                                    yt = this.config.minAutoBitrate;
                                if (!xt) return 0;
                                for (var Tt = xt.length, Ft = 0; Ft < Tt; Ft++)
                                    if (xt[Ft].maxBitrate >= yt) return Ft;
                                return 0
                            }
                        }, {
                            key: "maxAutoLevel",
                            get: function() {
                                var xt = this.levels,
                                    yt = this.autoLevelCapping,
                                    Tt;
                                return yt === -1 && xt && xt.length ? Tt = xt.length - 1 : Tt = yt, Tt
                            }
                        }, {
                            key: "nextAutoLevel",
                            get: function() {
                                return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel)
                            },
                            set: function(xt) {
                                this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, xt)
                            }
                        }, {
                            key: "playingDate",
                            get: function() {
                                return this.streamController.currentProgramDateTime
                            }
                        }, {
                            key: "mainForwardBufferInfo",
                            get: function() {
                                return this.streamController.getMainFwdBufferInfo()
                            }
                        }, {
                            key: "audioTracks",
                            get: function() {
                                var xt = this.audioTrackController;
                                return xt ? xt.audioTracks : []
                            }
                        }, {
                            key: "audioTrack",
                            get: function() {
                                var xt = this.audioTrackController;
                                return xt ? xt.audioTrack : -1
                            },
                            set: function(xt) {
                                var yt = this.audioTrackController;
                                yt && (yt.audioTrack = xt)
                            }
                        }, {
                            key: "subtitleTracks",
                            get: function() {
                                var xt = this.subtitleTrackController;
                                return xt ? xt.subtitleTracks : []
                            }
                        }, {
                            key: "subtitleTrack",
                            get: function() {
                                var xt = this.subtitleTrackController;
                                return xt ? xt.subtitleTrack : -1
                            },
                            set: function(xt) {
                                var yt = this.subtitleTrackController;
                                yt && (yt.subtitleTrack = xt)
                            }
                        }, {
                            key: "media",
                            get: function() {
                                return this._media
                            }
                        }, {
                            key: "subtitleDisplay",
                            get: function() {
                                var xt = this.subtitleTrackController;
                                return xt ? xt.subtitleDisplay : !1
                            },
                            set: function(xt) {
                                var yt = this.subtitleTrackController;
                                yt && (yt.subtitleDisplay = xt)
                            }
                        }, {
                            key: "lowLatencyMode",
                            get: function() {
                                return this.config.lowLatencyMode
                            },
                            set: function(xt) {
                                this.config.lowLatencyMode = xt
                            }
                        }, {
                            key: "liveSyncPosition",
                            get: function() {
                                return this.latencyController.liveSyncPosition
                            }
                        }, {
                            key: "latency",
                            get: function() {
                                return this.latencyController.latency
                            }
                        }, {
                            key: "maxLatency",
                            get: function() {
                                return this.latencyController.maxLatency
                            }
                        }, {
                            key: "targetLatency",
                            get: function() {
                                return this.latencyController.targetLatency
                            }
                        }, {
                            key: "drift",
                            get: function() {
                                return this.latencyController.drift
                            }
                        }, {
                            key: "forceStartLoad",
                            get: function() {
                                return this.streamController.forceStartLoad
                            }
                        }], [{
                            key: "version",
                            get: function() {
                                return "1.2.9"
                            }
                        }, {
                            key: "Events",
                            get: function() {
                                return Pt.Events
                            }
                        }, {
                            key: "ErrorTypes",
                            get: function() {
                                return gt.ErrorTypes
                            }
                        }, {
                            key: "ErrorDetails",
                            get: function() {
                                return gt.ErrorDetails
                            }
                        }, {
                            key: "DefaultConfig",
                            get: function() {
                                return _t.defaultConfig ? _t.defaultConfig : Et.hlsDefaultConfig
                            },
                            set: function(xt) {
                                _t.defaultConfig = xt
                            }
                        }]), _t
                    }();
                    St.defaultConfig = void 0
                },
                "./src/is-supported.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        changeTypeSupported: () => pt,
                        isSupported: () => bt
                    });
                    var ut = it("./src/utils/mediasource-helper.ts");

                    function lt() {
                        return self.SourceBuffer || self.WebKitSourceBuffer
                    }

                    function bt() {
                        var It = (0, ut.getMediaSource)();
                        if (!It) return !1;
                        var At = lt(),
                            Ct = It && typeof It.isTypeSupported == "function" && It.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'),
                            ht = !At || At.prototype && typeof At.prototype.appendBuffer == "function" && typeof At.prototype.remove == "function";
                        return !!Ct && !!ht
                    }

                    function pt() {
                        var It, At = lt();
                        return typeof(At == null || (It = At.prototype) === null || It === void 0 ? void 0 : It.changeType) == "function"
                    }
                },
                "./src/loader/date-range.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        DateRange: () => ht,
                        DateRangeAttribute: () => Ct
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/utils/attr-list.ts"),
                        bt = it("./src/utils/logger.ts");

                    function pt() {
                        return pt = Object.assign ? Object.assign.bind() : function(ot) {
                            for (var ct = 1; ct < arguments.length; ct++) {
                                var Et = arguments[ct];
                                for (var Dt in Et) Object.prototype.hasOwnProperty.call(Et, Dt) && (ot[Dt] = Et[Dt])
                            }
                            return ot
                        }, pt.apply(this, arguments)
                    }

                    function It(ot, ct) {
                        for (var Et = 0; Et < ct.length; Et++) {
                            var Dt = ct[Et];
                            Dt.enumerable = Dt.enumerable || !1, Dt.configurable = !0, "value" in Dt && (Dt.writable = !0), Object.defineProperty(ot, Dt.key, Dt)
                        }
                    }

                    function At(ot, ct, Et) {
                        return ct && It(ot.prototype, ct), Et && It(ot, Et), Object.defineProperty(ot, "prototype", {
                            writable: !1
                        }), ot
                    }
                    var Ct;
                    (function(ot) {
                        ot.ID = "ID", ot.CLASS = "CLASS", ot.START_DATE = "START-DATE", ot.DURATION = "DURATION", ot.END_DATE = "END-DATE", ot.END_ON_NEXT = "END-ON-NEXT", ot.PLANNED_DURATION = "PLANNED-DURATION", ot.SCTE35_OUT = "SCTE35-OUT", ot.SCTE35_IN = "SCTE35-IN"
                    })(Ct || (Ct = {}));
                    var ht = function() {
                        function ot(ct, Et) {
                            if (this.attr = void 0, this._startDate = void 0, this._endDate = void 0, this._badValueForSameId = void 0, Et) {
                                var Dt = Et.attr;
                                for (var Pt in Dt)
                                    if (Object.prototype.hasOwnProperty.call(ct, Pt) && ct[Pt] !== Dt[Pt]) {
                                        bt.logger.warn('DATERANGE tag attribute: "' + Pt + '" does not match for tags with ID: "' + ct.ID + '"'), this._badValueForSameId = Pt;
                                        break
                                    } ct = pt(new lt.AttrList({}), Dt, ct)
                            }
                            if (this.attr = ct, this._startDate = new Date(ct[Ct.START_DATE]), Ct.END_DATE in this.attr) {
                                var gt = new Date(this.attr[Ct.END_DATE]);
                                (0, ut.isFiniteNumber)(gt.getTime()) && (this._endDate = gt)
                            }
                        }
                        return At(ot, [{
                            key: "id",
                            get: function() {
                                return this.attr.ID
                            }
                        }, {
                            key: "class",
                            get: function() {
                                return this.attr.CLASS
                            }
                        }, {
                            key: "startDate",
                            get: function() {
                                return this._startDate
                            }
                        }, {
                            key: "endDate",
                            get: function() {
                                if (this._endDate) return this._endDate;
                                var Et = this.duration;
                                return Et !== null ? new Date(this._startDate.getTime() + Et * 1e3) : null
                            }
                        }, {
                            key: "duration",
                            get: function() {
                                if (Ct.DURATION in this.attr) {
                                    var Et = this.attr.decimalFloatingPoint(Ct.DURATION);
                                    if ((0, ut.isFiniteNumber)(Et)) return Et
                                } else if (this._endDate) return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
                                return null
                            }
                        }, {
                            key: "plannedDuration",
                            get: function() {
                                return Ct.PLANNED_DURATION in this.attr ? this.attr.decimalFloatingPoint(Ct.PLANNED_DURATION) : null
                            }
                        }, {
                            key: "endOnNext",
                            get: function() {
                                return this.attr.bool(Ct.END_ON_NEXT)
                            }
                        }, {
                            key: "isValid",
                            get: function() {
                                return !!this.id && !this._badValueForSameId && (0, ut.isFiniteNumber)(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class)
                            }
                        }]), ot
                    }()
                },
                "./src/loader/fragment-loader.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        LoadError: () => Pt,
                        default: () => Et
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/errors.ts");

                    function bt(gt, ft) {
                        gt.prototype = Object.create(ft.prototype), gt.prototype.constructor = gt, ht(gt, ft)
                    }

                    function pt(gt) {
                        var ft = typeof Map == "function" ? new Map : void 0;
                        return pt = function(St) {
                            if (St === null || !Ct(St)) return St;
                            if (typeof St != "function") throw new TypeError("Super expression must either be null or a function");
                            if (typeof ft < "u") {
                                if (ft.has(St)) return ft.get(St);
                                ft.set(St, _t)
                            }

                            function _t() {
                                return It(St, arguments, ot(this).constructor)
                            }
                            return _t.prototype = Object.create(St.prototype, {
                                constructor: {
                                    value: _t,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), ht(_t, St)
                        }, pt(gt)
                    }

                    function It(gt, ft, dt) {
                        return At() ? It = Reflect.construct.bind() : It = function(_t, vt, mt) {
                            var xt = [null];
                            xt.push.apply(xt, vt);
                            var yt = Function.bind.apply(_t, xt),
                                Tt = new yt;
                            return mt && ht(Tt, mt.prototype), Tt
                        }, It.apply(null, arguments)
                    }

                    function At() {
                        if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
                        if (typeof Proxy == "function") return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
                        } catch {
                            return !1
                        }
                    }

                    function Ct(gt) {
                        return Function.toString.call(gt).indexOf("[native code]") !== -1
                    }

                    function ht(gt, ft) {
                        return ht = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(St, _t) {
                            return St.__proto__ = _t, St
                        }, ht(gt, ft)
                    }

                    function ot(gt) {
                        return ot = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(dt) {
                            return dt.__proto__ || Object.getPrototypeOf(dt)
                        }, ot(gt)
                    }
                    var ct = Math.pow(2, 17),
                        Et = function() {
                            function gt(dt) {
                                this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = dt
                            }
                            var ft = gt.prototype;
                            return ft.destroy = function() {
                                this.loader && (this.loader.destroy(), this.loader = null)
                            }, ft.abort = function() {
                                this.loader && this.loader.abort()
                            }, ft.load = function(St, _t) {
                                var vt = this,
                                    mt = St.url;
                                if (!mt) return Promise.reject(new Pt({
                                    type: lt.ErrorTypes.NETWORK_ERROR,
                                    details: lt.ErrorDetails.FRAG_LOAD_ERROR,
                                    fatal: !1,
                                    frag: St,
                                    networkDetails: null
                                }, "Fragment does not have a " + (mt ? "part list" : "url")));
                                this.abort();
                                var xt = this.config,
                                    yt = xt.fLoader,
                                    Tt = xt.loader;
                                return new Promise(function(Ft, wt) {
                                    vt.loader && vt.loader.destroy();
                                    var kt = vt.loader = St.loader = yt ? new yt(xt) : new Tt(xt),
                                        Ot = Dt(St),
                                        Rt = {
                                            timeout: xt.fragLoadingTimeOut,
                                            maxRetry: 0,
                                            retryDelay: 0,
                                            maxRetryDelay: xt.fragLoadingMaxRetryTimeout,
                                            highWaterMark: St.sn === "initSegment" ? 1 / 0 : ct
                                        };
                                    St.stats = kt.stats, kt.load(Ot, Rt, {
                                        onSuccess: function(Bt, Nt, $t, jt) {
                                            vt.resetLoader(St, kt), Ft({
                                                frag: St,
                                                part: null,
                                                payload: Bt.data,
                                                networkDetails: jt
                                            })
                                        },
                                        onError: function(Bt, Nt, $t) {
                                            vt.resetLoader(St, kt), wt(new Pt({
                                                type: lt.ErrorTypes.NETWORK_ERROR,
                                                details: lt.ErrorDetails.FRAG_LOAD_ERROR,
                                                fatal: !1,
                                                frag: St,
                                                response: Bt,
                                                networkDetails: $t
                                            }))
                                        },
                                        onAbort: function(Bt, Nt, $t) {
                                            vt.resetLoader(St, kt), wt(new Pt({
                                                type: lt.ErrorTypes.NETWORK_ERROR,
                                                details: lt.ErrorDetails.INTERNAL_ABORTED,
                                                fatal: !1,
                                                frag: St,
                                                networkDetails: $t
                                            }))
                                        },
                                        onTimeout: function(Bt, Nt, $t) {
                                            vt.resetLoader(St, kt), wt(new Pt({
                                                type: lt.ErrorTypes.NETWORK_ERROR,
                                                details: lt.ErrorDetails.FRAG_LOAD_TIMEOUT,
                                                fatal: !1,
                                                frag: St,
                                                networkDetails: $t
                                            }))
                                        },
                                        onProgress: function(Bt, Nt, $t, jt) {
                                            _t && _t({
                                                frag: St,
                                                part: null,
                                                payload: $t,
                                                networkDetails: jt
                                            })
                                        }
                                    })
                                })
                            }, ft.loadPart = function(St, _t, vt) {
                                var mt = this;
                                this.abort();
                                var xt = this.config,
                                    yt = xt.fLoader,
                                    Tt = xt.loader;
                                return new Promise(function(Ft, wt) {
                                    mt.loader && mt.loader.destroy();
                                    var kt = mt.loader = St.loader = yt ? new yt(xt) : new Tt(xt),
                                        Ot = Dt(St, _t),
                                        Rt = {
                                            timeout: xt.fragLoadingTimeOut,
                                            maxRetry: 0,
                                            retryDelay: 0,
                                            maxRetryDelay: xt.fragLoadingMaxRetryTimeout,
                                            highWaterMark: ct
                                        };
                                    _t.stats = kt.stats, kt.load(Ot, Rt, {
                                        onSuccess: function(Bt, Nt, $t, jt) {
                                            mt.resetLoader(St, kt), mt.updateStatsFromPart(St, _t);
                                            var Ut = {
                                                frag: St,
                                                part: _t,
                                                payload: Bt.data,
                                                networkDetails: jt
                                            };
                                            vt(Ut), Ft(Ut)
                                        },
                                        onError: function(Bt, Nt, $t) {
                                            mt.resetLoader(St, kt), wt(new Pt({
                                                type: lt.ErrorTypes.NETWORK_ERROR,
                                                details: lt.ErrorDetails.FRAG_LOAD_ERROR,
                                                fatal: !1,
                                                frag: St,
                                                part: _t,
                                                response: Bt,
                                                networkDetails: $t
                                            }))
                                        },
                                        onAbort: function(Bt, Nt, $t) {
                                            St.stats.aborted = _t.stats.aborted, mt.resetLoader(St, kt), wt(new Pt({
                                                type: lt.ErrorTypes.NETWORK_ERROR,
                                                details: lt.ErrorDetails.INTERNAL_ABORTED,
                                                fatal: !1,
                                                frag: St,
                                                part: _t,
                                                networkDetails: $t
                                            }))
                                        },
                                        onTimeout: function(Bt, Nt, $t) {
                                            mt.resetLoader(St, kt), wt(new Pt({
                                                type: lt.ErrorTypes.NETWORK_ERROR,
                                                details: lt.ErrorDetails.FRAG_LOAD_TIMEOUT,
                                                fatal: !1,
                                                frag: St,
                                                part: _t,
                                                networkDetails: $t
                                            }))
                                        }
                                    })
                                })
                            }, ft.updateStatsFromPart = function(St, _t) {
                                var vt = St.stats,
                                    mt = _t.stats,
                                    xt = mt.total;
                                if (vt.loaded += mt.loaded, xt) {
                                    var yt = Math.round(St.duration / _t.duration),
                                        Tt = Math.min(Math.round(vt.loaded / xt), yt),
                                        Ft = yt - Tt,
                                        wt = Ft * Math.round(vt.loaded / Tt);
                                    vt.total = vt.loaded + wt
                                } else vt.total = Math.max(vt.loaded, vt.total);
                                var kt = vt.loading,
                                    Ot = mt.loading;
                                kt.start ? kt.first += Ot.first - Ot.start : (kt.start = Ot.start, kt.first = Ot.first), kt.end = Ot.end
                            }, ft.resetLoader = function(St, _t) {
                                St.loader = null, this.loader === _t && (self.clearTimeout(this.partLoadTimeout), this.loader = null), _t.destroy()
                            }, gt
                        }();

                    function Dt(gt, ft) {
                        ft === void 0 && (ft = null);
                        var dt = ft || gt,
                            St = {
                                frag: gt,
                                part: ft,
                                responseType: "arraybuffer",
                                url: dt.url,
                                headers: {},
                                rangeStart: 0,
                                rangeEnd: 0
                            },
                            _t = dt.byteRangeStartOffset,
                            vt = dt.byteRangeEndOffset;
                        return (0, ut.isFiniteNumber)(_t) && (0, ut.isFiniteNumber)(vt) && (St.rangeStart = _t, St.rangeEnd = vt), St
                    }
                    var Pt = function(gt) {
                        bt(ft, gt);

                        function ft(dt) {
                            for (var St, _t = arguments.length, vt = new Array(_t > 1 ? _t - 1 : 0), mt = 1; mt < _t; mt++) vt[mt - 1] = arguments[mt];
                            return St = gt.call.apply(gt, [this].concat(vt)) || this, St.data = void 0, St.data = dt, St
                        }
                        return ft
                    }(pt(Error))
                },
                "./src/loader/fragment.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        BaseSegment: () => Et,
                        ElementaryStreamTypes: () => ct,
                        Fragment: () => Dt,
                        Part: () => Pt
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./node_modules/url-toolkit/src/url-toolkit.js"),
                        bt = it("./src/utils/logger.ts"),
                        pt = it("./src/loader/level-key.ts"),
                        It = it("./src/loader/load-stats.ts");

                    function At(gt, ft) {
                        gt.prototype = Object.create(ft.prototype), gt.prototype.constructor = gt, Ct(gt, ft)
                    }

                    function Ct(gt, ft) {
                        return Ct = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(St, _t) {
                            return St.__proto__ = _t, St
                        }, Ct(gt, ft)
                    }

                    function ht(gt, ft) {
                        for (var dt = 0; dt < ft.length; dt++) {
                            var St = ft[dt];
                            St.enumerable = St.enumerable || !1, St.configurable = !0, "value" in St && (St.writable = !0), Object.defineProperty(gt, St.key, St)
                        }
                    }

                    function ot(gt, ft, dt) {
                        return ft && ht(gt.prototype, ft), dt && ht(gt, dt), Object.defineProperty(gt, "prototype", {
                            writable: !1
                        }), gt
                    }
                    var ct;
                    (function(gt) {
                        gt.AUDIO = "audio", gt.VIDEO = "video", gt.AUDIOVIDEO = "audiovideo"
                    })(ct || (ct = {}));
                    var Et = function() {
                            function gt(dt) {
                                var St;
                                this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = (St = {}, St[ct.AUDIO] = null, St[ct.VIDEO] = null, St[ct.AUDIOVIDEO] = null, St), this.baseurl = dt
                            }
                            var ft = gt.prototype;
                            return ft.setByteRange = function(St, _t) {
                                var vt = St.split("@", 2),
                                    mt = [];
                                vt.length === 1 ? mt[0] = _t ? _t.byteRangeEndOffset : 0 : mt[0] = parseInt(vt[1]), mt[1] = parseInt(vt[0]) + mt[0], this._byteRange = mt
                            }, ot(gt, [{
                                key: "byteRange",
                                get: function() {
                                    return this._byteRange ? this._byteRange : []
                                }
                            }, {
                                key: "byteRangeStartOffset",
                                get: function() {
                                    return this.byteRange[0]
                                }
                            }, {
                                key: "byteRangeEndOffset",
                                get: function() {
                                    return this.byteRange[1]
                                }
                            }, {
                                key: "url",
                                get: function() {
                                    return !this._url && this.baseurl && this.relurl && (this._url = (0, lt.buildAbsoluteURL)(this.baseurl, this.relurl, {
                                        alwaysNormalize: !0
                                    })), this._url || ""
                                },
                                set: function(St) {
                                    this._url = St
                                }
                            }]), gt
                        }(),
                        Dt = function(gt) {
                            At(ft, gt);

                            function ft(St, _t) {
                                var vt;
                                return vt = gt.call(this, _t) || this, vt._decryptdata = null, vt.rawProgramDateTime = null, vt.programDateTime = null, vt.tagList = [], vt.duration = 0, vt.sn = 0, vt.levelkey = void 0, vt.type = void 0, vt.loader = null, vt.level = -1, vt.cc = 0, vt.startPTS = void 0, vt.endPTS = void 0, vt.appendedPTS = void 0, vt.startDTS = void 0, vt.endDTS = void 0, vt.start = 0, vt.deltaPTS = void 0, vt.maxStartPTS = void 0, vt.minEndPTS = void 0, vt.stats = new It.LoadStats, vt.urlId = 0, vt.data = void 0, vt.bitrateTest = !1, vt.title = null, vt.initSegment = null, vt.type = St, vt
                            }
                            var dt = ft.prototype;
                            return dt.createInitializationVector = function(_t) {
                                for (var vt = new Uint8Array(16), mt = 12; mt < 16; mt++) vt[mt] = _t >> 8 * (15 - mt) & 255;
                                return vt
                            }, dt.setDecryptDataFromLevelKey = function(_t, vt) {
                                var mt = _t;
                                return (_t == null ? void 0 : _t.method) === "AES-128" && _t.uri && !_t.iv && (mt = pt.LevelKey.fromURI(_t.uri), mt.method = _t.method, mt.iv = this.createInitializationVector(vt), mt.keyFormat = "identity"), mt
                            }, dt.setElementaryStreamInfo = function(_t, vt, mt, xt, yt, Tt) {
                                Tt === void 0 && (Tt = !1);
                                var Ft = this.elementaryStreams,
                                    wt = Ft[_t];
                                if (!wt) {
                                    Ft[_t] = {
                                        startPTS: vt,
                                        endPTS: mt,
                                        startDTS: xt,
                                        endDTS: yt,
                                        partial: Tt
                                    };
                                    return
                                }
                                wt.startPTS = Math.min(wt.startPTS, vt), wt.endPTS = Math.max(wt.endPTS, mt), wt.startDTS = Math.min(wt.startDTS, xt), wt.endDTS = Math.max(wt.endDTS, yt)
                            }, dt.clearElementaryStreamInfo = function() {
                                var _t = this.elementaryStreams;
                                _t[ct.AUDIO] = null, _t[ct.VIDEO] = null, _t[ct.AUDIOVIDEO] = null
                            }, ot(ft, [{
                                key: "decryptdata",
                                get: function() {
                                    if (!this.levelkey && !this._decryptdata) return null;
                                    if (!this._decryptdata && this.levelkey) {
                                        var _t = this.sn;
                                        typeof _t != "number" && (this.levelkey && this.levelkey.method === "AES-128" && !this.levelkey.iv && bt.logger.warn('missing IV for initialization segment with method="' + this.levelkey.method + '" - compliance issue'), _t = 0), this._decryptdata = this.setDecryptDataFromLevelKey(this.levelkey, _t)
                                    }
                                    return this._decryptdata
                                }
                            }, {
                                key: "end",
                                get: function() {
                                    return this.start + this.duration
                                }
                            }, {
                                key: "endProgramDateTime",
                                get: function() {
                                    if (this.programDateTime === null || !(0, ut.isFiniteNumber)(this.programDateTime)) return null;
                                    var _t = (0, ut.isFiniteNumber)(this.duration) ? this.duration : 0;
                                    return this.programDateTime + _t * 1e3
                                }
                            }, {
                                key: "encrypted",
                                get: function() {
                                    var _t;
                                    return !!((_t = this.decryptdata) !== null && _t !== void 0 && _t.keyFormat && this.decryptdata.uri)
                                }
                            }]), ft
                        }(Et),
                        Pt = function(gt) {
                            At(ft, gt);

                            function ft(dt, St, _t, vt, mt) {
                                var xt;
                                xt = gt.call(this, _t) || this, xt.fragOffset = 0, xt.duration = 0, xt.gap = !1, xt.independent = !1, xt.relurl = void 0, xt.fragment = void 0, xt.index = void 0, xt.stats = new It.LoadStats, xt.duration = dt.decimalFloatingPoint("DURATION"), xt.gap = dt.bool("GAP"), xt.independent = dt.bool("INDEPENDENT"), xt.relurl = dt.enumeratedString("URI"), xt.fragment = St, xt.index = vt;
                                var yt = dt.enumeratedString("BYTERANGE");
                                return yt && xt.setByteRange(yt, mt), mt && (xt.fragOffset = mt.fragOffset + mt.duration), xt
                            }
                            return ot(ft, [{
                                key: "start",
                                get: function() {
                                    return this.fragment.start + this.fragOffset
                                }
                            }, {
                                key: "end",
                                get: function() {
                                    return this.start + this.duration
                                }
                            }, {
                                key: "loaded",
                                get: function() {
                                    var St = this.elementaryStreams;
                                    return !!(St.audio || St.video || St.audiovideo)
                                }
                            }]), ft
                        }(Et)
                },
                "./src/loader/key-loader.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => pt
                    });
                    var ut = it("./src/events.ts"),
                        lt = it("./src/errors.ts"),
                        bt = it("./src/utils/logger.ts"),
                        pt = function() {
                            function It(Ct) {
                                this.hls = void 0, this.loaders = {}, this.decryptkey = null, this.decrypturl = null, this.hls = Ct, this.registerListeners()
                            }
                            var At = It.prototype;
                            return At.startLoad = function(ht) {}, At.stopLoad = function() {
                                this.destroyInternalLoaders()
                            }, At.registerListeners = function() {
                                this.hls.on(ut.Events.KEY_LOADING, this.onKeyLoading, this)
                            }, At.unregisterListeners = function() {
                                this.hls.off(ut.Events.KEY_LOADING, this.onKeyLoading)
                            }, At.destroyInternalLoaders = function() {
                                for (var ht in this.loaders) {
                                    var ot = this.loaders[ht];
                                    ot && ot.destroy()
                                }
                                this.loaders = {}
                            }, At.destroy = function() {
                                this.unregisterListeners(), this.destroyInternalLoaders()
                            }, At.onKeyLoading = function(ht, ot) {
                                var ct = ot.frag,
                                    Et = ct.type,
                                    Dt = this.loaders[Et];
                                if (!ct.decryptdata) {
                                    bt.logger.warn("Missing decryption data on fragment in onKeyLoading");
                                    return
                                }
                                var Pt = ct.decryptdata.uri;
                                if (Pt !== this.decrypturl || this.decryptkey === null) {
                                    var gt = this.hls.config;
                                    if (Dt && (bt.logger.warn("abort previous key loader for type:" + Et), Dt.abort()), !Pt) {
                                        bt.logger.warn("key uri is falsy");
                                        return
                                    }
                                    var ft = gt.loader,
                                        dt = ct.loader = this.loaders[Et] = new ft(gt);
                                    this.decrypturl = Pt, this.decryptkey = null;
                                    var St = {
                                            url: Pt,
                                            frag: ct,
                                            responseType: "arraybuffer"
                                        },
                                        _t = {
                                            timeout: gt.fragLoadingTimeOut,
                                            maxRetry: 0,
                                            retryDelay: gt.fragLoadingRetryDelay,
                                            maxRetryDelay: gt.fragLoadingMaxRetryTimeout,
                                            highWaterMark: 0
                                        },
                                        vt = {
                                            onSuccess: this.loadsuccess.bind(this),
                                            onError: this.loaderror.bind(this),
                                            onTimeout: this.loadtimeout.bind(this)
                                        };
                                    dt.load(St, _t, vt)
                                } else this.decryptkey && (ct.decryptdata.key = this.decryptkey, this.hls.trigger(ut.Events.KEY_LOADED, {
                                    frag: ct
                                }))
                            }, At.loadsuccess = function(ht, ot, ct) {
                                var Et = ct.frag;
                                if (!Et.decryptdata) {
                                    bt.logger.error("after key load, decryptdata unset");
                                    return
                                }
                                this.decryptkey = Et.decryptdata.key = new Uint8Array(ht.data), Et.loader = null, delete this.loaders[Et.type], this.hls.trigger(ut.Events.KEY_LOADED, {
                                    frag: Et
                                })
                            }, At.loaderror = function(ht, ot) {
                                var ct = ot.frag,
                                    Et = ct.loader;
                                Et && Et.abort(), delete this.loaders[ct.type], this.hls.trigger(ut.Events.ERROR, {
                                    type: lt.ErrorTypes.NETWORK_ERROR,
                                    details: lt.ErrorDetails.KEY_LOAD_ERROR,
                                    fatal: !1,
                                    frag: ct,
                                    response: ht
                                })
                            }, At.loadtimeout = function(ht, ot) {
                                var ct = ot.frag,
                                    Et = ct.loader;
                                Et && Et.abort(), delete this.loaders[ct.type], this.hls.trigger(ut.Events.ERROR, {
                                    type: lt.ErrorTypes.NETWORK_ERROR,
                                    details: lt.ErrorDetails.KEY_LOAD_TIMEOUT,
                                    fatal: !1,
                                    frag: ct
                                })
                            }, It
                        }()
                },
                "./src/loader/level-details.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        LevelDetails: () => It
                    });
                    var ut = it("./src/polyfills/number.ts");

                    function lt(At, Ct) {
                        for (var ht = 0; ht < Ct.length; ht++) {
                            var ot = Ct[ht];
                            ot.enumerable = ot.enumerable || !1, ot.configurable = !0, "value" in ot && (ot.writable = !0), Object.defineProperty(At, ot.key, ot)
                        }
                    }

                    function bt(At, Ct, ht) {
                        return Ct && lt(At.prototype, Ct), ht && lt(At, ht), Object.defineProperty(At, "prototype", {
                            writable: !1
                        }), At
                    }
                    var pt = 10,
                        It = function() {
                            function At(ht) {
                                this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.live = !0, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.availabilityDelay = void 0, this.misses = 0, this.needSidxRanges = !1, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.fragments = [], this.dateRanges = {}, this.url = ht
                            }
                            var Ct = At.prototype;
                            return Ct.reloaded = function(ot) {
                                if (!ot) {
                                    this.advanced = !0, this.updated = !0;
                                    return
                                }
                                var ct = this.lastPartSn - ot.lastPartSn,
                                    Et = this.lastPartIndex - ot.lastPartIndex;
                                this.updated = this.endSN !== ot.endSN || !!Et || !!ct, this.advanced = this.endSN > ot.endSN || ct > 0 || ct === 0 && Et > 0, this.updated || this.advanced ? this.misses = Math.floor(ot.misses * .6) : this.misses = ot.misses + 1, this.availabilityDelay = ot.availabilityDelay
                            }, bt(At, [{
                                key: "hasProgramDateTime",
                                get: function() {
                                    return this.fragments.length ? (0, ut.isFiniteNumber)(this.fragments[this.fragments.length - 1].programDateTime) : !1
                                }
                            }, {
                                key: "levelTargetDuration",
                                get: function() {
                                    return this.averagetargetduration || this.targetduration || pt
                                }
                            }, {
                                key: "drift",
                                get: function() {
                                    var ot = this.driftEndTime - this.driftStartTime;
                                    if (ot > 0) {
                                        var ct = this.driftEnd - this.driftStart;
                                        return ct * 1e3 / ot
                                    }
                                    return 1
                                }
                            }, {
                                key: "edge",
                                get: function() {
                                    return this.partEnd || this.fragmentEnd
                                }
                            }, {
                                key: "partEnd",
                                get: function() {
                                    var ot;
                                    return (ot = this.partList) !== null && ot !== void 0 && ot.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd
                                }
                            }, {
                                key: "fragmentEnd",
                                get: function() {
                                    var ot;
                                    return (ot = this.fragments) !== null && ot !== void 0 && ot.length ? this.fragments[this.fragments.length - 1].end : 0
                                }
                            }, {
                                key: "age",
                                get: function() {
                                    return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0
                                }
                            }, {
                                key: "lastPartIndex",
                                get: function() {
                                    var ot;
                                    return (ot = this.partList) !== null && ot !== void 0 && ot.length ? this.partList[this.partList.length - 1].index : -1
                                }
                            }, {
                                key: "lastPartSn",
                                get: function() {
                                    var ot;
                                    return (ot = this.partList) !== null && ot !== void 0 && ot.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN
                                }
                            }]), At
                        }()
                },
                "./src/loader/level-key.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        LevelKey: () => pt
                    });
                    var ut = it("./node_modules/url-toolkit/src/url-toolkit.js");

                    function lt(It, At) {
                        for (var Ct = 0; Ct < At.length; Ct++) {
                            var ht = At[Ct];
                            ht.enumerable = ht.enumerable || !1, ht.configurable = !0, "value" in ht && (ht.writable = !0), Object.defineProperty(It, ht.key, ht)
                        }
                    }

                    function bt(It, At, Ct) {
                        return At && lt(It.prototype, At), Ct && lt(It, Ct), Object.defineProperty(It, "prototype", {
                            writable: !1
                        }), It
                    }
                    var pt = function() {
                        It.fromURL = function(Ct, ht) {
                            return new It(Ct, ht)
                        }, It.fromURI = function(Ct) {
                            return new It(Ct)
                        };

                        function It(At, Ct) {
                            this._uri = null, this.method = null, this.keyFormat = null, this.keyFormatVersions = null, this.keyID = null, this.key = null, this.iv = null, Ct ? this._uri = (0, ut.buildAbsoluteURL)(At, Ct, {
                                alwaysNormalize: !0
                            }) : this._uri = At
                        }
                        return bt(It, [{
                            key: "uri",
                            get: function() {
                                return this._uri
                            }
                        }]), It
                    }()
                },
                "./src/loader/load-stats.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        LoadStats: () => ut
                    });
                    var ut = function() {
                        this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {
                            start: 0,
                            first: 0,
                            end: 0
                        }, this.parsing = {
                            start: 0,
                            end: 0
                        }, this.buffering = {
                            start: 0,
                            first: 0,
                            end: 0
                        }
                    }
                },
                "./src/loader/m3u8-parser.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => dt
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./node_modules/url-toolkit/src/url-toolkit.js"),
                        bt = it("./src/loader/date-range.ts"),
                        pt = it("./src/loader/fragment.ts"),
                        It = it("./src/loader/level-details.ts"),
                        At = it("./src/loader/level-key.ts"),
                        Ct = it("./src/utils/attr-list.ts"),
                        ht = it("./src/utils/logger.ts"),
                        ot = it("./src/utils/codecs.ts"),
                        ct = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-SESSION-DATA:([^\r\n]*)[\r\n]+/g,
                        Et = /#EXT-X-MEDIA:(.*)/g,
                        Dt = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"), "g"),
                        Pt = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|")),
                        gt = /\.(mp4|m4s|m4v|m4a)$/i;

                    function ft(yt) {
                        var Tt, Ft;
                        return gt.test((Tt = (Ft = lt.parseURL(yt)) === null || Ft === void 0 ? void 0 : Ft.path) != null ? Tt : "")
                    }
                    var dt = function() {
                        function yt() {}
                        return yt.findGroup = function(Ft, wt) {
                            for (var kt = 0; kt < Ft.length; kt++) {
                                var Ot = Ft[kt];
                                if (Ot.id === wt) return Ot
                            }
                        }, yt.convertAVC1ToAVCOTI = function(Ft) {
                            var wt = Ft.split(".");
                            if (wt.length > 2) {
                                var kt = wt.shift() + ".";
                                return kt += parseInt(wt.shift()).toString(16), kt += ("000" + parseInt(wt.shift()).toString(16)).slice(-4), kt
                            }
                            return Ft
                        }, yt.resolve = function(Ft, wt) {
                            return lt.buildAbsoluteURL(wt, Ft, {
                                alwaysNormalize: !0
                            })
                        }, yt.parseMasterPlaylist = function(Ft, wt) {
                            var kt = [],
                                Ot = [],
                                Rt = {},
                                Lt = !1;
                            ct.lastIndex = 0;
                            for (var Bt;
                                (Bt = ct.exec(Ft)) != null;)
                                if (Bt[1]) {
                                    var Nt, $t = new Ct.AttrList(Bt[1]),
                                        jt = {
                                            attrs: $t,
                                            bitrate: $t.decimalInteger("AVERAGE-BANDWIDTH") || $t.decimalInteger("BANDWIDTH"),
                                            name: $t.NAME,
                                            url: yt.resolve(Bt[2], wt)
                                        },
                                        Ut = $t.decimalResolution("RESOLUTION");
                                    Ut && (jt.width = Ut.width, jt.height = Ut.height), St(($t.CODECS || "").split(/[ ,]+/).filter(function(Kt) {
                                        return Kt
                                    }), jt), jt.videoCodec && jt.videoCodec.indexOf("avc1") !== -1 && (jt.videoCodec = yt.convertAVC1ToAVCOTI(jt.videoCodec)), (Nt = jt.unknownCodecs) !== null && Nt !== void 0 && Nt.length || Ot.push(jt), kt.push(jt)
                                } else if (Bt[3]) {
                                var Ht = new Ct.AttrList(Bt[3]);
                                Ht["DATA-ID"] && (Lt = !0, Rt[Ht["DATA-ID"]] = Ht)
                            }
                            var Wt = Ot.length > 0 && Ot.length < kt.length;
                            return {
                                levels: Wt ? Ot : kt,
                                sessionData: Lt ? Rt : null
                            }
                        }, yt.parseMasterPlaylistMedia = function(Ft, wt, kt, Ot) {
                            Ot === void 0 && (Ot = []);
                            var Rt, Lt = [],
                                Bt = 0;
                            for (Et.lastIndex = 0;
                                (Rt = Et.exec(Ft)) !== null;) {
                                var Nt = new Ct.AttrList(Rt[1]);
                                if (Nt.TYPE === kt) {
                                    var $t = {
                                        attrs: Nt,
                                        bitrate: 0,
                                        id: Bt++,
                                        groupId: Nt["GROUP-ID"],
                                        instreamId: Nt["INSTREAM-ID"],
                                        name: Nt.NAME || Nt.LANGUAGE || "",
                                        type: kt,
                                        default: Nt.bool("DEFAULT"),
                                        autoselect: Nt.bool("AUTOSELECT"),
                                        forced: Nt.bool("FORCED"),
                                        lang: Nt.LANGUAGE,
                                        url: Nt.URI ? yt.resolve(Nt.URI, wt) : ""
                                    };
                                    if (Ot.length) {
                                        var jt = yt.findGroup(Ot, $t.groupId) || Ot[0];
                                        _t($t, jt, "audioCodec"), _t($t, jt, "textCodec")
                                    }
                                    Lt.push($t)
                                }
                            }
                            return Lt
                        }, yt.parseLevelPlaylist = function(Ft, wt, kt, Ot, Rt) {
                            var Lt = new It.LevelDetails(wt),
                                Bt = Lt.fragments,
                                Nt = null,
                                $t = 0,
                                jt = 0,
                                Ut = 0,
                                Ht = 0,
                                Wt = null,
                                Kt = new pt.Fragment(Ot, wt),
                                Gt, Vt, zt, Xt = -1,
                                Yt = !1;
                            for (Dt.lastIndex = 0, Lt.m3u8 = Ft;
                                (Gt = Dt.exec(Ft)) !== null;) {
                                Yt && (Yt = !1, Kt = new pt.Fragment(Ot, wt), Kt.start = Ut, Kt.sn = $t, Kt.cc = Ht, Kt.level = kt, Nt && (Kt.initSegment = Nt, Kt.rawProgramDateTime = Nt.rawProgramDateTime, Nt.rawProgramDateTime = null));
                                var Zt = Gt[1];
                                if (Zt) {
                                    Kt.duration = parseFloat(Zt);
                                    var qt = (" " + Gt[2]).slice(1);
                                    Kt.title = qt || null, Kt.tagList.push(qt ? ["INF", Zt, qt] : ["INF", Zt])
                                } else if (Gt[3])(0, ut.isFiniteNumber)(Kt.duration) && (Kt.start = Ut, zt && (Kt.levelkey = zt), Kt.sn = $t, Kt.level = kt, Kt.cc = Ht, Kt.urlId = Rt, Bt.push(Kt), Kt.relurl = (" " + Gt[3]).slice(1), mt(Kt, Wt), Wt = Kt, Ut += Kt.duration, $t++, jt = 0, Yt = !0);
                                else if (Gt[4]) {
                                    var er = (" " + Gt[4]).slice(1);
                                    Wt ? Kt.setByteRange(er, Wt) : Kt.setByteRange(er)
                                } else if (Gt[5]) Kt.rawProgramDateTime = (" " + Gt[5]).slice(1), Kt.tagList.push(["PROGRAM-DATE-TIME", Kt.rawProgramDateTime]), Xt === -1 && (Xt = Bt.length);
                                else {
                                    if (Gt = Gt[0].match(Pt), !Gt) {
                                        ht.logger.warn("No matches on slow regex match for level playlist!");
                                        continue
                                    }
                                    for (Vt = 1; Vt < Gt.length && !(typeof Gt[Vt] < "u"); Vt++);
                                    var tr = (" " + Gt[Vt]).slice(1),
                                        Qt = (" " + Gt[Vt + 1]).slice(1),
                                        Jt = Gt[Vt + 2] ? (" " + Gt[Vt + 2]).slice(1) : "";
                                    switch (tr) {
                                        case "PLAYLIST-TYPE":
                                            Lt.type = Qt.toUpperCase();
                                            break;
                                        case "MEDIA-SEQUENCE":
                                            $t = Lt.startSN = parseInt(Qt);
                                            break;
                                        case "SKIP": {
                                            var nr = new Ct.AttrList(Qt),
                                                rr = nr.decimalInteger("SKIPPED-SEGMENTS");
                                            if ((0, ut.isFiniteNumber)(rr)) {
                                                Lt.skippedSegments = rr;
                                                for (var ir = rr; ir--;) Bt.unshift(null);
                                                $t += rr
                                            }
                                            var ur = nr.enumeratedString("RECENTLY-REMOVED-DATERANGES");
                                            ur && (Lt.recentlyRemovedDateranges = ur.split("	"));
                                            break
                                        }
                                        case "TARGETDURATION":
                                            Lt.targetduration = parseFloat(Qt);
                                            break;
                                        case "VERSION":
                                            Lt.version = parseInt(Qt);
                                            break;
                                        case "EXTM3U":
                                            break;
                                        case "ENDLIST":
                                            Lt.live = !1;
                                            break;
                                        case "#":
                                            (Qt || Jt) && Kt.tagList.push(Jt ? [Qt, Jt] : [Qt]);
                                            break;
                                        case "DISCONTINUITY":
                                            Ht++, Kt.tagList.push(["DIS"]);
                                            break;
                                        case "GAP":
                                            Kt.tagList.push([tr]);
                                            break;
                                        case "BITRATE":
                                            Kt.tagList.push([tr, Qt]);
                                            break;
                                        case "DATERANGE": {
                                            var ar = new Ct.AttrList(Qt),
                                                lr = new bt.DateRange(ar, Lt.dateRanges[ar.ID]);
                                            lr.isValid || Lt.skippedSegments ? Lt.dateRanges[lr.id] = lr : ht.logger.warn('Ignoring invalid DATERANGE tag: "' + Qt + '"'), Kt.tagList.push(["EXT-X-DATERANGE", Qt]);
                                            break
                                        }
                                        case "DISCONTINUITY-SEQUENCE":
                                            Ht = parseInt(Qt);
                                            break;
                                        case "KEY": {
                                            var or, fr = new Ct.AttrList(Qt),
                                                hr = fr.enumeratedString("METHOD"),
                                                xr = fr.URI,
                                                vr = fr.hexadecimalInteger("IV"),
                                                pr = fr.enumeratedString("KEYFORMATVERSIONS"),
                                                yr = fr.enumeratedString("KEYID"),
                                                _r = (or = fr.enumeratedString("KEYFORMAT")) != null ? or : "identity",
                                                Er = ["com.apple.streamingkeydelivery", "com.microsoft.playready", "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed", "com.widevine"];
                                            if (Er.indexOf(_r) > -1) {
                                                ht.logger.warn("Keyformat " + _r + " is not supported from the manifest");
                                                continue
                                            } else if (_r !== "identity") continue;
                                            hr && (zt = At.LevelKey.fromURL(wt, xr), xr && ["AES-128", "SAMPLE-AES", "SAMPLE-AES-CENC"].indexOf(hr) >= 0 && (zt.method = hr, zt.keyFormat = _r, yr && (zt.keyID = yr), pr && (zt.keyFormatVersions = pr), zt.iv = vr));
                                            break
                                        }
                                        case "START": {
                                            var Rr = new Ct.AttrList(Qt),
                                                cr = Rr.decimalFloatingPoint("TIME-OFFSET");
                                            (0, ut.isFiniteNumber)(cr) && (Lt.startTimeOffset = cr);
                                            break
                                        }
                                        case "MAP": {
                                            var dr = new Ct.AttrList(Qt);
                                            if (Kt.duration) {
                                                var Sr = new pt.Fragment(Ot, wt);
                                                xt(Sr, dr, kt, zt), Nt = Sr, Kt.initSegment = Nt, Nt.rawProgramDateTime && !Kt.rawProgramDateTime && (Kt.rawProgramDateTime = Nt.rawProgramDateTime)
                                            } else xt(Kt, dr, kt, zt), Nt = Kt, Yt = !0;
                                            break
                                        }
                                        case "SERVER-CONTROL": {
                                            var sr = new Ct.AttrList(Qt);
                                            Lt.canBlockReload = sr.bool("CAN-BLOCK-RELOAD"), Lt.canSkipUntil = sr.optionalFloat("CAN-SKIP-UNTIL", 0), Lt.canSkipDateRanges = Lt.canSkipUntil > 0 && sr.bool("CAN-SKIP-DATERANGES"), Lt.partHoldBack = sr.optionalFloat("PART-HOLD-BACK", 0), Lt.holdBack = sr.optionalFloat("HOLD-BACK", 0);
                                            break
                                        }
                                        case "PART-INF": {
                                            var gr = new Ct.AttrList(Qt);
                                            Lt.partTarget = gr.decimalFloatingPoint("PART-TARGET");
                                            break
                                        }
                                        case "PART": {
                                            var Dr = Lt.partList;
                                            Dr || (Dr = Lt.partList = []);
                                            var Pr = jt > 0 ? Dr[Dr.length - 1] : void 0,
                                                Or = jt++,
                                                Ir = new pt.Part(new Ct.AttrList(Qt), Kt, wt, Or, Pr);
                                            Dr.push(Ir), Kt.duration += Ir.duration;
                                            break
                                        }
                                        case "PRELOAD-HINT": {
                                            var Tr = new Ct.AttrList(Qt);
                                            Lt.preloadHint = Tr;
                                            break
                                        }
                                        case "RENDITION-REPORT": {
                                            var Mr = new Ct.AttrList(Qt);
                                            Lt.renditionReports = Lt.renditionReports || [], Lt.renditionReports.push(Mr);
                                            break
                                        }
                                        default:
                                            ht.logger.warn("line parsed but not handled: " + Gt);
                                            break
                                    }
                                }
                            }
                            Wt && !Wt.relurl ? (Bt.pop(), Ut -= Wt.duration, Lt.partList && (Lt.fragmentHint = Wt)) : Lt.partList && (mt(Kt, Wt), Kt.cc = Ht, Lt.fragmentHint = Kt);
                            var wr = Bt.length,
                                Cr = Bt[0],
                                Fr = Bt[wr - 1];
                            if (Ut += Lt.skippedSegments * Lt.targetduration, Ut > 0 && wr && Fr) {
                                Lt.averagetargetduration = Ut / wr;
                                var Lr = Fr.sn;
                                Lt.endSN = Lr !== "initSegment" ? Lr : 0, Cr && (Lt.startCC = Cr.cc, Cr.initSegment || Lt.fragments.every(function(mr) {
                                    return mr.relurl && ft(mr.relurl)
                                }) && (ht.logger.warn("MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX"), Kt = new pt.Fragment(Ot, wt), Kt.relurl = Fr.relurl, Kt.level = kt, Kt.sn = "initSegment", Cr.initSegment = Kt, Lt.needSidxRanges = !0))
                            } else Lt.endSN = 0, Lt.startCC = 0;
                            return Lt.fragmentHint && (Ut += Lt.fragmentHint.duration), Lt.totalduration = Ut, Lt.endCC = Ht, Xt > 0 && vt(Bt, Xt), Lt
                        }, yt
                    }();

                    function St(yt, Tt) {
                        ["video", "audio", "text"].forEach(function(Ft) {
                            var wt = yt.filter(function(Ot) {
                                return (0, ot.isCodecType)(Ot, Ft)
                            });
                            if (wt.length) {
                                var kt = wt.filter(function(Ot) {
                                    return Ot.lastIndexOf("avc1", 0) === 0 || Ot.lastIndexOf("mp4a", 0) === 0
                                });
                                Tt[Ft + "Codec"] = kt.length > 0 ? kt[0] : wt[0], yt = yt.filter(function(Ot) {
                                    return wt.indexOf(Ot) === -1
                                })
                            }
                        }), Tt.unknownCodecs = yt
                    }

                    function _t(yt, Tt, Ft) {
                        var wt = Tt[Ft];
                        wt && (yt[Ft] = wt)
                    }

                    function vt(yt, Tt) {
                        for (var Ft = yt[Tt], wt = Tt; wt--;) {
                            var kt = yt[wt];
                            if (!kt) return;
                            kt.programDateTime = Ft.programDateTime - kt.duration * 1e3, Ft = kt
                        }
                    }

                    function mt(yt, Tt) {
                        yt.rawProgramDateTime ? yt.programDateTime = Date.parse(yt.rawProgramDateTime) : Tt != null && Tt.programDateTime && (yt.programDateTime = Tt.endProgramDateTime), (0, ut.isFiniteNumber)(yt.programDateTime) || (yt.programDateTime = null, yt.rawProgramDateTime = null)
                    }

                    function xt(yt, Tt, Ft, wt) {
                        yt.relurl = Tt.URI, Tt.BYTERANGE && yt.setByteRange(Tt.BYTERANGE), yt.level = Ft, yt.sn = "initSegment", wt && (yt.levelkey = wt), yt.initSegment = null
                    }
                },
                "./src/loader/playlist-loader.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => Dt
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/events.ts"),
                        bt = it("./src/errors.ts"),
                        pt = it("./src/utils/logger.ts"),
                        It = it("./src/utils/mp4-tools.ts"),
                        At = it("./src/loader/m3u8-parser.ts"),
                        Ct = it("./src/types/loader.ts"),
                        ht = it("./src/utils/attr-list.ts");

                    function ot(Pt) {
                        var gt = Pt.type;
                        switch (gt) {
                            case Ct.PlaylistContextType.AUDIO_TRACK:
                                return Ct.PlaylistLevelType.AUDIO;
                            case Ct.PlaylistContextType.SUBTITLE_TRACK:
                                return Ct.PlaylistLevelType.SUBTITLE;
                            default:
                                return Ct.PlaylistLevelType.MAIN
                        }
                    }

                    function ct(Pt, gt) {
                        var ft = Pt.url;
                        return (ft === void 0 || ft.indexOf("data:") === 0) && (ft = gt.url), ft
                    }
                    var Et = function() {
                        function Pt(ft) {
                            this.hls = void 0, this.loaders = Object.create(null), this.hls = ft, this.registerListeners()
                        }
                        var gt = Pt.prototype;
                        return gt.startLoad = function(dt) {}, gt.stopLoad = function() {
                            this.destroyInternalLoaders()
                        }, gt.registerListeners = function() {
                            var dt = this.hls;
                            dt.on(lt.Events.MANIFEST_LOADING, this.onManifestLoading, this), dt.on(lt.Events.LEVEL_LOADING, this.onLevelLoading, this), dt.on(lt.Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), dt.on(lt.Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
                        }, gt.unregisterListeners = function() {
                            var dt = this.hls;
                            dt.off(lt.Events.MANIFEST_LOADING, this.onManifestLoading, this), dt.off(lt.Events.LEVEL_LOADING, this.onLevelLoading, this), dt.off(lt.Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), dt.off(lt.Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
                        }, gt.createInternalLoader = function(dt) {
                            var St = this.hls.config,
                                _t = St.pLoader,
                                vt = St.loader,
                                mt = _t || vt,
                                xt = new mt(St);
                            return dt.loader = xt, this.loaders[dt.type] = xt, xt
                        }, gt.getInternalLoader = function(dt) {
                            return this.loaders[dt.type]
                        }, gt.resetInternalLoader = function(dt) {
                            this.loaders[dt] && delete this.loaders[dt]
                        }, gt.destroyInternalLoaders = function() {
                            for (var dt in this.loaders) {
                                var St = this.loaders[dt];
                                St && St.destroy(), this.resetInternalLoader(dt)
                            }
                        }, gt.destroy = function() {
                            this.unregisterListeners(), this.destroyInternalLoaders()
                        }, gt.onManifestLoading = function(dt, St) {
                            var _t = St.url;
                            this.load({
                                id: null,
                                groupId: null,
                                level: 0,
                                responseType: "text",
                                type: Ct.PlaylistContextType.MANIFEST,
                                url: _t,
                                deliveryDirectives: null
                            })
                        }, gt.onLevelLoading = function(dt, St) {
                            var _t = St.id,
                                vt = St.level,
                                mt = St.url,
                                xt = St.deliveryDirectives;
                            this.load({
                                id: _t,
                                groupId: null,
                                level: vt,
                                responseType: "text",
                                type: Ct.PlaylistContextType.LEVEL,
                                url: mt,
                                deliveryDirectives: xt
                            })
                        }, gt.onAudioTrackLoading = function(dt, St) {
                            var _t = St.id,
                                vt = St.groupId,
                                mt = St.url,
                                xt = St.deliveryDirectives;
                            this.load({
                                id: _t,
                                groupId: vt,
                                level: null,
                                responseType: "text",
                                type: Ct.PlaylistContextType.AUDIO_TRACK,
                                url: mt,
                                deliveryDirectives: xt
                            })
                        }, gt.onSubtitleTrackLoading = function(dt, St) {
                            var _t = St.id,
                                vt = St.groupId,
                                mt = St.url,
                                xt = St.deliveryDirectives;
                            this.load({
                                id: _t,
                                groupId: vt,
                                level: null,
                                responseType: "text",
                                type: Ct.PlaylistContextType.SUBTITLE_TRACK,
                                url: mt,
                                deliveryDirectives: xt
                            })
                        }, gt.load = function(dt) {
                            var St, _t = this.hls.config,
                                vt = this.getInternalLoader(dt);
                            if (vt) {
                                var mt = vt.context;
                                if (mt && mt.url === dt.url) {
                                    pt.logger.trace("[playlist-loader]: playlist request ongoing");
                                    return
                                }
                                pt.logger.log("[playlist-loader]: aborting previous loader for type: " + dt.type), vt.abort()
                            }
                            var xt, yt, Tt, Ft;
                            switch (dt.type) {
                                case Ct.PlaylistContextType.MANIFEST:
                                    xt = _t.manifestLoadingMaxRetry, yt = _t.manifestLoadingTimeOut, Tt = _t.manifestLoadingRetryDelay, Ft = _t.manifestLoadingMaxRetryTimeout;
                                    break;
                                case Ct.PlaylistContextType.LEVEL:
                                case Ct.PlaylistContextType.AUDIO_TRACK:
                                case Ct.PlaylistContextType.SUBTITLE_TRACK:
                                    xt = 0, yt = _t.levelLoadingTimeOut;
                                    break;
                                default:
                                    xt = _t.levelLoadingMaxRetry, yt = _t.levelLoadingTimeOut, Tt = _t.levelLoadingRetryDelay, Ft = _t.levelLoadingMaxRetryTimeout;
                                    break
                            }
                            if (vt = this.createInternalLoader(dt), (St = dt.deliveryDirectives) !== null && St !== void 0 && St.part) {
                                var wt;
                                if (dt.type === Ct.PlaylistContextType.LEVEL && dt.level !== null ? wt = this.hls.levels[dt.level].details : dt.type === Ct.PlaylistContextType.AUDIO_TRACK && dt.id !== null ? wt = this.hls.audioTracks[dt.id].details : dt.type === Ct.PlaylistContextType.SUBTITLE_TRACK && dt.id !== null && (wt = this.hls.subtitleTracks[dt.id].details), wt) {
                                    var kt = wt.partTarget,
                                        Ot = wt.targetduration;
                                    kt && Ot && (yt = Math.min(Math.max(kt * 3, Ot * .8) * 1e3, yt))
                                }
                            }
                            var Rt = {
                                    timeout: yt,
                                    maxRetry: xt,
                                    retryDelay: Tt,
                                    maxRetryDelay: Ft,
                                    highWaterMark: 0
                                },
                                Lt = {
                                    onSuccess: this.loadsuccess.bind(this),
                                    onError: this.loaderror.bind(this),
                                    onTimeout: this.loadtimeout.bind(this)
                                };
                            vt.load(dt, Rt, Lt)
                        }, gt.loadsuccess = function(dt, St, _t, vt) {
                            if (vt === void 0 && (vt = null), _t.isSidxRequest) {
                                this.handleSidxRequest(dt, _t), this.handlePlaylistLoaded(dt, St, _t, vt);
                                return
                            }
                            this.resetInternalLoader(_t.type);
                            var mt = dt.data;
                            if (mt.indexOf("#EXTM3U") !== 0) {
                                this.handleManifestParsingError(dt, _t, "no EXTM3U delimiter", vt);
                                return
                            }
                            St.parsing.start = performance.now(), mt.indexOf("#EXTINF:") > 0 || mt.indexOf("#EXT-X-TARGETDURATION:") > 0 ? this.handleTrackOrLevelPlaylist(dt, St, _t, vt) : this.handleMasterPlaylist(dt, St, _t, vt)
                        }, gt.loaderror = function(dt, St, _t) {
                            _t === void 0 && (_t = null), this.handleNetworkError(St, _t, !1, dt)
                        }, gt.loadtimeout = function(dt, St, _t) {
                            _t === void 0 && (_t = null), this.handleNetworkError(St, _t, !0)
                        }, gt.handleMasterPlaylist = function(dt, St, _t, vt) {
                            var mt = this.hls,
                                xt = dt.data,
                                yt = ct(dt, _t),
                                Tt = At.default.parseMasterPlaylist(xt, yt),
                                Ft = Tt.levels,
                                wt = Tt.sessionData;
                            if (!Ft.length) {
                                this.handleManifestParsingError(dt, _t, "no level found in manifest", vt);
                                return
                            }
                            var kt = Ft.map(function($t) {
                                    return {
                                        id: $t.attrs.AUDIO,
                                        audioCodec: $t.audioCodec
                                    }
                                }),
                                Ot = Ft.map(function($t) {
                                    return {
                                        id: $t.attrs.SUBTITLES,
                                        textCodec: $t.textCodec
                                    }
                                }),
                                Rt = At.default.parseMasterPlaylistMedia(xt, yt, "AUDIO", kt),
                                Lt = At.default.parseMasterPlaylistMedia(xt, yt, "SUBTITLES", Ot),
                                Bt = At.default.parseMasterPlaylistMedia(xt, yt, "CLOSED-CAPTIONS");
                            if (Rt.length) {
                                var Nt = Rt.some(function($t) {
                                    return !$t.url
                                });
                                !Nt && Ft[0].audioCodec && !Ft[0].attrs.AUDIO && (pt.logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), Rt.unshift({
                                    type: "main",
                                    name: "main",
                                    default: !1,
                                    autoselect: !1,
                                    forced: !1,
                                    id: -1,
                                    attrs: new ht.AttrList({}),
                                    bitrate: 0,
                                    url: ""
                                }))
                            }
                            mt.trigger(lt.Events.MANIFEST_LOADED, {
                                levels: Ft,
                                audioTracks: Rt,
                                subtitles: Lt,
                                captions: Bt,
                                url: yt,
                                stats: St,
                                networkDetails: vt,
                                sessionData: wt
                            })
                        }, gt.handleTrackOrLevelPlaylist = function(dt, St, _t, vt) {
                            var mt = this.hls,
                                xt = _t.id,
                                yt = _t.level,
                                Tt = _t.type,
                                Ft = ct(dt, _t),
                                wt = (0, ut.isFiniteNumber)(xt) ? xt : 0,
                                kt = (0, ut.isFiniteNumber)(yt) ? yt : wt,
                                Ot = ot(_t),
                                Rt = At.default.parseLevelPlaylist(dt.data, Ft, kt, Ot, wt);
                            if (!Rt.fragments.length) {
                                mt.trigger(lt.Events.ERROR, {
                                    type: bt.ErrorTypes.NETWORK_ERROR,
                                    details: bt.ErrorDetails.LEVEL_EMPTY_ERROR,
                                    fatal: !1,
                                    url: Ft,
                                    reason: "no fragments found in level",
                                    level: typeof _t.level == "number" ? _t.level : void 0
                                });
                                return
                            }
                            if (Tt === Ct.PlaylistContextType.MANIFEST) {
                                var Lt = {
                                    attrs: new ht.AttrList({}),
                                    bitrate: 0,
                                    details: Rt,
                                    name: "",
                                    url: Ft
                                };
                                mt.trigger(lt.Events.MANIFEST_LOADED, {
                                    levels: [Lt],
                                    audioTracks: [],
                                    url: Ft,
                                    stats: St,
                                    networkDetails: vt,
                                    sessionData: null
                                })
                            }
                            if (St.parsing.end = performance.now(), Rt.needSidxRanges) {
                                var Bt, Nt = (Bt = Rt.fragments[0].initSegment) === null || Bt === void 0 ? void 0 : Bt.url;
                                this.load({
                                    url: Nt,
                                    isSidxRequest: !0,
                                    type: Tt,
                                    level: yt,
                                    levelDetails: Rt,
                                    id: xt,
                                    groupId: null,
                                    rangeStart: 0,
                                    rangeEnd: 2048,
                                    responseType: "arraybuffer",
                                    deliveryDirectives: null
                                });
                                return
                            }
                            _t.levelDetails = Rt, this.handlePlaylistLoaded(dt, St, _t, vt)
                        }, gt.handleSidxRequest = function(dt, St) {
                            var _t = new Uint8Array(dt.data),
                                vt = (0, It.findBox)(_t, ["sidx"])[0];
                            if (!!vt) {
                                var mt = (0, It.parseSegmentIndex)(vt);
                                if (!!mt) {
                                    var xt = mt.references,
                                        yt = St.levelDetails;
                                    xt.forEach(function(Tt, Ft) {
                                        var wt = Tt.info,
                                            kt = yt.fragments[Ft];
                                        if (kt.byteRange.length === 0 && kt.setByteRange(String(1 + wt.end - wt.start) + "@" + String(wt.start)), kt.initSegment) {
                                            var Ot = (0, It.findBox)(_t, ["moov"])[0],
                                                Rt = Ot ? Ot.length : null;
                                            kt.initSegment.setByteRange(String(Rt) + "@0")
                                        }
                                    })
                                }
                            }
                        }, gt.handleManifestParsingError = function(dt, St, _t, vt) {
                            this.hls.trigger(lt.Events.ERROR, {
                                type: bt.ErrorTypes.NETWORK_ERROR,
                                details: bt.ErrorDetails.MANIFEST_PARSING_ERROR,
                                fatal: St.type === Ct.PlaylistContextType.MANIFEST,
                                url: dt.url,
                                reason: _t,
                                response: dt,
                                context: St,
                                networkDetails: vt
                            })
                        }, gt.handleNetworkError = function(dt, St, _t, vt) {
                            _t === void 0 && (_t = !1), pt.logger.warn("[playlist-loader]: A network " + (_t ? "timeout" : "error") + " occurred while loading " + dt.type + " level: " + dt.level + " id: " + dt.id + ' group-id: "' + dt.groupId + '"');
                            var mt = bt.ErrorDetails.UNKNOWN,
                                xt = !1,
                                yt = this.getInternalLoader(dt);
                            switch (dt.type) {
                                case Ct.PlaylistContextType.MANIFEST:
                                    mt = _t ? bt.ErrorDetails.MANIFEST_LOAD_TIMEOUT : bt.ErrorDetails.MANIFEST_LOAD_ERROR, xt = !0;
                                    break;
                                case Ct.PlaylistContextType.LEVEL:
                                    mt = _t ? bt.ErrorDetails.LEVEL_LOAD_TIMEOUT : bt.ErrorDetails.LEVEL_LOAD_ERROR, xt = !1;
                                    break;
                                case Ct.PlaylistContextType.AUDIO_TRACK:
                                    mt = _t ? bt.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : bt.ErrorDetails.AUDIO_TRACK_LOAD_ERROR, xt = !1;
                                    break;
                                case Ct.PlaylistContextType.SUBTITLE_TRACK:
                                    mt = _t ? bt.ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : bt.ErrorDetails.SUBTITLE_LOAD_ERROR, xt = !1;
                                    break
                            }
                            yt && this.resetInternalLoader(dt.type);
                            var Tt = {
                                type: bt.ErrorTypes.NETWORK_ERROR,
                                details: mt,
                                fatal: xt,
                                url: dt.url,
                                loader: yt,
                                context: dt,
                                networkDetails: St
                            };
                            vt && (Tt.response = vt), this.hls.trigger(lt.Events.ERROR, Tt)
                        }, gt.handlePlaylistLoaded = function(dt, St, _t, vt) {
                            var mt = _t.type,
                                xt = _t.level,
                                yt = _t.id,
                                Tt = _t.groupId,
                                Ft = _t.loader,
                                wt = _t.levelDetails,
                                kt = _t.deliveryDirectives;
                            if (!(wt != null && wt.targetduration)) {
                                this.handleManifestParsingError(dt, _t, "invalid target duration", vt);
                                return
                            }
                            if (!!Ft) switch (wt.live && (Ft.getCacheAge && (wt.ageHeader = Ft.getCacheAge() || 0), (!Ft.getCacheAge || isNaN(wt.ageHeader)) && (wt.ageHeader = 0)), mt) {
                                case Ct.PlaylistContextType.MANIFEST:
                                case Ct.PlaylistContextType.LEVEL:
                                    this.hls.trigger(lt.Events.LEVEL_LOADED, {
                                        details: wt,
                                        level: xt || 0,
                                        id: yt || 0,
                                        stats: St,
                                        networkDetails: vt,
                                        deliveryDirectives: kt
                                    });
                                    break;
                                case Ct.PlaylistContextType.AUDIO_TRACK:
                                    this.hls.trigger(lt.Events.AUDIO_TRACK_LOADED, {
                                        details: wt,
                                        id: yt || 0,
                                        groupId: Tt || "",
                                        stats: St,
                                        networkDetails: vt,
                                        deliveryDirectives: kt
                                    });
                                    break;
                                case Ct.PlaylistContextType.SUBTITLE_TRACK:
                                    this.hls.trigger(lt.Events.SUBTITLE_TRACK_LOADED, {
                                        details: wt,
                                        id: yt || 0,
                                        groupId: Tt || "",
                                        stats: St,
                                        networkDetails: vt,
                                        deliveryDirectives: kt
                                    });
                                    break
                            }
                        }, Pt
                    }();
                    const Dt = Et
                },
                "./src/polyfills/number.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        MAX_SAFE_INTEGER: () => lt,
                        isFiniteNumber: () => ut
                    });
                    var ut = Number.isFinite || function(bt) {
                            return typeof bt == "number" && isFinite(bt)
                        },
                        lt = Number.MAX_SAFE_INTEGER || 9007199254740991
                },
                "./src/remux/aac-helper.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => lt
                    });
                    var ut = function() {
                        function bt() {}
                        return bt.getSilentFrame = function(It, At) {
                            switch (It) {
                                case "mp4a.40.2":
                                    if (At === 1) return new Uint8Array([0, 200, 0, 128, 35, 128]);
                                    if (At === 2) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
                                    if (At === 3) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
                                    if (At === 4) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
                                    if (At === 5) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
                                    if (At === 6) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
                                    break;
                                default:
                                    if (At === 1) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                                    if (At === 2) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                                    if (At === 3) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                                    break
                            }
                        }, bt
                    }();
                    const lt = ut
                },
                "./src/remux/mp4-generator.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => bt
                    });
                    var ut = Math.pow(2, 32) - 1,
                        lt = function() {
                            function pt() {}
                            return pt.init = function() {
                                pt.types = {
                                    avc1: [],
                                    avcC: [],
                                    btrt: [],
                                    dinf: [],
                                    dref: [],
                                    esds: [],
                                    ftyp: [],
                                    hdlr: [],
                                    mdat: [],
                                    mdhd: [],
                                    mdia: [],
                                    mfhd: [],
                                    minf: [],
                                    moof: [],
                                    moov: [],
                                    mp4a: [],
                                    ".mp3": [],
                                    mvex: [],
                                    mvhd: [],
                                    pasp: [],
                                    sdtp: [],
                                    stbl: [],
                                    stco: [],
                                    stsc: [],
                                    stsd: [],
                                    stsz: [],
                                    stts: [],
                                    tfdt: [],
                                    tfhd: [],
                                    traf: [],
                                    trak: [],
                                    trun: [],
                                    trex: [],
                                    tkhd: [],
                                    vmhd: [],
                                    smhd: []
                                };
                                var At;
                                for (At in pt.types) pt.types.hasOwnProperty(At) && (pt.types[At] = [At.charCodeAt(0), At.charCodeAt(1), At.charCodeAt(2), At.charCodeAt(3)]);
                                var Ct = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),
                                    ht = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
                                pt.HDLR_TYPES = {
                                    video: Ct,
                                    audio: ht
                                };
                                var ot = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),
                                    ct = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
                                pt.STTS = pt.STSC = pt.STCO = ct, pt.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), pt.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), pt.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), pt.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
                                var Et = new Uint8Array([105, 115, 111, 109]),
                                    Dt = new Uint8Array([97, 118, 99, 49]),
                                    Pt = new Uint8Array([0, 0, 0, 1]);
                                pt.FTYP = pt.box(pt.types.ftyp, Et, Pt, Et, Dt), pt.DINF = pt.box(pt.types.dinf, pt.box(pt.types.dref, ot))
                            }, pt.box = function(At) {
                                for (var Ct = 8, ht = arguments.length, ot = new Array(ht > 1 ? ht - 1 : 0), ct = 1; ct < ht; ct++) ot[ct - 1] = arguments[ct];
                                for (var Et = ot.length, Dt = Et; Et--;) Ct += ot[Et].byteLength;
                                var Pt = new Uint8Array(Ct);
                                for (Pt[0] = Ct >> 24 & 255, Pt[1] = Ct >> 16 & 255, Pt[2] = Ct >> 8 & 255, Pt[3] = Ct & 255, Pt.set(At, 4), Et = 0, Ct = 8; Et < Dt; Et++) Pt.set(ot[Et], Ct), Ct += ot[Et].byteLength;
                                return Pt
                            }, pt.hdlr = function(At) {
                                return pt.box(pt.types.hdlr, pt.HDLR_TYPES[At])
                            }, pt.mdat = function(At) {
                                return pt.box(pt.types.mdat, At)
                            }, pt.mdhd = function(At, Ct) {
                                Ct *= At;
                                var ht = Math.floor(Ct / (ut + 1)),
                                    ot = Math.floor(Ct % (ut + 1));
                                return pt.box(pt.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, At >> 24 & 255, At >> 16 & 255, At >> 8 & 255, At & 255, ht >> 24, ht >> 16 & 255, ht >> 8 & 255, ht & 255, ot >> 24, ot >> 16 & 255, ot >> 8 & 255, ot & 255, 85, 196, 0, 0]))
                            }, pt.mdia = function(At) {
                                return pt.box(pt.types.mdia, pt.mdhd(At.timescale, At.duration), pt.hdlr(At.type), pt.minf(At))
                            }, pt.mfhd = function(At) {
                                return pt.box(pt.types.mfhd, new Uint8Array([0, 0, 0, 0, At >> 24, At >> 16 & 255, At >> 8 & 255, At & 255]))
                            }, pt.minf = function(At) {
                                return At.type === "audio" ? pt.box(pt.types.minf, pt.box(pt.types.smhd, pt.SMHD), pt.DINF, pt.stbl(At)) : pt.box(pt.types.minf, pt.box(pt.types.vmhd, pt.VMHD), pt.DINF, pt.stbl(At))
                            }, pt.moof = function(At, Ct, ht) {
                                return pt.box(pt.types.moof, pt.mfhd(At), pt.traf(ht, Ct))
                            }, pt.moov = function(At) {
                                for (var Ct = At.length, ht = []; Ct--;) ht[Ct] = pt.trak(At[Ct]);
                                return pt.box.apply(null, [pt.types.moov, pt.mvhd(At[0].timescale, At[0].duration)].concat(ht).concat(pt.mvex(At)))
                            }, pt.mvex = function(At) {
                                for (var Ct = At.length, ht = []; Ct--;) ht[Ct] = pt.trex(At[Ct]);
                                return pt.box.apply(null, [pt.types.mvex].concat(ht))
                            }, pt.mvhd = function(At, Ct) {
                                Ct *= At;
                                var ht = Math.floor(Ct / (ut + 1)),
                                    ot = Math.floor(Ct % (ut + 1)),
                                    ct = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, At >> 24 & 255, At >> 16 & 255, At >> 8 & 255, At & 255, ht >> 24, ht >> 16 & 255, ht >> 8 & 255, ht & 255, ot >> 24, ot >> 16 & 255, ot >> 8 & 255, ot & 255, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
                                return pt.box(pt.types.mvhd, ct)
                            }, pt.sdtp = function(At) {
                                var Ct = At.samples || [],
                                    ht = new Uint8Array(4 + Ct.length),
                                    ot, ct;
                                for (ot = 0; ot < Ct.length; ot++) ct = Ct[ot].flags, ht[ot + 4] = ct.dependsOn << 4 | ct.isDependedOn << 2 | ct.hasRedundancy;
                                return pt.box(pt.types.sdtp, ht)
                            }, pt.stbl = function(At) {
                                return pt.box(pt.types.stbl, pt.stsd(At), pt.box(pt.types.stts, pt.STTS), pt.box(pt.types.stsc, pt.STSC), pt.box(pt.types.stsz, pt.STSZ), pt.box(pt.types.stco, pt.STCO))
                            }, pt.avc1 = function(At) {
                                var Ct = [],
                                    ht = [],
                                    ot, ct, Et;
                                for (ot = 0; ot < At.sps.length; ot++) ct = At.sps[ot], Et = ct.byteLength, Ct.push(Et >>> 8 & 255), Ct.push(Et & 255), Ct = Ct.concat(Array.prototype.slice.call(ct));
                                for (ot = 0; ot < At.pps.length; ot++) ct = At.pps[ot], Et = ct.byteLength, ht.push(Et >>> 8 & 255), ht.push(Et & 255), ht = ht.concat(Array.prototype.slice.call(ct));
                                var Dt = pt.box(pt.types.avcC, new Uint8Array([1, Ct[3], Ct[4], Ct[5], 255, 224 | At.sps.length].concat(Ct).concat([At.pps.length]).concat(ht))),
                                    Pt = At.width,
                                    gt = At.height,
                                    ft = At.pixelRatio[0],
                                    dt = At.pixelRatio[1];
                                return pt.box(pt.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Pt >> 8 & 255, Pt & 255, gt >> 8 & 255, gt & 255, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), Dt, pt.box(pt.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), pt.box(pt.types.pasp, new Uint8Array([ft >> 24, ft >> 16 & 255, ft >> 8 & 255, ft & 255, dt >> 24, dt >> 16 & 255, dt >> 8 & 255, dt & 255])))
                            }, pt.esds = function(At) {
                                var Ct = At.config.length;
                                return new Uint8Array([0, 0, 0, 0, 3, 23 + Ct, 0, 1, 0, 4, 15 + Ct, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([Ct]).concat(At.config).concat([6, 1, 2]))
                            }, pt.mp4a = function(At) {
                                var Ct = At.samplerate;
                                return pt.box(pt.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, At.channelCount, 0, 16, 0, 0, 0, 0, Ct >> 8 & 255, Ct & 255, 0, 0]), pt.box(pt.types.esds, pt.esds(At)))
                            }, pt.mp3 = function(At) {
                                var Ct = At.samplerate;
                                return pt.box(pt.types[".mp3"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, At.channelCount, 0, 16, 0, 0, 0, 0, Ct >> 8 & 255, Ct & 255, 0, 0]))
                            }, pt.stsd = function(At) {
                                return At.type === "audio" ? At.segmentCodec === "mp3" && At.codec === "mp3" ? pt.box(pt.types.stsd, pt.STSD, pt.mp3(At)) : pt.box(pt.types.stsd, pt.STSD, pt.mp4a(At)) : pt.box(pt.types.stsd, pt.STSD, pt.avc1(At))
                            }, pt.tkhd = function(At) {
                                var Ct = At.id,
                                    ht = At.duration * At.timescale,
                                    ot = At.width,
                                    ct = At.height,
                                    Et = Math.floor(ht / (ut + 1)),
                                    Dt = Math.floor(ht % (ut + 1));
                                return pt.box(pt.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, Ct >> 24 & 255, Ct >> 16 & 255, Ct >> 8 & 255, Ct & 255, 0, 0, 0, 0, Et >> 24, Et >> 16 & 255, Et >> 8 & 255, Et & 255, Dt >> 24, Dt >> 16 & 255, Dt >> 8 & 255, Dt & 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, ot >> 8 & 255, ot & 255, 0, 0, ct >> 8 & 255, ct & 255, 0, 0]))
                            }, pt.traf = function(At, Ct) {
                                var ht = pt.sdtp(At),
                                    ot = At.id,
                                    ct = Math.floor(Ct / (ut + 1)),
                                    Et = Math.floor(Ct % (ut + 1));
                                return pt.box(pt.types.traf, pt.box(pt.types.tfhd, new Uint8Array([0, 0, 0, 0, ot >> 24, ot >> 16 & 255, ot >> 8 & 255, ot & 255])), pt.box(pt.types.tfdt, new Uint8Array([1, 0, 0, 0, ct >> 24, ct >> 16 & 255, ct >> 8 & 255, ct & 255, Et >> 24, Et >> 16 & 255, Et >> 8 & 255, Et & 255])), pt.trun(At, ht.length + 16 + 20 + 8 + 16 + 8 + 8), ht)
                            }, pt.trak = function(At) {
                                return At.duration = At.duration || 4294967295, pt.box(pt.types.trak, pt.tkhd(At), pt.mdia(At))
                            }, pt.trex = function(At) {
                                var Ct = At.id;
                                return pt.box(pt.types.trex, new Uint8Array([0, 0, 0, 0, Ct >> 24, Ct >> 16 & 255, Ct >> 8 & 255, Ct & 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
                            }, pt.trun = function(At, Ct) {
                                var ht = At.samples || [],
                                    ot = ht.length,
                                    ct = 12 + 16 * ot,
                                    Et = new Uint8Array(ct),
                                    Dt, Pt, gt, ft, dt, St;
                                for (Ct += 8 + ct, Et.set([At.type === "video" ? 1 : 0, 0, 15, 1, ot >>> 24 & 255, ot >>> 16 & 255, ot >>> 8 & 255, ot & 255, Ct >>> 24 & 255, Ct >>> 16 & 255, Ct >>> 8 & 255, Ct & 255], 0), Dt = 0; Dt < ot; Dt++) Pt = ht[Dt], gt = Pt.duration, ft = Pt.size, dt = Pt.flags, St = Pt.cts, Et.set([gt >>> 24 & 255, gt >>> 16 & 255, gt >>> 8 & 255, gt & 255, ft >>> 24 & 255, ft >>> 16 & 255, ft >>> 8 & 255, ft & 255, dt.isLeading << 2 | dt.dependsOn, dt.isDependedOn << 6 | dt.hasRedundancy << 4 | dt.paddingValue << 1 | dt.isNonSync, dt.degradPrio & 240 << 8, dt.degradPrio & 15, St >>> 24 & 255, St >>> 16 & 255, St >>> 8 & 255, St & 255], 12 + 16 * Dt);
                                return pt.box(pt.types.trun, Et)
                            }, pt.initSegment = function(At) {
                                pt.types || pt.init();
                                var Ct = pt.moov(At),
                                    ht = new Uint8Array(pt.FTYP.byteLength + Ct.byteLength);
                                return ht.set(pt.FTYP), ht.set(Ct, pt.FTYP.byteLength), ht
                            }, pt
                        }();
                    lt.types = void 0, lt.HDLR_TYPES = void 0, lt.STTS = void 0, lt.STSC = void 0, lt.STCO = void 0, lt.STSZ = void 0, lt.VMHD = void 0, lt.SMHD = void 0, lt.STSD = void 0, lt.FTYP = void 0, lt.DINF = void 0;
                    const bt = lt
                },
                "./src/remux/mp4-remuxer.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => ft,
                        flushTextTrackMetadataCueSamples: () => _t,
                        flushTextTrackUserdataCueSamples: () => vt,
                        normalizePts: () => dt
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/remux/aac-helper.ts"),
                        bt = it("./src/remux/mp4-generator.ts"),
                        pt = it("./src/events.ts"),
                        It = it("./src/errors.ts"),
                        At = it("./src/utils/logger.ts"),
                        Ct = it("./src/types/loader.ts"),
                        ht = it("./src/utils/timescale-conversion.ts");

                    function ot() {
                        return ot = Object.assign ? Object.assign.bind() : function(yt) {
                            for (var Tt = 1; Tt < arguments.length; Tt++) {
                                var Ft = arguments[Tt];
                                for (var wt in Ft) Object.prototype.hasOwnProperty.call(Ft, wt) && (yt[wt] = Ft[wt])
                            }
                            return yt
                        }, ot.apply(this, arguments)
                    }
                    var ct = 10 * 1e3,
                        Et = 1024,
                        Dt = 1152,
                        Pt = null,
                        gt = null,
                        ft = function() {
                            function yt(Ft, wt, kt, Ot) {
                                if (this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = void 0, this._initDTS = void 0, this.nextAvcDts = null, this.nextAudioPts = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.observer = Ft, this.config = wt, this.typeSupported = kt, this.ISGenerated = !1, Pt === null) {
                                    var Rt = navigator.userAgent || "",
                                        Lt = Rt.match(/Chrome\/(\d+)/i);
                                    Pt = Lt ? parseInt(Lt[1]) : 0
                                }
                                if (gt === null) {
                                    var Bt = navigator.userAgent.match(/Safari\/(\d+)/i);
                                    gt = Bt ? parseInt(Bt[1]) : 0
                                }
                            }
                            var Tt = yt.prototype;
                            return Tt.destroy = function() {}, Tt.resetTimeStamp = function(wt) {
                                At.logger.log("[mp4-remuxer]: initPTS & initDTS reset"), this._initPTS = this._initDTS = wt
                            }, Tt.resetNextTimestamp = function() {
                                At.logger.log("[mp4-remuxer]: reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1
                            }, Tt.resetInitSegment = function() {
                                At.logger.log("[mp4-remuxer]: ISGenerated flag reset"), this.ISGenerated = !1
                            }, Tt.getVideoStartPts = function(wt) {
                                var kt = !1,
                                    Ot = wt.reduce(function(Rt, Lt) {
                                        var Bt = Lt.pts - Rt;
                                        return Bt < -4294967296 ? (kt = !0, dt(Rt, Lt.pts)) : Bt > 0 ? Rt : Lt.pts
                                    }, wt[0].pts);
                                return kt && At.logger.debug("PTS rollover detected"), Ot
                            }, Tt.remux = function(wt, kt, Ot, Rt, Lt, Bt, Nt, $t) {
                                var jt, Ut, Ht, Wt, Kt, Gt, Vt = Lt,
                                    zt = Lt,
                                    Xt = wt.pid > -1,
                                    Yt = kt.pid > -1,
                                    Zt = kt.samples.length,
                                    qt = wt.samples.length > 0,
                                    er = Nt && Zt > 0 || Zt > 1,
                                    tr = (!Xt || qt) && (!Yt || er) || this.ISGenerated || Nt;
                                if (tr) {
                                    this.ISGenerated || (Ht = this.generateIS(wt, kt, Lt));
                                    var Qt = this.isVideoContiguous,
                                        Jt = -1,
                                        nr;
                                    if (er && (Jt = St(kt.samples), !Qt && this.config.forceKeyFrameOnDiscontinuity))
                                        if (Gt = !0, Jt > 0) {
                                            At.logger.warn("[mp4-remuxer]: Dropped " + Jt + " out of " + Zt + " video samples due to a missing keyframe");
                                            var rr = this.getVideoStartPts(kt.samples);
                                            kt.samples = kt.samples.slice(Jt), kt.dropped += Jt, zt += (kt.samples[0].pts - rr) / kt.inputTimeScale, nr = zt
                                        } else Jt === -1 && (At.logger.warn("[mp4-remuxer]: No keyframe found out of " + Zt + " video samples"), Gt = !1);
                                    if (this.ISGenerated) {
                                        if (qt && er) {
                                            var ir = this.getVideoStartPts(kt.samples),
                                                ur = dt(wt.samples[0].pts, ir) - ir,
                                                ar = ur / kt.inputTimeScale;
                                            Vt += Math.max(0, ar), zt += Math.max(0, -ar)
                                        }
                                        if (qt) {
                                            if (wt.samplerate || (At.logger.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"), Ht = this.generateIS(wt, kt, Lt)), Ut = this.remuxAudio(wt, Vt, this.isAudioContiguous, Bt, Yt || er || $t === Ct.PlaylistLevelType.AUDIO ? zt : void 0), er) {
                                                var lr = Ut ? Ut.endPTS - Ut.startPTS : 0;
                                                kt.inputTimeScale || (At.logger.warn("[mp4-remuxer]: regenerate InitSegment as video detected"), Ht = this.generateIS(wt, kt, Lt)), jt = this.remuxVideo(kt, zt, Qt, lr)
                                            }
                                        } else er && (jt = this.remuxVideo(kt, zt, Qt, 0));
                                        jt && (jt.firstKeyFrame = Jt, jt.independent = Jt !== -1, jt.firstKeyFramePTS = nr)
                                    }
                                }
                                return this.ISGenerated && (Ot.samples.length && (Kt = _t(Ot, Lt, this._initPTS, this._initDTS)), Rt.samples.length && (Wt = vt(Rt, Lt, this._initPTS))), {
                                    audio: Ut,
                                    video: jt,
                                    initSegment: Ht,
                                    independent: Gt,
                                    text: Wt,
                                    id3: Kt
                                }
                            }, Tt.generateIS = function(wt, kt, Ot) {
                                var Rt = wt.samples,
                                    Lt = kt.samples,
                                    Bt = this.typeSupported,
                                    Nt = {},
                                    $t = !(0, ut.isFiniteNumber)(this._initPTS),
                                    jt = "audio/mp4",
                                    Ut, Ht, Wt;
                                if ($t && (Ut = Ht = 1 / 0), wt.config && Rt.length) {
                                    switch (wt.timescale = wt.samplerate, wt.segmentCodec) {
                                        case "mp3":
                                            Bt.mpeg ? (jt = "audio/mpeg", wt.codec = "") : Bt.mp3 && (wt.codec = "mp3");
                                            break
                                    }
                                    Nt.audio = {
                                        id: "audio",
                                        container: jt,
                                        codec: wt.codec,
                                        initSegment: wt.segmentCodec === "mp3" && Bt.mpeg ? new Uint8Array(0) : bt.default.initSegment([wt]),
                                        metadata: {
                                            channelCount: wt.channelCount
                                        }
                                    }, $t && (Wt = wt.inputTimeScale, Ut = Ht = Rt[0].pts - Math.round(Wt * Ot))
                                }
                                if (kt.sps && kt.pps && Lt.length && (kt.timescale = kt.inputTimeScale, Nt.video = {
                                        id: "main",
                                        container: "video/mp4",
                                        codec: kt.codec,
                                        initSegment: bt.default.initSegment([kt]),
                                        metadata: {
                                            width: kt.width,
                                            height: kt.height
                                        }
                                    }, $t)) {
                                    Wt = kt.inputTimeScale;
                                    var Kt = this.getVideoStartPts(Lt),
                                        Gt = Math.round(Wt * Ot);
                                    Ht = Math.min(Ht, dt(Lt[0].dts, Kt) - Gt), Ut = Math.min(Ut, Kt - Gt)
                                }
                                if (Object.keys(Nt).length) return this.ISGenerated = !0, $t && (this._initPTS = Ut, this._initDTS = Ht), {
                                    tracks: Nt,
                                    initPTS: Ut,
                                    timescale: Wt
                                }
                            }, Tt.remuxVideo = function(wt, kt, Ot, Rt) {
                                var Lt = wt.inputTimeScale,
                                    Bt = wt.samples,
                                    Nt = [],
                                    $t = Bt.length,
                                    jt = this._initPTS,
                                    Ut = this.nextAvcDts,
                                    Ht = 8,
                                    Wt = this.videoSampleDuration,
                                    Kt, Gt, Vt = Number.POSITIVE_INFINITY,
                                    zt = Number.NEGATIVE_INFINITY,
                                    Xt = !1;
                                if (!Ot || Ut === null) {
                                    var Yt = kt * Lt,
                                        Zt = Bt[0].pts - dt(Bt[0].dts, Bt[0].pts);
                                    Ut = Yt - Zt
                                }
                                for (var qt = 0; qt < $t; qt++) {
                                    var er = Bt[qt];
                                    er.pts = dt(er.pts - jt, Ut), er.dts = dt(er.dts - jt, Ut), er.dts < Bt[qt > 0 ? qt - 1 : qt].dts && (Xt = !0)
                                }
                                Xt && Bt.sort(function(jr, Wr) {
                                    var Yr = jr.dts - Wr.dts,
                                        Qr = jr.pts - Wr.pts;
                                    return Yr || Qr
                                }), Kt = Bt[0].dts, Gt = Bt[Bt.length - 1].dts;
                                var tr = Gt - Kt,
                                    Qt = tr ? Math.round(tr / ($t - 1)) : Wt || wt.inputTimeScale / 30;
                                if (Ot) {
                                    var Jt = Kt - Ut,
                                        nr = Jt > Qt,
                                        rr = Jt < -1;
                                    if ((nr || rr) && (nr ? At.logger.warn("AVC: " + (0, ht.toMsFromMpegTsClock)(Jt, !0) + " ms (" + Jt + "dts) hole between fragments detected, filling it") : At.logger.warn("AVC: " + (0, ht.toMsFromMpegTsClock)(-Jt, !0) + " ms (" + Jt + "dts) overlapping between fragments detected"), !rr || Ut > Bt[0].pts)) {
                                        Kt = Ut;
                                        var ir = Bt[0].pts - Jt;
                                        Bt[0].dts = Kt, Bt[0].pts = ir, At.logger.log("Video: First PTS/DTS adjusted: " + (0, ht.toMsFromMpegTsClock)(ir, !0) + "/" + (0, ht.toMsFromMpegTsClock)(Kt, !0) + ", delta: " + (0, ht.toMsFromMpegTsClock)(Jt, !0) + " ms")
                                    }
                                }
                                Kt = Math.max(0, Kt);
                                for (var ur = 0, ar = 0, lr = 0; lr < $t; lr++) {
                                    for (var or = Bt[lr], fr = or.units, hr = fr.length, xr = 0, vr = 0; vr < hr; vr++) xr += fr[vr].data.length;
                                    ar += xr, ur += hr, or.length = xr, or.dts = Math.max(or.dts, Kt), Vt = Math.min(or.pts, Vt), zt = Math.max(or.pts, zt)
                                }
                                Gt = Bt[$t - 1].dts;
                                var pr = ar + 4 * ur + 8,
                                    yr;
                                try {
                                    yr = new Uint8Array(pr)
                                } catch {
                                    this.observer.emit(pt.Events.ERROR, pt.Events.ERROR, {
                                        type: It.ErrorTypes.MUX_ERROR,
                                        details: It.ErrorDetails.REMUX_ALLOC_ERROR,
                                        fatal: !1,
                                        bytes: pr,
                                        reason: "fail allocating video mdat " + pr
                                    });
                                    return
                                }
                                var _r = new DataView(yr.buffer);
                                _r.setUint32(0, pr), yr.set(bt.default.types.mdat, 4);
                                for (var Er = !1, Rr = Number.POSITIVE_INFINITY, cr = Number.POSITIVE_INFINITY, dr = Number.NEGATIVE_INFINITY, Sr = Number.NEGATIVE_INFINITY, sr = 0; sr < $t; sr++) {
                                    for (var gr = Bt[sr], Dr = gr.units, Pr = 0, Or = 0, Ir = Dr.length; Or < Ir; Or++) {
                                        var Tr = Dr[Or],
                                            Mr = Tr.data,
                                            wr = Tr.data.byteLength;
                                        _r.setUint32(Ht, wr), Ht += 4, yr.set(Mr, Ht), Ht += wr, Pr += 4 + wr
                                    }
                                    var Cr = void 0;
                                    if (sr < $t - 1) Wt = Bt[sr + 1].dts - gr.dts, Cr = Bt[sr + 1].pts - gr.pts;
                                    else {
                                        var Fr = this.config,
                                            Lr = sr > 0 ? gr.dts - Bt[sr - 1].dts : Qt;
                                        if (Cr = sr > 0 ? gr.pts - Bt[sr - 1].pts : Qt, Fr.stretchShortVideoTrack && this.nextAudioPts !== null) {
                                            var mr = Math.floor(Fr.maxBufferHole * Lt),
                                                Ar = (Rt ? Vt + Rt * Lt : this.nextAudioPts) - gr.pts;
                                            Ar > mr ? (Wt = Ar - Lr, Wt < 0 ? Wt = Lr : Er = !0, At.logger.log("[mp4-remuxer]: It is approximately " + Ar / 90 + " ms to the next segment; using duration " + Wt / 90 + " ms for the last video frame.")) : Wt = Lr
                                        } else Wt = Lr
                                    }
                                    var Br = Math.round(gr.pts - gr.dts);
                                    Rr = Math.min(Rr, Wt), dr = Math.max(dr, Wt), cr = Math.min(cr, Cr), Sr = Math.max(Sr, Cr), Nt.push(new mt(gr.key, Wt, Pr, Br))
                                }
                                if (Nt.length) {
                                    if (Pt) {
                                        if (Pt < 70) {
                                            var Nr = Nt[0].flags;
                                            Nr.dependsOn = 2, Nr.isNonSync = 0
                                        }
                                    } else if (gt && Sr - cr < dr - Rr && Qt / dr < .025 && Nt[0].cts === 0) {
                                        At.logger.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
                                        for (var $r = Kt, br = 0, Ur = Nt.length; br < Ur; br++) {
                                            var Hr = $r + Nt[br].duration,
                                                Kr = $r + Nt[br].cts;
                                            if (br < Ur - 1) {
                                                var Gr = Hr + Nt[br + 1].cts;
                                                Nt[br].duration = Gr - Kr
                                            } else Nt[br].duration = br ? Nt[br - 1].duration : Qt;
                                            Nt[br].cts = 0, $r = Hr
                                        }
                                    }
                                }
                                console.assert(Wt !== null, "mp4SampleDuration must be computed"), Wt = Er || !Wt ? Qt : Wt, this.nextAvcDts = Ut = Gt + Wt, this.videoSampleDuration = Wt, this.isVideoContiguous = !0;
                                var Vr = bt.default.moof(wt.sequenceNumber++, Kt, ot({}, wt, {
                                        samples: Nt
                                    })),
                                    zr = "video",
                                    Xr = {
                                        data1: Vr,
                                        data2: yr,
                                        startPTS: Vt / Lt,
                                        endPTS: (zt + Wt) / Lt,
                                        startDTS: Kt / Lt,
                                        endDTS: Ut / Lt,
                                        type: zr,
                                        hasAudio: !1,
                                        hasVideo: !0,
                                        nb: Nt.length,
                                        dropped: wt.dropped
                                    };
                                return wt.samples = [], wt.dropped = 0, console.assert(yr.length, "MDAT length must not be zero"), Xr
                            }, Tt.remuxAudio = function(wt, kt, Ot, Rt, Lt) {
                                var Bt = wt.inputTimeScale,
                                    Nt = wt.samplerate ? wt.samplerate : Bt,
                                    $t = Bt / Nt,
                                    jt = wt.segmentCodec === "aac" ? Et : Dt,
                                    Ut = jt * $t,
                                    Ht = this._initPTS,
                                    Wt = wt.segmentCodec === "mp3" && this.typeSupported.mpeg,
                                    Kt = [],
                                    Gt = Lt !== void 0,
                                    Vt = wt.samples,
                                    zt = Wt ? 0 : 8,
                                    Xt = this.nextAudioPts || -1,
                                    Yt = kt * Bt;
                                if (this.isAudioContiguous = Ot = Ot || Vt.length && Xt > 0 && (Rt && Math.abs(Yt - Xt) < 9e3 || Math.abs(dt(Vt[0].pts - Ht, Yt) - Xt) < 20 * Ut), Vt.forEach(function(Tr) {
                                        Tr.pts = dt(Tr.pts - Ht, Yt)
                                    }), !Ot || Xt < 0) {
                                    if (Vt = Vt.filter(function(Tr) {
                                            return Tr.pts >= 0
                                        }), !Vt.length) return;
                                    Lt === 0 ? Xt = 0 : Rt && !Gt ? Xt = Math.max(0, Yt) : Xt = Vt[0].pts
                                }
                                if (wt.segmentCodec === "aac")
                                    for (var Zt = this.config.maxAudioFramesDrift, qt = 0, er = Xt; qt < Vt.length; qt++) {
                                        var tr = Vt[qt],
                                            Qt = tr.pts,
                                            Jt = Qt - er,
                                            nr = Math.abs(1e3 * Jt / Bt);
                                        if (Jt <= -Zt * Ut && Gt) qt === 0 && (At.logger.warn("Audio frame @ " + (Qt / Bt).toFixed(3) + "s overlaps nextAudioPts by " + Math.round(1e3 * Jt / Bt) + " ms."), this.nextAudioPts = Xt = er = Qt);
                                        else if (Jt >= Zt * Ut && nr < ct && Gt) {
                                            var rr = Math.round(Jt / Ut);
                                            er = Qt - rr * Ut, er < 0 && (rr--, er += Ut), qt === 0 && (this.nextAudioPts = Xt = er), At.logger.warn("[mp4-remuxer]: Injecting " + rr + " audio frame @ " + (er / Bt).toFixed(3) + "s due to " + Math.round(1e3 * Jt / Bt) + " ms gap.");
                                            for (var ir = 0; ir < rr; ir++) {
                                                var ur = Math.max(er, 0),
                                                    ar = lt.default.getSilentFrame(wt.manifestCodec || wt.codec, wt.channelCount);
                                                ar || (At.logger.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."), ar = tr.unit.subarray()), Vt.splice(qt, 0, {
                                                    unit: ar,
                                                    pts: ur
                                                }), er += Ut, qt++
                                            }
                                        }
                                        tr.pts = er, er += Ut
                                    }
                                for (var lr = null, or = null, fr, hr = 0, xr = Vt.length; xr--;) hr += Vt[xr].unit.byteLength;
                                for (var vr = 0, pr = Vt.length; vr < pr; vr++) {
                                    var yr = Vt[vr],
                                        _r = yr.unit,
                                        Er = yr.pts;
                                    if (or !== null) {
                                        var Rr = Kt[vr - 1];
                                        Rr.duration = Math.round((Er - or) / $t)
                                    } else if (Ot && wt.segmentCodec === "aac" && (Er = Xt), lr = Er, hr > 0) {
                                        hr += zt;
                                        try {
                                            fr = new Uint8Array(hr)
                                        } catch {
                                            this.observer.emit(pt.Events.ERROR, pt.Events.ERROR, {
                                                type: It.ErrorTypes.MUX_ERROR,
                                                details: It.ErrorDetails.REMUX_ALLOC_ERROR,
                                                fatal: !1,
                                                bytes: hr,
                                                reason: "fail allocating audio mdat " + hr
                                            });
                                            return
                                        }
                                        if (!Wt) {
                                            var cr = new DataView(fr.buffer);
                                            cr.setUint32(0, hr), fr.set(bt.default.types.mdat, 4)
                                        }
                                    } else return;
                                    fr.set(_r, zt);
                                    var dr = _r.byteLength;
                                    zt += dr, Kt.push(new mt(!0, jt, dr, 0)), or = Er
                                }
                                var Sr = Kt.length;
                                if (!!Sr) {
                                    var sr = Kt[Kt.length - 1];
                                    this.nextAudioPts = Xt = or + $t * sr.duration;
                                    var gr = Wt ? new Uint8Array(0) : bt.default.moof(wt.sequenceNumber++, lr / $t, ot({}, wt, {
                                        samples: Kt
                                    }));
                                    wt.samples = [];
                                    var Dr = lr / Bt,
                                        Pr = Xt / Bt,
                                        Or = "audio",
                                        Ir = {
                                            data1: gr,
                                            data2: fr,
                                            startPTS: Dr,
                                            endPTS: Pr,
                                            startDTS: Dr,
                                            endDTS: Pr,
                                            type: Or,
                                            hasAudio: !0,
                                            hasVideo: !1,
                                            nb: Sr
                                        };
                                    return this.isAudioContiguous = !0, console.assert(fr.length, "MDAT length must not be zero"), Ir
                                }
                            }, Tt.remuxEmptyAudio = function(wt, kt, Ot, Rt) {
                                var Lt = wt.inputTimeScale,
                                    Bt = wt.samplerate ? wt.samplerate : Lt,
                                    Nt = Lt / Bt,
                                    $t = this.nextAudioPts,
                                    jt = ($t !== null ? $t : Rt.startDTS * Lt) + this._initDTS,
                                    Ut = Rt.endDTS * Lt + this._initDTS,
                                    Ht = Nt * Et,
                                    Wt = Math.ceil((Ut - jt) / Ht),
                                    Kt = lt.default.getSilentFrame(wt.manifestCodec || wt.codec, wt.channelCount);
                                if (At.logger.warn("[mp4-remuxer]: remux empty Audio"), !Kt) {
                                    At.logger.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec");
                                    return
                                }
                                for (var Gt = [], Vt = 0; Vt < Wt; Vt++) {
                                    var zt = jt + Vt * Ht;
                                    Gt.push({
                                        unit: Kt,
                                        pts: zt,
                                        dts: zt
                                    })
                                }
                                return wt.samples = Gt, this.remuxAudio(wt, kt, Ot, !1)
                            }, yt
                        }();

                    function dt(yt, Tt) {
                        var Ft;
                        if (Tt === null) return yt;
                        for (Tt < yt ? Ft = -8589934592 : Ft = 8589934592; Math.abs(yt - Tt) > 4294967296;) yt += Ft;
                        return yt
                    }

                    function St(yt) {
                        for (var Tt = 0; Tt < yt.length; Tt++)
                            if (yt[Tt].key) return Tt;
                        return -1
                    }

                    function _t(yt, Tt, Ft, wt) {
                        var kt = yt.samples.length;
                        if (!!kt) {
                            for (var Ot = yt.inputTimeScale, Rt = 0; Rt < kt; Rt++) {
                                var Lt = yt.samples[Rt];
                                Lt.pts = dt(Lt.pts - Ft, Tt * Ot) / Ot, Lt.dts = dt(Lt.dts - wt, Tt * Ot) / Ot
                            }
                            var Bt = yt.samples;
                            return yt.samples = [], {
                                samples: Bt
                            }
                        }
                    }

                    function vt(yt, Tt, Ft) {
                        var wt = yt.samples.length;
                        if (!!wt) {
                            for (var kt = yt.inputTimeScale, Ot = 0; Ot < wt; Ot++) {
                                var Rt = yt.samples[Ot];
                                Rt.pts = dt(Rt.pts - Ft, Tt * kt) / kt
                            }
                            yt.samples.sort(function(Bt, Nt) {
                                return Bt.pts - Nt.pts
                            });
                            var Lt = yt.samples;
                            return yt.samples = [], {
                                samples: Lt
                            }
                        }
                    }
                    var mt = function(Tt, Ft, wt, kt) {
                            this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = Ft, this.size = wt, this.cts = kt, this.flags = new xt(Tt)
                        },
                        xt = function(Tt) {
                            this.isLeading = 0, this.isDependedOn = 0, this.hasRedundancy = 0, this.degradPrio = 0, this.dependsOn = 1, this.isNonSync = 1, this.dependsOn = Tt ? 2 : 1, this.isNonSync = Tt ? 0 : 1
                        }
                },
                "./src/remux/passthrough-remuxer.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => ht
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/remux/mp4-remuxer.ts"),
                        bt = it("./src/utils/mp4-tools.ts"),
                        pt = it("./src/loader/fragment.ts"),
                        It = it("./src/utils/logger.ts"),
                        At = function() {
                            function ot() {
                                this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = void 0, this.initTracks = void 0, this.lastEndTime = null
                            }
                            var ct = ot.prototype;
                            return ct.destroy = function() {}, ct.resetTimeStamp = function(Dt) {
                                this.initPTS = Dt, this.lastEndTime = null
                            }, ct.resetNextTimestamp = function() {
                                this.lastEndTime = null
                            }, ct.resetInitSegment = function(Dt, Pt, gt) {
                                this.audioCodec = Pt, this.videoCodec = gt, this.generateInitSegment(Dt), this.emitInitSegment = !0
                            }, ct.generateInitSegment = function(Dt) {
                                var Pt = this.audioCodec,
                                    gt = this.videoCodec;
                                if (!Dt || !Dt.byteLength) {
                                    this.initTracks = void 0, this.initData = void 0;
                                    return
                                }
                                var ft = this.initData = (0, bt.parseInitSegment)(Dt);
                                Pt || (Pt = Ct(ft.audio, pt.ElementaryStreamTypes.AUDIO)), gt || (gt = Ct(ft.video, pt.ElementaryStreamTypes.VIDEO));
                                var dt = {};
                                ft.audio && ft.video ? dt.audiovideo = {
                                    container: "video/mp4",
                                    codec: Pt + "," + gt,
                                    initSegment: Dt,
                                    id: "main"
                                } : ft.audio ? dt.audio = {
                                    container: "audio/mp4",
                                    codec: Pt,
                                    initSegment: Dt,
                                    id: "audio"
                                } : ft.video ? dt.video = {
                                    container: "video/mp4",
                                    codec: gt,
                                    initSegment: Dt,
                                    id: "main"
                                } : It.logger.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."), this.initTracks = dt
                            }, ct.remux = function(Dt, Pt, gt, ft, dt) {
                                var St, _t = this.initPTS,
                                    vt = this.lastEndTime,
                                    mt = {
                                        audio: void 0,
                                        video: void 0,
                                        text: ft,
                                        id3: gt,
                                        initSegment: void 0
                                    };
                                (0, ut.isFiniteNumber)(vt) || (vt = this.lastEndTime = dt || 0);
                                var xt = Pt.samples;
                                if (!xt || !xt.length) return mt;
                                var yt = {
                                        initPTS: void 0,
                                        timescale: 1
                                    },
                                    Tt = this.initData;
                                if ((!Tt || !Tt.length) && (this.generateInitSegment(xt), Tt = this.initData), !Tt || !Tt.length) return It.logger.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."), mt;
                                this.emitInitSegment && (yt.tracks = this.initTracks, this.emitInitSegment = !1);
                                var Ft = (0, bt.getStartDTS)(Tt, xt);
                                (0, ut.isFiniteNumber)(_t) || (this.initPTS = yt.initPTS = _t = Ft - dt);
                                var wt = (0, bt.getDuration)(xt, Tt),
                                    kt = Dt ? Ft - _t : vt,
                                    Ot = kt + wt;
                                (0, bt.offsetStartDTS)(Tt, xt, _t), wt > 0 ? this.lastEndTime = Ot : (It.logger.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp());
                                var Rt = !!Tt.audio,
                                    Lt = !!Tt.video,
                                    Bt = "";
                                Rt && (Bt += "audio"), Lt && (Bt += "video");
                                var Nt = {
                                    data1: xt,
                                    startPTS: kt,
                                    startDTS: kt,
                                    endPTS: Ot,
                                    endDTS: Ot,
                                    type: Bt,
                                    hasAudio: Rt,
                                    hasVideo: Lt,
                                    nb: 1,
                                    dropped: 0
                                };
                                mt.audio = Nt.type === "audio" ? Nt : void 0, mt.video = Nt.type !== "audio" ? Nt : void 0, mt.initSegment = yt;
                                var $t = (St = this.initPTS) != null ? St : 0;
                                return mt.id3 = (0, lt.flushTextTrackMetadataCueSamples)(gt, dt, $t, $t), ft.samples.length && (mt.text = (0, lt.flushTextTrackUserdataCueSamples)(ft, dt, $t)), mt
                            }, ot
                        }();

                    function Ct(ot, ct) {
                        var Et = ot == null ? void 0 : ot.codec;
                        return Et && Et.length > 4 ? Et : Et === "hvc1" || Et === "hev1" ? "hvc1.1.c.L120.90" : Et === "av01" ? "av01.0.04M.08" : Et === "avc1" || ct === pt.ElementaryStreamTypes.VIDEO ? "avc1.42e01e" : "mp4a.40.5"
                    }
                    const ht = At
                },
                "./src/task-loop.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => ut
                    });
                    var ut = function() {
                        function lt() {
                            this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this)
                        }
                        var bt = lt.prototype;
                        return bt.destroy = function() {
                            this.onHandlerDestroying(), this.onHandlerDestroyed()
                        }, bt.onHandlerDestroying = function() {
                            this.clearNextTick(), this.clearInterval()
                        }, bt.onHandlerDestroyed = function() {}, bt.hasInterval = function() {
                            return !!this._tickInterval
                        }, bt.hasNextTick = function() {
                            return !!this._tickTimer
                        }, bt.setInterval = function(It) {
                            return this._tickInterval ? !1 : (this._tickInterval = self.setInterval(this._boundTick, It), !0)
                        }, bt.clearInterval = function() {
                            return this._tickInterval ? (self.clearInterval(this._tickInterval), this._tickInterval = null, !0) : !1
                        }, bt.clearNextTick = function() {
                            return this._tickTimer ? (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0) : !1
                        }, bt.tick = function() {
                            this._tickCallCount++, this._tickCallCount === 1 && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0)
                        }, bt.tickImmediate = function() {
                            this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0)
                        }, bt.doTick = function() {}, lt
                    }()
                },
                "./src/types/cmcd.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        CMCDObjectType: () => lt,
                        CMCDStreamType: () => pt,
                        CMCDStreamingFormat: () => bt,
                        CMCDVersion: () => ut
                    });
                    var ut = 1,
                        lt;
                    (function(It) {
                        It.MANIFEST = "m", It.AUDIO = "a", It.VIDEO = "v", It.MUXED = "av", It.INIT = "i", It.CAPTION = "c", It.TIMED_TEXT = "tt", It.KEY = "k", It.OTHER = "o"
                    })(lt || (lt = {}));
                    var bt;
                    (function(It) {
                        It.DASH = "d", It.HLS = "h", It.SMOOTH = "s", It.OTHER = "o"
                    })(bt || (bt = {}));
                    var pt;
                    (function(It) {
                        It.VOD = "v", It.LIVE = "l"
                    })(pt || (pt = {}))
                },
                "./src/types/demuxer.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        MetadataSchema: () => ut
                    });
                    var ut;
                    (function(lt) {
                        lt.audioId3 = "org.id3", lt.dateRange = "com.apple.quicktime.HLS", lt.emsg = "https://aomedia.org/emsg/ID3"
                    })(ut || (ut = {}))
                },
                "./src/types/level.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        HlsSkip: () => bt,
                        HlsUrlParameters: () => It,
                        Level: () => At,
                        getSkipValue: () => pt
                    });

                    function ut(Ct, ht) {
                        for (var ot = 0; ot < ht.length; ot++) {
                            var ct = ht[ot];
                            ct.enumerable = ct.enumerable || !1, ct.configurable = !0, "value" in ct && (ct.writable = !0), Object.defineProperty(Ct, ct.key, ct)
                        }
                    }

                    function lt(Ct, ht, ot) {
                        return ht && ut(Ct.prototype, ht), ot && ut(Ct, ot), Object.defineProperty(Ct, "prototype", {
                            writable: !1
                        }), Ct
                    }
                    var bt;
                    (function(Ct) {
                        Ct.No = "", Ct.Yes = "YES", Ct.v2 = "v2"
                    })(bt || (bt = {}));

                    function pt(Ct, ht) {
                        var ot = Ct.canSkipUntil,
                            ct = Ct.canSkipDateRanges,
                            Et = Ct.endSN,
                            Dt = ht !== void 0 ? ht - Et : 0;
                        return ot && Dt < ot ? ct ? bt.v2 : bt.Yes : bt.No
                    }
                    var It = function() {
                            function Ct(ot, ct, Et) {
                                this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = ot, this.part = ct, this.skip = Et
                            }
                            var ht = Ct.prototype;
                            return ht.addDirectives = function(ct) {
                                var Et = new self.URL(ct);
                                return this.msn !== void 0 && Et.searchParams.set("_HLS_msn", this.msn.toString()), this.part !== void 0 && Et.searchParams.set("_HLS_part", this.part.toString()), this.skip && Et.searchParams.set("_HLS_skip", this.skip), Et.toString()
                            }, Ct
                        }(),
                        At = function() {
                            function Ct(ht) {
                                this.attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.unknownCodecs = void 0, this.audioGroupIds = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.textGroupIds = void 0, this.url = void 0, this._urlId = 0, this.url = [ht.url], this.attrs = ht.attrs, this.bitrate = ht.bitrate, ht.details && (this.details = ht.details), this.id = ht.id || 0, this.name = ht.name, this.width = ht.width || 0, this.height = ht.height || 0, this.audioCodec = ht.audioCodec, this.videoCodec = ht.videoCodec, this.unknownCodecs = ht.unknownCodecs, this.codecSet = [ht.videoCodec, ht.audioCodec].filter(function(ot) {
                                    return ot
                                }).join(",").replace(/\.[^.,]+/g, "")
                            }
                            return lt(Ct, [{
                                key: "maxBitrate",
                                get: function() {
                                    return Math.max(this.realBitrate, this.bitrate)
                                }
                            }, {
                                key: "uri",
                                get: function() {
                                    return this.url[this._urlId] || ""
                                }
                            }, {
                                key: "urlId",
                                get: function() {
                                    return this._urlId
                                },
                                set: function(ot) {
                                    var ct = ot % this.url.length;
                                    this._urlId !== ct && (this.details = void 0, this._urlId = ct)
                                }
                            }]), Ct
                        }()
                },
                "./src/types/loader.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        PlaylistContextType: () => ut,
                        PlaylistLevelType: () => lt
                    });
                    var ut;
                    (function(bt) {
                        bt.MANIFEST = "manifest", bt.LEVEL = "level", bt.AUDIO_TRACK = "audioTrack", bt.SUBTITLE_TRACK = "subtitleTrack"
                    })(ut || (ut = {}));
                    var lt;
                    (function(bt) {
                        bt.MAIN = "main", bt.AUDIO = "audio", bt.SUBTITLE = "subtitle"
                    })(lt || (lt = {}))
                },
                "./src/types/transmuxer.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        ChunkMetadata: () => ut
                    });
                    var ut = function(pt, It, At, Ct, ht, ot) {
                        Ct === void 0 && (Ct = 0), ht === void 0 && (ht = -1), ot === void 0 && (ot = !1), this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = lt(), this.buffering = {
                            audio: lt(),
                            video: lt(),
                            audiovideo: lt()
                        }, this.level = pt, this.sn = It, this.id = At, this.size = Ct, this.part = ht, this.partial = ot
                    };

                    function lt() {
                        return {
                            start: 0,
                            executeStart: 0,
                            executeEnd: 0,
                            end: 0
                        }
                    }
                },
                "./src/utils/attr-list.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        AttrList: () => bt
                    });
                    var ut = /^(\d+)x(\d+)$/,
                        lt = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g,
                        bt = function() {
                            function pt(At) {
                                typeof At == "string" && (At = pt.parseAttrList(At));
                                for (var Ct in At) At.hasOwnProperty(Ct) && (this[Ct] = At[Ct])
                            }
                            var It = pt.prototype;
                            return It.decimalInteger = function(Ct) {
                                var ht = parseInt(this[Ct], 10);
                                return ht > Number.MAX_SAFE_INTEGER ? 1 / 0 : ht
                            }, It.hexadecimalInteger = function(Ct) {
                                if (this[Ct]) {
                                    var ht = (this[Ct] || "0x").slice(2);
                                    ht = (ht.length & 1 ? "0" : "") + ht;
                                    for (var ot = new Uint8Array(ht.length / 2), ct = 0; ct < ht.length / 2; ct++) ot[ct] = parseInt(ht.slice(ct * 2, ct * 2 + 2), 16);
                                    return ot
                                } else return null
                            }, It.hexadecimalIntegerAsNumber = function(Ct) {
                                var ht = parseInt(this[Ct], 16);
                                return ht > Number.MAX_SAFE_INTEGER ? 1 / 0 : ht
                            }, It.decimalFloatingPoint = function(Ct) {
                                return parseFloat(this[Ct])
                            }, It.optionalFloat = function(Ct, ht) {
                                var ot = this[Ct];
                                return ot ? parseFloat(ot) : ht
                            }, It.enumeratedString = function(Ct) {
                                return this[Ct]
                            }, It.bool = function(Ct) {
                                return this[Ct] === "YES"
                            }, It.decimalResolution = function(Ct) {
                                var ht = ut.exec(this[Ct]);
                                if (ht !== null) return {
                                    width: parseInt(ht[1], 10),
                                    height: parseInt(ht[2], 10)
                                }
                            }, pt.parseAttrList = function(Ct) {
                                var ht, ot = {},
                                    ct = '"';
                                for (lt.lastIndex = 0;
                                    (ht = lt.exec(Ct)) !== null;) {
                                    var Et = ht[2];
                                    Et.indexOf(ct) === 0 && Et.lastIndexOf(ct) === Et.length - 1 && (Et = Et.slice(1, -1)), ot[ht[1]] = Et
                                }
                                return ot
                            }, pt
                        }()
                },
                "./src/utils/binary-search.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => lt
                    });
                    var ut = {
                        search: function(pt, It) {
                            for (var At = 0, Ct = pt.length - 1, ht = null, ot = null; At <= Ct;) {
                                ht = (At + Ct) / 2 | 0, ot = pt[ht];
                                var ct = It(ot);
                                if (ct > 0) At = ht + 1;
                                else if (ct < 0) Ct = ht - 1;
                                else return ot
                            }
                            return null
                        }
                    };
                    const lt = ut
                },
                "./src/utils/buffer-helper.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        BufferHelper: () => bt
                    });
                    var ut = it("./src/utils/logger.ts"),
                        lt = {
                            length: 0,
                            start: function() {
                                return 0
                            },
                            end: function() {
                                return 0
                            }
                        },
                        bt = function() {
                            function pt() {}
                            return pt.isBuffered = function(At, Ct) {
                                try {
                                    if (At) {
                                        for (var ht = pt.getBuffered(At), ot = 0; ot < ht.length; ot++)
                                            if (Ct >= ht.start(ot) && Ct <= ht.end(ot)) return !0
                                    }
                                } catch {}
                                return !1
                            }, pt.bufferInfo = function(At, Ct, ht) {
                                try {
                                    if (At) {
                                        var ot = pt.getBuffered(At),
                                            ct = [],
                                            Et;
                                        for (Et = 0; Et < ot.length; Et++) ct.push({
                                            start: ot.start(Et),
                                            end: ot.end(Et)
                                        });
                                        return this.bufferedInfo(ct, Ct, ht)
                                    }
                                } catch {}
                                return {
                                    len: 0,
                                    start: Ct,
                                    end: Ct,
                                    nextStart: void 0
                                }
                            }, pt.bufferedInfo = function(At, Ct, ht) {
                                Ct = Math.max(0, Ct), At.sort(function(mt, xt) {
                                    var yt = mt.start - xt.start;
                                    return yt || xt.end - mt.end
                                });
                                var ot = [];
                                if (ht)
                                    for (var ct = 0; ct < At.length; ct++) {
                                        var Et = ot.length;
                                        if (Et) {
                                            var Dt = ot[Et - 1].end;
                                            At[ct].start - Dt < ht ? At[ct].end > Dt && (ot[Et - 1].end = At[ct].end) : ot.push(At[ct])
                                        } else ot.push(At[ct])
                                    } else ot = At;
                                for (var Pt = 0, gt, ft = Ct, dt = Ct, St = 0; St < ot.length; St++) {
                                    var _t = ot[St].start,
                                        vt = ot[St].end;
                                    if (Ct + ht >= _t && Ct < vt) ft = _t, dt = vt, Pt = dt - Ct;
                                    else if (Ct + ht < _t) {
                                        gt = _t;
                                        break
                                    }
                                }
                                return {
                                    len: Pt,
                                    start: ft || 0,
                                    end: dt || 0,
                                    nextStart: gt
                                }
                            }, pt.getBuffered = function(At) {
                                try {
                                    return At.buffered
                                } catch (Ct) {
                                    return ut.logger.log("failed to get media.buffered", Ct), lt
                                }
                            }, pt
                        }()
                },
                "./src/utils/cea-608-parser.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        CaptionScreen: () => St,
                        Row: () => dt,
                        default: () => Tt
                    });
                    var ut = it("./src/utils/logger.ts"),
                        lt = {
                            42: 225,
                            92: 233,
                            94: 237,
                            95: 243,
                            96: 250,
                            123: 231,
                            124: 247,
                            125: 209,
                            126: 241,
                            127: 9608,
                            128: 174,
                            129: 176,
                            130: 189,
                            131: 191,
                            132: 8482,
                            133: 162,
                            134: 163,
                            135: 9834,
                            136: 224,
                            137: 32,
                            138: 232,
                            139: 226,
                            140: 234,
                            141: 238,
                            142: 244,
                            143: 251,
                            144: 193,
                            145: 201,
                            146: 211,
                            147: 218,
                            148: 220,
                            149: 252,
                            150: 8216,
                            151: 161,
                            152: 42,
                            153: 8217,
                            154: 9473,
                            155: 169,
                            156: 8480,
                            157: 8226,
                            158: 8220,
                            159: 8221,
                            160: 192,
                            161: 194,
                            162: 199,
                            163: 200,
                            164: 202,
                            165: 203,
                            166: 235,
                            167: 206,
                            168: 207,
                            169: 239,
                            170: 212,
                            171: 217,
                            172: 249,
                            173: 219,
                            174: 171,
                            175: 187,
                            176: 195,
                            177: 227,
                            178: 205,
                            179: 204,
                            180: 236,
                            181: 210,
                            182: 242,
                            183: 213,
                            184: 245,
                            185: 123,
                            186: 125,
                            187: 92,
                            188: 94,
                            189: 95,
                            190: 124,
                            191: 8764,
                            192: 196,
                            193: 228,
                            194: 214,
                            195: 246,
                            196: 223,
                            197: 165,
                            198: 164,
                            199: 9475,
                            200: 197,
                            201: 229,
                            202: 216,
                            203: 248,
                            204: 9487,
                            205: 9491,
                            206: 9495,
                            207: 9499
                        },
                        bt = function(wt) {
                            var kt = wt;
                            return lt.hasOwnProperty(wt) && (kt = lt[wt]), String.fromCharCode(kt)
                        },
                        pt = 15,
                        It = 100,
                        At = {
                            17: 1,
                            18: 3,
                            21: 5,
                            22: 7,
                            23: 9,
                            16: 11,
                            19: 12,
                            20: 14
                        },
                        Ct = {
                            17: 2,
                            18: 4,
                            21: 6,
                            22: 8,
                            23: 10,
                            19: 13,
                            20: 15
                        },
                        ht = {
                            25: 1,
                            26: 3,
                            29: 5,
                            30: 7,
                            31: 9,
                            24: 11,
                            27: 12,
                            28: 14
                        },
                        ot = {
                            25: 2,
                            26: 4,
                            29: 6,
                            30: 8,
                            31: 10,
                            27: 13,
                            28: 15
                        },
                        ct = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"],
                        Et;
                    (function(Ft) {
                        Ft[Ft.ERROR = 0] = "ERROR", Ft[Ft.TEXT = 1] = "TEXT", Ft[Ft.WARNING = 2] = "WARNING", Ft[Ft.INFO = 2] = "INFO", Ft[Ft.DEBUG = 3] = "DEBUG", Ft[Ft.DATA = 3] = "DATA"
                    })(Et || (Et = {}));
                    var Dt = function() {
                            function Ft() {
                                this.time = null, this.verboseLevel = Et.ERROR
                            }
                            var wt = Ft.prototype;
                            return wt.log = function(Ot, Rt) {
                                this.verboseLevel >= Ot && ut.logger.log(this.time + " [" + Ot + "] " + Rt)
                            }, Ft
                        }(),
                        Pt = function(wt) {
                            for (var kt = [], Ot = 0; Ot < wt.length; Ot++) kt.push(wt[Ot].toString(16));
                            return kt
                        },
                        gt = function() {
                            function Ft(kt, Ot, Rt, Lt, Bt) {
                                this.foreground = void 0, this.underline = void 0, this.italics = void 0, this.background = void 0, this.flash = void 0, this.foreground = kt || "white", this.underline = Ot || !1, this.italics = Rt || !1, this.background = Lt || "black", this.flash = Bt || !1
                            }
                            var wt = Ft.prototype;
                            return wt.reset = function() {
                                this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1
                            }, wt.setStyles = function(Ot) {
                                for (var Rt = ["foreground", "underline", "italics", "background", "flash"], Lt = 0; Lt < Rt.length; Lt++) {
                                    var Bt = Rt[Lt];
                                    Ot.hasOwnProperty(Bt) && (this[Bt] = Ot[Bt])
                                }
                            }, wt.isDefault = function() {
                                return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash
                            }, wt.equals = function(Ot) {
                                return this.foreground === Ot.foreground && this.underline === Ot.underline && this.italics === Ot.italics && this.background === Ot.background && this.flash === Ot.flash
                            }, wt.copy = function(Ot) {
                                this.foreground = Ot.foreground, this.underline = Ot.underline, this.italics = Ot.italics, this.background = Ot.background, this.flash = Ot.flash
                            }, wt.toString = function() {
                                return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash
                            }, Ft
                        }(),
                        ft = function() {
                            function Ft(kt, Ot, Rt, Lt, Bt, Nt) {
                                this.uchar = void 0, this.penState = void 0, this.uchar = kt || " ", this.penState = new gt(Ot, Rt, Lt, Bt, Nt)
                            }
                            var wt = Ft.prototype;
                            return wt.reset = function() {
                                this.uchar = " ", this.penState.reset()
                            }, wt.setChar = function(Ot, Rt) {
                                this.uchar = Ot, this.penState.copy(Rt)
                            }, wt.setPenState = function(Ot) {
                                this.penState.copy(Ot)
                            }, wt.equals = function(Ot) {
                                return this.uchar === Ot.uchar && this.penState.equals(Ot.penState)
                            }, wt.copy = function(Ot) {
                                this.uchar = Ot.uchar, this.penState.copy(Ot.penState)
                            }, wt.isEmpty = function() {
                                return this.uchar === " " && this.penState.isDefault()
                            }, Ft
                        }(),
                        dt = function() {
                            function Ft(kt) {
                                this.chars = void 0, this.pos = void 0, this.currPenState = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chars = [];
                                for (var Ot = 0; Ot < It; Ot++) this.chars.push(new ft);
                                this.logger = kt, this.pos = 0, this.currPenState = new gt
                            }
                            var wt = Ft.prototype;
                            return wt.equals = function(Ot) {
                                for (var Rt = !0, Lt = 0; Lt < It; Lt++)
                                    if (!this.chars[Lt].equals(Ot.chars[Lt])) {
                                        Rt = !1;
                                        break
                                    } return Rt
                            }, wt.copy = function(Ot) {
                                for (var Rt = 0; Rt < It; Rt++) this.chars[Rt].copy(Ot.chars[Rt])
                            }, wt.isEmpty = function() {
                                for (var Ot = !0, Rt = 0; Rt < It; Rt++)
                                    if (!this.chars[Rt].isEmpty()) {
                                        Ot = !1;
                                        break
                                    } return Ot
                            }, wt.setCursor = function(Ot) {
                                this.pos !== Ot && (this.pos = Ot), this.pos < 0 ? (this.logger.log(Et.DEBUG, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > It && (this.logger.log(Et.DEBUG, "Too large cursor position " + this.pos), this.pos = It)
                            }, wt.moveCursor = function(Ot) {
                                var Rt = this.pos + Ot;
                                if (Ot > 1)
                                    for (var Lt = this.pos + 1; Lt < Rt + 1; Lt++) this.chars[Lt].setPenState(this.currPenState);
                                this.setCursor(Rt)
                            }, wt.backSpace = function() {
                                this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState)
                            }, wt.insertChar = function(Ot) {
                                Ot >= 144 && this.backSpace();
                                var Rt = bt(Ot);
                                if (this.pos >= It) {
                                    this.logger.log(Et.ERROR, "Cannot insert " + Ot.toString(16) + " (" + Rt + ") at position " + this.pos + ". Skipping it!");
                                    return
                                }
                                this.chars[this.pos].setChar(Rt, this.currPenState), this.moveCursor(1)
                            }, wt.clearFromPos = function(Ot) {
                                var Rt;
                                for (Rt = Ot; Rt < It; Rt++) this.chars[Rt].reset()
                            }, wt.clear = function() {
                                this.clearFromPos(0), this.pos = 0, this.currPenState.reset()
                            }, wt.clearToEndOfRow = function() {
                                this.clearFromPos(this.pos)
                            }, wt.getTextString = function() {
                                for (var Ot = [], Rt = !0, Lt = 0; Lt < It; Lt++) {
                                    var Bt = this.chars[Lt].uchar;
                                    Bt !== " " && (Rt = !1), Ot.push(Bt)
                                }
                                return Rt ? "" : Ot.join("")
                            }, wt.setPenStyles = function(Ot) {
                                this.currPenState.setStyles(Ot);
                                var Rt = this.chars[this.pos];
                                Rt.setPenState(this.currPenState)
                            }, Ft
                        }(),
                        St = function() {
                            function Ft(kt) {
                                this.rows = void 0, this.currRow = void 0, this.nrRollUpRows = void 0, this.lastOutputScreen = void 0, this.logger = void 0, this.rows = [];
                                for (var Ot = 0; Ot < pt; Ot++) this.rows.push(new dt(kt));
                                this.logger = kt, this.currRow = pt - 1, this.nrRollUpRows = null, this.lastOutputScreen = null, this.reset()
                            }
                            var wt = Ft.prototype;
                            return wt.reset = function() {
                                for (var Ot = 0; Ot < pt; Ot++) this.rows[Ot].clear();
                                this.currRow = pt - 1
                            }, wt.equals = function(Ot) {
                                for (var Rt = !0, Lt = 0; Lt < pt; Lt++)
                                    if (!this.rows[Lt].equals(Ot.rows[Lt])) {
                                        Rt = !1;
                                        break
                                    } return Rt
                            }, wt.copy = function(Ot) {
                                for (var Rt = 0; Rt < pt; Rt++) this.rows[Rt].copy(Ot.rows[Rt])
                            }, wt.isEmpty = function() {
                                for (var Ot = !0, Rt = 0; Rt < pt; Rt++)
                                    if (!this.rows[Rt].isEmpty()) {
                                        Ot = !1;
                                        break
                                    } return Ot
                            }, wt.backSpace = function() {
                                var Ot = this.rows[this.currRow];
                                Ot.backSpace()
                            }, wt.clearToEndOfRow = function() {
                                var Ot = this.rows[this.currRow];
                                Ot.clearToEndOfRow()
                            }, wt.insertChar = function(Ot) {
                                var Rt = this.rows[this.currRow];
                                Rt.insertChar(Ot)
                            }, wt.setPen = function(Ot) {
                                var Rt = this.rows[this.currRow];
                                Rt.setPenStyles(Ot)
                            }, wt.moveCursor = function(Ot) {
                                var Rt = this.rows[this.currRow];
                                Rt.moveCursor(Ot)
                            }, wt.setCursor = function(Ot) {
                                this.logger.log(Et.INFO, "setCursor: " + Ot);
                                var Rt = this.rows[this.currRow];
                                Rt.setCursor(Ot)
                            }, wt.setPAC = function(Ot) {
                                this.logger.log(Et.INFO, "pacData = " + JSON.stringify(Ot));
                                var Rt = Ot.row - 1;
                                if (this.nrRollUpRows && Rt < this.nrRollUpRows - 1 && (Rt = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== Rt) {
                                    for (var Lt = 0; Lt < pt; Lt++) this.rows[Lt].clear();
                                    var Bt = this.currRow + 1 - this.nrRollUpRows,
                                        Nt = this.lastOutputScreen;
                                    if (Nt) {
                                        var $t = Nt.rows[Bt].cueStartTime,
                                            jt = this.logger.time;
                                        if ($t && jt !== null && $t < jt)
                                            for (var Ut = 0; Ut < this.nrRollUpRows; Ut++) this.rows[Rt - this.nrRollUpRows + Ut + 1].copy(Nt.rows[Bt + Ut])
                                    }
                                }
                                this.currRow = Rt;
                                var Ht = this.rows[this.currRow];
                                if (Ot.indent !== null) {
                                    var Wt = Ot.indent,
                                        Kt = Math.max(Wt - 1, 0);
                                    Ht.setCursor(Ot.indent), Ot.color = Ht.chars[Kt].penState.foreground
                                }
                                var Gt = {
                                    foreground: Ot.color,
                                    underline: Ot.underline,
                                    italics: Ot.italics,
                                    background: "black",
                                    flash: !1
                                };
                                this.setPen(Gt)
                            }, wt.setBkgData = function(Ot) {
                                this.logger.log(Et.INFO, "bkgData = " + JSON.stringify(Ot)), this.backSpace(), this.setPen(Ot), this.insertChar(32)
                            }, wt.setRollUpRows = function(Ot) {
                                this.nrRollUpRows = Ot
                            }, wt.rollUp = function() {
                                if (this.nrRollUpRows === null) {
                                    this.logger.log(Et.DEBUG, "roll_up but nrRollUpRows not set yet");
                                    return
                                }
                                this.logger.log(Et.TEXT, this.getDisplayText());
                                var Ot = this.currRow + 1 - this.nrRollUpRows,
                                    Rt = this.rows.splice(Ot, 1)[0];
                                Rt.clear(), this.rows.splice(this.currRow, 0, Rt), this.logger.log(Et.INFO, "Rolling up")
                            }, wt.getDisplayText = function(Ot) {
                                Ot = Ot || !1;
                                for (var Rt = [], Lt = "", Bt = -1, Nt = 0; Nt < pt; Nt++) {
                                    var $t = this.rows[Nt].getTextString();
                                    $t && (Bt = Nt + 1, Ot ? Rt.push("Row " + Bt + ": '" + $t + "'") : Rt.push($t.trim()))
                                }
                                return Rt.length > 0 && (Ot ? Lt = "[" + Rt.join(" | ") + "]" : Lt = Rt.join(`
`)), Lt
                            }, wt.getTextAndFormat = function() {
                                return this.rows
                            }, Ft
                        }(),
                        _t = function() {
                            function Ft(kt, Ot, Rt) {
                                this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = kt, this.outputFilter = Ot, this.mode = null, this.verbose = 0, this.displayedMemory = new St(Rt), this.nonDisplayedMemory = new St(Rt), this.lastOutputScreen = new St(Rt), this.currRollUpRow = this.displayedMemory.rows[pt - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = Rt
                            }
                            var wt = Ft.prototype;
                            return wt.reset = function() {
                                this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[pt - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null
                            }, wt.getHandler = function() {
                                return this.outputFilter
                            }, wt.setHandler = function(Ot) {
                                this.outputFilter = Ot
                            }, wt.setPAC = function(Ot) {
                                this.writeScreen.setPAC(Ot)
                            }, wt.setBkgData = function(Ot) {
                                this.writeScreen.setBkgData(Ot)
                            }, wt.setMode = function(Ot) {
                                Ot !== this.mode && (this.mode = Ot, this.logger.log(Et.INFO, "MODE=" + Ot), this.mode === "MODE_POP-ON" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== "MODE_ROLL-UP" && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = Ot)
                            }, wt.insertChars = function(Ot) {
                                for (var Rt = 0; Rt < Ot.length; Rt++) this.writeScreen.insertChar(Ot[Rt]);
                                var Lt = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
                                this.logger.log(Et.INFO, Lt + ": " + this.writeScreen.getDisplayText(!0)), (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") && (this.logger.log(Et.TEXT, "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate())
                            }, wt.ccRCL = function() {
                                this.logger.log(Et.INFO, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON")
                            }, wt.ccBS = function() {
                                this.logger.log(Et.INFO, "BS - BackSpace"), this.mode !== "MODE_TEXT" && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate())
                            }, wt.ccAOF = function() {}, wt.ccAON = function() {}, wt.ccDER = function() {
                                this.logger.log(Et.INFO, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate()
                            }, wt.ccRU = function(Ot) {
                                this.logger.log(Et.INFO, "RU(" + Ot + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(Ot)
                            }, wt.ccFON = function() {
                                this.logger.log(Et.INFO, "FON - Flash On"), this.writeScreen.setPen({
                                    flash: !0
                                })
                            }, wt.ccRDC = function() {
                                this.logger.log(Et.INFO, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON")
                            }, wt.ccTR = function() {
                                this.logger.log(Et.INFO, "TR"), this.setMode("MODE_TEXT")
                            }, wt.ccRTD = function() {
                                this.logger.log(Et.INFO, "RTD"), this.setMode("MODE_TEXT")
                            }, wt.ccEDM = function() {
                                this.logger.log(Et.INFO, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0)
                            }, wt.ccCR = function() {
                                this.logger.log(Et.INFO, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0)
                            }, wt.ccENM = function() {
                                this.logger.log(Et.INFO, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset()
                            }, wt.ccEOC = function() {
                                if (this.logger.log(Et.INFO, "EOC - End Of Caption"), this.mode === "MODE_POP-ON") {
                                    var Ot = this.displayedMemory;
                                    this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = Ot, this.writeScreen = this.nonDisplayedMemory, this.logger.log(Et.TEXT, "DISP: " + this.displayedMemory.getDisplayText())
                                }
                                this.outputDataUpdate(!0)
                            }, wt.ccTO = function(Ot) {
                                this.logger.log(Et.INFO, "TO(" + Ot + ") - Tab Offset"), this.writeScreen.moveCursor(Ot)
                            }, wt.ccMIDROW = function(Ot) {
                                var Rt = {
                                    flash: !1
                                };
                                if (Rt.underline = Ot % 2 === 1, Rt.italics = Ot >= 46, Rt.italics) Rt.foreground = "white";
                                else {
                                    var Lt = Math.floor(Ot / 2) - 16,
                                        Bt = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
                                    Rt.foreground = Bt[Lt]
                                }
                                this.logger.log(Et.INFO, "MIDROW: " + JSON.stringify(Rt)), this.writeScreen.setPen(Rt)
                            }, wt.outputDataUpdate = function(Ot) {
                                Ot === void 0 && (Ot = !1);
                                var Rt = this.logger.time;
                                Rt !== null && this.outputFilter && (this.cueStartTime === null && !this.displayedMemory.isEmpty() ? this.cueStartTime = Rt : this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, Rt, this.lastOutputScreen), Ot && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : Rt), this.lastOutputScreen.copy(this.displayedMemory))
                            }, wt.cueSplitAtTime = function(Ot) {
                                this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, Ot, this.displayedMemory), this.cueStartTime = Ot))
                            }, Ft
                        }(),
                        vt = function() {
                            function Ft(kt, Ot, Rt) {
                                this.channels = void 0, this.currentChannel = 0, this.cmdHistory = void 0, this.logger = void 0;
                                var Lt = new Dt;
                                this.channels = [null, new _t(kt, Ot, Lt), new _t(kt + 1, Rt, Lt)], this.cmdHistory = yt(), this.logger = Lt
                            }
                            var wt = Ft.prototype;
                            return wt.getHandler = function(Ot) {
                                return this.channels[Ot].getHandler()
                            }, wt.setHandler = function(Ot, Rt) {
                                this.channels[Ot].setHandler(Rt)
                            }, wt.addData = function(Ot, Rt) {
                                var Lt, Bt, Nt, $t = !1;
                                this.logger.time = Ot;
                                for (var jt = 0; jt < Rt.length; jt += 2)
                                    if (Bt = Rt[jt] & 127, Nt = Rt[jt + 1] & 127, !(Bt === 0 && Nt === 0)) {
                                        if (this.logger.log(Et.DATA, "[" + Pt([Rt[jt], Rt[jt + 1]]) + "] -> (" + Pt([Bt, Nt]) + ")"), Lt = this.parseCmd(Bt, Nt), Lt || (Lt = this.parseMidrow(Bt, Nt)), Lt || (Lt = this.parsePAC(Bt, Nt)), Lt || (Lt = this.parseBackgroundAttributes(Bt, Nt)), !Lt && ($t = this.parseChars(Bt, Nt), $t)) {
                                            var Ut = this.currentChannel;
                                            if (Ut && Ut > 0) {
                                                var Ht = this.channels[Ut];
                                                Ht.insertChars($t)
                                            } else this.logger.log(Et.WARNING, "No channel found yet. TEXT-MODE?")
                                        }!Lt && !$t && this.logger.log(Et.WARNING, "Couldn't parse cleaned data " + Pt([Bt, Nt]) + " orig: " + Pt([Rt[jt], Rt[jt + 1]]))
                                    }
                            }, wt.parseCmd = function(Ot, Rt) {
                                var Lt = this.cmdHistory,
                                    Bt = (Ot === 20 || Ot === 28 || Ot === 21 || Ot === 29) && Rt >= 32 && Rt <= 47,
                                    Nt = (Ot === 23 || Ot === 31) && Rt >= 33 && Rt <= 35;
                                if (!(Bt || Nt)) return !1;
                                if (xt(Ot, Rt, Lt)) return mt(null, null, Lt), this.logger.log(Et.DEBUG, "Repeated command (" + Pt([Ot, Rt]) + ") is dropped"), !0;
                                var $t = Ot === 20 || Ot === 21 || Ot === 23 ? 1 : 2,
                                    jt = this.channels[$t];
                                return Ot === 20 || Ot === 21 || Ot === 28 || Ot === 29 ? Rt === 32 ? jt.ccRCL() : Rt === 33 ? jt.ccBS() : Rt === 34 ? jt.ccAOF() : Rt === 35 ? jt.ccAON() : Rt === 36 ? jt.ccDER() : Rt === 37 ? jt.ccRU(2) : Rt === 38 ? jt.ccRU(3) : Rt === 39 ? jt.ccRU(4) : Rt === 40 ? jt.ccFON() : Rt === 41 ? jt.ccRDC() : Rt === 42 ? jt.ccTR() : Rt === 43 ? jt.ccRTD() : Rt === 44 ? jt.ccEDM() : Rt === 45 ? jt.ccCR() : Rt === 46 ? jt.ccENM() : Rt === 47 && jt.ccEOC() : jt.ccTO(Rt - 32), mt(Ot, Rt, Lt), this.currentChannel = $t, !0
                            }, wt.parseMidrow = function(Ot, Rt) {
                                var Lt = 0;
                                if ((Ot === 17 || Ot === 25) && Rt >= 32 && Rt <= 47) {
                                    if (Ot === 17 ? Lt = 1 : Lt = 2, Lt !== this.currentChannel) return this.logger.log(Et.ERROR, "Mismatch channel in midrow parsing"), !1;
                                    var Bt = this.channels[Lt];
                                    return Bt ? (Bt.ccMIDROW(Rt), this.logger.log(Et.DEBUG, "MIDROW (" + Pt([Ot, Rt]) + ")"), !0) : !1
                                }
                                return !1
                            }, wt.parsePAC = function(Ot, Rt) {
                                var Lt, Bt = this.cmdHistory,
                                    Nt = (Ot >= 17 && Ot <= 23 || Ot >= 25 && Ot <= 31) && Rt >= 64 && Rt <= 127,
                                    $t = (Ot === 16 || Ot === 24) && Rt >= 64 && Rt <= 95;
                                if (!(Nt || $t)) return !1;
                                if (xt(Ot, Rt, Bt)) return mt(null, null, Bt), !0;
                                var jt = Ot <= 23 ? 1 : 2;
                                Rt >= 64 && Rt <= 95 ? Lt = jt === 1 ? At[Ot] : ht[Ot] : Lt = jt === 1 ? Ct[Ot] : ot[Ot];
                                var Ut = this.channels[jt];
                                return Ut ? (Ut.setPAC(this.interpretPAC(Lt, Rt)), mt(Ot, Rt, Bt), this.currentChannel = jt, !0) : !1
                            }, wt.interpretPAC = function(Ot, Rt) {
                                var Lt, Bt = {
                                    color: null,
                                    italics: !1,
                                    indent: null,
                                    underline: !1,
                                    row: Ot
                                };
                                return Rt > 95 ? Lt = Rt - 96 : Lt = Rt - 64, Bt.underline = (Lt & 1) === 1, Lt <= 13 ? Bt.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(Lt / 2)] : Lt <= 15 ? (Bt.italics = !0, Bt.color = "white") : Bt.indent = Math.floor((Lt - 16) / 2) * 4, Bt
                            }, wt.parseChars = function(Ot, Rt) {
                                var Lt, Bt = null,
                                    Nt = null;
                                if (Ot >= 25 ? (Lt = 2, Nt = Ot - 8) : (Lt = 1, Nt = Ot), Nt >= 17 && Nt <= 19) {
                                    var $t;
                                    Nt === 17 ? $t = Rt + 80 : Nt === 18 ? $t = Rt + 112 : $t = Rt + 144, this.logger.log(Et.INFO, "Special char '" + bt($t) + "' in channel " + Lt), Bt = [$t]
                                } else Ot >= 32 && Ot <= 127 && (Bt = Rt === 0 ? [Ot] : [Ot, Rt]);
                                if (Bt) {
                                    var jt = Pt(Bt);
                                    this.logger.log(Et.DEBUG, "Char codes =  " + jt.join(",")), mt(Ot, Rt, this.cmdHistory)
                                }
                                return Bt
                            }, wt.parseBackgroundAttributes = function(Ot, Rt) {
                                var Lt = (Ot === 16 || Ot === 24) && Rt >= 32 && Rt <= 47,
                                    Bt = (Ot === 23 || Ot === 31) && Rt >= 45 && Rt <= 47;
                                if (!(Lt || Bt)) return !1;
                                var Nt, $t = {};
                                Ot === 16 || Ot === 24 ? (Nt = Math.floor((Rt - 32) / 2), $t.background = ct[Nt], Rt % 2 === 1 && ($t.background = $t.background + "_semi")) : Rt === 45 ? $t.background = "transparent" : ($t.foreground = "black", Rt === 47 && ($t.underline = !0));
                                var jt = Ot <= 23 ? 1 : 2,
                                    Ut = this.channels[jt];
                                return Ut.setBkgData($t), mt(Ot, Rt, this.cmdHistory), !0
                            }, wt.reset = function() {
                                for (var Ot = 0; Ot < Object.keys(this.channels).length; Ot++) {
                                    var Rt = this.channels[Ot];
                                    Rt && Rt.reset()
                                }
                                this.cmdHistory = yt()
                            }, wt.cueSplitAtTime = function(Ot) {
                                for (var Rt = 0; Rt < this.channels.length; Rt++) {
                                    var Lt = this.channels[Rt];
                                    Lt && Lt.cueSplitAtTime(Ot)
                                }
                            }, Ft
                        }();

                    function mt(Ft, wt, kt) {
                        kt.a = Ft, kt.b = wt
                    }

                    function xt(Ft, wt, kt) {
                        return kt.a === Ft && kt.b === wt
                    }

                    function yt() {
                        return {
                            a: null,
                            b: null
                        }
                    }
                    const Tt = vt
                },
                "./src/utils/codecs.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        isCodecSupportedInMp4: () => bt,
                        isCodecType: () => lt
                    });
                    var ut = {
                        audio: {
                            a3ds: !0,
                            "ac-3": !0,
                            "ac-4": !0,
                            alac: !0,
                            alaw: !0,
                            dra1: !0,
                            "dts+": !0,
                            "dts-": !0,
                            dtsc: !0,
                            dtse: !0,
                            dtsh: !0,
                            "ec-3": !0,
                            enca: !0,
                            g719: !0,
                            g726: !0,
                            m4ae: !0,
                            mha1: !0,
                            mha2: !0,
                            mhm1: !0,
                            mhm2: !0,
                            mlpa: !0,
                            mp4a: !0,
                            "raw ": !0,
                            Opus: !0,
                            opus: !0,
                            samr: !0,
                            sawb: !0,
                            sawp: !0,
                            sevc: !0,
                            sqcp: !0,
                            ssmv: !0,
                            twos: !0,
                            ulaw: !0
                        },
                        video: {
                            avc1: !0,
                            avc2: !0,
                            avc3: !0,
                            avc4: !0,
                            avcp: !0,
                            av01: !0,
                            drac: !0,
                            dva1: !0,
                            dvav: !0,
                            dvh1: !0,
                            dvhe: !0,
                            encv: !0,
                            hev1: !0,
                            hvc1: !0,
                            mjp2: !0,
                            mp4v: !0,
                            mvc1: !0,
                            mvc2: !0,
                            mvc3: !0,
                            mvc4: !0,
                            resv: !0,
                            rv60: !0,
                            s263: !0,
                            svc1: !0,
                            svc2: !0,
                            "vc-1": !0,
                            vp08: !0,
                            vp09: !0
                        },
                        text: {
                            stpp: !0,
                            wvtt: !0
                        }
                    };

                    function lt(pt, It) {
                        var At = ut[It];
                        return !!At && At[pt.slice(0, 4)] === !0
                    }

                    function bt(pt, It) {
                        return MediaSource.isTypeSupported((It || "video") + '/mp4;codecs="' + pt + '"')
                    }
                },
                "./src/utils/cues.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => At
                    });
                    var ut = it("./src/utils/vttparser.ts"),
                        lt = it("./src/utils/webvtt-parser.ts"),
                        bt = it("./src/utils/texttrack-utils.ts"),
                        pt = /\s/,
                        It = {
                            newCue: function(ht, ot, ct, Et) {
                                for (var Dt = [], Pt, gt, ft, dt, St, _t = self.VTTCue || self.TextTrackCue, vt = 0; vt < Et.rows.length; vt++)
                                    if (Pt = Et.rows[vt], ft = !0, dt = 0, St = "", !Pt.isEmpty()) {
                                        for (var mt = 0; mt < Pt.chars.length; mt++) pt.test(Pt.chars[mt].uchar) && ft ? dt++ : (St += Pt.chars[mt].uchar, ft = !1);
                                        Pt.cueStartTime = ot, ot === ct && (ct += 1e-4), dt >= 16 ? dt-- : dt++;
                                        var xt = (0, ut.fixLineBreaks)(St.trim()),
                                            yt = (0, lt.generateCueId)(ot, ct, xt);
                                        (!ht || !ht.cues || !ht.cues.getCueById(yt)) && (gt = new _t(ot, ct, xt), gt.id = yt, gt.line = vt + 1, gt.align = "left", gt.position = 10 + Math.min(80, Math.floor(dt * 8 / 32) * 10), Dt.push(gt))
                                    } return ht && Dt.length && (Dt.sort(function(Tt, Ft) {
                                    return Tt.line === "auto" || Ft.line === "auto" ? 0 : Tt.line > 8 && Ft.line > 8 ? Ft.line - Tt.line : Tt.line - Ft.line
                                }), Dt.forEach(function(Tt) {
                                    return (0, bt.addCueToTrack)(ht, Tt)
                                })), Dt
                            }
                        };
                    const At = It
                },
                "./src/utils/discontinuities.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        adjustSlidingStart: () => ht,
                        alignMediaPlaylistByPDT: () => Dt,
                        alignPDT: () => Et,
                        alignStream: () => ot,
                        findDiscontinuousReferenceFrag: () => At,
                        findFirstFragWithCC: () => pt,
                        shouldAlignOnDiscontinuities: () => It
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/utils/logger.ts"),
                        bt = it("./src/controller/level-helper.ts");

                    function pt(Pt, gt) {
                        for (var ft = null, dt = 0, St = Pt.length; dt < St; dt++) {
                            var _t = Pt[dt];
                            if (_t && _t.cc === gt) {
                                ft = _t;
                                break
                            }
                        }
                        return ft
                    }

                    function It(Pt, gt, ft) {
                        return !!(gt.details && (ft.endCC > ft.startCC || Pt && Pt.cc < ft.startCC))
                    }

                    function At(Pt, gt, ft) {
                        var dt = Pt.fragments,
                            St = gt.fragments;
                        if (!St.length || !dt.length) {
                            lt.logger.log("No fragments to align");
                            return
                        }
                        var _t = pt(dt, St[0].cc);
                        if (!_t || _t && !_t.startPTS) {
                            lt.logger.log("No frag in previous level to align on");
                            return
                        }
                        return _t
                    }

                    function Ct(Pt, gt) {
                        if (Pt) {
                            var ft = Pt.start + gt;
                            Pt.start = Pt.startPTS = ft, Pt.endPTS = ft + Pt.duration
                        }
                    }

                    function ht(Pt, gt) {
                        for (var ft = gt.fragments, dt = 0, St = ft.length; dt < St; dt++) Ct(ft[dt], Pt);
                        gt.fragmentHint && Ct(gt.fragmentHint, Pt), gt.alignedSliding = !0
                    }

                    function ot(Pt, gt, ft) {
                        !gt || (ct(Pt, ft, gt), !ft.alignedSliding && gt.details && Et(ft, gt.details), !ft.alignedSliding && gt.details && !ft.skippedSegments && (0, bt.adjustSliding)(gt.details, ft))
                    }

                    function ct(Pt, gt, ft) {
                        if (It(Pt, ft, gt)) {
                            var dt = At(ft.details, gt);
                            dt && (0, ut.isFiniteNumber)(dt.start) && (lt.logger.log("Adjusting PTS using last level due to CC increase within current level " + gt.url), ht(dt.start, gt))
                        }
                    }

                    function Et(Pt, gt) {
                        if (!(!gt.fragments.length || !Pt.hasProgramDateTime || !gt.hasProgramDateTime)) {
                            var ft = gt.fragments[0].programDateTime,
                                dt = Pt.fragments[0].programDateTime,
                                St = (dt - ft) / 1e3 + gt.fragments[0].start;
                            St && (0, ut.isFiniteNumber)(St) && (lt.logger.log("Adjusting PTS using programDateTime delta " + (dt - ft) + "ms, sliding:" + St.toFixed(3) + " " + Pt.url + " "), ht(St, Pt))
                        }
                    }

                    function Dt(Pt, gt) {
                        if (!(!Pt.hasProgramDateTime || !gt.hasProgramDateTime)) {
                            var ft = Pt.fragments,
                                dt = gt.fragments;
                            if (!(!ft.length || !dt.length)) {
                                var St = Math.round(dt.length / 2) - 1,
                                    _t = dt[St],
                                    vt = pt(ft, _t.cc) || ft[Math.round(ft.length / 2) - 1],
                                    mt = _t.programDateTime,
                                    xt = vt.programDateTime;
                                if (!(mt === null || xt === null)) {
                                    var yt = (xt - mt) / 1e3 - (vt.start - _t.start);
                                    ht(yt, Pt)
                                }
                            }
                        }
                    }
                },
                "./src/utils/ewma-bandwidth-estimator.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => bt
                    });
                    var ut = it("./src/utils/ewma.ts"),
                        lt = function() {
                            function pt(At, Ct, ht) {
                                this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultEstimate_ = ht, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new ut.default(At), this.fast_ = new ut.default(Ct)
                            }
                            var It = pt.prototype;
                            return It.update = function(Ct, ht) {
                                var ot = this.slow_,
                                    ct = this.fast_;
                                this.slow_.halfLife !== Ct && (this.slow_ = new ut.default(Ct, ot.getEstimate(), ot.getTotalWeight())), this.fast_.halfLife !== ht && (this.fast_ = new ut.default(ht, ct.getEstimate(), ct.getTotalWeight()))
                            }, It.sample = function(Ct, ht) {
                                Ct = Math.max(Ct, this.minDelayMs_);
                                var ot = 8 * ht,
                                    ct = Ct / 1e3,
                                    Et = ot / ct;
                                this.fast_.sample(ct, Et), this.slow_.sample(ct, Et)
                            }, It.canEstimate = function() {
                                var Ct = this.fast_;
                                return Ct && Ct.getTotalWeight() >= this.minWeight_
                            }, It.getEstimate = function() {
                                return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_
                            }, It.destroy = function() {}, pt
                        }();
                    const bt = lt
                },
                "./src/utils/ewma.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => lt
                    });
                    var ut = function() {
                        function bt(It, At, Ct) {
                            At === void 0 && (At = 0), Ct === void 0 && (Ct = 0), this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = It, this.alpha_ = It ? Math.exp(Math.log(.5) / It) : 0, this.estimate_ = At, this.totalWeight_ = Ct
                        }
                        var pt = bt.prototype;
                        return pt.sample = function(At, Ct) {
                            var ht = Math.pow(this.alpha_, At);
                            this.estimate_ = Ct * (1 - ht) + ht * this.estimate_, this.totalWeight_ += At
                        }, pt.getTotalWeight = function() {
                            return this.totalWeight_
                        }, pt.getEstimate = function() {
                            if (this.alpha_) {
                                var At = 1 - Math.pow(this.alpha_, this.totalWeight_);
                                if (At) return this.estimate_ / At
                            }
                            return this.estimate_
                        }, bt
                    }();
                    const lt = ut
                },
                "./src/utils/fetch-loader.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => St,
                        fetchSupported: () => Dt
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/loader/load-stats.ts"),
                        bt = it("./src/demux/chunk-cache.ts");

                    function pt(_t, vt) {
                        _t.prototype = Object.create(vt.prototype), _t.prototype.constructor = _t, ot(_t, vt)
                    }

                    function It(_t) {
                        var vt = typeof Map == "function" ? new Map : void 0;
                        return It = function(xt) {
                            if (xt === null || !ht(xt)) return xt;
                            if (typeof xt != "function") throw new TypeError("Super expression must either be null or a function");
                            if (typeof vt < "u") {
                                if (vt.has(xt)) return vt.get(xt);
                                vt.set(xt, yt)
                            }

                            function yt() {
                                return At(xt, arguments, ct(this).constructor)
                            }
                            return yt.prototype = Object.create(xt.prototype, {
                                constructor: {
                                    value: yt,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), ot(yt, xt)
                        }, It(_t)
                    }

                    function At(_t, vt, mt) {
                        return Ct() ? At = Reflect.construct.bind() : At = function(yt, Tt, Ft) {
                            var wt = [null];
                            wt.push.apply(wt, Tt);
                            var kt = Function.bind.apply(yt, wt),
                                Ot = new kt;
                            return Ft && ot(Ot, Ft.prototype), Ot
                        }, At.apply(null, arguments)
                    }

                    function Ct() {
                        if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
                        if (typeof Proxy == "function") return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
                        } catch {
                            return !1
                        }
                    }

                    function ht(_t) {
                        return Function.toString.call(_t).indexOf("[native code]") !== -1
                    }

                    function ot(_t, vt) {
                        return ot = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(xt, yt) {
                            return xt.__proto__ = yt, xt
                        }, ot(_t, vt)
                    }

                    function ct(_t) {
                        return ct = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(mt) {
                            return mt.__proto__ || Object.getPrototypeOf(mt)
                        }, ct(_t)
                    }

                    function Et() {
                        return Et = Object.assign ? Object.assign.bind() : function(_t) {
                            for (var vt = 1; vt < arguments.length; vt++) {
                                var mt = arguments[vt];
                                for (var xt in mt) Object.prototype.hasOwnProperty.call(mt, xt) && (_t[xt] = mt[xt])
                            }
                            return _t
                        }, Et.apply(this, arguments)
                    }

                    function Dt() {
                        if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try {
                            return new self.ReadableStream({}), !0
                        } catch {}
                        return !1
                    }
                    var Pt = function() {
                        function _t(mt) {
                            this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = void 0, this.response = void 0, this.controller = void 0, this.context = void 0, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = mt.fetchSetup || ft, this.controller = new self.AbortController, this.stats = new lt.LoadStats
                        }
                        var vt = _t.prototype;
                        return vt.destroy = function() {
                            this.loader = this.callbacks = null, this.abortInternal()
                        }, vt.abortInternal = function() {
                            var xt = this.response;
                            (!xt || !xt.ok) && (this.stats.aborted = !0, this.controller.abort())
                        }, vt.abort = function() {
                            var xt;
                            this.abortInternal(), (xt = this.callbacks) !== null && xt !== void 0 && xt.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response)
                        }, vt.load = function(xt, yt, Tt) {
                            var Ft = this,
                                wt = this.stats;
                            if (wt.loading.start) throw new Error("Loader can only be used once.");
                            wt.loading.start = self.performance.now();
                            var kt = gt(xt, this.controller.signal),
                                Ot = Tt.onProgress,
                                Rt = xt.responseType === "arraybuffer",
                                Lt = Rt ? "byteLength" : "length";
                            this.context = xt, this.config = yt, this.callbacks = Tt, this.request = this.fetchSetup(xt, kt), self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(function() {
                                Ft.abortInternal(), Tt.onTimeout(wt, xt, Ft.response)
                            }, yt.timeout), self.fetch(this.request).then(function(Bt) {
                                if (Ft.response = Ft.loader = Bt, !Bt.ok) {
                                    var Nt = Bt.status,
                                        $t = Bt.statusText;
                                    throw new dt($t || "fetch, bad network response", Nt, Bt)
                                }
                                return wt.loading.first = Math.max(self.performance.now(), wt.loading.start), wt.total = parseInt(Bt.headers.get("Content-Length") || "0"), Ot && (0, ut.isFiniteNumber)(yt.highWaterMark) ? Ft.loadProgressively(Bt, wt, xt, yt.highWaterMark, Ot) : Rt ? Bt.arrayBuffer() : Bt.text()
                            }).then(function(Bt) {
                                var Nt = Ft.response;
                                self.clearTimeout(Ft.requestTimeout), wt.loading.end = Math.max(self.performance.now(), wt.loading.first);
                                var $t = Bt[Lt];
                                $t && (wt.loaded = wt.total = $t);
                                var jt = {
                                    url: Nt.url,
                                    data: Bt
                                };
                                Ot && !(0, ut.isFiniteNumber)(yt.highWaterMark) && Ot(wt, xt, Bt, Nt), Tt.onSuccess(jt, wt, xt, Nt)
                            }).catch(function(Bt) {
                                if (self.clearTimeout(Ft.requestTimeout), !wt.aborted) {
                                    var Nt = Bt && Bt.code || 0,
                                        $t = Bt ? Bt.message : null;
                                    Tt.onError({
                                        code: Nt,
                                        text: $t
                                    }, xt, Bt ? Bt.details : null)
                                }
                            })
                        }, vt.getCacheAge = function() {
                            var xt = null;
                            if (this.response) {
                                var yt = this.response.headers.get("age");
                                xt = yt ? parseFloat(yt) : null
                            }
                            return xt
                        }, vt.loadProgressively = function(xt, yt, Tt, Ft, wt) {
                            Ft === void 0 && (Ft = 0);
                            var kt = new bt.default,
                                Ot = xt.body.getReader(),
                                Rt = function Lt() {
                                    return Ot.read().then(function(Bt) {
                                        if (Bt.done) return kt.dataLength && wt(yt, Tt, kt.flush(), xt), Promise.resolve(new ArrayBuffer(0));
                                        var Nt = Bt.value,
                                            $t = Nt.length;
                                        return yt.loaded += $t, $t < Ft || kt.dataLength ? (kt.push(Nt), kt.dataLength >= Ft && wt(yt, Tt, kt.flush(), xt)) : wt(yt, Tt, Nt, xt), Lt()
                                    }).catch(function() {
                                        return Promise.reject()
                                    })
                                };
                            return Rt()
                        }, _t
                    }();

                    function gt(_t, vt) {
                        var mt = {
                            method: "GET",
                            mode: "cors",
                            credentials: "same-origin",
                            signal: vt,
                            headers: new self.Headers(Et({}, _t.headers))
                        };
                        return _t.rangeEnd && mt.headers.set("Range", "bytes=" + _t.rangeStart + "-" + String(_t.rangeEnd - 1)), mt
                    }

                    function ft(_t, vt) {
                        return new self.Request(_t.url, vt)
                    }
                    var dt = function(_t) {
                        pt(vt, _t);

                        function vt(mt, xt, yt) {
                            var Tt;
                            return Tt = _t.call(this, mt) || this, Tt.code = void 0, Tt.details = void 0, Tt.code = xt, Tt.details = yt, Tt
                        }
                        return vt
                    }(It(Error));
                    const St = Pt
                },
                "./src/utils/imsc1-ttml-parser.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        IMSC1_CODEC: () => ht,
                        parseIMSC1: () => Dt
                    });
                    var ut = it("./src/utils/mp4-tools.ts"),
                        lt = it("./src/utils/vttparser.ts"),
                        bt = it("./src/utils/vttcue.ts"),
                        pt = it("./src/demux/id3.ts"),
                        It = it("./src/utils/timescale-conversion.ts"),
                        At = it("./src/utils/webvtt-parser.ts");

                    function Ct() {
                        return Ct = Object.assign ? Object.assign.bind() : function(Tt) {
                            for (var Ft = 1; Ft < arguments.length; Ft++) {
                                var wt = arguments[Ft];
                                for (var kt in wt) Object.prototype.hasOwnProperty.call(wt, kt) && (Tt[kt] = wt[kt])
                            }
                            return Tt
                        }, Ct.apply(this, arguments)
                    }
                    var ht = "stpp.ttml.im1t",
                        ot = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/,
                        ct = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/,
                        Et = {
                            left: "start",
                            center: "center",
                            right: "end",
                            start: "start",
                            end: "end"
                        };

                    function Dt(Tt, Ft, wt, kt, Ot) {
                        var Rt = (0, ut.findBox)(new Uint8Array(Tt), ["mdat"]);
                        if (Rt.length === 0) {
                            Ot(new Error("Could not parse IMSC1 mdat"));
                            return
                        }
                        var Lt = Rt.map(function(Nt) {
                                return (0, pt.utf8ArrayToStr)(Nt)
                            }),
                            Bt = (0, It.toTimescaleFromScale)(Ft, 1, wt);
                        try {
                            Lt.forEach(function(Nt) {
                                return kt(Pt(Nt, Bt))
                            })
                        } catch (Nt) {
                            Ot(Nt)
                        }
                    }

                    function Pt(Tt, Ft) {
                        var wt = new DOMParser,
                            kt = wt.parseFromString(Tt, "text/xml"),
                            Ot = kt.getElementsByTagName("tt")[0];
                        if (!Ot) throw new Error("Invalid ttml");
                        var Rt = {
                                frameRate: 30,
                                subFrameRate: 1,
                                frameRateMultiplier: 0,
                                tickRate: 0
                            },
                            Lt = Object.keys(Rt).reduce(function(Ut, Ht) {
                                return Ut[Ht] = Ot.getAttribute("ttp:" + Ht) || Rt[Ht], Ut
                            }, {}),
                            Bt = Ot.getAttribute("xml:space") !== "preserve",
                            Nt = ft(gt(Ot, "styling", "style")),
                            $t = ft(gt(Ot, "layout", "region")),
                            jt = gt(Ot, "body", "[begin]");
                        return [].map.call(jt, function(Ut) {
                            var Ht = dt(Ut, Bt);
                            if (!Ht || !Ut.hasAttribute("begin")) return null;
                            var Wt = mt(Ut.getAttribute("begin"), Lt),
                                Kt = mt(Ut.getAttribute("dur"), Lt),
                                Gt = mt(Ut.getAttribute("end"), Lt);
                            if (Wt === null) throw vt(Ut);
                            if (Gt === null) {
                                if (Kt === null) throw vt(Ut);
                                Gt = Wt + Kt
                            }
                            var Vt = new bt.default(Wt - Ft, Gt - Ft, Ht);
                            Vt.id = (0, At.generateCueId)(Vt.startTime, Vt.endTime, Vt.text);
                            var zt = $t[Ut.getAttribute("region")],
                                Xt = Nt[Ut.getAttribute("style")];
                            Vt.position = 10, Vt.size = 80;
                            var Yt = St(zt, Xt, Nt),
                                Zt = Yt.textAlign;
                            if (Zt) {
                                var qt = Et[Zt];
                                qt && (Vt.lineAlign = qt), Vt.align = Zt
                            }
                            return Ct(Vt, Yt), Vt
                        }).filter(function(Ut) {
                            return Ut !== null
                        })
                    }

                    function gt(Tt, Ft, wt) {
                        var kt = Tt.getElementsByTagName(Ft)[0];
                        return kt ? [].slice.call(kt.querySelectorAll(wt)) : []
                    }

                    function ft(Tt) {
                        return Tt.reduce(function(Ft, wt) {
                            var kt = wt.getAttribute("xml:id");
                            return kt && (Ft[kt] = wt), Ft
                        }, {})
                    }

                    function dt(Tt, Ft) {
                        return [].slice.call(Tt.childNodes).reduce(function(wt, kt, Ot) {
                            var Rt;
                            return kt.nodeName === "br" && Ot ? wt + `
` : (Rt = kt.childNodes) !== null && Rt !== void 0 && Rt.length ? dt(kt, Ft) : Ft ? wt + kt.textContent.trim().replace(/\s+/g, " ") : wt + kt.textContent
                        }, "")
                    }

                    function St(Tt, Ft, wt) {
                        var kt = "http://www.w3.org/ns/ttml#styling",
                            Ot = null,
                            Rt = ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"],
                            Lt = Tt != null && Tt.hasAttribute("style") ? Tt.getAttribute("style") : null;
                        return Lt && wt.hasOwnProperty(Lt) && (Ot = wt[Lt]), Rt.reduce(function(Bt, Nt) {
                            var $t = _t(Ft, kt, Nt) || _t(Tt, kt, Nt) || _t(Ot, kt, Nt);
                            return $t && (Bt[Nt] = $t), Bt
                        }, {})
                    }

                    function _t(Tt, Ft, wt) {
                        return Tt && Tt.hasAttributeNS(Ft, wt) ? Tt.getAttributeNS(Ft, wt) : null
                    }

                    function vt(Tt) {
                        return new Error("Could not parse ttml timestamp " + Tt)
                    }

                    function mt(Tt, Ft) {
                        if (!Tt) return null;
                        var wt = (0, lt.parseTimeStamp)(Tt);
                        return wt === null && (ot.test(Tt) ? wt = xt(Tt, Ft) : ct.test(Tt) && (wt = yt(Tt, Ft))), wt
                    }

                    function xt(Tt, Ft) {
                        var wt = ot.exec(Tt),
                            kt = (wt[4] | 0) + (wt[5] | 0) / Ft.subFrameRate;
                        return (wt[1] | 0) * 3600 + (wt[2] | 0) * 60 + (wt[3] | 0) + kt / Ft.frameRate
                    }

                    function yt(Tt, Ft) {
                        var wt = ct.exec(Tt),
                            kt = Number(wt[1]),
                            Ot = wt[2];
                        switch (Ot) {
                            case "h":
                                return kt * 3600;
                            case "m":
                                return kt * 60;
                            case "ms":
                                return kt * 1e3;
                            case "f":
                                return kt / Ft.frameRate;
                            case "t":
                                return kt / Ft.tickRate
                        }
                        return kt
                    }
                },
                "./src/utils/logger.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        enableLogs: () => At,
                        logger: () => Ct
                    });
                    var ut = function() {},
                        lt = {
                            trace: ut,
                            debug: ut,
                            log: ut,
                            warn: ut,
                            info: ut,
                            error: ut
                        },
                        bt = lt;

                    function pt(ht) {
                        var ot = self.console[ht];
                        return ot ? ot.bind(self.console, "[" + ht + "] >") : ut
                    }

                    function It(ht) {
                        for (var ot = arguments.length, ct = new Array(ot > 1 ? ot - 1 : 0), Et = 1; Et < ot; Et++) ct[Et - 1] = arguments[Et];
                        ct.forEach(function(Dt) {
                            bt[Dt] = ht[Dt] ? ht[Dt].bind(ht) : pt(Dt)
                        })
                    }

                    function At(ht, ot) {
                        if (self.console && ht === !0 || typeof ht == "object") {
                            It(ht, "debug", "log", "info", "warn", "error");
                            try {
                                bt.log('Debug logs enabled for "' + ot + '"')
                            } catch {
                                bt = lt
                            }
                        } else bt = lt
                    }
                    var Ct = bt
                },
                "./src/utils/mediakeys-helper.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        KeySystems: () => ut,
                        requestMediaKeySystemAccess: () => lt
                    });
                    var ut;
                    (function(bt) {
                        bt.WIDEVINE = "com.widevine.alpha", bt.PLAYREADY = "com.microsoft.playready"
                    })(ut || (ut = {}));
                    var lt = function() {
                        return typeof self < "u" && self.navigator && self.navigator.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null
                    }()
                },
                "./src/utils/mediasource-helper.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        getMediaSource: () => ut
                    });

                    function ut() {
                        return self.MediaSource || self.WebKitMediaSource
                    }
                },
                "./src/utils/mp4-tools.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        RemuxerTrackIdConfig: () => At,
                        appendUint8Array: () => mt,
                        bin2str: () => Ct,
                        computeRawDurationFromSamples: () => St,
                        discardEPB: () => wt,
                        findBox: () => Dt,
                        getDuration: () => dt,
                        getStartDTS: () => ft,
                        offsetStartDTS: () => _t,
                        parseEmsg: () => kt,
                        parseInitSegment: () => gt,
                        parseSEIMessageFromNALu: () => Ft,
                        parseSamples: () => xt,
                        parseSegmentIndex: () => Pt,
                        readSint32: () => ct,
                        readUint16: () => ht,
                        readUint32: () => ot,
                        segmentValidRange: () => vt,
                        writeUint32: () => Et
                    });
                    var ut = it("./src/utils/typed-array.ts"),
                        lt = it("./src/loader/fragment.ts"),
                        bt = it("./src/demux/id3.ts"),
                        pt = Math.pow(2, 32) - 1,
                        It = [].push,
                        At = {
                            video: 1,
                            audio: 2,
                            id3: 3,
                            text: 4
                        };

                    function Ct(Ot) {
                        return String.fromCharCode.apply(null, Ot)
                    }

                    function ht(Ot, Rt) {
                        var Lt = Ot[Rt] << 8 | Ot[Rt + 1];
                        return Lt < 0 ? 65536 + Lt : Lt
                    }

                    function ot(Ot, Rt) {
                        var Lt = ct(Ot, Rt);
                        return Lt < 0 ? 4294967296 + Lt : Lt
                    }

                    function ct(Ot, Rt) {
                        return Ot[Rt] << 24 | Ot[Rt + 1] << 16 | Ot[Rt + 2] << 8 | Ot[Rt + 3]
                    }

                    function Et(Ot, Rt, Lt) {
                        Ot[Rt] = Lt >> 24, Ot[Rt + 1] = Lt >> 16 & 255, Ot[Rt + 2] = Lt >> 8 & 255, Ot[Rt + 3] = Lt & 255
                    }

                    function Dt(Ot, Rt) {
                        var Lt = [];
                        if (!Rt.length) return Lt;
                        for (var Bt = Ot.byteLength, Nt = 0; Nt < Bt;) {
                            var $t = ot(Ot, Nt),
                                jt = Ct(Ot.subarray(Nt + 4, Nt + 8)),
                                Ut = $t > 1 ? Nt + $t : Bt;
                            if (jt === Rt[0])
                                if (Rt.length === 1) Lt.push(Ot.subarray(Nt + 8, Ut));
                                else {
                                    var Ht = Dt(Ot.subarray(Nt + 8, Ut), Rt.slice(1));
                                    Ht.length && It.apply(Lt, Ht)
                                } Nt = Ut
                        }
                        return Lt
                    }

                    function Pt(Ot) {
                        var Rt = [],
                            Lt = Ot[0],
                            Bt = 8,
                            Nt = ot(Ot, Bt);
                        Bt += 4;
                        var $t = 0,
                            jt = 0;
                        Lt === 0 ? Bt += 8 : Bt += 16, Bt += 2;
                        var Ut = Ot.length + jt,
                            Ht = ht(Ot, Bt);
                        Bt += 2;
                        for (var Wt = 0; Wt < Ht; Wt++) {
                            var Kt = Bt,
                                Gt = ot(Ot, Kt);
                            Kt += 4;
                            var Vt = Gt & 2147483647,
                                zt = (Gt & 2147483648) >>> 31;
                            if (zt === 1) return console.warn("SIDX has hierarchical references (not supported)"), null;
                            var Xt = ot(Ot, Kt);
                            Kt += 4, Rt.push({
                                referenceSize: Vt,
                                subsegmentDuration: Xt,
                                info: {
                                    duration: Xt / Nt,
                                    start: Ut,
                                    end: Ut + Vt - 1
                                }
                            }), Ut += Vt, Kt += 4, Bt = Kt
                        }
                        return {
                            earliestPresentationTime: $t,
                            timescale: Nt,
                            version: Lt,
                            referencesCount: Ht,
                            references: Rt
                        }
                    }

                    function gt(Ot) {
                        for (var Rt = [], Lt = Dt(Ot, ["moov", "trak"]), Bt = 0; Bt < Lt.length; Bt++) {
                            var Nt = Lt[Bt],
                                $t = Dt(Nt, ["tkhd"])[0];
                            if ($t) {
                                var jt = $t[0],
                                    Ut = jt === 0 ? 12 : 20,
                                    Ht = ot($t, Ut),
                                    Wt = Dt(Nt, ["mdia", "mdhd"])[0];
                                if (Wt) {
                                    jt = Wt[0], Ut = jt === 0 ? 12 : 20;
                                    var Kt = ot(Wt, Ut),
                                        Gt = Dt(Nt, ["mdia", "hdlr"])[0];
                                    if (Gt) {
                                        var Vt = Ct(Gt.subarray(8, 12)),
                                            zt = {
                                                soun: lt.ElementaryStreamTypes.AUDIO,
                                                vide: lt.ElementaryStreamTypes.VIDEO
                                            } [Vt];
                                        if (zt) {
                                            var Xt = Dt(Nt, ["mdia", "minf", "stbl", "stsd"])[0],
                                                Yt = void 0;
                                            Xt && (Yt = Ct(Xt.subarray(12, 16))), Rt[Ht] = {
                                                timescale: Kt,
                                                type: zt
                                            }, Rt[zt] = {
                                                timescale: Kt,
                                                id: Ht,
                                                codec: Yt
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        var Zt = Dt(Ot, ["moov", "mvex", "trex"]);
                        return Zt.forEach(function(qt) {
                            var er = ot(qt, 4),
                                tr = Rt[er];
                            tr && (tr.default = {
                                duration: ot(qt, 12),
                                flags: ot(qt, 20)
                            })
                        }), Rt
                    }

                    function ft(Ot, Rt) {
                        return Dt(Rt, ["moof", "traf"]).reduce(function(Lt, Bt) {
                            var Nt = Dt(Bt, ["tfdt"])[0],
                                $t = Nt[0],
                                jt = Dt(Bt, ["tfhd"]).reduce(function(Ut, Ht) {
                                    var Wt = ot(Ht, 4),
                                        Kt = Ot[Wt];
                                    if (Kt) {
                                        var Gt = ot(Nt, 4);
                                        $t === 1 && (Gt *= Math.pow(2, 32), Gt += ot(Nt, 8));
                                        var Vt = Kt.timescale || 9e4,
                                            zt = Gt / Vt;
                                        if (isFinite(zt) && (Ut === null || zt < Ut)) return zt
                                    }
                                    return Ut
                                }, null);
                            return jt !== null && isFinite(jt) && (Lt === null || jt < Lt) ? jt : Lt
                        }, null) || 0
                    }

                    function dt(Ot, Rt) {
                        for (var Lt = 0, Bt = 0, Nt = 0, $t = Dt(Ot, ["moof", "traf"]), jt = 0; jt < $t.length; jt++) {
                            var Ut = $t[jt],
                                Ht = Dt(Ut, ["tfhd"])[0],
                                Wt = ot(Ht, 4),
                                Kt = Rt[Wt];
                            if (!!Kt) {
                                var Gt = Kt.default,
                                    Vt = ot(Ht, 0) | (Gt == null ? void 0 : Gt.flags),
                                    zt = Gt == null ? void 0 : Gt.duration;
                                Vt & 8 && (Vt & 2 ? zt = ot(Ht, 12) : zt = ot(Ht, 8));
                                for (var Xt = Kt.timescale || 9e4, Yt = Dt(Ut, ["trun"]), Zt = 0; Zt < Yt.length; Zt++) {
                                    if (Lt = St(Yt[Zt]), !Lt && zt) {
                                        var qt = ot(Yt[Zt], 4);
                                        Lt = zt * qt
                                    }
                                    Kt.type === lt.ElementaryStreamTypes.VIDEO ? Bt += Lt / Xt : Kt.type === lt.ElementaryStreamTypes.AUDIO && (Nt += Lt / Xt)
                                }
                            }
                        }
                        if (Bt === 0 && Nt === 0) {
                            for (var er = 0, tr = Dt(Ot, ["sidx"]), Qt = 0; Qt < tr.length; Qt++) {
                                var Jt = Pt(tr[Qt]);
                                Jt != null && Jt.references && (er += Jt.references.reduce(function(nr, rr) {
                                    return nr + rr.info.duration || 0
                                }, 0))
                            }
                            return er
                        }
                        return Bt || Nt
                    }

                    function St(Ot) {
                        var Rt = ot(Ot, 0),
                            Lt = 8;
                        Rt & 1 && (Lt += 4), Rt & 4 && (Lt += 4);
                        for (var Bt = 0, Nt = ot(Ot, 4), $t = 0; $t < Nt; $t++) {
                            if (Rt & 256) {
                                var jt = ot(Ot, Lt);
                                Bt += jt, Lt += 4
                            }
                            Rt & 512 && (Lt += 4), Rt & 1024 && (Lt += 4), Rt & 2048 && (Lt += 4)
                        }
                        return Bt
                    }

                    function _t(Ot, Rt, Lt) {
                        Dt(Rt, ["moof", "traf"]).forEach(function(Bt) {
                            Dt(Bt, ["tfhd"]).forEach(function(Nt) {
                                var $t = ot(Nt, 4),
                                    jt = Ot[$t];
                                if (!!jt) {
                                    var Ut = jt.timescale || 9e4;
                                    Dt(Bt, ["tfdt"]).forEach(function(Ht) {
                                        var Wt = Ht[0],
                                            Kt = ot(Ht, 4);
                                        if (Wt === 0) Kt -= Lt * Ut, Kt = Math.max(Kt, 0), Et(Ht, 4, Kt);
                                        else {
                                            Kt *= Math.pow(2, 32), Kt += ot(Ht, 8), Kt -= Lt * Ut, Kt = Math.max(Kt, 0);
                                            var Gt = Math.floor(Kt / (pt + 1)),
                                                Vt = Math.floor(Kt % (pt + 1));
                                            Et(Ht, 4, Gt), Et(Ht, 8, Vt)
                                        }
                                    })
                                }
                            })
                        })
                    }

                    function vt(Ot) {
                        var Rt = {
                                valid: null,
                                remainder: null
                            },
                            Lt = Dt(Ot, ["moof"]);
                        if (Lt) {
                            if (Lt.length < 2) return Rt.remainder = Ot, Rt
                        } else return Rt;
                        var Bt = Lt[Lt.length - 1];
                        return Rt.valid = (0, ut.sliceUint8)(Ot, 0, Bt.byteOffset - 8), Rt.remainder = (0, ut.sliceUint8)(Ot, Bt.byteOffset - 8), Rt
                    }

                    function mt(Ot, Rt) {
                        var Lt = new Uint8Array(Ot.length + Rt.length);
                        return Lt.set(Ot), Lt.set(Rt, Ot.length), Lt
                    }

                    function xt(Ot, Rt) {
                        var Lt = [],
                            Bt = Rt.samples,
                            Nt = Rt.timescale,
                            $t = Rt.id,
                            jt = !1,
                            Ut = Dt(Bt, ["moof"]);
                        return Ut.map(function(Ht) {
                            var Wt = Ht.byteOffset - 8,
                                Kt = Dt(Ht, ["traf"]);
                            Kt.map(function(Gt) {
                                var Vt = Dt(Gt, ["tfdt"]).map(function(zt) {
                                    var Xt = zt[0],
                                        Yt = ot(zt, 4);
                                    return Xt === 1 && (Yt *= Math.pow(2, 32), Yt += ot(zt, 8)), Yt / Nt
                                })[0];
                                return Vt !== void 0 && (Ot = Vt), Dt(Gt, ["tfhd"]).map(function(zt) {
                                    var Xt = ot(zt, 4),
                                        Yt = ot(zt, 0) & 16777215,
                                        Zt = (Yt & 1) !== 0,
                                        qt = (Yt & 2) !== 0,
                                        er = (Yt & 8) !== 0,
                                        tr = 0,
                                        Qt = (Yt & 16) !== 0,
                                        Jt = 0,
                                        nr = (Yt & 32) !== 0,
                                        rr = 8;
                                    Xt === $t && (Zt && (rr += 8), qt && (rr += 4), er && (tr = ot(zt, rr), rr += 4), Qt && (Jt = ot(zt, rr), rr += 4), nr && (rr += 4), Rt.type === "video" && (jt = yt(Rt.codec)), Dt(Gt, ["trun"]).map(function(ir) {
                                        var ur = ir[0],
                                            ar = ot(ir, 0) & 16777215,
                                            lr = (ar & 1) !== 0,
                                            or = 0,
                                            fr = (ar & 4) !== 0,
                                            hr = (ar & 256) !== 0,
                                            xr = 0,
                                            vr = (ar & 512) !== 0,
                                            pr = 0,
                                            yr = (ar & 1024) !== 0,
                                            _r = (ar & 2048) !== 0,
                                            Er = 0,
                                            Rr = ot(ir, 4),
                                            cr = 8;
                                        lr && (or = ot(ir, cr), cr += 4), fr && (cr += 4);
                                        for (var dr = or + Wt, Sr = 0; Sr < Rr; Sr++) {
                                            if (hr ? (xr = ot(ir, cr), cr += 4) : xr = tr, vr ? (pr = ot(ir, cr), cr += 4) : pr = Jt, yr && (cr += 4), _r && (ur === 0 ? Er = ot(ir, cr) : Er = ct(ir, cr), cr += 4), Rt.type === lt.ElementaryStreamTypes.VIDEO)
                                                for (var sr = 0; sr < pr;) {
                                                    var gr = ot(Bt, dr);
                                                    if (dr += 4, Tt(jt, Bt[dr])) {
                                                        var Dr = Bt.subarray(dr, dr + gr);
                                                        Ft(Dr, jt ? 2 : 1, Ot + Er / Nt, Lt)
                                                    }
                                                    dr += gr, sr += gr + 4
                                                }
                                            Ot += xr / Nt
                                        }
                                    }))
                                })
                            })
                        }), Lt
                    }

                    function yt(Ot) {
                        if (!Ot) return !1;
                        var Rt = Ot.indexOf("."),
                            Lt = Rt < 0 ? Ot : Ot.substring(0, Rt);
                        return Lt === "hvc1" || Lt === "hev1" || Lt === "dvh1" || Lt === "dvhe"
                    }

                    function Tt(Ot, Rt) {
                        if (Ot) {
                            var Lt = Rt >> 1 & 63;
                            return Lt === 39 || Lt === 40
                        } else {
                            var Bt = Rt & 31;
                            return Bt === 6
                        }
                    }

                    function Ft(Ot, Rt, Lt, Bt) {
                        var Nt = wt(Ot),
                            $t = 0;
                        $t += Rt;
                        for (var jt = 0, Ut = 0, Ht = !1, Wt = 0; $t < Nt.length;) {
                            jt = 0;
                            do {
                                if ($t >= Nt.length) break;
                                Wt = Nt[$t++], jt += Wt
                            } while (Wt === 255);
                            Ut = 0;
                            do {
                                if ($t >= Nt.length) break;
                                Wt = Nt[$t++], Ut += Wt
                            } while (Wt === 255);
                            var Kt = Nt.length - $t;
                            if (!Ht && jt === 4 && $t < Nt.length) {
                                Ht = !0;
                                var Gt = Nt[$t++];
                                if (Gt === 181) {
                                    var Vt = ht(Nt, $t);
                                    if ($t += 2, Vt === 49) {
                                        var zt = ot(Nt, $t);
                                        if ($t += 4, zt === 1195456820) {
                                            var Xt = Nt[$t++];
                                            if (Xt === 3) {
                                                var Yt = Nt[$t++],
                                                    Zt = 31 & Yt,
                                                    qt = 64 & Yt,
                                                    er = qt ? 2 + Zt * 3 : 0,
                                                    tr = new Uint8Array(er);
                                                if (qt) {
                                                    tr[0] = Yt;
                                                    for (var Qt = 1; Qt < er; Qt++) tr[Qt] = Nt[$t++]
                                                }
                                                Bt.push({
                                                    type: Xt,
                                                    payloadType: jt,
                                                    pts: Lt,
                                                    bytes: tr
                                                })
                                            }
                                        }
                                    }
                                }
                            } else if (jt === 5 && Ut < Kt) {
                                if (Ht = !0, Ut > 16) {
                                    for (var Jt = [], nr = 0; nr < 16; nr++) {
                                        var rr = Nt[$t++].toString(16);
                                        Jt.push(rr.length == 1 ? "0" + rr : rr), (nr === 3 || nr === 5 || nr === 7 || nr === 9) && Jt.push("-")
                                    }
                                    for (var ir = Ut - 16, ur = new Uint8Array(ir), ar = 0; ar < ir; ar++) ur[ar] = Nt[$t++];
                                    Bt.push({
                                        payloadType: jt,
                                        pts: Lt,
                                        uuid: Jt.join(""),
                                        userData: (0, bt.utf8ArrayToStr)(ur),
                                        userDataBytes: ur
                                    })
                                }
                            } else if (Ut < Kt) $t += Ut;
                            else if (Ut > Kt) break
                        }
                    }

                    function wt(Ot) {
                        for (var Rt = Ot.byteLength, Lt = [], Bt = 1; Bt < Rt - 2;) Ot[Bt] === 0 && Ot[Bt + 1] === 0 && Ot[Bt + 2] === 3 ? (Lt.push(Bt + 2), Bt += 2) : Bt++;
                        if (Lt.length === 0) return Ot;
                        var Nt = Rt - Lt.length,
                            $t = new Uint8Array(Nt),
                            jt = 0;
                        for (Bt = 0; Bt < Nt; jt++, Bt++) jt === Lt[0] && (jt++, Lt.shift()), $t[Bt] = Ot[jt];
                        return $t
                    }

                    function kt(Ot) {
                        var Rt = Ot[0],
                            Lt = "",
                            Bt = "",
                            Nt = 0,
                            $t = 0,
                            jt = 0,
                            Ut = 0,
                            Ht = 0,
                            Wt = 0;
                        if (Rt === 0) {
                            for (; Ct(Ot.subarray(Wt, Wt + 1)) !== "\0";) Lt += Ct(Ot.subarray(Wt, Wt + 1)), Wt += 1;
                            for (Lt += Ct(Ot.subarray(Wt, Wt + 1)), Wt += 1; Ct(Ot.subarray(Wt, Wt + 1)) !== "\0";) Bt += Ct(Ot.subarray(Wt, Wt + 1)), Wt += 1;
                            Bt += Ct(Ot.subarray(Wt, Wt + 1)), Wt += 1, Nt = ot(Ot, 12), $t = ot(Ot, 16), Ut = ot(Ot, 20), Ht = ot(Ot, 24), Wt = 28
                        } else if (Rt === 1) {
                            Wt += 4, Nt = ot(Ot, Wt), Wt += 4;
                            var Kt = ot(Ot, Wt);
                            Wt += 4;
                            var Gt = ot(Ot, Wt);
                            for (Wt += 4, jt = Math.pow(2, 32) * Kt + Gt, Number.isSafeInteger(jt) || (jt = Number.MAX_SAFE_INTEGER, console.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), Ut = ot(Ot, Wt), Wt += 4, Ht = ot(Ot, Wt), Wt += 4; Ct(Ot.subarray(Wt, Wt + 1)) !== "\0";) Lt += Ct(Ot.subarray(Wt, Wt + 1)), Wt += 1;
                            for (Lt += Ct(Ot.subarray(Wt, Wt + 1)), Wt += 1; Ct(Ot.subarray(Wt, Wt + 1)) !== "\0";) Bt += Ct(Ot.subarray(Wt, Wt + 1)), Wt += 1;
                            Bt += Ct(Ot.subarray(Wt, Wt + 1)), Wt += 1
                        }
                        var Vt = Ot.subarray(Wt, Ot.byteLength);
                        return {
                            schemeIdUri: Lt,
                            value: Bt,
                            timeScale: Nt,
                            presentationTime: jt,
                            presentationTimeDelta: $t,
                            eventDuration: Ut,
                            id: Ht,
                            payload: Vt
                        }
                    }
                },
                "./src/utils/output-filter.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => ut
                    });
                    var ut = function() {
                        function lt(pt, It) {
                            this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = pt, this.trackName = It
                        }
                        var bt = lt.prototype;
                        return bt.dispatchCue = function() {
                            this.startTime !== null && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null)
                        }, bt.newCue = function(It, At, Ct) {
                            (this.startTime === null || this.startTime > It) && (this.startTime = It), this.endTime = At, this.screen = Ct, this.timelineController.createCaptionsTrack(this.trackName)
                        }, bt.reset = function() {
                            this.cueRanges = [], this.startTime = null
                        }, lt
                    }()
                },
                "./src/utils/texttrack-utils.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        addCueToTrack: () => bt,
                        clearCurrentCues: () => pt,
                        getCuesInRange: () => Ct,
                        removeCuesInRange: () => It,
                        sendAddTrackEvent: () => lt
                    });
                    var ut = it("./src/utils/logger.ts");

                    function lt(ht, ot) {
                        var ct;
                        try {
                            ct = new Event("addtrack")
                        } catch {
                            ct = document.createEvent("Event"), ct.initEvent("addtrack", !1, !1)
                        }
                        ct.track = ht, ot.dispatchEvent(ct)
                    }

                    function bt(ht, ot) {
                        var ct = ht.mode;
                        if (ct === "disabled" && (ht.mode = "hidden"), ht.cues && !ht.cues.getCueById(ot.id)) try {
                            if (ht.addCue(ot), !ht.cues.getCueById(ot.id)) throw new Error("addCue is failed for: " + ot)
                        } catch (Dt) {
                            ut.logger.debug("[texttrack-utils]: " + Dt);
                            var Et = new self.TextTrackCue(ot.startTime, ot.endTime, ot.text);
                            Et.id = ot.id, ht.addCue(Et)
                        }
                        ct === "disabled" && (ht.mode = ct)
                    }

                    function pt(ht) {
                        var ot = ht.mode;
                        if (ot === "disabled" && (ht.mode = "hidden"), ht.cues)
                            for (var ct = ht.cues.length; ct--;) ht.removeCue(ht.cues[ct]);
                        ot === "disabled" && (ht.mode = ot)
                    }

                    function It(ht, ot, ct, Et) {
                        var Dt = ht.mode;
                        if (Dt === "disabled" && (ht.mode = "hidden"), ht.cues && ht.cues.length > 0)
                            for (var Pt = Ct(ht.cues, ot, ct), gt = 0; gt < Pt.length; gt++)(!Et || Et(Pt[gt])) && ht.removeCue(Pt[gt]);
                        Dt === "disabled" && (ht.mode = Dt)
                    }

                    function At(ht, ot) {
                        if (ot < ht[0].startTime) return 0;
                        var ct = ht.length - 1;
                        if (ot > ht[ct].endTime) return -1;
                        for (var Et = 0, Dt = ct; Et <= Dt;) {
                            var Pt = Math.floor((Dt + Et) / 2);
                            if (ot < ht[Pt].startTime) Dt = Pt - 1;
                            else if (ot > ht[Pt].startTime && Et < ct) Et = Pt + 1;
                            else return Pt
                        }
                        return ht[Et].startTime - ot < ot - ht[Dt].startTime ? Et : Dt
                    }

                    function Ct(ht, ot, ct) {
                        var Et = [],
                            Dt = At(ht, ot);
                        if (Dt > -1)
                            for (var Pt = Dt, gt = ht.length; Pt < gt; Pt++) {
                                var ft = ht[Pt];
                                if (ft.startTime >= ot && ft.endTime <= ct) Et.push(ft);
                                else if (ft.startTime > ct) return Et
                            }
                        return Et
                    }
                },
                "./src/utils/time-ranges.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => lt
                    });
                    var ut = {
                        toString: function(pt) {
                            for (var It = "", At = pt.length, Ct = 0; Ct < At; Ct++) It += "[" + pt.start(Ct).toFixed(3) + "," + pt.end(Ct).toFixed(3) + "]";
                            return It
                        }
                    };
                    const lt = ut
                },
                "./src/utils/timescale-conversion.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        toMpegTsClockFromTimescale: () => It,
                        toMsFromMpegTsClock: () => pt,
                        toTimescaleFromBase: () => lt,
                        toTimescaleFromScale: () => bt
                    });
                    var ut = 9e4;

                    function lt(At, Ct, ht, ot) {
                        ht === void 0 && (ht = 1), ot === void 0 && (ot = !1);
                        var ct = At * Ct * ht;
                        return ot ? Math.round(ct) : ct
                    }

                    function bt(At, Ct, ht, ot) {
                        return ht === void 0 && (ht = 1), ot === void 0 && (ot = !1), lt(At, Ct, 1 / ht, ot)
                    }

                    function pt(At, Ct) {
                        return Ct === void 0 && (Ct = !1), lt(At, 1e3, 1 / ut, Ct)
                    }

                    function It(At, Ct) {
                        return Ct === void 0 && (Ct = 1), lt(At, ut, 1 / Ct)
                    }
                },
                "./src/utils/typed-array.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        sliceUint8: () => ut
                    });

                    function ut(lt, bt, pt) {
                        return Uint8Array.prototype.slice ? lt.slice(bt, pt) : new Uint8Array(Array.prototype.slice.call(lt, bt, pt))
                    }
                },
                "./src/utils/vttcue.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => ut
                    });
                    const ut = function() {
                        if (typeof self < "u" && self.VTTCue) return self.VTTCue;
                        var lt = ["", "lr", "rl"],
                            bt = ["start", "middle", "end", "left", "right"];

                        function pt(ot, ct) {
                            if (typeof ct != "string" || !Array.isArray(ot)) return !1;
                            var Et = ct.toLowerCase();
                            return ~ot.indexOf(Et) ? Et : !1
                        }

                        function It(ot) {
                            return pt(lt, ot)
                        }

                        function At(ot) {
                            return pt(bt, ot)
                        }

                        function Ct(ot) {
                            for (var ct = arguments.length, Et = new Array(ct > 1 ? ct - 1 : 0), Dt = 1; Dt < ct; Dt++) Et[Dt - 1] = arguments[Dt];
                            for (var Pt = 1; Pt < arguments.length; Pt++) {
                                var gt = arguments[Pt];
                                for (var ft in gt) ot[ft] = gt[ft]
                            }
                            return ot
                        }

                        function ht(ot, ct, Et) {
                            var Dt = this,
                                Pt = {
                                    enumerable: !0
                                };
                            Dt.hasBeenReset = !1;
                            var gt = "",
                                ft = !1,
                                dt = ot,
                                St = ct,
                                _t = Et,
                                vt = null,
                                mt = "",
                                xt = !0,
                                yt = "auto",
                                Tt = "start",
                                Ft = 50,
                                wt = "middle",
                                kt = 50,
                                Ot = "middle";
                            Object.defineProperty(Dt, "id", Ct({}, Pt, {
                                get: function() {
                                    return gt
                                },
                                set: function(Lt) {
                                    gt = "" + Lt
                                }
                            })), Object.defineProperty(Dt, "pauseOnExit", Ct({}, Pt, {
                                get: function() {
                                    return ft
                                },
                                set: function(Lt) {
                                    ft = !!Lt
                                }
                            })), Object.defineProperty(Dt, "startTime", Ct({}, Pt, {
                                get: function() {
                                    return dt
                                },
                                set: function(Lt) {
                                    if (typeof Lt != "number") throw new TypeError("Start time must be set to a number.");
                                    dt = Lt, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(Dt, "endTime", Ct({}, Pt, {
                                get: function() {
                                    return St
                                },
                                set: function(Lt) {
                                    if (typeof Lt != "number") throw new TypeError("End time must be set to a number.");
                                    St = Lt, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(Dt, "text", Ct({}, Pt, {
                                get: function() {
                                    return _t
                                },
                                set: function(Lt) {
                                    _t = "" + Lt, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(Dt, "region", Ct({}, Pt, {
                                get: function() {
                                    return vt
                                },
                                set: function(Lt) {
                                    vt = Lt, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(Dt, "vertical", Ct({}, Pt, {
                                get: function() {
                                    return mt
                                },
                                set: function(Lt) {
                                    var Bt = It(Lt);
                                    if (Bt === !1) throw new SyntaxError("An invalid or illegal string was specified.");
                                    mt = Bt, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(Dt, "snapToLines", Ct({}, Pt, {
                                get: function() {
                                    return xt
                                },
                                set: function(Lt) {
                                    xt = !!Lt, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(Dt, "line", Ct({}, Pt, {
                                get: function() {
                                    return yt
                                },
                                set: function(Lt) {
                                    if (typeof Lt != "number" && Lt !== "auto") throw new SyntaxError("An invalid number or illegal string was specified.");
                                    yt = Lt, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(Dt, "lineAlign", Ct({}, Pt, {
                                get: function() {
                                    return Tt
                                },
                                set: function(Lt) {
                                    var Bt = At(Lt);
                                    if (!Bt) throw new SyntaxError("An invalid or illegal string was specified.");
                                    Tt = Bt, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(Dt, "position", Ct({}, Pt, {
                                get: function() {
                                    return Ft
                                },
                                set: function(Lt) {
                                    if (Lt < 0 || Lt > 100) throw new Error("Position must be between 0 and 100.");
                                    Ft = Lt, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(Dt, "positionAlign", Ct({}, Pt, {
                                get: function() {
                                    return wt
                                },
                                set: function(Lt) {
                                    var Bt = At(Lt);
                                    if (!Bt) throw new SyntaxError("An invalid or illegal string was specified.");
                                    wt = Bt, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(Dt, "size", Ct({}, Pt, {
                                get: function() {
                                    return kt
                                },
                                set: function(Lt) {
                                    if (Lt < 0 || Lt > 100) throw new Error("Size must be between 0 and 100.");
                                    kt = Lt, this.hasBeenReset = !0
                                }
                            })), Object.defineProperty(Dt, "align", Ct({}, Pt, {
                                get: function() {
                                    return Ot
                                },
                                set: function(Lt) {
                                    var Bt = At(Lt);
                                    if (!Bt) throw new SyntaxError("An invalid or illegal string was specified.");
                                    Ot = Bt, this.hasBeenReset = !0
                                }
                            })), Dt.displayState = void 0
                        }
                        return ht.prototype.getCueAsHTML = function() {
                            var ot = self.WebVTT;
                            return ot.convertCueToDOMTree(self, this.text)
                        }, ht
                    }()
                },
                "./src/utils/vttparser.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        VTTParser: () => ct,
                        fixLineBreaks: () => ot,
                        parseTimeStamp: () => bt
                    });
                    var ut = it("./src/utils/vttcue.ts"),
                        lt = function() {
                            function Et() {}
                            var Dt = Et.prototype;
                            return Dt.decode = function(gt, ft) {
                                if (!gt) return "";
                                if (typeof gt != "string") throw new Error("Error - expected string data.");
                                return decodeURIComponent(encodeURIComponent(gt))
                            }, Et
                        }();

                    function bt(Et) {
                        function Dt(gt, ft, dt, St) {
                            return (gt | 0) * 3600 + (ft | 0) * 60 + (dt | 0) + parseFloat(St || 0)
                        }
                        var Pt = Et.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
                        return Pt ? parseFloat(Pt[2]) > 59 ? Dt(Pt[2], Pt[3], 0, Pt[4]) : Dt(Pt[1], Pt[2], Pt[3], Pt[4]) : null
                    }
                    var pt = function() {
                        function Et() {
                            this.values = Object.create(null)
                        }
                        var Dt = Et.prototype;
                        return Dt.set = function(gt, ft) {
                            !this.get(gt) && ft !== "" && (this.values[gt] = ft)
                        }, Dt.get = function(gt, ft, dt) {
                            return dt ? this.has(gt) ? this.values[gt] : ft[dt] : this.has(gt) ? this.values[gt] : ft
                        }, Dt.has = function(gt) {
                            return gt in this.values
                        }, Dt.alt = function(gt, ft, dt) {
                            for (var St = 0; St < dt.length; ++St)
                                if (ft === dt[St]) {
                                    this.set(gt, ft);
                                    break
                                }
                        }, Dt.integer = function(gt, ft) {
                            /^-?\d+$/.test(ft) && this.set(gt, parseInt(ft, 10))
                        }, Dt.percent = function(gt, ft) {
                            if (/^([\d]{1,3})(\.[\d]*)?%$/.test(ft)) {
                                var dt = parseFloat(ft);
                                if (dt >= 0 && dt <= 100) return this.set(gt, dt), !0
                            }
                            return !1
                        }, Et
                    }();

                    function It(Et, Dt, Pt, gt) {
                        var ft = gt ? Et.split(gt) : [Et];
                        for (var dt in ft)
                            if (typeof ft[dt] == "string") {
                                var St = ft[dt].split(Pt);
                                if (St.length === 2) {
                                    var _t = St[0],
                                        vt = St[1];
                                    Dt(_t, vt)
                                }
                            }
                    }
                    var At = new ut.default(0, 0, ""),
                        Ct = At.align === "middle" ? "middle" : "center";

                    function ht(Et, Dt, Pt) {
                        var gt = Et;

                        function ft() {
                            var _t = bt(Et);
                            if (_t === null) throw new Error("Malformed timestamp: " + gt);
                            return Et = Et.replace(/^[^\sa-zA-Z-]+/, ""), _t
                        }

                        function dt(_t, vt) {
                            var mt = new pt;
                            It(_t, function(Tt, Ft) {
                                var wt;
                                switch (Tt) {
                                    case "region":
                                        for (var kt = Pt.length - 1; kt >= 0; kt--)
                                            if (Pt[kt].id === Ft) {
                                                mt.set(Tt, Pt[kt].region);
                                                break
                                            } break;
                                    case "vertical":
                                        mt.alt(Tt, Ft, ["rl", "lr"]);
                                        break;
                                    case "line":
                                        wt = Ft.split(","), mt.integer(Tt, wt[0]), mt.percent(Tt, wt[0]) && mt.set("snapToLines", !1), mt.alt(Tt, wt[0], ["auto"]), wt.length === 2 && mt.alt("lineAlign", wt[1], ["start", Ct, "end"]);
                                        break;
                                    case "position":
                                        wt = Ft.split(","), mt.percent(Tt, wt[0]), wt.length === 2 && mt.alt("positionAlign", wt[1], ["start", Ct, "end", "line-left", "line-right", "auto"]);
                                        break;
                                    case "size":
                                        mt.percent(Tt, Ft);
                                        break;
                                    case "align":
                                        mt.alt(Tt, Ft, ["start", Ct, "end", "left", "right"]);
                                        break
                                }
                            }, /:/, /\s/), vt.region = mt.get("region", null), vt.vertical = mt.get("vertical", "");
                            var xt = mt.get("line", "auto");
                            xt === "auto" && At.line === -1 && (xt = -1), vt.line = xt, vt.lineAlign = mt.get("lineAlign", "start"), vt.snapToLines = mt.get("snapToLines", !0), vt.size = mt.get("size", 100), vt.align = mt.get("align", Ct);
                            var yt = mt.get("position", "auto");
                            yt === "auto" && At.position === 50 && (yt = vt.align === "start" || vt.align === "left" ? 0 : vt.align === "end" || vt.align === "right" ? 100 : 50), vt.position = yt
                        }

                        function St() {
                            Et = Et.replace(/^\s+/, "")
                        }
                        if (St(), Dt.startTime = ft(), St(), Et.slice(0, 3) !== "-->") throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + gt);
                        Et = Et.slice(3), St(), Dt.endTime = ft(), St(), dt(Et, Dt)
                    }

                    function ot(Et) {
                        return Et.replace(/<br(?: \/)?>/gi, `
`)
                    }
                    var ct = function() {
                        function Et() {
                            this.state = "INITIAL", this.buffer = "", this.decoder = new lt, this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0
                        }
                        var Dt = Et.prototype;
                        return Dt.parse = function(gt) {
                            var ft = this;
                            gt && (ft.buffer += ft.decoder.decode(gt, {
                                stream: !0
                            }));

                            function dt() {
                                var yt = ft.buffer,
                                    Tt = 0;
                                for (yt = ot(yt); Tt < yt.length && yt[Tt] !== "\r" && yt[Tt] !== `
`;) ++Tt;
                                var Ft = yt.slice(0, Tt);
                                return yt[Tt] === "\r" && ++Tt, yt[Tt] === `
` && ++Tt, ft.buffer = yt.slice(Tt), Ft
                            }

                            function St(yt) {
                                It(yt, function(Tt, Ft) {}, /:/)
                            }
                            try {
                                var _t = "";
                                if (ft.state === "INITIAL") {
                                    if (!/\r\n|\n/.test(ft.buffer)) return this;
                                    _t = dt();
                                    var vt = _t.match(/^()?WEBVTT([ \t].*)?$/);
                                    if (!vt || !vt[0]) throw new Error("Malformed WebVTT signature.");
                                    ft.state = "HEADER"
                                }
                                for (var mt = !1; ft.buffer;) {
                                    if (!/\r\n|\n/.test(ft.buffer)) return this;
                                    switch (mt ? mt = !1 : _t = dt(), ft.state) {
                                        case "HEADER":
                                            /:/.test(_t) ? St(_t) : _t || (ft.state = "ID");
                                            continue;
                                        case "NOTE":
                                            _t || (ft.state = "ID");
                                            continue;
                                        case "ID":
                                            if (/^NOTE($|[ \t])/.test(_t)) {
                                                ft.state = "NOTE";
                                                break
                                            }
                                            if (!_t) continue;
                                            if (ft.cue = new ut.default(0, 0, ""), ft.state = "CUE", _t.indexOf("-->") === -1) {
                                                ft.cue.id = _t;
                                                continue
                                            }
                                        case "CUE":
                                            if (!ft.cue) {
                                                ft.state = "BADCUE";
                                                continue
                                            }
                                            try {
                                                ht(_t, ft.cue, ft.regionList)
                                            } catch {
                                                ft.cue = null, ft.state = "BADCUE";
                                                continue
                                            }
                                            ft.state = "CUETEXT";
                                            continue;
                                        case "CUETEXT": {
                                            var xt = _t.indexOf("-->") !== -1;
                                            if (!_t || xt && (mt = !0)) {
                                                ft.oncue && ft.cue && ft.oncue(ft.cue), ft.cue = null, ft.state = "ID";
                                                continue
                                            }
                                            if (ft.cue === null) continue;
                                            ft.cue.text && (ft.cue.text += `
`), ft.cue.text += _t
                                        }
                                        continue;
                                        case "BADCUE":
                                            _t || (ft.state = "ID")
                                    }
                                }
                            } catch {
                                ft.state === "CUETEXT" && ft.cue && ft.oncue && ft.oncue(ft.cue), ft.cue = null, ft.state = ft.state === "INITIAL" ? "BADWEBVTT" : "BADCUE"
                            }
                            return this
                        }, Dt.flush = function() {
                            var gt = this;
                            try {
                                if ((gt.cue || gt.state === "HEADER") && (gt.buffer += `

`, gt.parse()), gt.state === "INITIAL" || gt.state === "BADWEBVTT") throw new Error("Malformed WebVTT signature.")
                            } catch (ft) {
                                gt.onparsingerror && gt.onparsingerror(ft)
                            }
                            return gt.onflush && gt.onflush(), this
                        }, Et
                    }()
                },
                "./src/utils/webvtt-parser.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        generateCueId: () => ct,
                        parseWebVTT: () => Dt
                    });
                    var ut = it("./src/polyfills/number.ts"),
                        lt = it("./src/utils/vttparser.ts"),
                        bt = it("./src/demux/id3.ts"),
                        pt = it("./src/utils/timescale-conversion.ts"),
                        It = it("./src/remux/mp4-remuxer.ts"),
                        At = /\r\n|\n\r|\n|\r/g,
                        Ct = function(gt, ft, dt) {
                            return dt === void 0 && (dt = 0), gt.slice(dt, dt + ft.length) === ft
                        },
                        ht = function(gt) {
                            var ft = parseInt(gt.slice(-3)),
                                dt = parseInt(gt.slice(-6, -4)),
                                St = parseInt(gt.slice(-9, -7)),
                                _t = gt.length > 9 ? parseInt(gt.substring(0, gt.indexOf(":"))) : 0;
                            if (!(0, ut.isFiniteNumber)(ft) || !(0, ut.isFiniteNumber)(dt) || !(0, ut.isFiniteNumber)(St) || !(0, ut.isFiniteNumber)(_t)) throw Error("Malformed X-TIMESTAMP-MAP: Local:" + gt);
                            return ft += 1e3 * dt, ft += 60 * 1e3 * St, ft += 60 * 60 * 1e3 * _t, ft
                        },
                        ot = function(gt) {
                            for (var ft = 5381, dt = gt.length; dt;) ft = ft * 33 ^ gt.charCodeAt(--dt);
                            return (ft >>> 0).toString()
                        };

                    function ct(Pt, gt, ft) {
                        return ot(Pt.toString()) + ot(gt.toString()) + ot(ft)
                    }
                    var Et = function(gt, ft, dt) {
                        var St = gt[ft],
                            _t = gt[St.prevCC];
                        if (!_t || !_t.new && St.new) {
                            gt.ccOffset = gt.presentationOffset = St.start, St.new = !1;
                            return
                        }
                        for (;
                            (vt = _t) !== null && vt !== void 0 && vt.new;) {
                            var vt;
                            gt.ccOffset += St.start - _t.start, St.new = !1, St = _t, _t = gt[St.prevCC]
                        }
                        gt.presentationOffset = dt
                    };

                    function Dt(Pt, gt, ft, dt, St, _t, vt, mt) {
                        var xt = new lt.VTTParser,
                            yt = (0, bt.utf8ArrayToStr)(new Uint8Array(Pt)).trim().replace(At, `
`).split(`
`),
                            Tt = [],
                            Ft = (0, pt.toMpegTsClockFromTimescale)(gt, ft),
                            wt = "00:00.000",
                            kt = 0,
                            Ot = 0,
                            Rt, Lt = !0;
                        xt.oncue = function(Bt) {
                            var Nt = dt[St],
                                $t = dt.ccOffset,
                                jt = (kt - Ft) / 9e4;
                            Nt != null && Nt.new && (Ot !== void 0 ? $t = dt.ccOffset = Nt.start : Et(dt, St, jt)), jt && ($t = jt - dt.presentationOffset);
                            var Ut = Bt.endTime - Bt.startTime,
                                Ht = (0, It.normalizePts)((Bt.startTime + $t - Ot) * 9e4, _t * 9e4) / 9e4;
                            Bt.startTime = Math.max(Ht, 0), Bt.endTime = Math.max(Ht + Ut, 0);
                            var Wt = Bt.text.trim();
                            Bt.text = decodeURIComponent(encodeURIComponent(Wt)), Bt.id || (Bt.id = ct(Bt.startTime, Bt.endTime, Wt)), Bt.endTime > 0 && Tt.push(Bt)
                        }, xt.onparsingerror = function(Bt) {
                            Rt = Bt
                        }, xt.onflush = function() {
                            if (Rt) {
                                mt(Rt);
                                return
                            }
                            vt(Tt)
                        }, yt.forEach(function(Bt) {
                            if (Lt)
                                if (Ct(Bt, "X-TIMESTAMP-MAP=")) {
                                    Lt = !1, Bt.slice(16).split(",").forEach(function(Nt) {
                                        Ct(Nt, "LOCAL:") ? wt = Nt.slice(6) : Ct(Nt, "MPEGTS:") && (kt = parseInt(Nt.slice(7)))
                                    });
                                    try {
                                        Ot = ht(wt) / 1e3
                                    } catch (Nt) {
                                        Rt = Nt
                                    }
                                    return
                                } else Bt === "" && (Lt = !1);
                            xt.parse(Bt + `
`)
                        }), xt.flush()
                    }
                },
                "./src/utils/xhr-loader.ts": (at, st, it) => {
                    it.r(st), it.d(st, {
                        default: () => It
                    });
                    var ut = it("./src/utils/logger.ts"),
                        lt = it("./src/loader/load-stats.ts"),
                        bt = /^age:\s*[\d.]+\s*$/m,
                        pt = function() {
                            function At(ht) {
                                this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = void 0, this.loader = null, this.stats = void 0, this.xhrSetup = ht ? ht.xhrSetup : null, this.stats = new lt.LoadStats, this.retryDelay = 0
                            }
                            var Ct = At.prototype;
                            return Ct.destroy = function() {
                                this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null
                            }, Ct.abortInternal = function() {
                                var ot = this.loader;
                                self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), ot && (ot.onreadystatechange = null, ot.onprogress = null, ot.readyState !== 4 && (this.stats.aborted = !0, ot.abort()))
                            }, Ct.abort = function() {
                                var ot;
                                this.abortInternal(), (ot = this.callbacks) !== null && ot !== void 0 && ot.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader)
                            }, Ct.load = function(ot, ct, Et) {
                                if (this.stats.loading.start) throw new Error("Loader can only be used once.");
                                this.stats.loading.start = self.performance.now(), this.context = ot, this.config = ct, this.callbacks = Et, this.retryDelay = ct.retryDelay, this.loadInternal()
                            }, Ct.loadInternal = function() {
                                var ot = this.config,
                                    ct = this.context;
                                if (!!ot) {
                                    var Et = this.loader = new self.XMLHttpRequest,
                                        Dt = this.stats;
                                    Dt.loading.first = 0, Dt.loaded = 0;
                                    var Pt = this.xhrSetup;
                                    try {
                                        if (Pt) try {
                                            Pt(Et, ct.url)
                                        } catch {
                                            Et.open("GET", ct.url, !0), Pt(Et, ct.url)
                                        }
                                        Et.readyState || Et.open("GET", ct.url, !0);
                                        var gt = this.context.headers;
                                        if (gt)
                                            for (var ft in gt) Et.setRequestHeader(ft, gt[ft])
                                    } catch (dt) {
                                        this.callbacks.onError({
                                            code: Et.status,
                                            text: dt.message
                                        }, ct, Et);
                                        return
                                    }
                                    ct.rangeEnd && Et.setRequestHeader("Range", "bytes=" + ct.rangeStart + "-" + (ct.rangeEnd - 1)), Et.onreadystatechange = this.readystatechange.bind(this), Et.onprogress = this.loadprogress.bind(this), Et.responseType = ct.responseType, self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), ot.timeout), Et.send()
                                }
                            }, Ct.readystatechange = function() {
                                var ot = this.context,
                                    ct = this.loader,
                                    Et = this.stats;
                                if (!(!ot || !ct)) {
                                    var Dt = ct.readyState,
                                        Pt = this.config;
                                    if (!Et.aborted && Dt >= 2)
                                        if (self.clearTimeout(this.requestTimeout), Et.loading.first === 0 && (Et.loading.first = Math.max(self.performance.now(), Et.loading.start)), Dt === 4) {
                                            ct.onreadystatechange = null, ct.onprogress = null;
                                            var gt = ct.status,
                                                ft = ct.responseType === "arraybuffer";
                                            if (gt >= 200 && gt < 300 && (ft && ct.response || ct.responseText !== null)) {
                                                Et.loading.end = Math.max(self.performance.now(), Et.loading.first);
                                                var dt, St;
                                                if (ft ? (dt = ct.response, St = dt.byteLength) : (dt = ct.responseText, St = dt.length), Et.loaded = Et.total = St, !this.callbacks) return;
                                                var _t = this.callbacks.onProgress;
                                                if (_t && _t(Et, ot, dt, ct), !this.callbacks) return;
                                                var vt = {
                                                    url: ct.responseURL,
                                                    data: dt
                                                };
                                                this.callbacks.onSuccess(vt, Et, ot, ct)
                                            } else Et.retry >= Pt.maxRetry || gt >= 400 && gt < 499 ? (ut.logger.error(gt + " while loading " + ot.url), this.callbacks.onError({
                                                code: gt,
                                                text: ct.statusText
                                            }, ot, ct)) : (ut.logger.warn(gt + " while loading " + ot.url + ", retrying in " + this.retryDelay + "..."), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay), this.retryDelay = Math.min(2 * this.retryDelay, Pt.maxRetryDelay), Et.retry++)
                                        } else self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), Pt.timeout)
                                }
                            }, Ct.loadtimeout = function() {
                                ut.logger.warn("timeout while loading " + this.context.url);
                                var ot = this.callbacks;
                                ot && (this.abortInternal(), ot.onTimeout(this.stats, this.context, this.loader))
                            }, Ct.loadprogress = function(ot) {
                                var ct = this.stats;
                                ct.loaded = ot.loaded, ot.lengthComputable && (ct.total = ot.total)
                            }, Ct.getCacheAge = function() {
                                var ot = null;
                                if (this.loader && bt.test(this.loader.getAllResponseHeaders())) {
                                    var ct = this.loader.getResponseHeader("age");
                                    ot = ct ? parseFloat(ct) : null
                                }
                                return ot
                            }, At
                        }();
                    const It = pt
                },
                "./node_modules/eventemitter3/index.js": at => {
                    var st = Object.prototype.hasOwnProperty,
                        it = "~";

                    function ut() {}
                    Object.create && (ut.prototype = Object.create(null), new ut().__proto__ || (it = !1));

                    function lt(At, Ct, ht) {
                        this.fn = At, this.context = Ct, this.once = ht || !1
                    }

                    function bt(At, Ct, ht, ot, ct) {
                        if (typeof ht != "function") throw new TypeError("The listener must be a function");
                        var Et = new lt(ht, ot || At, ct),
                            Dt = it ? it + Ct : Ct;
                        return At._events[Dt] ? At._events[Dt].fn ? At._events[Dt] = [At._events[Dt], Et] : At._events[Dt].push(Et) : (At._events[Dt] = Et, At._eventsCount++), At
                    }

                    function pt(At, Ct) {
                        --At._eventsCount === 0 ? At._events = new ut : delete At._events[Ct]
                    }

                    function It() {
                        this._events = new ut, this._eventsCount = 0
                    }
                    It.prototype.eventNames = function() {
                        var Ct = [],
                            ht, ot;
                        if (this._eventsCount === 0) return Ct;
                        for (ot in ht = this._events) st.call(ht, ot) && Ct.push(it ? ot.slice(1) : ot);
                        return Object.getOwnPropertySymbols ? Ct.concat(Object.getOwnPropertySymbols(ht)) : Ct
                    }, It.prototype.listeners = function(Ct) {
                        var ht = it ? it + Ct : Ct,
                            ot = this._events[ht];
                        if (!ot) return [];
                        if (ot.fn) return [ot.fn];
                        for (var ct = 0, Et = ot.length, Dt = new Array(Et); ct < Et; ct++) Dt[ct] = ot[ct].fn;
                        return Dt
                    }, It.prototype.listenerCount = function(Ct) {
                        var ht = it ? it + Ct : Ct,
                            ot = this._events[ht];
                        return ot ? ot.fn ? 1 : ot.length : 0
                    }, It.prototype.emit = function(Ct, ht, ot, ct, Et, Dt) {
                        var Pt = it ? it + Ct : Ct;
                        if (!this._events[Pt]) return !1;
                        var gt = this._events[Pt],
                            ft = arguments.length,
                            dt, St;
                        if (gt.fn) {
                            switch (gt.once && this.removeListener(Ct, gt.fn, void 0, !0), ft) {
                                case 1:
                                    return gt.fn.call(gt.context), !0;
                                case 2:
                                    return gt.fn.call(gt.context, ht), !0;
                                case 3:
                                    return gt.fn.call(gt.context, ht, ot), !0;
                                case 4:
                                    return gt.fn.call(gt.context, ht, ot, ct), !0;
                                case 5:
                                    return gt.fn.call(gt.context, ht, ot, ct, Et), !0;
                                case 6:
                                    return gt.fn.call(gt.context, ht, ot, ct, Et, Dt), !0
                            }
                            for (St = 1, dt = new Array(ft - 1); St < ft; St++) dt[St - 1] = arguments[St];
                            gt.fn.apply(gt.context, dt)
                        } else {
                            var _t = gt.length,
                                vt;
                            for (St = 0; St < _t; St++) switch (gt[St].once && this.removeListener(Ct, gt[St].fn, void 0, !0), ft) {
                                case 1:
                                    gt[St].fn.call(gt[St].context);
                                    break;
                                case 2:
                                    gt[St].fn.call(gt[St].context, ht);
                                    break;
                                case 3:
                                    gt[St].fn.call(gt[St].context, ht, ot);
                                    break;
                                case 4:
                                    gt[St].fn.call(gt[St].context, ht, ot, ct);
                                    break;
                                default:
                                    if (!dt)
                                        for (vt = 1, dt = new Array(ft - 1); vt < ft; vt++) dt[vt - 1] = arguments[vt];
                                    gt[St].fn.apply(gt[St].context, dt)
                            }
                        }
                        return !0
                    }, It.prototype.on = function(Ct, ht, ot) {
                        return bt(this, Ct, ht, ot, !1)
                    }, It.prototype.once = function(Ct, ht, ot) {
                        return bt(this, Ct, ht, ot, !0)
                    }, It.prototype.removeListener = function(Ct, ht, ot, ct) {
                        var Et = it ? it + Ct : Ct;
                        if (!this._events[Et]) return this;
                        if (!ht) return pt(this, Et), this;
                        var Dt = this._events[Et];
                        if (Dt.fn) Dt.fn === ht && (!ct || Dt.once) && (!ot || Dt.context === ot) && pt(this, Et);
                        else {
                            for (var Pt = 0, gt = [], ft = Dt.length; Pt < ft; Pt++)(Dt[Pt].fn !== ht || ct && !Dt[Pt].once || ot && Dt[Pt].context !== ot) && gt.push(Dt[Pt]);
                            gt.length ? this._events[Et] = gt.length === 1 ? gt[0] : gt : pt(this, Et)
                        }
                        return this
                    }, It.prototype.removeAllListeners = function(Ct) {
                        var ht;
                        return Ct ? (ht = it ? it + Ct : Ct, this._events[ht] && pt(this, ht)) : (this._events = new ut, this._eventsCount = 0), this
                    }, It.prototype.off = It.prototype.removeListener, It.prototype.addListener = It.prototype.on, It.prefixed = it, It.EventEmitter = It, at.exports = It
                },
                "./node_modules/url-toolkit/src/url-toolkit.js": function(at) {
                    (function(st) {
                        var it = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/,
                            ut = /^(?=([^\/?#]*))\1([^]*)$/,
                            lt = /(?:\/|^)\.(?=\/)/g,
                            bt = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g,
                            pt = {
                                buildAbsoluteURL: function(It, At, Ct) {
                                    if (Ct = Ct || {}, It = It.trim(), At = At.trim(), !At) {
                                        if (!Ct.alwaysNormalize) return It;
                                        var ht = pt.parseURL(It);
                                        if (!ht) throw new Error("Error trying to parse base URL.");
                                        return ht.path = pt.normalizePath(ht.path), pt.buildURLFromParts(ht)
                                    }
                                    var ot = pt.parseURL(At);
                                    if (!ot) throw new Error("Error trying to parse relative URL.");
                                    if (ot.scheme) return Ct.alwaysNormalize ? (ot.path = pt.normalizePath(ot.path), pt.buildURLFromParts(ot)) : At;
                                    var ct = pt.parseURL(It);
                                    if (!ct) throw new Error("Error trying to parse base URL.");
                                    if (!ct.netLoc && ct.path && ct.path[0] !== "/") {
                                        var Et = ut.exec(ct.path);
                                        ct.netLoc = Et[1], ct.path = Et[2]
                                    }
                                    ct.netLoc && !ct.path && (ct.path = "/");
                                    var Dt = {
                                        scheme: ct.scheme,
                                        netLoc: ot.netLoc,
                                        path: null,
                                        params: ot.params,
                                        query: ot.query,
                                        fragment: ot.fragment
                                    };
                                    if (!ot.netLoc && (Dt.netLoc = ct.netLoc, ot.path[0] !== "/"))
                                        if (!ot.path) Dt.path = ct.path, ot.params || (Dt.params = ct.params, ot.query || (Dt.query = ct.query));
                                        else {
                                            var Pt = ct.path,
                                                gt = Pt.substring(0, Pt.lastIndexOf("/") + 1) + ot.path;
                                            Dt.path = pt.normalizePath(gt)
                                        } return Dt.path === null && (Dt.path = Ct.alwaysNormalize ? pt.normalizePath(ot.path) : ot.path), pt.buildURLFromParts(Dt)
                                },
                                parseURL: function(It) {
                                    var At = it.exec(It);
                                    return At ? {
                                        scheme: At[1] || "",
                                        netLoc: At[2] || "",
                                        path: At[3] || "",
                                        params: At[4] || "",
                                        query: At[5] || "",
                                        fragment: At[6] || ""
                                    } : null
                                },
                                normalizePath: function(It) {
                                    for (It = It.split("").reverse().join("").replace(lt, ""); It.length !== (It = It.replace(bt, "")).length;);
                                    return It.split("").reverse().join("")
                                },
                                buildURLFromParts: function(It) {
                                    return It.scheme + It.netLoc + It.path + It.params + It.query + It.fragment
                                }
                            };
                        at.exports = pt
                    })()
                }
            },
            tt = {};

        function rt(at) {
            var st = tt[at];
            if (st !== void 0) return st.exports;
            var it = tt[at] = {
                exports: {}
            };
            return et[at].call(it.exports, it, it.exports, rt), it.exports
        }
        rt.m = et, rt.n = at => {
            var st = at && at.__esModule ? () => at.default : () => at;
            return rt.d(st, {
                a: st
            }), st
        }, rt.d = (at, st) => {
            for (var it in st) rt.o(st, it) && !rt.o(at, it) && Object.defineProperty(at, it, {
                enumerable: !0,
                get: st[it]
            })
        }, rt.o = (at, st) => Object.prototype.hasOwnProperty.call(at, st), rt.r = at => {
            typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(at, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(at, "__esModule", {
                value: !0
            })
        };
        var nt = rt("./src/hls.ts");
        return nt = nt.default, nt
    })())
})(hls);
const Hls = getDefaultExportFromCjs(hls.exports);

function Loading(_) {
    return jsxRuntime.exports.jsx("div", {
        className: _.className,
        children: jsxRuntime.exports.jsxs("div", {
            className: "flex flex-col items-center justify-center",
            children: [jsxRuntime.exports.jsxs("div", {
                className: "flex h-12 items-center justify-center",
                children: [jsxRuntime.exports.jsx("div", {
                    className: "animate-loading-pin bg-denim-300 mx-1 h-2 w-2 rounded-full"
                }), jsxRuntime.exports.jsx("div", {
                    className: "animate-loading-pin bg-denim-300 mx-1 h-2 w-2 rounded-full [animation-delay:150ms]"
                }), jsxRuntime.exports.jsx("div", {
                    className: "animate-loading-pin bg-denim-300 mx-1 h-2 w-2 rounded-full [animation-delay:300ms]"
                }), jsxRuntime.exports.jsx("div", {
                    className: "animate-loading-pin bg-denim-300 mx-1 h-2 w-2 rounded-full [animation-delay:450ms]"
                })]
            }), _.text && _.text.length ? jsxRuntime.exports.jsx("p", {
                className: "mt-3 max-w-xs text-sm opacity-75",
                children: _.text
            }) : null]
        })
    })
}

function SkeletonVideoPlayer(_) {
    return jsxRuntime.exports.jsx("div", {
        className: "flex aspect-video w-full items-center justify-center bg-denim-200 lg:rounded-xl",
        children: _.error ? jsxRuntime.exports.jsxs("div", {
            className: "flex flex-col items-center",
            children: [jsxRuntime.exports.jsx(IconPatch, {
                icon: Icons.WARNING,
                className: "text-red-400"
            }), jsxRuntime.exports.jsx("p", {
                className: "mt-5 text-white",
                children: "Couldn't get your stream"
            })]
        }) : jsxRuntime.exports.jsxs("div", {
            className: "flex flex-col items-center",
            children: [jsxRuntime.exports.jsx(Loading, {}), jsxRuntime.exports.jsx("p", {
                className: "mt-3 text-white",
                children: "Getting your stream..."
            })]
        })
    })
}

function VideoPlayer(_) {
    const _e = react.exports.useRef(null),
        [et, tt] = react.exports.useState(!1),
        [rt, nt] = react.exports.useState(!0),
        at = !rt && !et,
        st = _.source.type === "m3u8";
    react.exports.useEffect(() => {
        if (nt(!0), tt(!1), st) {
            if (!_e.current) return;
            if (!Hls.isSupported()) {
                nt(!1), tt(!0);
                return
            }
            const ut = new Hls;
            if (_e.current.canPlayType("application/vnd.apple.mpegurl")) {
                _e.current.src = _.source.url;
                return
            }
            ut.attachMedia(_e.current), ut.loadSource(_.source.url), ut.on(Hls.Events.ERROR, (lt, bt) => {
                tt(!0), console.error(bt)
            })
        }
    }, [_.source.url, _e, st]);
    let it = null;
    return et ? it = jsxRuntime.exports.jsx(SkeletonVideoPlayer, {
        error: !0
    }) : rt && (it = jsxRuntime.exports.jsx(SkeletonVideoPlayer, {})), jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, {
        children: [it, jsxRuntime.exports.jsxs("video", {
            className: `w-full rounded-xl bg-black ${at?"":"hidden"}`,
            ref: _e,
            onProgress: ut => _.onProgress && _.onProgress(ut.nativeEvent),
            onLoadedData: ut => {
                nt(!1), _.startAt && (ut.target.currentTime = _.startAt)
            },
            onError: ut => {
                console.error("failed to playback stream", ut), tt(!0)
            },
            controls: !0,
            autoPlay: !0,
            children: [st ? null : jsxRuntime.exports.jsx("source", {
                src: _.source.url,
                type: "video/mp4"
            }), _.captions.map(ut => jsxRuntime.exports.jsx("track", {
                kind: "captions",
                label: ut.label,
                src: ut.url
            }, ut.id))]
        })]
    })
}

function DotList(_) {
    return jsxRuntime.exports.jsx("p", {
        className: `text-denim-700 font-semibold ${_.className||""}`,
        children: _.content.map((_e, et) => jsxRuntime.exports.jsxs("span", {
            children: [et !== 0 ? jsxRuntime.exports.jsx("span", {
                className: "mx-[0.6em] text-[1em]",
                children: ""
            }) : null, _e]
        }, _e))
    })
}

function NotFoundChecks(_) {
    const _e = _.portable ? getProviderMetadata(_.portable.providerId) : void 0;
    return !_e || !_e.exists ? jsxRuntime.exports.jsx(NotFoundMedia, {}) : _e.enabled ? _.children || null : jsxRuntime.exports.jsx(NotFoundProvider, {})
}

function StyledMediaView(_) {
    var rt;
    const _e = useWatchedContext(),
        et = (rt = getWatchedFromPortable(_e.watched.items, _.media)) == null ? void 0 : rt.progress;

    function tt(nt) {
        if (!_.media) return;
        const at = nt.currentTarget;
        at.currentTime <= 30 || _e.updateProgress(_.media, at.currentTime, at.duration)
    }
    return jsxRuntime.exports.jsx(VideoPlayer, {
        source: _.stream,
        captions: _.stream.captions,
        onProgress: nt => tt(nt),
        startAt: et
    })
}

function StyledMediaFooter(_) {
    const {
        setItemBookmark: _e,
        getFilteredBookmarks: et
    } = useBookmarkContext(), tt = getIfBookmarkedFromPortable(et(), _.media);
    return jsxRuntime.exports.jsxs(Paper, {
        className: "mt-5",
        children: [jsxRuntime.exports.jsxs("div", {
            className: "flex",
            children: [jsxRuntime.exports.jsxs("div", {
                className: "flex-1",
                children: [jsxRuntime.exports.jsx(Title, {
                    children: _.media.title
                }), jsxRuntime.exports.jsx(DotList, {
                    className: "mt-3 text-sm",
                    content: [_.provider.displayName, _.media.mediaType, _.media.year]
                })]
            }), jsxRuntime.exports.jsx("div", {
                children: jsxRuntime.exports.jsx(IconPatch, {
                    icon: Icons.BOOKMARK,
                    active: tt,
                    onClick: () => _e(_.media, !tt),
                    clickable: !0
                })
            })]
        }), _.media.mediaType !== MWMediaType.MOVIE ? jsxRuntime.exports.jsx(Seasons, {
            media: _.media
        }) : null]
    })
}

function LoadingMediaFooter(_) {
    const {
        t: _e
    } = useTranslation();
    return jsxRuntime.exports.jsx(Paper, {
        className: "mt-5",
        children: jsxRuntime.exports.jsx("div", {
            className: "flex",
            children: jsxRuntime.exports.jsxs("div", {
                className: "flex-1",
                children: [jsxRuntime.exports.jsx("div", {
                    className: "mb-2 h-4 w-48 rounded-full bg-denim-500"
                }), jsxRuntime.exports.jsxs("div", {
                    children: [jsxRuntime.exports.jsx("span", {
                        className: "mr-4 inline-block h-2 w-12 rounded-full bg-denim-400"
                    }), jsxRuntime.exports.jsx("span", {
                        className: "mr-4 inline-block h-2 w-12 rounded-full bg-denim-400"
                    })]
                }), _.error ? jsxRuntime.exports.jsxs("div", {
                    className: "flex items-center space-x-3",
                    children: [jsxRuntime.exports.jsx(IconPatch, {
                        icon: Icons.WARNING,
                        className: "text-red-400"
                    }), jsxRuntime.exports.jsx("p", {
                        children: _e("media.invalidUrl")
                    })]
                }) : jsxRuntime.exports.jsx(LoadingSeasons, {})]
            })
        })
    })
}

function MediaViewContent(_) {
    const _e = _.portable,
        [et, tt] = react.exports.useState(),
        [rt, nt] = react.exports.useState(),
        [at, st, it] = useLoading(At => convertPortableToMedia(At)),
        [ut, lt, bt] = useLoading(At => getStream(At));
    react.exports.useEffect(() => {
        (async () => _e && nt(await at(_e)))()
    }, [_e, nt, at]), react.exports.useEffect(() => {
        (async () => _e && tt(await ut(_e)))()
    }, [_e, tt, ut]);
    let pt = null;
    lt ? pt = jsxRuntime.exports.jsx(SkeletonVideoPlayer, {}) : bt ? pt = jsxRuntime.exports.jsx(SkeletonVideoPlayer, {
        error: !0
    }) : rt && et && (pt = jsxRuntime.exports.jsx(StyledMediaView, {
        media: rt,
        stream: et
    }));
    let It = null;
    return st ? It = jsxRuntime.exports.jsx(LoadingMediaFooter, {}) : it ? It = jsxRuntime.exports.jsx(LoadingMediaFooter, {
        error: !0
    }) : _e && rt && (It = jsxRuntime.exports.jsx(StyledMediaFooter, {
        provider: getProviderFromId(_e.providerId),
        media: rt
    })), jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, {
        children: [pt, It]
    })
}

function MediaView() {
    const {
        t: _
    } = useTranslation(), _e = usePortableMedia(), et = useHistory();
    return jsxRuntime.exports.jsxs("div", {
        className: "flex min-h-screen w-full",
        children: [jsxRuntime.exports.jsx(Navigation, {
            children: jsxRuntime.exports.jsx(ArrowLink, {
                onClick: () => et.action !== "POP" ? et.goBack() : et.push("/"),
                direction: "left",
                linkText: _("media.arrowText")
            })
        }), jsxRuntime.exports.jsx(NotFoundChecks, {
            portable: _e,
            children: jsxRuntime.exports.jsx("div", {
                className: "container mx-auto mt-40 mb-16 max-w-[1100px]",
                children: jsxRuntime.exports.jsx(MediaViewContent, {
                    portable: _e
                })
            })
        })]
    })
}

function MediaCardContent({
    media: _,
    linkable: _e,
    watchedPercentage: et,
    series: tt
}) {
    const rt = getProviderFromId(_.providerId);
    return rt ? jsxRuntime.exports.jsxs("article", {
        className: `group relative mb-4 flex overflow-hidden rounded bg-denim-300 py-4 px-5 ${_e?"hover:bg-denim-400":""}`,
        children: [et > 0 ? jsxRuntime.exports.jsx("div", {
            className: "absolute top-0 left-0 right-0 bottom-0",
            children: jsxRuntime.exports.jsx("div", {
                className: "relative h-full bg-bink-300 bg-opacity-30",
                style: {
                    width: `${et}%`
                },
                children: jsxRuntime.exports.jsx("div", {
                    className: "absolute right-0 top-0 bottom-0 ml-auto w-40 bg-gradient-to-l from-bink-400 to-transparent opacity-40"
                })
            })
        }) : null, jsxRuntime.exports.jsxs("div", {
            className: "relative flex flex-1",
            children: [jsxRuntime.exports.jsxs("div", {
                className: "flex-1",
                children: [jsxRuntime.exports.jsxs("h1", {
                    className: "mb-1 font-bold text-white",
                    children: [_.title, tt && _.seasonId && _.episodeId ? jsxRuntime.exports.jsxs("span", {
                        className: "ml-2 text-xs text-denim-700",
                        children: ["S", _.seasonId, " E", _.episodeId]
                    }) : null]
                }), jsxRuntime.exports.jsx(DotList, {
                    className: "text-xs",
                    content: [rt.displayName, _.mediaType, _.year]
                })]
            }), jsxRuntime.exports.jsx("div", {
                className: `flex translate-x-3 items-center justify-end text-xl text-white opacity-0 transition-[opacity,transform] ${_e?"group-hover:translate-x-0 group-hover:opacity-100":""}`,
                children: jsxRuntime.exports.jsx(Icon, {
                    icon: Icons.CHEVRON_RIGHT
                })
            })]
        })]
    }) : null
}

function MediaCard(_) {
    let _e = "movie";
    _.media.mediaType === MWMediaType.SERIES && (_e = "series");
    const et = jsxRuntime.exports.jsx(MediaCardContent, {
        ..._
    });
    return _.linkable ? jsxRuntime.exports.jsx(Link$1, {
        to: `/media/${_e}/${serializePortableMedia(convertMediaToPortable(_.media))}`,
        children: et
    }) : jsxRuntime.exports.jsx("span", {
        children: et
    })
}

function WatchedMediaCard(_) {
    const {
        watched: _e
    } = useWatchedContext(), et = getWatchedFromPortable(_e.items, _.media), tt = et && et.percentage || 0;
    return jsxRuntime.exports.jsx(MediaCard, {
        watchedPercentage: tt,
        media: _.media,
        series: _.series && _.media.episodeId !== void 0,
        linkable: !0
    })
}
const useFade$1 = "",
    useFade = (_ = !1) => {
        const [_e, et] = react.exports.useState(_), [tt, rt] = react.exports.useState(_e);
        return react.exports.useEffect(() => {
            _e && rt(!0)
        }, [_e]), [tt, et, {
            style: {
                animation: `${_e?"fadeIn":"fadeOut"} .3s`
            },
            onAnimationEnd: () => {
                _e || rt(!1)
            }
        }]
    };

function useBackdrop() {
    const [_, _e] = react.exports.useState(!1), [et, tt] = react.exports.useState(!1);
    return [st => {
        _e(st), st && tt(!0)
    }, {
        active: _,
        onBackdropHide() {
            tt(!1)
        }
    }, {
        style: et ? {
            zIndex: "1000",
            position: "relative"
        } : {}
    }]
}

function Backdrop(_) {
    const _e = _.onClick || (() => {}),
        et = _.onBackdropHide || (() => {}),
        [tt, rt, nt] = useFade();
    return react.exports.useEffect(() => {
        rt(!!_.active)
    }, [_.active, rt]), react.exports.useEffect(() => {
        tt || et()
    }, [tt]), tt ? jsxRuntime.exports.jsx("div", {
        className: `fixed top-0 left-0 right-0 z-[999] h-screen bg-black bg-opacity-50 opacity-100 transition-opacity ${tt?"":"opacity-0"}`,
        ...nt,
        onClick: at => _e(at.nativeEvent)
    }) : null
}

function ButtonControl({
    onClick: _,
    children: _e,
    className: et
}) {
    return jsxRuntime.exports.jsx("button", {
        onClick: _,
        className: et,
        type: "button",
        children: _e
    })
}

function Option({
    option: _,
    onClick: _e,
    tabIndex: et
}) {
    return jsxRuntime.exports.jsxs("div", {
        className: "flex h-10 cursor-pointer items-center space-x-2 px-4 py-2 text-left text-denim-700 transition-colors hover:text-white",
        onClick: _e,
        tabIndex: et,
        children: [jsxRuntime.exports.jsx(Icon, {
            icon: _.icon
        }), jsxRuntime.exports.jsx("input", {
            type: "radio",
            className: "hidden",
            id: _.id
        }), jsxRuntime.exports.jsx("label", {
            htmlFor: _.id,
            className: "cursor-pointer ",
            children: jsxRuntime.exports.jsx("div", {
                className: "item",
                children: _.name
            })
        })]
    })
}
const DropdownButton = React.forwardRef((_, _e) => {
    const [et, tt, rt] = useBackdrop(), [nt, at] = react.exports.useState(_.selectedItem);
    react.exports.useEffect(() => {
        let ut;
        return _.open ? at(_.selectedItem) : ut = setTimeout(() => {
            at(_.selectedItem)
        }, 200), () => {
            ut && clearTimeout(ut)
        }
    }, [_.open]);
    const st = _.options.find(ut => ut.id === _.selectedItem) || {
        id: "movie",
        name: "movie",
        icon: Icons.ARROW_LEFT
    };
    react.exports.useEffect(() => {
        et(_.open)
    }, [_.open]);
    const it = (ut, lt) => {
        ut.stopPropagation(), _.setSelectedItem(lt.id), _.setOpen(!1)
    };
    return jsxRuntime.exports.jsxs("div", {
        className: "w-full min-w-[140px] sm:w-auto",
        children: [jsxRuntime.exports.jsxs("div", {
            ref: _e,
            className: "relative w-full sm:w-auto",
            ...rt,
            children: [jsxRuntime.exports.jsxs(ButtonControl, {
                ..._,
                className: "sm:justify-left relative z-20 flex h-10 w-full items-center justify-center space-x-2 rounded-[20px] bg-bink-200 px-4 py-2 text-white hover:bg-bink-300",
                children: [jsxRuntime.exports.jsx(Icon, {
                    icon: st.icon
                }), jsxRuntime.exports.jsx("span", {
                    className: "flex-1",
                    children: st.name
                }), jsxRuntime.exports.jsx(Icon, {
                    icon: Icons.CHEVRON_DOWN,
                    className: `transition-transform ${_.open?"rotate-180":""}`
                })]
            }), jsxRuntime.exports.jsx("div", {
                className: `absolute top-0 z-10 w-full rounded-[20px] bg-denim-300 pt-[40px] transition-all duration-200 ${_.open?"block max-h-60 opacity-100":"invisible max-h-0 opacity-0"}`,
                children: _.options.filter(ut => ut.id !== nt).map(ut => jsxRuntime.exports.jsx(Option, {
                    option: ut,
                    onClick: lt => it(lt, ut),
                    tabIndex: _.open ? 0 : void 0
                }, ut.id))
            })]
        }), jsxRuntime.exports.jsx(Backdrop, {
            onClick: () => _.setOpen(!1),
            ...tt
        })]
    })
});

function TextInputControl({
    onChange: _,
    onUnFocus: _e,
    value: et,
    label: tt,
    className: rt,
    placeholder: nt
}) {
    const at = jsxRuntime.exports.jsx("input", {
        type: "text",
        className: rt,
        placeholder: nt,
        onChange: st => _ && _(st.target.value),
        value: et,
        onBlur: () => _e && _e()
    });
    return tt ? jsxRuntime.exports.jsxs("label", {
        children: [jsxRuntime.exports.jsx("span", {
            children: tt
        }), at]
    }) : at
}

function SearchBarInput(_) {
    const {
        t: _e
    } = useTranslation(), [et, tt] = react.exports.useState(!1);

    function rt(at) {
        _.onChange({
            ..._.value,
            searchQuery: at
        }, !1)
    }

    function nt(at) {
        _.onChange({
            ..._.value,
            type: at
        }, !0)
    }
    return jsxRuntime.exports.jsxs("div", {
        className: "flex flex-col items-center gap-4 rounded-[28px] bg-denim-300 px-4 py-4 transition-colors focus-within:bg-denim-400 hover:bg-denim-400 sm:flex-row sm:py-2 sm:pl-8  sm:pr-2",
        children: [jsxRuntime.exports.jsx(TextInputControl, {
            onUnFocus: _.onUnFocus,
            onChange: at => rt(at),
            value: _.value.searchQuery,
            className: "w-full flex-1 bg-transparent text-white placeholder-denim-700 focus:outline-none",
            placeholder: _.placeholder
        }), jsxRuntime.exports.jsx(DropdownButton, {
            icon: Icons.SEARCH,
            open: et,
            setOpen: at => tt(at),
            selectedItem: _.value.type,
            setSelectedItem: at => nt(at),
            options: [{
                id: MWMediaType.MOVIE,
                name: _e("searchBar.movie"),
                icon: Icons.FILM
            }, {
                id: MWMediaType.SERIES,
                name: _e("searchBar.series"),
                icon: Icons.CLAPPER_BOARD
            }],
            onClick: () => tt(at => !at),
            children: _.buttonText || _e("searchBar.search")
        })]
    })
}

function ThinContainer(_) {
    return jsxRuntime.exports.jsx("div", {
        className: `max-w-[600px] mx-auto px-2 sm:px-0 ${_.classNames||""}`,
        children: _.children
    })
}

function SectionHeading(_) {
    return jsxRuntime.exports.jsxs("div", {
        className: `mt-12 ${_.className}`,
        children: [jsxRuntime.exports.jsxs("div", {
            className: "mb-4 flex items-end",
            children: [jsxRuntime.exports.jsxs("p", {
                className: "flex flex-1 items-center font-bold uppercase text-denim-700",
                children: [_.icon ? jsxRuntime.exports.jsx("span", {
                    className: "mr-2 text-xl",
                    children: jsxRuntime.exports.jsx(Icon, {
                        icon: _.icon
                    })
                }) : null, _.title]
            }), _.linkText ? jsxRuntime.exports.jsx(ArrowLink, {
                linkText: _.linkText,
                direction: "left",
                onClick: _.onClick
            }) : null]
        }), _.children]
    })
}

function Tagline(_) {
    return jsxRuntime.exports.jsx("p", {
        className: "font-bold text-bink-600",
        children: _.children
    })
}

function useDebounce(_, _e) {
    const [et, tt] = react.exports.useState(_);
    return react.exports.useEffect(() => {
        const rt = setTimeout(() => {
            tt(_)
        }, _e);
        return () => {
            clearTimeout(rt)
        }
    }, [_, _e]), et
}

function useSearchQuery() {
    const _ = useHistory(),
        _e = react.exports.useRef(!0),
        {
            path: et,
            params: tt
        } = useRouteMatch(),
        [rt, nt] = react.exports.useState({
            searchQuery: "",
            type: MWMediaType.MOVIE
        }),
        at = (it, ut) => {
            const lt = {
                ...rt
            };
            Object.assign(lt, it), nt(lt), ut && _.replace(generatePath(et, {
                query: lt.searchQuery.length === 0 ? void 0 : it.searchQuery,
                type: lt.type
            }))
        },
        st = () => {
            _.replace(generatePath(et, {
                query: rt.searchQuery.length === 0 ? void 0 : rt.searchQuery,
                type: rt.type
            }))
        };
    return React.useEffect(() => {
        if (_e.current === !1) return;
        _e.current = !1;
        const it = Object.values(MWMediaType).find(lt => tt.type === lt) || MWMediaType.MOVIE,
            ut = tt.query || "";
        nt({
            type: it,
            searchQuery: ut
        })
    }, [nt, tt, _e]), [rt, at, st]
}

function SearchLoading() {
    const {
        t: _
    } = useTranslation();
    return jsxRuntime.exports.jsx(Loading, {
        className: "my-24",
        text: _("search.loading") || "Fetching your favourite shows..."
    })
}

function SearchSuffix(_) {
    const {
        t: _e
    } = useTranslation(), et = _.fails === _.total, tt = et ? Icons.WARNING : Icons.EYE_SLASH;
    return jsxRuntime.exports.jsxs("div", {
        className: "my-24 flex flex-col items-center justify-center space-y-3 text-center",
        children: [jsxRuntime.exports.jsx(IconPatch, {
            icon: tt,
            className: `text-xl ${et?"text-red-400":"text-bink-600"}`
        }), et ? null : jsxRuntime.exports.jsxs("div", {
            children: [_.fails > 0 ? jsxRuntime.exports.jsx("p", {
                className: "text-red-400",
                children: _e("search.providersFailed", {
                    fails: _.fails,
                    total: _.total
                })
            }) : null, _.resultsSize > 0 ? jsxRuntime.exports.jsx("p", {
                children: _e("search.allResults")
            }) : jsxRuntime.exports.jsx("p", {
                children: _e("search.noResults")
            })]
        }), et ? jsxRuntime.exports.jsx("div", {
            children: jsxRuntime.exports.jsx("p", {
                children: _e("search.allFailed")
            })
        }) : null]
    })
}

function SearchResultsView({
    searchQuery: _,
    clear: _e
}) {
    const {
        t: et
    } = useTranslation(), [tt, rt] = react.exports.useState(), [nt, at, st, it] = useLoading(ut => SearchProviders(ut));
    return react.exports.useEffect(() => {
        async function ut(lt) {
            const bt = await nt(lt);
            !bt || rt(bt)
        }
        _.searchQuery !== "" && ut(_)
    }, [_, nt]), jsxRuntime.exports.jsxs("div", {
        children: [it && (tt != null && tt.results.length) ? jsxRuntime.exports.jsx(SectionHeading, {
            title: et("search.headingTitle") || "Search results",
            icon: Icons.SEARCH,
            linkText: et("search.headingLink") || "Back to home",
            onClick: () => _e(),
            children: tt.results.map(ut => jsxRuntime.exports.jsx(WatchedMediaCard, {
                media: ut
            }, [ut.mediaId, ut.providerId].join("|")))
        }) : null, it && tt ? jsxRuntime.exports.jsx(SearchSuffix, {
            resultsSize: tt.results.length,
            fails: tt.stats.failed,
            total: tt.stats.total
        }) : null, st ? jsxRuntime.exports.jsx(SearchSuffix, {
            resultsSize: 0,
            fails: 1,
            total: 1
        }) : null, at ? jsxRuntime.exports.jsx(SearchLoading, {}) : null]
    })
}

function ExtraItems() {
    const {
        t: _
    } = useTranslation(), {
        getFilteredBookmarks: _e
    } = useBookmarkContext(), {
        getFilteredWatched: et
    } = useWatchedContext(), tt = _e(), rt = et().filter(nt => !getIfBookmarkedFromPortable(tt, nt));
    return rt.length === 0 && tt.length === 0 ? null : jsxRuntime.exports.jsxs("div", {
        className: "mb-16 mt-32",
        children: [tt.length > 0 ? jsxRuntime.exports.jsx(SectionHeading, {
            title: _("search.bookmarks") || "Bookmarks",
            icon: Icons.BOOKMARK,
            children: tt.map(nt => jsxRuntime.exports.jsx(WatchedMediaCard, {
                media: nt
            }, [nt.mediaId, nt.providerId].join("|")))
        }) : null, rt.length > 0 ? jsxRuntime.exports.jsx(SectionHeading, {
            title: _("search.continueWatching") || "Continue Watching",
            icon: Icons.CLOCK,
            children: rt.map(nt => jsxRuntime.exports.jsx(WatchedMediaCard, {
                media: nt,
                series: !0
            }, [nt.mediaId, nt.providerId].join("|")))
        }) : null]
    })
}

function SearchView() {
    const {
        t: _
    } = useTranslation(), [_e, et] = react.exports.useState(!1), [tt, rt] = react.exports.useState(!1), [nt, at, st] = useSearchQuery(), it = useDebounce(nt, 2e3);
    react.exports.useEffect(() => {
        et(nt.searchQuery !== ""), rt(nt.searchQuery !== "")
    }, [nt]), react.exports.useEffect(() => {
        rt(!1)
    }, [it]);
    const ut = react.exports.useMemo(() => tt ? jsxRuntime.exports.jsx(SearchLoading, {}) : _e ? jsxRuntime.exports.jsx(SearchResultsView, {
        searchQuery: it,
        clear: () => at({
            searchQuery: ""
        }, !0)
    }) : jsxRuntime.exports.jsx(ExtraItems, {}), [tt, _e, it, at]);
    return jsxRuntime.exports.jsxs(jsxRuntime.exports.Fragment, {
        children: [jsxRuntime.exports.jsx(Navigation, {}), jsxRuntime.exports.jsxs(ThinContainer, {
            children: [jsxRuntime.exports.jsxs("div", {
                className: "mt-44 space-y-16 text-center",
                children: [jsxRuntime.exports.jsxs("div", {
                    className: "space-y-4",
                    children: [jsxRuntime.exports.jsx(Tagline, {
                        children: _("search.tagline")
                    }), jsxRuntime.exports.jsx(Title, {
                        children: _("search.title")
                    })]
                }), jsxRuntime.exports.jsx(SearchBarInput, {
                    onChange: at,
                    value: nt,
                    onUnFocus: st,
                    placeholder: _("search.placeholder") || "What do you want to watch?"
                })]
            }), ut]
        })]
    })
}

function App() {
    return jsxRuntime.exports.jsx(WatchedContextProvider, {
        children: jsxRuntime.exports.jsx(BookmarkContextProvider, {
            children: jsxRuntime.exports.jsxs(Switch, {
                children: [jsxRuntime.exports.jsx(Route, {
                    exact: !0,
                    path: "/",
                    children: jsxRuntime.exports.jsx(Redirect, {
                        to: `/search/${MWMediaType.MOVIE}`
                    })
                }), jsxRuntime.exports.jsx(Route, {
                    exact: !0,
                    path: "/media/movie/:media",
                    component: MediaView
                }), jsxRuntime.exports.jsx(Route, {
                    exact: !0,
                    path: "/media/series/:media",
                    component: MediaView
                }), jsxRuntime.exports.jsx(Route, {
                    exact: !0,
                    path: "/search/:type/:query?",
                    component: SearchView
                }), jsxRuntime.exports.jsx(Route, {
                    path: "*",
                    component: NotFoundPage
                })]
            })
        })
    })
}

function _assertThisInitialized(_) {
    if (_ === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return _
}

function _inherits(_, _e) {
    if (typeof _e != "function" && _e !== null) throw new TypeError("Super expression must either be null or a function");
    _.prototype = Object.create(_e && _e.prototype, {
        constructor: {
            value: _,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(_, "prototype", {
        writable: !1
    }), _e && _setPrototypeOf(_, _e)
}

function _possibleConstructorReturn(_, _e) {
    if (_e && (_typeof$3(_e) === "object" || typeof _e == "function")) return _e;
    if (_e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(_)
}

function _getPrototypeOf(_) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(et) {
        return et.__proto__ || Object.getPrototypeOf(et)
    }, _getPrototypeOf(_)
}

function _iterableToArray(_) {
    if (typeof Symbol < "u" && _[Symbol.iterator] != null || _["@@iterator"] != null) return Array.from(_)
}

function _toArray(_) {
    return _arrayWithHoles(_) || _iterableToArray(_) || _unsupportedIterableToArray(_) || _nonIterableRest()
}

function ownKeys$6(_, _e) {
    var et = Object.keys(_);
    if (Object.getOwnPropertySymbols) {
        var tt = Object.getOwnPropertySymbols(_);
        _e && (tt = tt.filter(function(rt) {
            return Object.getOwnPropertyDescriptor(_, rt).enumerable
        })), et.push.apply(et, tt)
    }
    return et
}

function _objectSpread$6(_) {
    for (var _e = 1; _e < arguments.length; _e++) {
        var et = arguments[_e] != null ? arguments[_e] : {};
        _e % 2 ? ownKeys$6(Object(et), !0).forEach(function(tt) {
            _defineProperty$1(_, tt, et[tt])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(et)) : ownKeys$6(Object(et)).forEach(function(tt) {
            Object.defineProperty(_, tt, Object.getOwnPropertyDescriptor(et, tt))
        })
    }
    return _
}
var consoleLogger = {
        type: "logger",
        log: function _(_e) {
            this.output("log", _e)
        },
        warn: function _(_e) {
            this.output("warn", _e)
        },
        error: function _(_e) {
            this.output("error", _e)
        },
        output: function _(_e, et) {
            console && console[_e] && console[_e].apply(console, et)
        }
    },
    Logger = function() {
        function _(_e) {
            var et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            _classCallCheck$1(this, _), this.init(_e, et)
        }
        return _createClass$1(_, [{
            key: "init",
            value: function(et) {
                var tt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                this.prefix = tt.prefix || "i18next:", this.logger = et || consoleLogger, this.options = tt, this.debug = tt.debug
            }
        }, {
            key: "setDebug",
            value: function(et) {
                this.debug = et
            }
        }, {
            key: "log",
            value: function() {
                for (var et = arguments.length, tt = new Array(et), rt = 0; rt < et; rt++) tt[rt] = arguments[rt];
                return this.forward(tt, "log", "", !0)
            }
        }, {
            key: "warn",
            value: function() {
                for (var et = arguments.length, tt = new Array(et), rt = 0; rt < et; rt++) tt[rt] = arguments[rt];
                return this.forward(tt, "warn", "", !0)
            }
        }, {
            key: "error",
            value: function() {
                for (var et = arguments.length, tt = new Array(et), rt = 0; rt < et; rt++) tt[rt] = arguments[rt];
                return this.forward(tt, "error", "")
            }
        }, {
            key: "deprecate",
            value: function() {
                for (var et = arguments.length, tt = new Array(et), rt = 0; rt < et; rt++) tt[rt] = arguments[rt];
                return this.forward(tt, "warn", "WARNING DEPRECATED: ", !0)
            }
        }, {
            key: "forward",
            value: function(et, tt, rt, nt) {
                return nt && !this.debug ? null : (typeof et[0] == "string" && (et[0] = "".concat(rt).concat(this.prefix, " ").concat(et[0])), this.logger[tt](et))
            }
        }, {
            key: "create",
            value: function(et) {
                return new _(this.logger, _objectSpread$6(_objectSpread$6({}, {
                    prefix: "".concat(this.prefix, ":").concat(et, ":")
                }), this.options))
            }
        }, {
            key: "clone",
            value: function(et) {
                return et = et || this.options, et.prefix = et.prefix || this.prefix, new _(this.logger, et)
            }
        }]), _
    }(),
    baseLogger = new Logger,
    EventEmitter = function() {
        function _() {
            _classCallCheck$1(this, _), this.observers = {}
        }
        return _createClass$1(_, [{
            key: "on",
            value: function(et, tt) {
                var rt = this;
                return et.split(" ").forEach(function(nt) {
                    rt.observers[nt] = rt.observers[nt] || [], rt.observers[nt].push(tt)
                }), this
            }
        }, {
            key: "off",
            value: function(et, tt) {
                if (!!this.observers[et]) {
                    if (!tt) {
                        delete this.observers[et];
                        return
                    }
                    this.observers[et] = this.observers[et].filter(function(rt) {
                        return rt !== tt
                    })
                }
            }
        }, {
            key: "emit",
            value: function(et) {
                for (var tt = arguments.length, rt = new Array(tt > 1 ? tt - 1 : 0), nt = 1; nt < tt; nt++) rt[nt - 1] = arguments[nt];
                if (this.observers[et]) {
                    var at = [].concat(this.observers[et]);
                    at.forEach(function(it) {
                        it.apply(void 0, rt)
                    })
                }
                if (this.observers["*"]) {
                    var st = [].concat(this.observers["*"]);
                    st.forEach(function(it) {
                        it.apply(it, [et].concat(rt))
                    })
                }
            }
        }]), _
    }();

function defer() {
    var _, _e, et = new Promise(function(tt, rt) {
        _ = tt, _e = rt
    });
    return et.resolve = _, et.reject = _e, et
}

function makeString(_) {
    return _ == null ? "" : "" + _
}

function copy(_, _e, et) {
    _.forEach(function(tt) {
        _e[tt] && (et[tt] = _e[tt])
    })
}

function getLastOfPath(_, _e, et) {
    function tt(st) {
        return st && st.indexOf("###") > -1 ? st.replace(/###/g, ".") : st
    }

    function rt() {
        return !_ || typeof _ == "string"
    }
    for (var nt = typeof _e != "string" ? [].concat(_e) : _e.split("."); nt.length > 1;) {
        if (rt()) return {};
        var at = tt(nt.shift());
        !_[at] && et && (_[at] = new et), Object.prototype.hasOwnProperty.call(_, at) ? _ = _[at] : _ = {}
    }
    return rt() ? {} : {
        obj: _,
        k: tt(nt.shift())
    }
}

function setPath(_, _e, et) {
    var tt = getLastOfPath(_, _e, Object),
        rt = tt.obj,
        nt = tt.k;
    rt[nt] = et
}

function pushPath(_, _e, et, tt) {
    var rt = getLastOfPath(_, _e, Object),
        nt = rt.obj,
        at = rt.k;
    nt[at] = nt[at] || [], tt && (nt[at] = nt[at].concat(et)), tt || nt[at].push(et)
}

function getPath(_, _e) {
    var et = getLastOfPath(_, _e),
        tt = et.obj,
        rt = et.k;
    if (!!tt) return tt[rt]
}

function getPathWithDefaults(_, _e, et) {
    var tt = getPath(_, et);
    return tt !== void 0 ? tt : getPath(_e, et)
}

function deepExtend(_, _e, et) {
    for (var tt in _e) tt !== "__proto__" && tt !== "constructor" && (tt in _ ? typeof _[tt] == "string" || _[tt] instanceof String || typeof _e[tt] == "string" || _e[tt] instanceof String ? et && (_[tt] = _e[tt]) : deepExtend(_[tt], _e[tt], et) : _[tt] = _e[tt]);
    return _
}

function regexEscape(_) {
    return _.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
}
var _entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;"
};

function escape$1(_) {
    return typeof _ == "string" ? _.replace(/[&<>"'\/]/g, function(_e) {
        return _entityMap[_e]
    }) : _
}
var isIE10 = typeof window < "u" && window.navigator && typeof window.navigator.userAgentData > "u" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1,
    chars = [" ", ",", "?", "!", ";"];

function looksLikeObjectPath(_, _e, et) {
    _e = _e || "", et = et || "";
    var tt = chars.filter(function(st) {
        return _e.indexOf(st) < 0 && et.indexOf(st) < 0
    });
    if (tt.length === 0) return !0;
    var rt = new RegExp("(".concat(tt.map(function(st) {
            return st === "?" ? "\\?" : st
        }).join("|"), ")")),
        nt = !rt.test(_);
    if (!nt) {
        var at = _.indexOf(et);
        at > 0 && !rt.test(_.substring(0, at)) && (nt = !0)
    }
    return nt
}

function ownKeys$5(_, _e) {
    var et = Object.keys(_);
    if (Object.getOwnPropertySymbols) {
        var tt = Object.getOwnPropertySymbols(_);
        _e && (tt = tt.filter(function(rt) {
            return Object.getOwnPropertyDescriptor(_, rt).enumerable
        })), et.push.apply(et, tt)
    }
    return et
}

function _objectSpread$5(_) {
    for (var _e = 1; _e < arguments.length; _e++) {
        var et = arguments[_e] != null ? arguments[_e] : {};
        _e % 2 ? ownKeys$5(Object(et), !0).forEach(function(tt) {
            _defineProperty$1(_, tt, et[tt])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(et)) : ownKeys$5(Object(et)).forEach(function(tt) {
            Object.defineProperty(_, tt, Object.getOwnPropertyDescriptor(et, tt))
        })
    }
    return _
}

function _createSuper$3(_) {
    var _e = _isNativeReflectConstruct$3();
    return function() {
        var tt = _getPrototypeOf(_),
            rt;
        if (_e) {
            var nt = _getPrototypeOf(this).constructor;
            rt = Reflect.construct(tt, arguments, nt)
        } else rt = tt.apply(this, arguments);
        return _possibleConstructorReturn(this, rt)
    }
}

function _isNativeReflectConstruct$3() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
    } catch {
        return !1
    }
}

function deepFind(_, _e) {
    var et = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
    if (!!_) {
        if (_[_e]) return _[_e];
        for (var tt = _e.split(et), rt = _, nt = 0; nt < tt.length; ++nt) {
            if (!rt || typeof rt[tt[nt]] == "string" && nt + 1 < tt.length) return;
            if (rt[tt[nt]] === void 0) {
                for (var at = 2, st = tt.slice(nt, nt + at).join(et), it = rt[st]; it === void 0 && tt.length > nt + at;) at++, st = tt.slice(nt, nt + at).join(et), it = rt[st];
                if (it === void 0) return;
                if (it === null) return null;
                if (_e.endsWith(st)) {
                    if (typeof it == "string") return it;
                    if (st && typeof it[st] == "string") return it[st]
                }
                var ut = tt.slice(nt + at).join(et);
                return ut ? deepFind(it, ut, et) : void 0
            }
            rt = rt[tt[nt]]
        }
        return rt
    }
}
var ResourceStore = function(_) {
        _inherits(et, _);
        var _e = _createSuper$3(et);

        function et(tt) {
            var rt, nt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                ns: ["translation"],
                defaultNS: "translation"
            };
            return _classCallCheck$1(this, et), rt = _e.call(this), isIE10 && EventEmitter.call(_assertThisInitialized(rt)), rt.data = tt || {}, rt.options = nt, rt.options.keySeparator === void 0 && (rt.options.keySeparator = "."), rt.options.ignoreJSONStructure === void 0 && (rt.options.ignoreJSONStructure = !0), rt
        }
        return _createClass$1(et, [{
            key: "addNamespaces",
            value: function(rt) {
                this.options.ns.indexOf(rt) < 0 && this.options.ns.push(rt)
            }
        }, {
            key: "removeNamespaces",
            value: function(rt) {
                var nt = this.options.ns.indexOf(rt);
                nt > -1 && this.options.ns.splice(nt, 1)
            }
        }, {
            key: "getResource",
            value: function(rt, nt, at) {
                var st = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
                    it = st.keySeparator !== void 0 ? st.keySeparator : this.options.keySeparator,
                    ut = st.ignoreJSONStructure !== void 0 ? st.ignoreJSONStructure : this.options.ignoreJSONStructure,
                    lt = [rt, nt];
                at && typeof at != "string" && (lt = lt.concat(at)), at && typeof at == "string" && (lt = lt.concat(it ? at.split(it) : at)), rt.indexOf(".") > -1 && (lt = rt.split("."));
                var bt = getPath(this.data, lt);
                return bt || !ut || typeof at != "string" ? bt : deepFind(this.data && this.data[rt] && this.data[rt][nt], at, it)
            }
        }, {
            key: "addResource",
            value: function(rt, nt, at, st) {
                var it = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
                        silent: !1
                    },
                    ut = this.options.keySeparator;
                ut === void 0 && (ut = ".");
                var lt = [rt, nt];
                at && (lt = lt.concat(ut ? at.split(ut) : at)), rt.indexOf(".") > -1 && (lt = rt.split("."), st = nt, nt = lt[1]), this.addNamespaces(nt), setPath(this.data, lt, st), it.silent || this.emit("added", rt, nt, at, st)
            }
        }, {
            key: "addResources",
            value: function(rt, nt, at) {
                var st = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
                    silent: !1
                };
                for (var it in at)(typeof at[it] == "string" || Object.prototype.toString.apply(at[it]) === "[object Array]") && this.addResource(rt, nt, it, at[it], {
                    silent: !0
                });
                st.silent || this.emit("added", rt, nt, at)
            }
        }, {
            key: "addResourceBundle",
            value: function(rt, nt, at, st, it) {
                var ut = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
                        silent: !1
                    },
                    lt = [rt, nt];
                rt.indexOf(".") > -1 && (lt = rt.split("."), st = at, at = nt, nt = lt[1]), this.addNamespaces(nt);
                var bt = getPath(this.data, lt) || {};
                st ? deepExtend(bt, at, it) : bt = _objectSpread$5(_objectSpread$5({}, bt), at), setPath(this.data, lt, bt), ut.silent || this.emit("added", rt, nt, at)
            }
        }, {
            key: "removeResourceBundle",
            value: function(rt, nt) {
                this.hasResourceBundle(rt, nt) && delete this.data[rt][nt], this.removeNamespaces(nt), this.emit("removed", rt, nt)
            }
        }, {
            key: "hasResourceBundle",
            value: function(rt, nt) {
                return this.getResource(rt, nt) !== void 0
            }
        }, {
            key: "getResourceBundle",
            value: function(rt, nt) {
                return nt || (nt = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? _objectSpread$5(_objectSpread$5({}, {}), this.getResource(rt, nt)) : this.getResource(rt, nt)
            }
        }, {
            key: "getDataByLanguage",
            value: function(rt) {
                return this.data[rt]
            }
        }, {
            key: "hasLanguageSomeTranslations",
            value: function(rt) {
                var nt = this.getDataByLanguage(rt),
                    at = nt && Object.keys(nt) || [];
                return !!at.find(function(st) {
                    return nt[st] && Object.keys(nt[st]).length > 0
                })
            }
        }, {
            key: "toJSON",
            value: function() {
                return this.data
            }
        }]), et
    }(EventEmitter),
    postProcessor = {
        processors: {},
        addPostProcessor: function _(_e) {
            this.processors[_e.name] = _e
        },
        handle: function _(_e, et, tt, rt, nt) {
            var at = this;
            return _e.forEach(function(st) {
                at.processors[st] && (et = at.processors[st].process(et, tt, rt, nt))
            }), et
        }
    };

function ownKeys$4(_, _e) {
    var et = Object.keys(_);
    if (Object.getOwnPropertySymbols) {
        var tt = Object.getOwnPropertySymbols(_);
        _e && (tt = tt.filter(function(rt) {
            return Object.getOwnPropertyDescriptor(_, rt).enumerable
        })), et.push.apply(et, tt)
    }
    return et
}

function _objectSpread$4(_) {
    for (var _e = 1; _e < arguments.length; _e++) {
        var et = arguments[_e] != null ? arguments[_e] : {};
        _e % 2 ? ownKeys$4(Object(et), !0).forEach(function(tt) {
            _defineProperty$1(_, tt, et[tt])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(et)) : ownKeys$4(Object(et)).forEach(function(tt) {
            Object.defineProperty(_, tt, Object.getOwnPropertyDescriptor(et, tt))
        })
    }
    return _
}

function _createSuper$2(_) {
    var _e = _isNativeReflectConstruct$2();
    return function() {
        var tt = _getPrototypeOf(_),
            rt;
        if (_e) {
            var nt = _getPrototypeOf(this).constructor;
            rt = Reflect.construct(tt, arguments, nt)
        } else rt = tt.apply(this, arguments);
        return _possibleConstructorReturn(this, rt)
    }
}

function _isNativeReflectConstruct$2() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
    } catch {
        return !1
    }
}
var checkedLoadedFor = {},
    Translator = function(_) {
        _inherits(et, _);
        var _e = _createSuper$2(et);

        function et(tt) {
            var rt, nt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return _classCallCheck$1(this, et), rt = _e.call(this), isIE10 && EventEmitter.call(_assertThisInitialized(rt)), copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], tt, _assertThisInitialized(rt)), rt.options = nt, rt.options.keySeparator === void 0 && (rt.options.keySeparator = "."), rt.logger = baseLogger.create("translator"), rt
        }
        return _createClass$1(et, [{
            key: "changeLanguage",
            value: function(rt) {
                rt && (this.language = rt)
            }
        }, {
            key: "exists",
            value: function(rt) {
                var nt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                    interpolation: {}
                };
                if (rt == null) return !1;
                var at = this.resolve(rt, nt);
                return at && at.res !== void 0
            }
        }, {
            key: "extractFromKey",
            value: function(rt, nt) {
                var at = nt.nsSeparator !== void 0 ? nt.nsSeparator : this.options.nsSeparator;
                at === void 0 && (at = ":");
                var st = nt.keySeparator !== void 0 ? nt.keySeparator : this.options.keySeparator,
                    it = nt.ns || this.options.defaultNS || [],
                    ut = at && rt.indexOf(at) > -1,
                    lt = !this.options.userDefinedKeySeparator && !nt.keySeparator && !this.options.userDefinedNsSeparator && !nt.nsSeparator && !looksLikeObjectPath(rt, at, st);
                if (ut && !lt) {
                    var bt = rt.match(this.interpolator.nestingRegexp);
                    if (bt && bt.length > 0) return {
                        key: rt,
                        namespaces: it
                    };
                    var pt = rt.split(at);
                    (at !== st || at === st && this.options.ns.indexOf(pt[0]) > -1) && (it = pt.shift()), rt = pt.join(st)
                }
                return typeof it == "string" && (it = [it]), {
                    key: rt,
                    namespaces: it
                }
            }
        }, {
            key: "translate",
            value: function(rt, nt, at) {
                var st = this;
                if (_typeof$3(nt) !== "object" && this.options.overloadTranslationOptionHandler && (nt = this.options.overloadTranslationOptionHandler(arguments)), nt || (nt = {}), rt == null) return "";
                Array.isArray(rt) || (rt = [String(rt)]);
                var it = nt.returnDetails !== void 0 ? nt.returnDetails : this.options.returnDetails,
                    ut = nt.keySeparator !== void 0 ? nt.keySeparator : this.options.keySeparator,
                    lt = this.extractFromKey(rt[rt.length - 1], nt),
                    bt = lt.key,
                    pt = lt.namespaces,
                    It = pt[pt.length - 1],
                    At = nt.lng || this.language,
                    Ct = nt.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
                if (At && At.toLowerCase() === "cimode") {
                    if (Ct) {
                        var ht = nt.nsSeparator || this.options.nsSeparator;
                        return it ? (ot.res = "".concat(It).concat(ht).concat(bt), ot) : "".concat(It).concat(ht).concat(bt)
                    }
                    return it ? (ot.res = bt, ot) : bt
                }
                var ot = this.resolve(rt, nt),
                    ct = ot && ot.res,
                    Et = ot && ot.usedKey || bt,
                    Dt = ot && ot.exactUsedKey || bt,
                    Pt = Object.prototype.toString.apply(ct),
                    gt = ["[object Number]", "[object Function]", "[object RegExp]"],
                    ft = nt.joinArrays !== void 0 ? nt.joinArrays : this.options.joinArrays,
                    dt = !this.i18nFormat || this.i18nFormat.handleAsObject,
                    St = typeof ct != "string" && typeof ct != "boolean" && typeof ct != "number";
                if (dt && ct && St && gt.indexOf(Pt) < 0 && !(typeof ft == "string" && Pt === "[object Array]")) {
                    if (!nt.returnObjects && !this.options.returnObjects) {
                        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
                        var _t = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(Et, ct, _objectSpread$4(_objectSpread$4({}, nt), {}, {
                            ns: pt
                        })) : "key '".concat(bt, " (").concat(this.language, ")' returned an object instead of string.");
                        return it ? (ot.res = _t, ot) : _t
                    }
                    if (ut) {
                        var vt = Pt === "[object Array]",
                            mt = vt ? [] : {},
                            xt = vt ? Dt : Et;
                        for (var yt in ct)
                            if (Object.prototype.hasOwnProperty.call(ct, yt)) {
                                var Tt = "".concat(xt).concat(ut).concat(yt);
                                mt[yt] = this.translate(Tt, _objectSpread$4(_objectSpread$4({}, nt), {
                                    joinArrays: !1,
                                    ns: pt
                                })), mt[yt] === Tt && (mt[yt] = ct[yt])
                            } ct = mt
                    }
                } else if (dt && typeof ft == "string" && Pt === "[object Array]") ct = ct.join(ft), ct && (ct = this.extendTranslation(ct, rt, nt, at));
                else {
                    var Ft = !1,
                        wt = !1,
                        kt = nt.count !== void 0 && typeof nt.count != "string",
                        Ot = et.hasDefaultValue(nt),
                        Rt = kt ? this.pluralResolver.getSuffix(At, nt.count, nt) : "",
                        Lt = nt["defaultValue".concat(Rt)] || nt.defaultValue;
                    !this.isValidLookup(ct) && Ot && (Ft = !0, ct = Lt), this.isValidLookup(ct) || (wt = !0, ct = bt);
                    var Bt = nt.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey,
                        Nt = Bt && wt ? void 0 : ct,
                        $t = Ot && Lt !== ct && this.options.updateMissing;
                    if (wt || Ft || $t) {
                        if (this.logger.log($t ? "updateKey" : "missingKey", At, It, bt, $t ? Lt : ct), ut) {
                            var jt = this.resolve(bt, _objectSpread$4(_objectSpread$4({}, nt), {}, {
                                keySeparator: !1
                            }));
                            jt && jt.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")
                        }
                        var Ut = [],
                            Ht = this.languageUtils.getFallbackCodes(this.options.fallbackLng, nt.lng || this.language);
                        if (this.options.saveMissingTo === "fallback" && Ht && Ht[0])
                            for (var Wt = 0; Wt < Ht.length; Wt++) Ut.push(Ht[Wt]);
                        else this.options.saveMissingTo === "all" ? Ut = this.languageUtils.toResolveHierarchy(nt.lng || this.language) : Ut.push(nt.lng || this.language);
                        var Kt = function(Vt, zt, Xt) {
                            var Yt = Ot && Xt !== ct ? Xt : Nt;
                            st.options.missingKeyHandler ? st.options.missingKeyHandler(Vt, It, zt, Yt, $t, nt) : st.backendConnector && st.backendConnector.saveMissing && st.backendConnector.saveMissing(Vt, It, zt, Yt, $t, nt), st.emit("missingKey", Vt, It, zt, ct)
                        };
                        this.options.saveMissing && (this.options.saveMissingPlurals && kt ? Ut.forEach(function(Gt) {
                            st.pluralResolver.getSuffixes(Gt, nt).forEach(function(Vt) {
                                Kt([Gt], bt + Vt, nt["defaultValue".concat(Vt)] || Lt)
                            })
                        }) : Kt(Ut, bt, Lt))
                    }
                    ct = this.extendTranslation(ct, rt, nt, ot, at), wt && ct === bt && this.options.appendNamespaceToMissingKey && (ct = "".concat(It, ":").concat(bt)), (wt || Ft) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? ct = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(It, ":").concat(bt) : bt, Ft ? ct : void 0) : ct = this.options.parseMissingKeyHandler(ct))
                }
                return it ? (ot.res = ct, ot) : ct
            }
        }, {
            key: "extendTranslation",
            value: function(rt, nt, at, st, it) {
                var ut = this;
                if (this.i18nFormat && this.i18nFormat.parse) rt = this.i18nFormat.parse(rt, _objectSpread$4(_objectSpread$4({}, this.options.interpolation.defaultVariables), at), st.usedLng, st.usedNS, st.usedKey, {
                    resolved: st
                });
                else if (!at.skipInterpolation) {
                    at.interpolation && this.interpolator.init(_objectSpread$4(_objectSpread$4({}, at), {
                        interpolation: _objectSpread$4(_objectSpread$4({}, this.options.interpolation), at.interpolation)
                    }));
                    var lt = typeof rt == "string" && (at && at.interpolation && at.interpolation.skipOnVariables !== void 0 ? at.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables),
                        bt;
                    if (lt) {
                        var pt = rt.match(this.interpolator.nestingRegexp);
                        bt = pt && pt.length
                    }
                    var It = at.replace && typeof at.replace != "string" ? at.replace : at;
                    if (this.options.interpolation.defaultVariables && (It = _objectSpread$4(_objectSpread$4({}, this.options.interpolation.defaultVariables), It)), rt = this.interpolator.interpolate(rt, It, at.lng || this.language, at), lt) {
                        var At = rt.match(this.interpolator.nestingRegexp),
                            Ct = At && At.length;
                        bt < Ct && (at.nest = !1)
                    }
                    at.nest !== !1 && (rt = this.interpolator.nest(rt, function() {
                        for (var ct = arguments.length, Et = new Array(ct), Dt = 0; Dt < ct; Dt++) Et[Dt] = arguments[Dt];
                        return it && it[0] === Et[0] && !at.context ? (ut.logger.warn("It seems you are nesting recursively key: ".concat(Et[0], " in key: ").concat(nt[0])), null) : ut.translate.apply(ut, Et.concat([nt]))
                    }, at)), at.interpolation && this.interpolator.reset()
                }
                var ht = at.postProcess || this.options.postProcess,
                    ot = typeof ht == "string" ? [ht] : ht;
                return rt != null && ot && ot.length && at.applyPostProcessor !== !1 && (rt = postProcessor.handle(ot, rt, nt, this.options && this.options.postProcessPassResolved ? _objectSpread$4({
                    i18nResolved: st
                }, at) : at, this)), rt
            }
        }, {
            key: "resolve",
            value: function(rt) {
                var nt = this,
                    at = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                    st, it, ut, lt, bt;
                return typeof rt == "string" && (rt = [rt]), rt.forEach(function(pt) {
                    if (!nt.isValidLookup(st)) {
                        var It = nt.extractFromKey(pt, at),
                            At = It.key;
                        it = At;
                        var Ct = It.namespaces;
                        nt.options.fallbackNS && (Ct = Ct.concat(nt.options.fallbackNS));
                        var ht = at.count !== void 0 && typeof at.count != "string",
                            ot = ht && !at.ordinal && at.count === 0 && nt.pluralResolver.shouldUseIntlApi(),
                            ct = at.context !== void 0 && (typeof at.context == "string" || typeof at.context == "number") && at.context !== "",
                            Et = at.lngs ? at.lngs : nt.languageUtils.toResolveHierarchy(at.lng || nt.language, at.fallbackLng);
                        Ct.forEach(function(Dt) {
                            nt.isValidLookup(st) || (bt = Dt, !checkedLoadedFor["".concat(Et[0], "-").concat(Dt)] && nt.utils && nt.utils.hasLoadedNamespace && !nt.utils.hasLoadedNamespace(bt) && (checkedLoadedFor["".concat(Et[0], "-").concat(Dt)] = !0, nt.logger.warn('key "'.concat(it, '" for languages "').concat(Et.join(", "), `" won't get resolved as namespace "`).concat(bt, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), Et.forEach(function(Pt) {
                                if (!nt.isValidLookup(st)) {
                                    lt = Pt;
                                    var gt = [At];
                                    if (nt.i18nFormat && nt.i18nFormat.addLookupKeys) nt.i18nFormat.addLookupKeys(gt, At, Pt, Dt, at);
                                    else {
                                        var ft;
                                        ht && (ft = nt.pluralResolver.getSuffix(Pt, at.count, at));
                                        var dt = "".concat(nt.options.pluralSeparator, "zero");
                                        if (ht && (gt.push(At + ft), ot && gt.push(At + dt)), ct) {
                                            var St = "".concat(At).concat(nt.options.contextSeparator).concat(at.context);
                                            gt.push(St), ht && (gt.push(St + ft), ot && gt.push(St + dt))
                                        }
                                    }
                                    for (var _t; _t = gt.pop();) nt.isValidLookup(st) || (ut = _t, st = nt.getResource(Pt, Dt, _t, at))
                                }
                            }))
                        })
                    }
                }), {
                    res: st,
                    usedKey: it,
                    exactUsedKey: ut,
                    usedLng: lt,
                    usedNS: bt
                }
            }
        }, {
            key: "isValidLookup",
            value: function(rt) {
                return rt !== void 0 && !(!this.options.returnNull && rt === null) && !(!this.options.returnEmptyString && rt === "")
            }
        }, {
            key: "getResource",
            value: function(rt, nt, at) {
                var st = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
                return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(rt, nt, at, st) : this.resourceStore.getResource(rt, nt, at, st)
            }
        }], [{
            key: "hasDefaultValue",
            value: function(rt) {
                var nt = "defaultValue";
                for (var at in rt)
                    if (Object.prototype.hasOwnProperty.call(rt, at) && nt === at.substring(0, nt.length) && rt[at] !== void 0) return !0;
                return !1
            }
        }]), et
    }(EventEmitter);

function capitalize(_) {
    return _.charAt(0).toUpperCase() + _.slice(1)
}
var LanguageUtil = function() {
        function _(_e) {
            _classCallCheck$1(this, _), this.options = _e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = baseLogger.create("languageUtils")
        }
        return _createClass$1(_, [{
            key: "getScriptPartFromCode",
            value: function(et) {
                if (!et || et.indexOf("-") < 0) return null;
                var tt = et.split("-");
                return tt.length === 2 || (tt.pop(), tt[tt.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(tt.join("-"))
            }
        }, {
            key: "getLanguagePartFromCode",
            value: function(et) {
                if (!et || et.indexOf("-") < 0) return et;
                var tt = et.split("-");
                return this.formatLanguageCode(tt[0])
            }
        }, {
            key: "formatLanguageCode",
            value: function(et) {
                if (typeof et == "string" && et.indexOf("-") > -1) {
                    var tt = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"],
                        rt = et.split("-");
                    return this.options.lowerCaseLng ? rt = rt.map(function(nt) {
                        return nt.toLowerCase()
                    }) : rt.length === 2 ? (rt[0] = rt[0].toLowerCase(), rt[1] = rt[1].toUpperCase(), tt.indexOf(rt[1].toLowerCase()) > -1 && (rt[1] = capitalize(rt[1].toLowerCase()))) : rt.length === 3 && (rt[0] = rt[0].toLowerCase(), rt[1].length === 2 && (rt[1] = rt[1].toUpperCase()), rt[0] !== "sgn" && rt[2].length === 2 && (rt[2] = rt[2].toUpperCase()), tt.indexOf(rt[1].toLowerCase()) > -1 && (rt[1] = capitalize(rt[1].toLowerCase())), tt.indexOf(rt[2].toLowerCase()) > -1 && (rt[2] = capitalize(rt[2].toLowerCase()))), rt.join("-")
                }
                return this.options.cleanCode || this.options.lowerCaseLng ? et.toLowerCase() : et
            }
        }, {
            key: "isSupportedCode",
            value: function(et) {
                return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (et = this.getLanguagePartFromCode(et)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(et) > -1
            }
        }, {
            key: "getBestMatchFromCodes",
            value: function(et) {
                var tt = this;
                if (!et) return null;
                var rt;
                return et.forEach(function(nt) {
                    if (!rt) {
                        var at = tt.formatLanguageCode(nt);
                        (!tt.options.supportedLngs || tt.isSupportedCode(at)) && (rt = at)
                    }
                }), !rt && this.options.supportedLngs && et.forEach(function(nt) {
                    if (!rt) {
                        var at = tt.getLanguagePartFromCode(nt);
                        if (tt.isSupportedCode(at)) return rt = at;
                        rt = tt.options.supportedLngs.find(function(st) {
                            if (st.indexOf(at) === 0) return st
                        })
                    }
                }), rt || (rt = this.getFallbackCodes(this.options.fallbackLng)[0]), rt
            }
        }, {
            key: "getFallbackCodes",
            value: function(et, tt) {
                if (!et) return [];
                if (typeof et == "function" && (et = et(tt)), typeof et == "string" && (et = [et]), Object.prototype.toString.apply(et) === "[object Array]") return et;
                if (!tt) return et.default || [];
                var rt = et[tt];
                return rt || (rt = et[this.getScriptPartFromCode(tt)]), rt || (rt = et[this.formatLanguageCode(tt)]), rt || (rt = et[this.getLanguagePartFromCode(tt)]), rt || (rt = et.default), rt || []
            }
        }, {
            key: "toResolveHierarchy",
            value: function(et, tt) {
                var rt = this,
                    nt = this.getFallbackCodes(tt || this.options.fallbackLng || [], et),
                    at = [],
                    st = function(ut) {
                        !ut || (rt.isSupportedCode(ut) ? at.push(ut) : rt.logger.warn("rejecting language code not found in supportedLngs: ".concat(ut)))
                    };
                return typeof et == "string" && et.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && st(this.formatLanguageCode(et)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && st(this.getScriptPartFromCode(et)), this.options.load !== "currentOnly" && st(this.getLanguagePartFromCode(et))) : typeof et == "string" && st(this.formatLanguageCode(et)), nt.forEach(function(it) {
                    at.indexOf(it) < 0 && st(rt.formatLanguageCode(it))
                }), at
            }
        }]), _
    }(),
    sets = [{
        lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
        nr: [1, 2],
        fc: 1
    }, {
        lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
        nr: [1, 2],
        fc: 2
    }, {
        lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
        nr: [1],
        fc: 3
    }, {
        lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
        nr: [1, 2, 5],
        fc: 4
    }, {
        lngs: ["ar"],
        nr: [0, 1, 2, 3, 11, 100],
        fc: 5
    }, {
        lngs: ["cs", "sk"],
        nr: [1, 2, 5],
        fc: 6
    }, {
        lngs: ["csb", "pl"],
        nr: [1, 2, 5],
        fc: 7
    }, {
        lngs: ["cy"],
        nr: [1, 2, 3, 8],
        fc: 8
    }, {
        lngs: ["fr"],
        nr: [1, 2],
        fc: 9
    }, {
        lngs: ["ga"],
        nr: [1, 2, 3, 7, 11],
        fc: 10
    }, {
        lngs: ["gd"],
        nr: [1, 2, 3, 20],
        fc: 11
    }, {
        lngs: ["is"],
        nr: [1, 2],
        fc: 12
    }, {
        lngs: ["jv"],
        nr: [0, 1],
        fc: 13
    }, {
        lngs: ["kw"],
        nr: [1, 2, 3, 4],
        fc: 14
    }, {
        lngs: ["lt"],
        nr: [1, 2, 10],
        fc: 15
    }, {
        lngs: ["lv"],
        nr: [1, 2, 0],
        fc: 16
    }, {
        lngs: ["mk"],
        nr: [1, 2],
        fc: 17
    }, {
        lngs: ["mnk"],
        nr: [0, 1, 2],
        fc: 18
    }, {
        lngs: ["mt"],
        nr: [1, 2, 11, 20],
        fc: 19
    }, {
        lngs: ["or"],
        nr: [2, 1],
        fc: 2
    }, {
        lngs: ["ro"],
        nr: [1, 2, 20],
        fc: 20
    }, {
        lngs: ["sl"],
        nr: [5, 1, 2, 3],
        fc: 21
    }, {
        lngs: ["he", "iw"],
        nr: [1, 2, 20, 21],
        fc: 22
    }],
    _rulesPluralsTypes = {
        1: function _(_e) {
            return Number(_e > 1)
        },
        2: function _(_e) {
            return Number(_e != 1)
        },
        3: function _(_e) {
            return 0
        },
        4: function _(_e) {
            return Number(_e % 10 == 1 && _e % 100 != 11 ? 0 : _e % 10 >= 2 && _e % 10 <= 4 && (_e % 100 < 10 || _e % 100 >= 20) ? 1 : 2)
        },
        5: function _(_e) {
            return Number(_e == 0 ? 0 : _e == 1 ? 1 : _e == 2 ? 2 : _e % 100 >= 3 && _e % 100 <= 10 ? 3 : _e % 100 >= 11 ? 4 : 5)
        },
        6: function _(_e) {
            return Number(_e == 1 ? 0 : _e >= 2 && _e <= 4 ? 1 : 2)
        },
        7: function _(_e) {
            return Number(_e == 1 ? 0 : _e % 10 >= 2 && _e % 10 <= 4 && (_e % 100 < 10 || _e % 100 >= 20) ? 1 : 2)
        },
        8: function _(_e) {
            return Number(_e == 1 ? 0 : _e == 2 ? 1 : _e != 8 && _e != 11 ? 2 : 3)
        },
        9: function _(_e) {
            return Number(_e >= 2)
        },
        10: function _(_e) {
            return Number(_e == 1 ? 0 : _e == 2 ? 1 : _e < 7 ? 2 : _e < 11 ? 3 : 4)
        },
        11: function _(_e) {
            return Number(_e == 1 || _e == 11 ? 0 : _e == 2 || _e == 12 ? 1 : _e > 2 && _e < 20 ? 2 : 3)
        },
        12: function _(_e) {
            return Number(_e % 10 != 1 || _e % 100 == 11)
        },
        13: function _(_e) {
            return Number(_e !== 0)
        },
        14: function _(_e) {
            return Number(_e == 1 ? 0 : _e == 2 ? 1 : _e == 3 ? 2 : 3)
        },
        15: function _(_e) {
            return Number(_e % 10 == 1 && _e % 100 != 11 ? 0 : _e % 10 >= 2 && (_e % 100 < 10 || _e % 100 >= 20) ? 1 : 2)
        },
        16: function _(_e) {
            return Number(_e % 10 == 1 && _e % 100 != 11 ? 0 : _e !== 0 ? 1 : 2)
        },
        17: function _(_e) {
            return Number(_e == 1 || _e % 10 == 1 && _e % 100 != 11 ? 0 : 1)
        },
        18: function _(_e) {
            return Number(_e == 0 ? 0 : _e == 1 ? 1 : 2)
        },
        19: function _(_e) {
            return Number(_e == 1 ? 0 : _e == 0 || _e % 100 > 1 && _e % 100 < 11 ? 1 : _e % 100 > 10 && _e % 100 < 20 ? 2 : 3)
        },
        20: function _(_e) {
            return Number(_e == 1 ? 0 : _e == 0 || _e % 100 > 0 && _e % 100 < 20 ? 1 : 2)
        },
        21: function _(_e) {
            return Number(_e % 100 == 1 ? 1 : _e % 100 == 2 ? 2 : _e % 100 == 3 || _e % 100 == 4 ? 3 : 0)
        },
        22: function _(_e) {
            return Number(_e == 1 ? 0 : _e == 2 ? 1 : (_e < 0 || _e > 10) && _e % 10 == 0 ? 2 : 3)
        }
    },
    deprecatedJsonVersions = ["v1", "v2", "v3"],
    suffixesOrder = {
        zero: 0,
        one: 1,
        two: 2,
        few: 3,
        many: 4,
        other: 5
    };

function createRules() {
    var _ = {};
    return sets.forEach(function(_e) {
        _e.lngs.forEach(function(et) {
            _[et] = {
                numbers: _e.nr,
                plurals: _rulesPluralsTypes[_e.fc]
            }
        })
    }), _
}
var PluralResolver = function() {
    function _(_e) {
        var et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck$1(this, _), this.languageUtils = _e, this.options = et, this.logger = baseLogger.create("pluralResolver"), (!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = createRules()
    }
    return _createClass$1(_, [{
        key: "addRule",
        value: function(et, tt) {
            this.rules[et] = tt
        }
    }, {
        key: "getRule",
        value: function(et) {
            var tt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (this.shouldUseIntlApi()) try {
                return new Intl.PluralRules(et, {
                    type: tt.ordinal ? "ordinal" : "cardinal"
                })
            } catch {
                return
            }
            return this.rules[et] || this.rules[this.languageUtils.getLanguagePartFromCode(et)]
        }
    }, {
        key: "needsPlural",
        value: function(et) {
            var tt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                rt = this.getRule(et, tt);
            return this.shouldUseIntlApi() ? rt && rt.resolvedOptions().pluralCategories.length > 1 : rt && rt.numbers.length > 1
        }
    }, {
        key: "getPluralFormsOfKey",
        value: function(et, tt) {
            var rt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return this.getSuffixes(et, rt).map(function(nt) {
                return "".concat(tt).concat(nt)
            })
        }
    }, {
        key: "getSuffixes",
        value: function(et) {
            var tt = this,
                rt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                nt = this.getRule(et, rt);
            return nt ? this.shouldUseIntlApi() ? nt.resolvedOptions().pluralCategories.sort(function(at, st) {
                return suffixesOrder[at] - suffixesOrder[st]
            }).map(function(at) {
                return "".concat(tt.options.prepend).concat(at)
            }) : nt.numbers.map(function(at) {
                return tt.getSuffix(et, at, rt)
            }) : []
        }
    }, {
        key: "getSuffix",
        value: function(et, tt) {
            var rt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
                nt = this.getRule(et, rt);
            return nt ? this.shouldUseIntlApi() ? "".concat(this.options.prepend).concat(nt.select(tt)) : this.getSuffixRetroCompatible(nt, tt) : (this.logger.warn("no plural rule found for: ".concat(et)), "")
        }
    }, {
        key: "getSuffixRetroCompatible",
        value: function(et, tt) {
            var rt = this,
                nt = et.noAbs ? et.plurals(tt) : et.plurals(Math.abs(tt)),
                at = et.numbers[nt];
            this.options.simplifyPluralSuffix && et.numbers.length === 2 && et.numbers[0] === 1 && (at === 2 ? at = "plural" : at === 1 && (at = ""));
            var st = function() {
                return rt.options.prepend && at.toString() ? rt.options.prepend + at.toString() : at.toString()
            };
            return this.options.compatibilityJSON === "v1" ? at === 1 ? "" : typeof at == "number" ? "_plural_".concat(at.toString()) : st() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && et.numbers.length === 2 && et.numbers[0] === 1 ? st() : this.options.prepend && nt.toString() ? this.options.prepend + nt.toString() : nt.toString()
        }
    }, {
        key: "shouldUseIntlApi",
        value: function() {
            return !deprecatedJsonVersions.includes(this.options.compatibilityJSON)
        }
    }]), _
}();

function ownKeys$3(_, _e) {
    var et = Object.keys(_);
    if (Object.getOwnPropertySymbols) {
        var tt = Object.getOwnPropertySymbols(_);
        _e && (tt = tt.filter(function(rt) {
            return Object.getOwnPropertyDescriptor(_, rt).enumerable
        })), et.push.apply(et, tt)
    }
    return et
}

function _objectSpread$3(_) {
    for (var _e = 1; _e < arguments.length; _e++) {
        var et = arguments[_e] != null ? arguments[_e] : {};
        _e % 2 ? ownKeys$3(Object(et), !0).forEach(function(tt) {
            _defineProperty$1(_, tt, et[tt])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(et)) : ownKeys$3(Object(et)).forEach(function(tt) {
            Object.defineProperty(_, tt, Object.getOwnPropertyDescriptor(et, tt))
        })
    }
    return _
}
var Interpolator = function() {
    function _() {
        var _e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck$1(this, _), this.logger = baseLogger.create("interpolator"), this.options = _e, this.format = _e.interpolation && _e.interpolation.format || function(et) {
            return et
        }, this.init(_e)
    }
    return _createClass$1(_, [{
        key: "init",
        value: function() {
            var et = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            et.interpolation || (et.interpolation = {
                escapeValue: !0
            });
            var tt = et.interpolation;
            this.escape = tt.escape !== void 0 ? tt.escape : escape$1, this.escapeValue = tt.escapeValue !== void 0 ? tt.escapeValue : !0, this.useRawValueToEscape = tt.useRawValueToEscape !== void 0 ? tt.useRawValueToEscape : !1, this.prefix = tt.prefix ? regexEscape(tt.prefix) : tt.prefixEscaped || "{{", this.suffix = tt.suffix ? regexEscape(tt.suffix) : tt.suffixEscaped || "}}", this.formatSeparator = tt.formatSeparator ? tt.formatSeparator : tt.formatSeparator || ",", this.unescapePrefix = tt.unescapeSuffix ? "" : tt.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : tt.unescapeSuffix || "", this.nestingPrefix = tt.nestingPrefix ? regexEscape(tt.nestingPrefix) : tt.nestingPrefixEscaped || regexEscape("$t("), this.nestingSuffix = tt.nestingSuffix ? regexEscape(tt.nestingSuffix) : tt.nestingSuffixEscaped || regexEscape(")"), this.nestingOptionsSeparator = tt.nestingOptionsSeparator ? tt.nestingOptionsSeparator : tt.nestingOptionsSeparator || ",", this.maxReplaces = tt.maxReplaces ? tt.maxReplaces : 1e3, this.alwaysFormat = tt.alwaysFormat !== void 0 ? tt.alwaysFormat : !1, this.resetRegExp()
        }
    }, {
        key: "reset",
        value: function() {
            this.options && this.init(this.options)
        }
    }, {
        key: "resetRegExp",
        value: function() {
            var et = "".concat(this.prefix, "(.+?)").concat(this.suffix);
            this.regexp = new RegExp(et, "g");
            var tt = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
            this.regexpUnescape = new RegExp(tt, "g");
            var rt = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
            this.nestingRegexp = new RegExp(rt, "g")
        }
    }, {
        key: "interpolate",
        value: function(et, tt, rt, nt) {
            var at = this,
                st, it, ut, lt = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};

            function bt(ht) {
                return ht.replace(/\$/g, "$$$$")
            }
            var pt = function(ot) {
                if (ot.indexOf(at.formatSeparator) < 0) {
                    var ct = getPathWithDefaults(tt, lt, ot);
                    return at.alwaysFormat ? at.format(ct, void 0, rt, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, nt), tt), {}, {
                        interpolationkey: ot
                    })) : ct
                }
                var Et = ot.split(at.formatSeparator),
                    Dt = Et.shift().trim(),
                    Pt = Et.join(at.formatSeparator).trim();
                return at.format(getPathWithDefaults(tt, lt, Dt), Pt, rt, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, nt), tt), {}, {
                    interpolationkey: Dt
                }))
            };
            this.resetRegExp();
            var It = nt && nt.missingInterpolationHandler || this.options.missingInterpolationHandler,
                At = nt && nt.interpolation && nt.interpolation.skipOnVariables !== void 0 ? nt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables,
                Ct = [{
                    regex: this.regexpUnescape,
                    safeValue: function(ot) {
                        return bt(ot)
                    }
                }, {
                    regex: this.regexp,
                    safeValue: function(ot) {
                        return at.escapeValue ? bt(at.escape(ot)) : bt(ot)
                    }
                }];
            return Ct.forEach(function(ht) {
                for (ut = 0; st = ht.regex.exec(et);) {
                    var ot = st[1].trim();
                    if (it = pt(ot), it === void 0)
                        if (typeof It == "function") {
                            var ct = It(et, st, nt);
                            it = typeof ct == "string" ? ct : ""
                        } else if (nt && nt.hasOwnProperty(ot)) it = "";
                    else if (At) {
                        it = st[0];
                        continue
                    } else at.logger.warn("missed to pass in variable ".concat(ot, " for interpolating ").concat(et)), it = "";
                    else typeof it != "string" && !at.useRawValueToEscape && (it = makeString(it));
                    var Et = ht.safeValue(it);
                    if (et = et.replace(st[0], Et), At ? (ht.regex.lastIndex += it.length, ht.regex.lastIndex -= st[0].length) : ht.regex.lastIndex = 0, ut++, ut >= at.maxReplaces) break
                }
            }), et
        }
    }, {
        key: "nest",
        value: function(et, tt) {
            var rt = this,
                nt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
                at, st, it;

            function ut(It, At) {
                var Ct = this.nestingOptionsSeparator;
                if (It.indexOf(Ct) < 0) return It;
                var ht = It.split(new RegExp("".concat(Ct, "[ ]*{"))),
                    ot = "{".concat(ht[1]);
                It = ht[0], ot = this.interpolate(ot, it);
                var ct = ot.match(/'/g),
                    Et = ot.match(/"/g);
                (ct && ct.length % 2 === 0 && !Et || Et.length % 2 !== 0) && (ot = ot.replace(/'/g, '"'));
                try {
                    it = JSON.parse(ot), At && (it = _objectSpread$3(_objectSpread$3({}, At), it))
                } catch (Dt) {
                    return this.logger.warn("failed parsing options string in nesting for key ".concat(It), Dt), "".concat(It).concat(Ct).concat(ot)
                }
                return delete it.defaultValue, It
            }
            for (; at = this.nestingRegexp.exec(et);) {
                var lt = [];
                it = _objectSpread$3({}, nt), it.applyPostProcessor = !1, delete it.defaultValue;
                var bt = !1;
                if (at[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(at[1])) {
                    var pt = at[1].split(this.formatSeparator).map(function(It) {
                        return It.trim()
                    });
                    at[1] = pt.shift(), lt = pt, bt = !0
                }
                if (st = tt(ut.call(this, at[1].trim(), it), it), st && at[0] === et && typeof st != "string") return st;
                typeof st != "string" && (st = makeString(st)), st || (this.logger.warn("missed to resolve ".concat(at[1], " for nesting ").concat(et)), st = ""), bt && (st = lt.reduce(function(It, At) {
                    return rt.format(It, At, nt.lng, _objectSpread$3(_objectSpread$3({}, nt), {}, {
                        interpolationkey: at[1].trim()
                    }))
                }, st.trim())), et = et.replace(at[0], st), this.regexp.lastIndex = 0
            }
            return et
        }
    }]), _
}();

function ownKeys$2(_, _e) {
    var et = Object.keys(_);
    if (Object.getOwnPropertySymbols) {
        var tt = Object.getOwnPropertySymbols(_);
        _e && (tt = tt.filter(function(rt) {
            return Object.getOwnPropertyDescriptor(_, rt).enumerable
        })), et.push.apply(et, tt)
    }
    return et
}

function _objectSpread$2(_) {
    for (var _e = 1; _e < arguments.length; _e++) {
        var et = arguments[_e] != null ? arguments[_e] : {};
        _e % 2 ? ownKeys$2(Object(et), !0).forEach(function(tt) {
            _defineProperty$1(_, tt, et[tt])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(et)) : ownKeys$2(Object(et)).forEach(function(tt) {
            Object.defineProperty(_, tt, Object.getOwnPropertyDescriptor(et, tt))
        })
    }
    return _
}

function parseFormatStr(_) {
    var _e = _.toLowerCase().trim(),
        et = {};
    if (_.indexOf("(") > -1) {
        var tt = _.split("(");
        _e = tt[0].toLowerCase().trim();
        var rt = tt[1].substring(0, tt[1].length - 1);
        if (_e === "currency" && rt.indexOf(":") < 0) et.currency || (et.currency = rt.trim());
        else if (_e === "relativetime" && rt.indexOf(":") < 0) et.range || (et.range = rt.trim());
        else {
            var nt = rt.split(";");
            nt.forEach(function(at) {
                if (!!at) {
                    var st = at.split(":"),
                        it = _toArray(st),
                        ut = it[0],
                        lt = it.slice(1),
                        bt = lt.join(":").trim().replace(/^'+|'+$/g, "");
                    et[ut.trim()] || (et[ut.trim()] = bt), bt === "false" && (et[ut.trim()] = !1), bt === "true" && (et[ut.trim()] = !0), isNaN(bt) || (et[ut.trim()] = parseInt(bt, 10))
                }
            })
        }
    }
    return {
        formatName: _e,
        formatOptions: et
    }
}

function createCachedFormatter(_) {
    var _e = {};
    return function(tt, rt, nt) {
        var at = rt + JSON.stringify(nt),
            st = _e[at];
        return st || (st = _(rt, nt), _e[at] = st), st(tt)
    }
}
var Formatter = function() {
    function _() {
        var _e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck$1(this, _), this.logger = baseLogger.create("formatter"), this.options = _e, this.formats = {
            number: createCachedFormatter(function(et, tt) {
                var rt = new Intl.NumberFormat(et, tt);
                return function(nt) {
                    return rt.format(nt)
                }
            }),
            currency: createCachedFormatter(function(et, tt) {
                var rt = new Intl.NumberFormat(et, _objectSpread$2(_objectSpread$2({}, tt), {}, {
                    style: "currency"
                }));
                return function(nt) {
                    return rt.format(nt)
                }
            }),
            datetime: createCachedFormatter(function(et, tt) {
                var rt = new Intl.DateTimeFormat(et, _objectSpread$2({}, tt));
                return function(nt) {
                    return rt.format(nt)
                }
            }),
            relativetime: createCachedFormatter(function(et, tt) {
                var rt = new Intl.RelativeTimeFormat(et, _objectSpread$2({}, tt));
                return function(nt) {
                    return rt.format(nt, tt.range || "day")
                }
            }),
            list: createCachedFormatter(function(et, tt) {
                var rt = new Intl.ListFormat(et, _objectSpread$2({}, tt));
                return function(nt) {
                    return rt.format(nt)
                }
            })
        }, this.init(_e)
    }
    return _createClass$1(_, [{
        key: "init",
        value: function(et) {
            var tt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                    interpolation: {}
                },
                rt = tt.interpolation;
            this.formatSeparator = rt.formatSeparator ? rt.formatSeparator : rt.formatSeparator || ","
        }
    }, {
        key: "add",
        value: function(et, tt) {
            this.formats[et.toLowerCase().trim()] = tt
        }
    }, {
        key: "addCached",
        value: function(et, tt) {
            this.formats[et.toLowerCase().trim()] = createCachedFormatter(tt)
        }
    }, {
        key: "format",
        value: function(et, tt, rt, nt) {
            var at = this,
                st = tt.split(this.formatSeparator),
                it = st.reduce(function(ut, lt) {
                    var bt = parseFormatStr(lt),
                        pt = bt.formatName,
                        It = bt.formatOptions;
                    if (at.formats[pt]) {
                        var At = ut;
                        try {
                            var Ct = nt && nt.formatParams && nt.formatParams[nt.interpolationkey] || {},
                                ht = Ct.locale || Ct.lng || nt.locale || nt.lng || rt;
                            At = at.formats[pt](ut, ht, _objectSpread$2(_objectSpread$2(_objectSpread$2({}, It), nt), Ct))
                        } catch (ot) {
                            at.logger.warn(ot)
                        }
                        return At
                    } else at.logger.warn("there was no format function for ".concat(pt));
                    return ut
                }, et);
            return it
        }
    }]), _
}();

function ownKeys$1(_, _e) {
    var et = Object.keys(_);
    if (Object.getOwnPropertySymbols) {
        var tt = Object.getOwnPropertySymbols(_);
        _e && (tt = tt.filter(function(rt) {
            return Object.getOwnPropertyDescriptor(_, rt).enumerable
        })), et.push.apply(et, tt)
    }
    return et
}

function _objectSpread$1(_) {
    for (var _e = 1; _e < arguments.length; _e++) {
        var et = arguments[_e] != null ? arguments[_e] : {};
        _e % 2 ? ownKeys$1(Object(et), !0).forEach(function(tt) {
            _defineProperty$1(_, tt, et[tt])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(et)) : ownKeys$1(Object(et)).forEach(function(tt) {
            Object.defineProperty(_, tt, Object.getOwnPropertyDescriptor(et, tt))
        })
    }
    return _
}

function _createSuper$1(_) {
    var _e = _isNativeReflectConstruct$1();
    return function() {
        var tt = _getPrototypeOf(_),
            rt;
        if (_e) {
            var nt = _getPrototypeOf(this).constructor;
            rt = Reflect.construct(tt, arguments, nt)
        } else rt = tt.apply(this, arguments);
        return _possibleConstructorReturn(this, rt)
    }
}

function _isNativeReflectConstruct$1() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
    } catch {
        return !1
    }
}

function removePending(_, _e) {
    _.pending[_e] !== void 0 && (delete _.pending[_e], _.pendingCount--)
}
var Connector = function(_) {
    _inherits(et, _);
    var _e = _createSuper$1(et);

    function et(tt, rt, nt) {
        var at, st = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        return _classCallCheck$1(this, et), at = _e.call(this), isIE10 && EventEmitter.call(_assertThisInitialized(at)), at.backend = tt, at.store = rt, at.services = nt, at.languageUtils = nt.languageUtils, at.options = st, at.logger = baseLogger.create("backendConnector"), at.waitingReads = [], at.maxParallelReads = st.maxParallelReads || 10, at.readingCalls = 0, at.maxRetries = st.maxRetries >= 0 ? st.maxRetries : 5, at.retryTimeout = st.retryTimeout >= 1 ? st.retryTimeout : 350, at.state = {}, at.queue = [], at.backend && at.backend.init && at.backend.init(nt, st.backend, st), at
    }
    return _createClass$1(et, [{
        key: "queueLoad",
        value: function(rt, nt, at, st) {
            var it = this,
                ut = {},
                lt = {},
                bt = {},
                pt = {};
            return rt.forEach(function(It) {
                var At = !0;
                nt.forEach(function(Ct) {
                    var ht = "".concat(It, "|").concat(Ct);
                    !at.reload && it.store.hasResourceBundle(It, Ct) ? it.state[ht] = 2 : it.state[ht] < 0 || (it.state[ht] === 1 ? lt[ht] === void 0 && (lt[ht] = !0) : (it.state[ht] = 1, At = !1, lt[ht] === void 0 && (lt[ht] = !0), ut[ht] === void 0 && (ut[ht] = !0), pt[Ct] === void 0 && (pt[Ct] = !0)))
                }), At || (bt[It] = !0)
            }), (Object.keys(ut).length || Object.keys(lt).length) && this.queue.push({
                pending: lt,
                pendingCount: Object.keys(lt).length,
                loaded: {},
                errors: [],
                callback: st
            }), {
                toLoad: Object.keys(ut),
                pending: Object.keys(lt),
                toLoadLanguages: Object.keys(bt),
                toLoadNamespaces: Object.keys(pt)
            }
        }
    }, {
        key: "loaded",
        value: function(rt, nt, at) {
            var st = rt.split("|"),
                it = st[0],
                ut = st[1];
            nt && this.emit("failedLoading", it, ut, nt), at && this.store.addResourceBundle(it, ut, at), this.state[rt] = nt ? -1 : 2;
            var lt = {};
            this.queue.forEach(function(bt) {
                pushPath(bt.loaded, [it], ut), removePending(bt, rt), nt && bt.errors.push(nt), bt.pendingCount === 0 && !bt.done && (Object.keys(bt.loaded).forEach(function(pt) {
                    lt[pt] || (lt[pt] = {});
                    var It = bt.loaded[pt];
                    It.length && It.forEach(function(At) {
                        lt[pt][At] === void 0 && (lt[pt][At] = !0)
                    })
                }), bt.done = !0, bt.errors.length ? bt.callback(bt.errors) : bt.callback())
            }), this.emit("loaded", lt), this.queue = this.queue.filter(function(bt) {
                return !bt.done
            })
        }
    }, {
        key: "read",
        value: function(rt, nt, at) {
            var st = this,
                it = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0,
                ut = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout,
                lt = arguments.length > 5 ? arguments[5] : void 0;
            if (!rt.length) return lt(null, {});
            if (this.readingCalls >= this.maxParallelReads) {
                this.waitingReads.push({
                    lng: rt,
                    ns: nt,
                    fcName: at,
                    tried: it,
                    wait: ut,
                    callback: lt
                });
                return
            }
            this.readingCalls++;
            var bt = function(Ct, ht) {
                    if (st.readingCalls--, st.waitingReads.length > 0) {
                        var ot = st.waitingReads.shift();
                        st.read(ot.lng, ot.ns, ot.fcName, ot.tried, ot.wait, ot.callback)
                    }
                    if (Ct && ht && it < st.maxRetries) {
                        setTimeout(function() {
                            st.read.call(st, rt, nt, at, it + 1, ut * 2, lt)
                        }, ut);
                        return
                    }
                    lt(Ct, ht)
                },
                pt = this.backend[at].bind(this.backend);
            if (pt.length === 2) {
                try {
                    var It = pt(rt, nt);
                    It && typeof It.then == "function" ? It.then(function(At) {
                        return bt(null, At)
                    }).catch(bt) : bt(null, It)
                } catch (At) {
                    bt(At)
                }
                return
            }
            return pt(rt, nt, bt)
        }
    }, {
        key: "prepareLoading",
        value: function(rt, nt) {
            var at = this,
                st = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
                it = arguments.length > 3 ? arguments[3] : void 0;
            if (!this.backend) return this.logger.warn("No backend was added via i18next.use. Will not load resources."), it && it();
            typeof rt == "string" && (rt = this.languageUtils.toResolveHierarchy(rt)), typeof nt == "string" && (nt = [nt]);
            var ut = this.queueLoad(rt, nt, st, it);
            if (!ut.toLoad.length) return ut.pending.length || it(), null;
            ut.toLoad.forEach(function(lt) {
                at.loadOne(lt)
            })
        }
    }, {
        key: "load",
        value: function(rt, nt, at) {
            this.prepareLoading(rt, nt, {}, at)
        }
    }, {
        key: "reload",
        value: function(rt, nt, at) {
            this.prepareLoading(rt, nt, {
                reload: !0
            }, at)
        }
    }, {
        key: "loadOne",
        value: function(rt) {
            var nt = this,
                at = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "",
                st = rt.split("|"),
                it = st[0],
                ut = st[1];
            this.read(it, ut, "read", void 0, void 0, function(lt, bt) {
                lt && nt.logger.warn("".concat(at, "loading namespace ").concat(ut, " for language ").concat(it, " failed"), lt), !lt && bt && nt.logger.log("".concat(at, "loaded namespace ").concat(ut, " for language ").concat(it), bt), nt.loaded(rt, lt, bt)
            })
        }
    }, {
        key: "saveMissing",
        value: function(rt, nt, at, st, it) {
            var ut = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {},
                lt = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : function() {};
            if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(nt)) {
                this.logger.warn('did not save key "'.concat(at, '" as the namespace "').concat(nt, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
                return
            }
            if (!(at == null || at === "")) {
                if (this.backend && this.backend.create) {
                    var bt = _objectSpread$1(_objectSpread$1({}, ut), {}, {
                            isUpdate: it
                        }),
                        pt = this.backend.create.bind(this.backend);
                    if (pt.length < 6) try {
                        var It;
                        pt.length === 5 ? It = pt(rt, nt, at, st, bt) : It = pt(rt, nt, at, st), It && typeof It.then == "function" ? It.then(function(At) {
                            return lt(null, At)
                        }).catch(lt) : lt(null, It)
                    } catch (At) {
                        lt(At)
                    } else pt(rt, nt, at, st, lt, bt)
                }!rt || !rt[0] || this.store.addResource(rt[0], nt, at, st)
            }
        }
    }]), et
}(EventEmitter);

function get() {
    return {
        debug: !1,
        initImmediate: !0,
        ns: ["translation"],
        defaultNS: ["translation"],
        fallbackLng: ["dev"],
        fallbackNS: !1,
        supportedLngs: !1,
        nonExplicitSupportedLngs: !1,
        load: "all",
        preload: !1,
        simplifyPluralSuffix: !0,
        keySeparator: ".",
        nsSeparator: ":",
        pluralSeparator: "_",
        contextSeparator: "_",
        partialBundledLanguages: !1,
        saveMissing: !1,
        updateMissing: !1,
        saveMissingTo: "fallback",
        saveMissingPlurals: !0,
        missingKeyHandler: !1,
        missingInterpolationHandler: !1,
        postProcess: !1,
        postProcessPassResolved: !1,
        returnNull: !0,
        returnEmptyString: !0,
        returnObjects: !1,
        joinArrays: !1,
        returnedObjectHandler: !1,
        parseMissingKeyHandler: !1,
        appendNamespaceToMissingKey: !1,
        appendNamespaceToCIMode: !1,
        overloadTranslationOptionHandler: function(_e) {
            var et = {};
            if (_typeof$3(_e[1]) === "object" && (et = _e[1]), typeof _e[1] == "string" && (et.defaultValue = _e[1]), typeof _e[2] == "string" && (et.tDescription = _e[2]), _typeof$3(_e[2]) === "object" || _typeof$3(_e[3]) === "object") {
                var tt = _e[3] || _e[2];
                Object.keys(tt).forEach(function(rt) {
                    et[rt] = tt[rt]
                })
            }
            return et
        },
        interpolation: {
            escapeValue: !0,
            format: function(_e, et, tt, rt) {
                return _e
            },
            prefix: "{{",
            suffix: "}}",
            formatSeparator: ",",
            unescapePrefix: "-",
            nestingPrefix: "$t(",
            nestingSuffix: ")",
            nestingOptionsSeparator: ",",
            maxReplaces: 1e3,
            skipOnVariables: !0
        }
    }
}

function transformOptions(_) {
    return typeof _.ns == "string" && (_.ns = [_.ns]), typeof _.fallbackLng == "string" && (_.fallbackLng = [_.fallbackLng]), typeof _.fallbackNS == "string" && (_.fallbackNS = [_.fallbackNS]), _.supportedLngs && _.supportedLngs.indexOf("cimode") < 0 && (_.supportedLngs = _.supportedLngs.concat(["cimode"])), _
}

function ownKeys(_, _e) {
    var et = Object.keys(_);
    if (Object.getOwnPropertySymbols) {
        var tt = Object.getOwnPropertySymbols(_);
        _e && (tt = tt.filter(function(rt) {
            return Object.getOwnPropertyDescriptor(_, rt).enumerable
        })), et.push.apply(et, tt)
    }
    return et
}

function _objectSpread(_) {
    for (var _e = 1; _e < arguments.length; _e++) {
        var et = arguments[_e] != null ? arguments[_e] : {};
        _e % 2 ? ownKeys(Object(et), !0).forEach(function(tt) {
            _defineProperty$1(_, tt, et[tt])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(et)) : ownKeys(Object(et)).forEach(function(tt) {
            Object.defineProperty(_, tt, Object.getOwnPropertyDescriptor(et, tt))
        })
    }
    return _
}

function _createSuper(_) {
    var _e = _isNativeReflectConstruct();
    return function() {
        var tt = _getPrototypeOf(_),
            rt;
        if (_e) {
            var nt = _getPrototypeOf(this).constructor;
            rt = Reflect.construct(tt, arguments, nt)
        } else rt = tt.apply(this, arguments);
        return _possibleConstructorReturn(this, rt)
    }
}

function _isNativeReflectConstruct() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
    } catch {
        return !1
    }
}

function noop() {}

function bindMemberFunctions(_) {
    var _e = Object.getOwnPropertyNames(Object.getPrototypeOf(_));
    _e.forEach(function(et) {
        typeof _[et] == "function" && (_[et] = _[et].bind(_))
    })
}
var I18n = function(_) {
    _inherits(et, _);
    var _e = _createSuper(et);

    function et() {
        var tt, rt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            nt = arguments.length > 1 ? arguments[1] : void 0;
        if (_classCallCheck$1(this, et), tt = _e.call(this), isIE10 && EventEmitter.call(_assertThisInitialized(tt)), tt.options = transformOptions(rt), tt.services = {}, tt.logger = baseLogger, tt.modules = {
                external: []
            }, bindMemberFunctions(_assertThisInitialized(tt)), nt && !tt.isInitialized && !rt.isClone) {
            if (!tt.options.initImmediate) return tt.init(rt, nt), _possibleConstructorReturn(tt, _assertThisInitialized(tt));
            setTimeout(function() {
                tt.init(rt, nt)
            }, 0)
        }
        return tt
    }
    return _createClass$1(et, [{
        key: "init",
        value: function() {
            var rt = this,
                nt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
                at = arguments.length > 1 ? arguments[1] : void 0;
            typeof nt == "function" && (at = nt, nt = {}), !nt.defaultNS && nt.defaultNS !== !1 && nt.ns && (typeof nt.ns == "string" ? nt.defaultNS = nt.ns : nt.ns.indexOf("translation") < 0 && (nt.defaultNS = nt.ns[0]));
            var st = get();
            this.options = _objectSpread(_objectSpread(_objectSpread({}, st), this.options), transformOptions(nt)), this.options.compatibilityAPI !== "v1" && (this.options.interpolation = _objectSpread(_objectSpread({}, st.interpolation), this.options.interpolation)), nt.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = nt.keySeparator), nt.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = nt.nsSeparator);

            function it(ot) {
                return ot ? typeof ot == "function" ? new ot : ot : null
            }
            if (!this.options.isClone) {
                this.modules.logger ? baseLogger.init(it(this.modules.logger), this.options) : baseLogger.init(null, this.options);
                var ut;
                this.modules.formatter ? ut = this.modules.formatter : typeof Intl < "u" && (ut = Formatter);
                var lt = new LanguageUtil(this.options);
                this.store = new ResourceStore(this.options.resources, this.options);
                var bt = this.services;
                bt.logger = baseLogger, bt.resourceStore = this.store, bt.languageUtils = lt, bt.pluralResolver = new PluralResolver(lt, {
                    prepend: this.options.pluralSeparator,
                    compatibilityJSON: this.options.compatibilityJSON,
                    simplifyPluralSuffix: this.options.simplifyPluralSuffix
                }), ut && (!this.options.interpolation.format || this.options.interpolation.format === st.interpolation.format) && (bt.formatter = it(ut), bt.formatter.init(bt, this.options), this.options.interpolation.format = bt.formatter.format.bind(bt.formatter)), bt.interpolator = new Interpolator(this.options), bt.utils = {
                    hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
                }, bt.backendConnector = new Connector(it(this.modules.backend), bt.resourceStore, bt, this.options), bt.backendConnector.on("*", function(ot) {
                    for (var ct = arguments.length, Et = new Array(ct > 1 ? ct - 1 : 0), Dt = 1; Dt < ct; Dt++) Et[Dt - 1] = arguments[Dt];
                    rt.emit.apply(rt, [ot].concat(Et))
                }), this.modules.languageDetector && (bt.languageDetector = it(this.modules.languageDetector), bt.languageDetector.init && bt.languageDetector.init(bt, this.options.detection, this.options)), this.modules.i18nFormat && (bt.i18nFormat = it(this.modules.i18nFormat), bt.i18nFormat.init && bt.i18nFormat.init(this)), this.translator = new Translator(this.services, this.options), this.translator.on("*", function(ot) {
                    for (var ct = arguments.length, Et = new Array(ct > 1 ? ct - 1 : 0), Dt = 1; Dt < ct; Dt++) Et[Dt - 1] = arguments[Dt];
                    rt.emit.apply(rt, [ot].concat(Et))
                }), this.modules.external.forEach(function(ot) {
                    ot.init && ot.init(rt)
                })
            }
            if (this.format = this.options.interpolation.format, at || (at = noop), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
                var pt = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
                pt.length > 0 && pt[0] !== "dev" && (this.options.lng = pt[0])
            }!this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined");
            var It = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
            It.forEach(function(ot) {
                rt[ot] = function() {
                    var ct;
                    return (ct = rt.store)[ot].apply(ct, arguments)
                }
            });
            var At = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
            At.forEach(function(ot) {
                rt[ot] = function() {
                    var ct;
                    return (ct = rt.store)[ot].apply(ct, arguments), rt
                }
            });
            var Ct = defer(),
                ht = function() {
                    var ct = function(Dt, Pt) {
                        rt.isInitialized && !rt.initializedStoreOnce && rt.logger.warn("init: i18next is already initialized. You should call init just once!"), rt.isInitialized = !0, rt.options.isClone || rt.logger.log("initialized", rt.options), rt.emit("initialized", rt.options), Ct.resolve(Pt), at(Dt, Pt)
                    };
                    if (rt.languages && rt.options.compatibilityAPI !== "v1" && !rt.isInitialized) return ct(null, rt.t.bind(rt));
                    rt.changeLanguage(rt.options.lng, ct)
                };
            return this.options.resources || !this.options.initImmediate ? ht() : setTimeout(ht, 0), Ct
        }
    }, {
        key: "loadResources",
        value: function(rt) {
            var nt = this,
                at = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop,
                st = at,
                it = typeof rt == "string" ? rt : this.language;
            if (typeof rt == "function" && (st = rt), !this.options.resources || this.options.partialBundledLanguages) {
                if (it && it.toLowerCase() === "cimode") return st();
                var ut = [],
                    lt = function(It) {
                        if (!!It) {
                            var At = nt.services.languageUtils.toResolveHierarchy(It);
                            At.forEach(function(Ct) {
                                ut.indexOf(Ct) < 0 && ut.push(Ct)
                            })
                        }
                    };
                if (it) lt(it);
                else {
                    var bt = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
                    bt.forEach(function(pt) {
                        return lt(pt)
                    })
                }
                this.options.preload && this.options.preload.forEach(function(pt) {
                    return lt(pt)
                }), this.services.backendConnector.load(ut, this.options.ns, function(pt) {
                    !pt && !nt.resolvedLanguage && nt.language && nt.setResolvedLanguage(nt.language), st(pt)
                })
            } else st(null)
        }
    }, {
        key: "reloadResources",
        value: function(rt, nt, at) {
            var st = defer();
            return rt || (rt = this.languages), nt || (nt = this.options.ns), at || (at = noop), this.services.backendConnector.reload(rt, nt, function(it) {
                st.resolve(), at(it)
            }), st
        }
    }, {
        key: "use",
        value: function(rt) {
            if (!rt) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
            if (!rt.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
            return rt.type === "backend" && (this.modules.backend = rt), (rt.type === "logger" || rt.log && rt.warn && rt.error) && (this.modules.logger = rt), rt.type === "languageDetector" && (this.modules.languageDetector = rt), rt.type === "i18nFormat" && (this.modules.i18nFormat = rt), rt.type === "postProcessor" && postProcessor.addPostProcessor(rt), rt.type === "formatter" && (this.modules.formatter = rt), rt.type === "3rdParty" && this.modules.external.push(rt), this
        }
    }, {
        key: "setResolvedLanguage",
        value: function(rt) {
            if (!(!rt || !this.languages) && !(["cimode", "dev"].indexOf(rt) > -1))
                for (var nt = 0; nt < this.languages.length; nt++) {
                    var at = this.languages[nt];
                    if (!(["cimode", "dev"].indexOf(at) > -1) && this.store.hasLanguageSomeTranslations(at)) {
                        this.resolvedLanguage = at;
                        break
                    }
                }
        }
    }, {
        key: "changeLanguage",
        value: function(rt, nt) {
            var at = this;
            this.isLanguageChangingTo = rt;
            var st = defer();
            this.emit("languageChanging", rt);
            var it = function(pt) {
                    at.language = pt, at.languages = at.services.languageUtils.toResolveHierarchy(pt), at.resolvedLanguage = void 0, at.setResolvedLanguage(pt)
                },
                ut = function(pt, It) {
                    It ? (it(It), at.translator.changeLanguage(It), at.isLanguageChangingTo = void 0, at.emit("languageChanged", It), at.logger.log("languageChanged", It)) : at.isLanguageChangingTo = void 0, st.resolve(function() {
                        return at.t.apply(at, arguments)
                    }), nt && nt(pt, function() {
                        return at.t.apply(at, arguments)
                    })
                },
                lt = function(pt) {
                    !rt && !pt && at.services.languageDetector && (pt = []);
                    var It = typeof pt == "string" ? pt : at.services.languageUtils.getBestMatchFromCodes(pt);
                    It && (at.language || it(It), at.translator.language || at.translator.changeLanguage(It), at.services.languageDetector && at.services.languageDetector.cacheUserLanguage && at.services.languageDetector.cacheUserLanguage(It)), at.loadResources(It, function(At) {
                        ut(At, It)
                    })
                };
            return !rt && this.services.languageDetector && !this.services.languageDetector.async ? lt(this.services.languageDetector.detect()) : !rt && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(lt) : this.services.languageDetector.detect(lt) : lt(rt), st
        }
    }, {
        key: "getFixedT",
        value: function(rt, nt, at) {
            var st = this,
                it = function ut(lt, bt) {
                    var pt;
                    if (_typeof$3(bt) !== "object") {
                        for (var It = arguments.length, At = new Array(It > 2 ? It - 2 : 0), Ct = 2; Ct < It; Ct++) At[Ct - 2] = arguments[Ct];
                        pt = st.options.overloadTranslationOptionHandler([lt, bt].concat(At))
                    } else pt = _objectSpread({}, bt);
                    pt.lng = pt.lng || ut.lng, pt.lngs = pt.lngs || ut.lngs, pt.ns = pt.ns || ut.ns, pt.keyPrefix = pt.keyPrefix || at || ut.keyPrefix;
                    var ht = st.options.keySeparator || ".",
                        ot = pt.keyPrefix ? "".concat(pt.keyPrefix).concat(ht).concat(lt) : lt;
                    return st.t(ot, pt)
                };
            return typeof rt == "string" ? it.lng = rt : it.lngs = rt, it.ns = nt, it.keyPrefix = at, it
        }
    }, {
        key: "t",
        value: function() {
            var rt;
            return this.translator && (rt = this.translator).translate.apply(rt, arguments)
        }
    }, {
        key: "exists",
        value: function() {
            var rt;
            return this.translator && (rt = this.translator).exists.apply(rt, arguments)
        }
    }, {
        key: "setDefaultNamespace",
        value: function(rt) {
            this.options.defaultNS = rt
        }
    }, {
        key: "hasLoadedNamespace",
        value: function(rt) {
            var nt = this,
                at = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (!this.isInitialized) return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
            if (!this.languages || !this.languages.length) return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
            var st = this.resolvedLanguage || this.languages[0],
                it = this.options ? this.options.fallbackLng : !1,
                ut = this.languages[this.languages.length - 1];
            if (st.toLowerCase() === "cimode") return !0;
            var lt = function(It, At) {
                var Ct = nt.services.backendConnector.state["".concat(It, "|").concat(At)];
                return Ct === -1 || Ct === 2
            };
            if (at.precheck) {
                var bt = at.precheck(this, lt);
                if (bt !== void 0) return bt
            }
            return !!(this.hasResourceBundle(st, rt) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || lt(st, rt) && (!it || lt(ut, rt)))
        }
    }, {
        key: "loadNamespaces",
        value: function(rt, nt) {
            var at = this,
                st = defer();
            return this.options.ns ? (typeof rt == "string" && (rt = [rt]), rt.forEach(function(it) {
                at.options.ns.indexOf(it) < 0 && at.options.ns.push(it)
            }), this.loadResources(function(it) {
                st.resolve(), nt && nt(it)
            }), st) : (nt && nt(), Promise.resolve())
        }
    }, {
        key: "loadLanguages",
        value: function(rt, nt) {
            var at = defer();
            typeof rt == "string" && (rt = [rt]);
            var st = this.options.preload || [],
                it = rt.filter(function(ut) {
                    return st.indexOf(ut) < 0
                });
            return it.length ? (this.options.preload = st.concat(it), this.loadResources(function(ut) {
                at.resolve(), nt && nt(ut)
            }), at) : (nt && nt(), Promise.resolve())
        }
    }, {
        key: "dir",
        value: function(rt) {
            if (rt || (rt = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !rt) return "rtl";
            var nt = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"],
                at = this.services && this.services.languageUtils || new LanguageUtil(get());
            return nt.indexOf(at.getLanguagePartFromCode(rt)) > -1 || rt.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr"
        }
    }, {
        key: "cloneInstance",
        value: function() {
            var rt = this,
                nt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
                at = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop,
                st = _objectSpread(_objectSpread(_objectSpread({}, this.options), nt), {
                    isClone: !0
                }),
                it = new et(st);
            (nt.debug !== void 0 || nt.prefix !== void 0) && (it.logger = it.logger.clone(nt));
            var ut = ["store", "services", "language"];
            return ut.forEach(function(lt) {
                it[lt] = rt[lt]
            }), it.services = _objectSpread({}, this.services), it.services.utils = {
                hasLoadedNamespace: it.hasLoadedNamespace.bind(it)
            }, it.translator = new Translator(it.services, it.options), it.translator.on("*", function(lt) {
                for (var bt = arguments.length, pt = new Array(bt > 1 ? bt - 1 : 0), It = 1; It < bt; It++) pt[It - 1] = arguments[It];
                it.emit.apply(it, [lt].concat(pt))
            }), it.init(st, at), it.translator.options = it.options, it.translator.backendConnector.services.utils = {
                hasLoadedNamespace: it.hasLoadedNamespace.bind(it)
            }, it
        }
    }, {
        key: "toJSON",
        value: function() {
            return {
                options: this.options,
                store: this.store,
                language: this.language,
                languages: this.languages,
                resolvedLanguage: this.resolvedLanguage
            }
        }
    }]), et
}(EventEmitter);
_defineProperty$1(I18n, "createInstance", function() {
    var _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
        _e = arguments.length > 1 ? arguments[1] : void 0;
    return new I18n(_, _e)
});
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;

function _typeof$2(_) {
    return _typeof$2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(_e) {
        return typeof _e
    } : function(_e) {
        return _e && typeof Symbol == "function" && _e.constructor === Symbol && _e !== Symbol.prototype ? "symbol" : typeof _e
    }, _typeof$2(_)
}
var arr$1 = [],
    each$1 = arr$1.forEach,
    slice$1 = arr$1.slice;

function defaults$1(_) {
    return each$1.call(slice$1.call(arguments, 1), function(_e) {
        if (_e)
            for (var et in _e) _[et] === void 0 && (_[et] = _e[et])
    }), _
}

function hasXMLHttpRequest() {
    return typeof XMLHttpRequest == "function" || (typeof XMLHttpRequest > "u" ? "undefined" : _typeof$2(XMLHttpRequest)) === "object"
}

function isPromise(_) {
    return !!_ && typeof _.then == "function"
}

function makePromise(_) {
    return isPromise(_) ? _ : Promise.resolve(_)
}
var getFetch$1 = {
        exports: {}
    },
    browserPonyfill = {
        exports: {}
    },
    hasRequiredBrowserPonyfill;

function requireBrowserPonyfill() {
    return hasRequiredBrowserPonyfill || (hasRequiredBrowserPonyfill = 1, function(_, _e) {
        var et = typeof self < "u" ? self : commonjsGlobal$1,
            tt = function() {
                function nt() {
                    this.fetch = !1, this.DOMException = et.DOMException
                }
                return nt.prototype = et, new nt
            }();
        (function(nt) {
            (function(at) {
                var st = {
                    searchParams: "URLSearchParams" in nt,
                    iterable: "Symbol" in nt && "iterator" in Symbol,
                    blob: "FileReader" in nt && "Blob" in nt && function() {
                        try {
                            return new Blob, !0
                        } catch {
                            return !1
                        }
                    }(),
                    formData: "FormData" in nt,
                    arrayBuffer: "ArrayBuffer" in nt
                };

                function it(yt) {
                    return yt && DataView.prototype.isPrototypeOf(yt)
                }
                if (st.arrayBuffer) var ut = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                    lt = ArrayBuffer.isView || function(yt) {
                        return yt && ut.indexOf(Object.prototype.toString.call(yt)) > -1
                    };

                function bt(yt) {
                    if (typeof yt != "string" && (yt = String(yt)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(yt)) throw new TypeError("Invalid character in header field name");
                    return yt.toLowerCase()
                }

                function pt(yt) {
                    return typeof yt != "string" && (yt = String(yt)), yt
                }

                function It(yt) {
                    var Tt = {
                        next: function() {
                            var Ft = yt.shift();
                            return {
                                done: Ft === void 0,
                                value: Ft
                            }
                        }
                    };
                    return st.iterable && (Tt[Symbol.iterator] = function() {
                        return Tt
                    }), Tt
                }

                function At(yt) {
                    this.map = {}, yt instanceof At ? yt.forEach(function(Tt, Ft) {
                        this.append(Ft, Tt)
                    }, this) : Array.isArray(yt) ? yt.forEach(function(Tt) {
                        this.append(Tt[0], Tt[1])
                    }, this) : yt && Object.getOwnPropertyNames(yt).forEach(function(Tt) {
                        this.append(Tt, yt[Tt])
                    }, this)
                }
                At.prototype.append = function(yt, Tt) {
                    yt = bt(yt), Tt = pt(Tt);
                    var Ft = this.map[yt];
                    this.map[yt] = Ft ? Ft + ", " + Tt : Tt
                }, At.prototype.delete = function(yt) {
                    delete this.map[bt(yt)]
                }, At.prototype.get = function(yt) {
                    return yt = bt(yt), this.has(yt) ? this.map[yt] : null
                }, At.prototype.has = function(yt) {
                    return this.map.hasOwnProperty(bt(yt))
                }, At.prototype.set = function(yt, Tt) {
                    this.map[bt(yt)] = pt(Tt)
                }, At.prototype.forEach = function(yt, Tt) {
                    for (var Ft in this.map) this.map.hasOwnProperty(Ft) && yt.call(Tt, this.map[Ft], Ft, this)
                }, At.prototype.keys = function() {
                    var yt = [];
                    return this.forEach(function(Tt, Ft) {
                        yt.push(Ft)
                    }), It(yt)
                }, At.prototype.values = function() {
                    var yt = [];
                    return this.forEach(function(Tt) {
                        yt.push(Tt)
                    }), It(yt)
                }, At.prototype.entries = function() {
                    var yt = [];
                    return this.forEach(function(Tt, Ft) {
                        yt.push([Ft, Tt])
                    }), It(yt)
                }, st.iterable && (At.prototype[Symbol.iterator] = At.prototype.entries);

                function Ct(yt) {
                    if (yt.bodyUsed) return Promise.reject(new TypeError("Already read"));
                    yt.bodyUsed = !0
                }

                function ht(yt) {
                    return new Promise(function(Tt, Ft) {
                        yt.onload = function() {
                            Tt(yt.result)
                        }, yt.onerror = function() {
                            Ft(yt.error)
                        }
                    })
                }

                function ot(yt) {
                    var Tt = new FileReader,
                        Ft = ht(Tt);
                    return Tt.readAsArrayBuffer(yt), Ft
                }

                function ct(yt) {
                    var Tt = new FileReader,
                        Ft = ht(Tt);
                    return Tt.readAsText(yt), Ft
                }

                function Et(yt) {
                    for (var Tt = new Uint8Array(yt), Ft = new Array(Tt.length), wt = 0; wt < Tt.length; wt++) Ft[wt] = String.fromCharCode(Tt[wt]);
                    return Ft.join("")
                }

                function Dt(yt) {
                    if (yt.slice) return yt.slice(0);
                    var Tt = new Uint8Array(yt.byteLength);
                    return Tt.set(new Uint8Array(yt)), Tt.buffer
                }

                function Pt() {
                    return this.bodyUsed = !1, this._initBody = function(yt) {
                        this._bodyInit = yt, yt ? typeof yt == "string" ? this._bodyText = yt : st.blob && Blob.prototype.isPrototypeOf(yt) ? this._bodyBlob = yt : st.formData && FormData.prototype.isPrototypeOf(yt) ? this._bodyFormData = yt : st.searchParams && URLSearchParams.prototype.isPrototypeOf(yt) ? this._bodyText = yt.toString() : st.arrayBuffer && st.blob && it(yt) ? (this._bodyArrayBuffer = Dt(yt.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : st.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(yt) || lt(yt)) ? this._bodyArrayBuffer = Dt(yt) : this._bodyText = yt = Object.prototype.toString.call(yt) : this._bodyText = "", this.headers.get("content-type") || (typeof yt == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : st.searchParams && URLSearchParams.prototype.isPrototypeOf(yt) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                    }, st.blob && (this.blob = function() {
                        var yt = Ct(this);
                        if (yt) return yt;
                        if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                        if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                        if (this._bodyFormData) throw new Error("could not read FormData body as blob");
                        return Promise.resolve(new Blob([this._bodyText]))
                    }, this.arrayBuffer = function() {
                        return this._bodyArrayBuffer ? Ct(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(ot)
                    }), this.text = function() {
                        var yt = Ct(this);
                        if (yt) return yt;
                        if (this._bodyBlob) return ct(this._bodyBlob);
                        if (this._bodyArrayBuffer) return Promise.resolve(Et(this._bodyArrayBuffer));
                        if (this._bodyFormData) throw new Error("could not read FormData body as text");
                        return Promise.resolve(this._bodyText)
                    }, st.formData && (this.formData = function() {
                        return this.text().then(St)
                    }), this.json = function() {
                        return this.text().then(JSON.parse)
                    }, this
                }
                var gt = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

                function ft(yt) {
                    var Tt = yt.toUpperCase();
                    return gt.indexOf(Tt) > -1 ? Tt : yt
                }

                function dt(yt, Tt) {
                    Tt = Tt || {};
                    var Ft = Tt.body;
                    if (yt instanceof dt) {
                        if (yt.bodyUsed) throw new TypeError("Already read");
                        this.url = yt.url, this.credentials = yt.credentials, Tt.headers || (this.headers = new At(yt.headers)), this.method = yt.method, this.mode = yt.mode, this.signal = yt.signal, !Ft && yt._bodyInit != null && (Ft = yt._bodyInit, yt.bodyUsed = !0)
                    } else this.url = String(yt);
                    if (this.credentials = Tt.credentials || this.credentials || "same-origin", (Tt.headers || !this.headers) && (this.headers = new At(Tt.headers)), this.method = ft(Tt.method || this.method || "GET"), this.mode = Tt.mode || this.mode || null, this.signal = Tt.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && Ft) throw new TypeError("Body not allowed for GET or HEAD requests");
                    this._initBody(Ft)
                }
                dt.prototype.clone = function() {
                    return new dt(this, {
                        body: this._bodyInit
                    })
                };

                function St(yt) {
                    var Tt = new FormData;
                    return yt.trim().split("&").forEach(function(Ft) {
                        if (Ft) {
                            var wt = Ft.split("="),
                                kt = wt.shift().replace(/\+/g, " "),
                                Ot = wt.join("=").replace(/\+/g, " ");
                            Tt.append(decodeURIComponent(kt), decodeURIComponent(Ot))
                        }
                    }), Tt
                }

                function _t(yt) {
                    var Tt = new At,
                        Ft = yt.replace(/\r?\n[\t ]+/g, " ");
                    return Ft.split(/\r?\n/).forEach(function(wt) {
                        var kt = wt.split(":"),
                            Ot = kt.shift().trim();
                        if (Ot) {
                            var Rt = kt.join(":").trim();
                            Tt.append(Ot, Rt)
                        }
                    }), Tt
                }
                Pt.call(dt.prototype);

                function vt(yt, Tt) {
                    Tt || (Tt = {}), this.type = "default", this.status = Tt.status === void 0 ? 200 : Tt.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in Tt ? Tt.statusText : "OK", this.headers = new At(Tt.headers), this.url = Tt.url || "", this._initBody(yt)
                }
                Pt.call(vt.prototype), vt.prototype.clone = function() {
                    return new vt(this._bodyInit, {
                        status: this.status,
                        statusText: this.statusText,
                        headers: new At(this.headers),
                        url: this.url
                    })
                }, vt.error = function() {
                    var yt = new vt(null, {
                        status: 0,
                        statusText: ""
                    });
                    return yt.type = "error", yt
                };
                var mt = [301, 302, 303, 307, 308];
                vt.redirect = function(yt, Tt) {
                    if (mt.indexOf(Tt) === -1) throw new RangeError("Invalid status code");
                    return new vt(null, {
                        status: Tt,
                        headers: {
                            location: yt
                        }
                    })
                }, at.DOMException = nt.DOMException;
                try {
                    new at.DOMException
                } catch {
                    at.DOMException = function(Tt, Ft) {
                        this.message = Tt, this.name = Ft;
                        var wt = Error(Tt);
                        this.stack = wt.stack
                    }, at.DOMException.prototype = Object.create(Error.prototype), at.DOMException.prototype.constructor = at.DOMException
                }

                function xt(yt, Tt) {
                    return new Promise(function(Ft, wt) {
                        var kt = new dt(yt, Tt);
                        if (kt.signal && kt.signal.aborted) return wt(new at.DOMException("Aborted", "AbortError"));
                        var Ot = new XMLHttpRequest;

                        function Rt() {
                            Ot.abort()
                        }
                        Ot.onload = function() {
                            var Lt = {
                                status: Ot.status,
                                statusText: Ot.statusText,
                                headers: _t(Ot.getAllResponseHeaders() || "")
                            };
                            Lt.url = "responseURL" in Ot ? Ot.responseURL : Lt.headers.get("X-Request-URL");
                            var Bt = "response" in Ot ? Ot.response : Ot.responseText;
                            Ft(new vt(Bt, Lt))
                        }, Ot.onerror = function() {
                            wt(new TypeError("Network request failed"))
                        }, Ot.ontimeout = function() {
                            wt(new TypeError("Network request failed"))
                        }, Ot.onabort = function() {
                            wt(new at.DOMException("Aborted", "AbortError"))
                        }, Ot.open(kt.method, kt.url, !0), kt.credentials === "include" ? Ot.withCredentials = !0 : kt.credentials === "omit" && (Ot.withCredentials = !1), "responseType" in Ot && st.blob && (Ot.responseType = "blob"), kt.headers.forEach(function(Lt, Bt) {
                            Ot.setRequestHeader(Bt, Lt)
                        }), kt.signal && (kt.signal.addEventListener("abort", Rt), Ot.onreadystatechange = function() {
                            Ot.readyState === 4 && kt.signal.removeEventListener("abort", Rt)
                        }), Ot.send(typeof kt._bodyInit > "u" ? null : kt._bodyInit)
                    })
                }
                return xt.polyfill = !0, nt.fetch || (nt.fetch = xt, nt.Headers = At, nt.Request = dt, nt.Response = vt), at.Headers = At, at.Request = dt, at.Response = vt, at.fetch = xt, Object.defineProperty(at, "__esModule", {
                    value: !0
                }), at
            })({})
        })(tt), tt.fetch.ponyfill = !0, delete tt.fetch.polyfill;
        var rt = tt;
        _e = rt.fetch, _e.default = rt.fetch, _e.fetch = rt.fetch, _e.Headers = rt.Headers, _e.Request = rt.Request, _e.Response = rt.Response, _.exports = _e
    }(browserPonyfill, browserPonyfill.exports)), browserPonyfill.exports
}(function(_, _e) {
    var et;
    if (typeof fetch == "function" && (typeof commonjsGlobal$1 < "u" && commonjsGlobal$1.fetch ? et = commonjsGlobal$1.fetch : typeof window < "u" && window.fetch ? et = window.fetch : et = fetch), typeof commonjsRequire < "u" && (typeof window > "u" || typeof window.document > "u")) {
        var tt = et || requireBrowserPonyfill();
        tt.default && (tt = tt.default), _e.default = tt, _.exports = _e.default
    }
})(getFetch$1, getFetch$1.exports);
const getFetch = getFetch$1.exports,
    fetchNode = _mergeNamespaces({
        __proto__: null,
        default: getFetch
    }, [getFetch$1.exports]);

function _typeof$1(_) {
    return _typeof$1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(_e) {
        return typeof _e
    } : function(_e) {
        return _e && typeof Symbol == "function" && _e.constructor === Symbol && _e !== Symbol.prototype ? "symbol" : typeof _e
    }, _typeof$1(_)
}
var fetchApi;
typeof fetch == "function" && (typeof global < "u" && global.fetch ? fetchApi = global.fetch : typeof window < "u" && window.fetch ? fetchApi = window.fetch : fetchApi = fetch);
var XmlHttpRequestApi;
hasXMLHttpRequest() && (typeof global < "u" && global.XMLHttpRequest ? XmlHttpRequestApi = global.XMLHttpRequest : typeof window < "u" && window.XMLHttpRequest && (XmlHttpRequestApi = window.XMLHttpRequest));
var ActiveXObjectApi;
typeof ActiveXObject == "function" && (typeof global < "u" && global.ActiveXObject ? ActiveXObjectApi = global.ActiveXObject : typeof window < "u" && window.ActiveXObject && (ActiveXObjectApi = window.ActiveXObject));
!fetchApi && fetchNode && !XmlHttpRequestApi && !ActiveXObjectApi && (fetchApi = getFetch || fetchNode);
typeof fetchApi != "function" && (fetchApi = void 0);
var addQueryString = function _(_e, et) {
        if (et && _typeof$1(et) === "object") {
            var tt = "";
            for (var rt in et) tt += "&" + encodeURIComponent(rt) + "=" + encodeURIComponent(et[rt]);
            if (!tt) return _e;
            _e = _e + (_e.indexOf("?") !== -1 ? "&" : "?") + tt.slice(1)
        }
        return _e
    },
    fetchIt = function _(_e, et, tt) {
        fetchApi(_e, et).then(function(rt) {
            if (!rt.ok) return tt(rt.statusText || "Error", {
                status: rt.status
            });
            rt.text().then(function(nt) {
                tt(null, {
                    status: rt.status,
                    data: nt
                })
            }).catch(tt)
        }).catch(tt)
    },
    omitFetchOptions = !1,
    requestWithFetch = function _(_e, et, tt, rt) {
        _e.queryStringParams && (et = addQueryString(et, _e.queryStringParams));
        var nt = defaults$1({}, typeof _e.customHeaders == "function" ? _e.customHeaders() : _e.customHeaders);
        tt && (nt["Content-Type"] = "application/json");
        var at = typeof _e.requestOptions == "function" ? _e.requestOptions(tt) : _e.requestOptions,
            st = defaults$1({
                method: tt ? "POST" : "GET",
                body: tt ? _e.stringify(tt) : void 0,
                headers: nt
            }, omitFetchOptions ? {} : at);
        try {
            fetchIt(et, st, rt)
        } catch (it) {
            if (!at || Object.keys(at).length === 0 || !it.message || it.message.indexOf("not implemented") < 0) return rt(it);
            try {
                Object.keys(at).forEach(function(ut) {
                    delete st[ut]
                }), fetchIt(et, st, rt), omitFetchOptions = !0
            } catch (ut) {
                rt(ut)
            }
        }
    },
    requestWithXmlHttpRequest = function _(_e, et, tt, rt) {
        tt && _typeof$1(tt) === "object" && (tt = addQueryString("", tt).slice(1)), _e.queryStringParams && (et = addQueryString(et, _e.queryStringParams));
        try {
            var nt;
            XmlHttpRequestApi ? nt = new XmlHttpRequestApi : nt = new ActiveXObjectApi("MSXML2.XMLHTTP.3.0"), nt.open(tt ? "POST" : "GET", et, 1), _e.crossDomain || nt.setRequestHeader("X-Requested-With", "XMLHttpRequest"), nt.withCredentials = !!_e.withCredentials, tt && nt.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), nt.overrideMimeType && nt.overrideMimeType("application/json");
            var at = _e.customHeaders;
            if (at = typeof at == "function" ? at() : at, at)
                for (var st in at) nt.setRequestHeader(st, at[st]);
            nt.onreadystatechange = function() {
                nt.readyState > 3 && rt(nt.status >= 400 ? nt.statusText : null, {
                    status: nt.status,
                    data: nt.responseText
                })
            }, nt.send(tt)
        } catch (it) {
            console && console.log(it)
        }
    },
    request = function _(_e, et, tt, rt) {
        if (typeof tt == "function" && (rt = tt, tt = void 0), rt = rt || function() {}, fetchApi && et.indexOf("file:") !== 0) return requestWithFetch(_e, et, tt, rt);
        if (hasXMLHttpRequest() || typeof ActiveXObject == "function") return requestWithXmlHttpRequest(_e, et, tt, rt);
        rt(new Error("No fetch and no xhr implementation found!"))
    };

function _typeof(_) {
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(_e) {
        return typeof _e
    } : function(_e) {
        return _e && typeof Symbol == "function" && _e.constructor === Symbol && _e !== Symbol.prototype ? "symbol" : typeof _e
    }, _typeof(_)
}

function _classCallCheck(_, _e) {
    if (!(_ instanceof _e)) throw new TypeError("Cannot call a class as a function")
}

function _defineProperties(_, _e) {
    for (var et = 0; et < _e.length; et++) {
        var tt = _e[et];
        tt.enumerable = tt.enumerable || !1, tt.configurable = !0, "value" in tt && (tt.writable = !0), Object.defineProperty(_, _toPropertyKey(tt.key), tt)
    }
}

function _createClass(_, _e, et) {
    return _e && _defineProperties(_.prototype, _e), et && _defineProperties(_, et), Object.defineProperty(_, "prototype", {
        writable: !1
    }), _
}

function _defineProperty(_, _e, et) {
    return _e = _toPropertyKey(_e), _e in _ ? Object.defineProperty(_, _e, {
        value: et,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : _[_e] = et, _
}

function _toPropertyKey(_) {
    var _e = _toPrimitive(_, "string");
    return _typeof(_e) === "symbol" ? _e : String(_e)
}

function _toPrimitive(_, _e) {
    if (_typeof(_) !== "object" || _ === null) return _;
    var et = _[Symbol.toPrimitive];
    if (et !== void 0) {
        var tt = et.call(_, _e || "default");
        if (_typeof(tt) !== "object") return tt;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (_e === "string" ? String : Number)(_)
}
var getDefaults$1 = function _() {
        return {
            loadPath: "/locales/{{lng}}/{{ns}}.json",
            addPath: "/locales/add/{{lng}}/{{ns}}",
            allowMultiLoading: !1,
            parse: function(et) {
                return JSON.parse(et)
            },
            stringify: JSON.stringify,
            parsePayload: function(et, tt, rt) {
                return _defineProperty({}, tt, rt || "")
            },
            request,
            reloadInterval: typeof window < "u" ? !1 : 60 * 60 * 1e3,
            customHeaders: {},
            queryStringParams: {},
            crossDomain: !1,
            withCredentials: !1,
            overrideMimeType: !1,
            requestOptions: {
                mode: "cors",
                credentials: "same-origin",
                cache: "default"
            }
        }
    },
    Backend = function() {
        function _(_e) {
            var et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                tt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            _classCallCheck(this, _), this.services = _e, this.options = et, this.allOptions = tt, this.type = "backend", this.init(_e, et, tt)
        }
        return _createClass(_, [{
            key: "init",
            value: function(et) {
                var tt = this,
                    rt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                    nt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                this.services = et, this.options = defaults$1(rt, this.options || {}, getDefaults$1()), this.allOptions = nt, this.services && this.options.reloadInterval && setInterval(function() {
                    return tt.reload()
                }, this.options.reloadInterval)
            }
        }, {
            key: "readMulti",
            value: function(et, tt, rt) {
                this._readAny(et, et, tt, tt, rt)
            }
        }, {
            key: "read",
            value: function(et, tt, rt) {
                this._readAny([et], et, [tt], tt, rt)
            }
        }, {
            key: "_readAny",
            value: function(et, tt, rt, nt, at) {
                var st = this,
                    it = this.options.loadPath;
                typeof this.options.loadPath == "function" && (it = this.options.loadPath(et, rt)), it = makePromise(it), it.then(function(ut) {
                    if (!ut) return at(null, {});
                    var lt = st.services.interpolator.interpolate(ut, {
                        lng: et.join("+"),
                        ns: rt.join("+")
                    });
                    st.loadUrl(lt, at, tt, nt)
                })
            }
        }, {
            key: "loadUrl",
            value: function(et, tt, rt, nt) {
                var at = this;
                this.options.request(this.options, et, void 0, function(st, it) {
                    if (it && (it.status >= 500 && it.status < 600 || !it.status)) return tt("failed loading " + et + "; status code: " + it.status, !0);
                    if (it && it.status >= 400 && it.status < 500) return tt("failed loading " + et + "; status code: " + it.status, !1);
                    if (!it && st && st.message && st.message.indexOf("Failed to fetch") > -1) return tt("failed loading " + et + ": " + st.message, !0);
                    if (st) return tt(st, !1);
                    var ut, lt;
                    try {
                        typeof it.data == "string" ? ut = at.options.parse(it.data, rt, nt) : ut = it.data
                    } catch {
                        lt = "failed parsing " + et + " to json"
                    }
                    if (lt) return tt(lt, !1);
                    tt(null, ut)
                })
            }
        }, {
            key: "create",
            value: function(et, tt, rt, nt, at) {
                var st = this;
                if (!!this.options.addPath) {
                    typeof et == "string" && (et = [et]);
                    var it = this.options.parsePayload(tt, rt, nt),
                        ut = 0,
                        lt = [],
                        bt = [];
                    et.forEach(function(pt) {
                        var It = st.options.addPath;
                        typeof st.options.addPath == "function" && (It = st.options.addPath(pt, tt));
                        var At = st.services.interpolator.interpolate(It, {
                            lng: pt,
                            ns: tt
                        });
                        st.options.request(st.options, At, it, function(Ct, ht) {
                            ut += 1, lt.push(Ct), bt.push(ht), ut === et.length && at && at(lt, bt)
                        })
                    })
                }
            }
        }, {
            key: "reload",
            value: function() {
                var et = this,
                    tt = this.services,
                    rt = tt.backendConnector,
                    nt = tt.languageUtils,
                    at = tt.logger,
                    st = rt.language;
                if (!(st && st.toLowerCase() === "cimode")) {
                    var it = [],
                        ut = function(bt) {
                            var pt = nt.toResolveHierarchy(bt);
                            pt.forEach(function(It) {
                                it.indexOf(It) < 0 && it.push(It)
                            })
                        };
                    ut(st), this.allOptions.preload && this.allOptions.preload.forEach(function(lt) {
                        return ut(lt)
                    }), it.forEach(function(lt) {
                        et.allOptions.ns.forEach(function(bt) {
                            rt.read(lt, bt, "read", null, null, function(pt, It) {
                                pt && at.warn("loading namespace ".concat(bt, " for language ").concat(lt, " failed"), pt), !pt && It && at.log("loaded namespace ".concat(bt, " for language ").concat(lt), It), rt.loaded("".concat(lt, "|").concat(bt), pt, It)
                            })
                        })
                    })
                }
            }
        }]), _
    }();
Backend.type = "backend";
var arr = [],
    each = arr.forEach,
    slice = arr.slice;

function defaults(_) {
    return each.call(slice.call(arguments, 1), function(_e) {
        if (_e)
            for (var et in _e) _[et] === void 0 && (_[et] = _e[et])
    }), _
}
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/,
    serializeCookie = function _(_e, et, tt) {
        var rt = tt || {};
        rt.path = rt.path || "/";
        var nt = encodeURIComponent(et),
            at = "".concat(_e, "=").concat(nt);
        if (rt.maxAge > 0) {
            var st = rt.maxAge - 0;
            if (Number.isNaN(st)) throw new Error("maxAge should be a Number");
            at += "; Max-Age=".concat(Math.floor(st))
        }
        if (rt.domain) {
            if (!fieldContentRegExp.test(rt.domain)) throw new TypeError("option domain is invalid");
            at += "; Domain=".concat(rt.domain)
        }
        if (rt.path) {
            if (!fieldContentRegExp.test(rt.path)) throw new TypeError("option path is invalid");
            at += "; Path=".concat(rt.path)
        }
        if (rt.expires) {
            if (typeof rt.expires.toUTCString != "function") throw new TypeError("option expires is invalid");
            at += "; Expires=".concat(rt.expires.toUTCString())
        }
        if (rt.httpOnly && (at += "; HttpOnly"), rt.secure && (at += "; Secure"), rt.sameSite) {
            var it = typeof rt.sameSite == "string" ? rt.sameSite.toLowerCase() : rt.sameSite;
            switch (it) {
                case !0:
                    at += "; SameSite=Strict";
                    break;
                case "lax":
                    at += "; SameSite=Lax";
                    break;
                case "strict":
                    at += "; SameSite=Strict";
                    break;
                case "none":
                    at += "; SameSite=None";
                    break;
                default:
                    throw new TypeError("option sameSite is invalid")
            }
        }
        return at
    },
    cookie = {
        create: function _(_e, et, tt, rt) {
            var nt = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
                path: "/",
                sameSite: "strict"
            };
            tt && (nt.expires = new Date, nt.expires.setTime(nt.expires.getTime() + tt * 60 * 1e3)), rt && (nt.domain = rt), document.cookie = serializeCookie(_e, encodeURIComponent(et), nt)
        },
        read: function _(_e) {
            for (var et = "".concat(_e, "="), tt = document.cookie.split(";"), rt = 0; rt < tt.length; rt++) {
                for (var nt = tt[rt]; nt.charAt(0) === " ";) nt = nt.substring(1, nt.length);
                if (nt.indexOf(et) === 0) return nt.substring(et.length, nt.length)
            }
            return null
        },
        remove: function _(_e) {
            this.create(_e, "", -1)
        }
    },
    cookie$1 = {
        name: "cookie",
        lookup: function _(_e) {
            var et;
            if (_e.lookupCookie && typeof document < "u") {
                var tt = cookie.read(_e.lookupCookie);
                tt && (et = tt)
            }
            return et
        },
        cacheUserLanguage: function _(_e, et) {
            et.lookupCookie && typeof document < "u" && cookie.create(et.lookupCookie, _e, et.cookieMinutes, et.cookieDomain, et.cookieOptions)
        }
    },
    querystring = {
        name: "querystring",
        lookup: function _(_e) {
            var et;
            if (typeof window < "u") {
                var tt = window.location.search;
                !window.location.search && window.location.hash && window.location.hash.indexOf("?") > -1 && (tt = window.location.hash.substring(window.location.hash.indexOf("?")));
                for (var rt = tt.substring(1), nt = rt.split("&"), at = 0; at < nt.length; at++) {
                    var st = nt[at].indexOf("=");
                    if (st > 0) {
                        var it = nt[at].substring(0, st);
                        it === _e.lookupQuerystring && (et = nt[at].substring(st + 1))
                    }
                }
            }
            return et
        }
    },
    hasLocalStorageSupport = null,
    localStorageAvailable = function _() {
        if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;
        try {
            hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
            var _e = "i18next.translate.boo";
            window.localStorage.setItem(_e, "foo"), window.localStorage.removeItem(_e)
        } catch {
            hasLocalStorageSupport = !1
        }
        return hasLocalStorageSupport
    },
    localStorage$1 = {
        name: "localStorage",
        lookup: function _(_e) {
            var et;
            if (_e.lookupLocalStorage && localStorageAvailable()) {
                var tt = window.localStorage.getItem(_e.lookupLocalStorage);
                tt && (et = tt)
            }
            return et
        },
        cacheUserLanguage: function _(_e, et) {
            et.lookupLocalStorage && localStorageAvailable() && window.localStorage.setItem(et.lookupLocalStorage, _e)
        }
    },
    hasSessionStorageSupport = null,
    sessionStorageAvailable = function _() {
        if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;
        try {
            hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
            var _e = "i18next.translate.boo";
            window.sessionStorage.setItem(_e, "foo"), window.sessionStorage.removeItem(_e)
        } catch {
            hasSessionStorageSupport = !1
        }
        return hasSessionStorageSupport
    },
    sessionStorage = {
        name: "sessionStorage",
        lookup: function _(_e) {
            var et;
            if (_e.lookupSessionStorage && sessionStorageAvailable()) {
                var tt = window.sessionStorage.getItem(_e.lookupSessionStorage);
                tt && (et = tt)
            }
            return et
        },
        cacheUserLanguage: function _(_e, et) {
            et.lookupSessionStorage && sessionStorageAvailable() && window.sessionStorage.setItem(et.lookupSessionStorage, _e)
        }
    },
    navigator$1 = {
        name: "navigator",
        lookup: function _(_e) {
            var et = [];
            if (typeof navigator < "u") {
                if (navigator.languages)
                    for (var tt = 0; tt < navigator.languages.length; tt++) et.push(navigator.languages[tt]);
                navigator.userLanguage && et.push(navigator.userLanguage), navigator.language && et.push(navigator.language)
            }
            return et.length > 0 ? et : void 0
        }
    },
    htmlTag = {
        name: "htmlTag",
        lookup: function _(_e) {
            var et, tt = _e.htmlTag || (typeof document < "u" ? document.documentElement : null);
            return tt && typeof tt.getAttribute == "function" && (et = tt.getAttribute("lang")), et
        }
    },
    path = {
        name: "path",
        lookup: function _(_e) {
            var et;
            if (typeof window < "u") {
                var tt = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
                if (tt instanceof Array)
                    if (typeof _e.lookupFromPathIndex == "number") {
                        if (typeof tt[_e.lookupFromPathIndex] != "string") return;
                        et = tt[_e.lookupFromPathIndex].replace("/", "")
                    } else et = tt[0].replace("/", "")
            }
            return et
        }
    },
    subdomain = {
        name: "subdomain",
        lookup: function _(_e) {
            var et = typeof _e.lookupFromSubdomainIndex == "number" ? _e.lookupFromSubdomainIndex + 1 : 1,
                tt = typeof window < "u" && window.location && window.location.hostname && window.location.hostname.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
            if (!!tt) return tt[et]
        }
    };

function getDefaults() {
    return {
        order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
        lookupQuerystring: "lng",
        lookupCookie: "i18next",
        lookupLocalStorage: "i18nextLng",
        lookupSessionStorage: "i18nextLng",
        caches: ["localStorage"],
        excludeCacheFor: ["cimode"]
    }
}
var Browser = function() {
    function _(_e) {
        var et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck$1(this, _), this.type = "languageDetector", this.detectors = {}, this.init(_e, et)
    }
    return _createClass$1(_, [{
        key: "init",
        value: function(et) {
            var tt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                rt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            this.services = et, this.options = defaults(tt, this.options || {}, getDefaults()), this.options.lookupFromUrlIndex && (this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex), this.i18nOptions = rt, this.addDetector(cookie$1), this.addDetector(querystring), this.addDetector(localStorage$1), this.addDetector(sessionStorage), this.addDetector(navigator$1), this.addDetector(htmlTag), this.addDetector(path), this.addDetector(subdomain)
        }
    }, {
        key: "addDetector",
        value: function(et) {
            this.detectors[et.name] = et
        }
    }, {
        key: "detect",
        value: function(et) {
            var tt = this;
            et || (et = this.options.order);
            var rt = [];
            return et.forEach(function(nt) {
                if (tt.detectors[nt]) {
                    var at = tt.detectors[nt].lookup(tt.options);
                    at && typeof at == "string" && (at = [at]), at && (rt = rt.concat(at))
                }
            }), this.services.languageUtils.getBestMatchFromCodes ? rt : rt.length > 0 ? rt[0] : null
        }
    }, {
        key: "cacheUserLanguage",
        value: function(et, tt) {
            var rt = this;
            tt || (tt = this.options.caches), tt && (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(et) > -1 || tt.forEach(function(nt) {
                rt.detectors[nt] && rt.detectors[nt].cacheUserLanguage(et, rt.options)
            }))
        }
    }]), _
}();
Browser.type = "languageDetector";
instance.use(Backend).use(Browser).use(initReactI18next).init({
    fallbackLng: "en-GB",
    interpolation: {
        escapeValue: !1
    }
});
ReactDOM.render(jsxRuntime.exports.jsx(React.StrictMode, {
    children: jsxRuntime.exports.jsx(ErrorBoundary, {
        children: jsxRuntime.exports.jsx(HashRouter, {
            children: jsxRuntime.exports.jsx(react.exports.Suspense, {
                fallback: "",
                children: jsxRuntime.exports.jsx(App, {})
            })
        })
    })
}), document.getElementById("root"));
